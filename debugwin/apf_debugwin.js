
/*FILEHEAD(/var/lib/platform/source/trunk/jpack_begin.js)SIZE(0)TIME(1238593371)*/



/*FILEHEAD(/var/lib/platform/source/trunk/apf.js)SIZE(92389)TIME(1271196962)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * Ajax.org Platform
 *
 * @author    Ruben Daniels (ruben AT ajax DOT org)
 * @version   3.0
 * @url       http://www.ajax.org
 *
 * @event domready      Fires when the browsers' dom is ready to be manipulated.
 * @event movefocus         Fires when the focus moves from one element to another.
 *   object:
 *   {AMLElement} toElement the element that will receive the focus.
 * @event exit              Fires when the application wants to exit.
 *   cancelable:  Prevents the application from exiting. The returnValue of the
 *   event object is displayed in a popup which asks the user for permission.
 * @event keyup         Fires when the user stops pressing a key.
 *   cancelable: Prevents the behaviour.
 *   object:
 *   {Number}  keyCode   the char code of the pressed key.
 *   {Boolean} ctrlKey   whether the ctrl key was pressed.
 *   {Boolean} shiftKey  whether the shift key was pressed.
 *   {Boolean} altKey    whether the alt key was pressed.
 *   {Object}  htmlEvent the html event object.
 * @event mousescroll   Fires when the user scrolls the mouse
 *   cancelable: Prevents the container to scroll
 *   object:
 *   {Number} delta the scroll impulse.
 * @event hotkey        Fires when the user presses a hotkey
 *   bubbles: yes
 *   cancelable: Prevents the default hotkey behaviour.
 *   object:
 *   {Number}  keyCode   the char code of the pressed key.
 *   {Boolean} ctrlKey   whether the ctrl key was pressed.
 *   {Boolean} shiftKey  whether the shift key was pressed.
 *   {Boolean} altKey    whether the alt key was pressed.
 *   {Object}  htmlEvent the html event object.
 * @event keydown       Fires when the user presses a key
 *   bubbles: yes
 *   cancelable: Prevents the behaviour.
 *   object:
 *   {Number}  keyCode   the char code of the pressed key.
 *   {Boolean} ctrlKey   whether the ctrl key was pressed.
 *   {Boolean} shiftKey  whether the shift key was pressed.
 *   {Boolean} altKey    whether the alt key was pressed.
 *   {Object}  htmlEvent the html event object.
 * @event mousedown     Fires when the user presses a mouse button
 *   object:
 *   {Event}      htmlEvent the char code of the pressed key.
 *   {AMLElement} amlNode   the element on which is clicked.
 * @event onbeforeprint Fires before the application will print.
 * @event onafterprint  Fires after the application has printed.
 * @event load          Fires after the application is loaded.
 * @event error         Fires when a communication error has occured while making a request for this element.
 *   cancelable: Prevents the error from being thrown.
 *   bubbles:
 *   object:
 *   {Error}          error     the error object that is thrown when the event callback doesn't return false.
 *   {Number}         state     the state of the call
 *     Possible values:
 *     apf.SUCCESS  the request was successfull
 *     apf.TIMEOUT  the request has timed out.
 *     apf.ERROR    an error has occurred while making the request.
 *     apf.OFFLINE  the request was made while the application was offline.
 *   {mixed}          userdata  data that the caller wanted to be available in the callback of the http request.
 *   {XMLHttpRequest} http      the object that executed the actual http request.
 *   {String}         url       the url that was requested.
 *   {Http}           tpModule  the teleport module that is making the request.
 *   {Number}         id        the id of the request.
 *   {String}         message   the error message.
 * @default_private
 */
var apf = {
VERSION:'3.3beta',
    // Content Distribution Network URL:
    
    /**
     * The url to the content delivery network.
     * @type {String}
     */
    CDN            : "",
    

    /**
     * Boolean specifying whether apf is ready for dom operations.
     * @type {Boolean}
     */
    READY          : false,

    //AML nodeFunc constants
    /**
     * Constant for a hidden aml element.
     * @type {Number}
     */
    NODE_HIDDEN    : 101,
    /**
     * Constant for a visible aml element.
     * @type {Number}
     */
    NODE_VISIBLE   : 102,
    /**
     * Constant for an o3 widget.
     * @type {Number}
     */
    NODE_O3 : 103,

    /**
     * Constant for specifying that a widget is using only the keyboard to receive focus.
     * @type {Number}
     * @see baseclass.guielement.method.focus
     */
    KEYBOARD       : 2,
    /**
     * Constant for specifying that a widget is using the keyboard or the mouse to receive focus.
     * @type {Boolean}
     * @see baseclass.guielement.method.focus
     */
    KEYBOARD_MOUSE : true,

    /**
     * Constant for specifying success.
     * @type {Number}
     * @see element.teleport
     */
    SUCCESS : 1,
    /**
     * Constant for specifying a timeout.
     * @type {Number}
     * @see element.teleport
     */
    TIMEOUT : 2,
    /**
     * Constant for specifying an error.
     * @type {Number}
     * @see element.teleport
     */
    ERROR   : 3,
    /**
     * Constant for specifying the application is offline.
     * @type {Number}
     * @see element.teleport
     */
    OFFLINE : 4,

    
    debug         : true,
    debugType     : "Memory",
    debugFilter   : "!teleport",
    

    includeStack  : [],
    initialized   : false,
    AppModules    : [],
    
    /**
     * Boolean specifying whether apf tries to load a skin from skins.xml when no skin element is specified.
     * @type {Boolean}
     */
    autoLoadSkin  : false,
    /**
     * Boolean specifying whether apf has started loading scripts and started the init process.
     * @type {Boolean}
     */
    started       : false,
    /**
     * Namespace for all crypto libraries included with Ajax.org Platform.
     */
    crypto        : {}, //namespace
    config        : {},
    _GET          : {},
    $asyncObjects : {"apf.oHttp" : 1, "apf.ajax": 1},
    
    /**
     * String specifying the basepath for loading apf from seperate files.
     * @type {String}
     */
    
    basePath      : "./",
    

    
    /**
     * {Object} contains several known and often used namespace URI's.
     * @private
     */
    ns : {
        apf    : "http://ajax.org/2005/aml",
        aml    : "http://ajax.org/2005/aml",
        xsd    : "http://www.w3.org/2001/XMLSchema",
        xhtml  : "http://www.w3.org/1999/xhtml",
        xslt   : "http://www.w3.org/1999/XSL/Transform",
        xforms : "http://www.w3.org/2002/xforms",
        ev     : "http://www.w3.org/2001/xml-events"
    },
    
    
    availHTTP  : [],
    /**
     * @private
     */
    releaseHTTP: function(http){
        if (apf.brokenHttpAbort) 
            return;
        if (self.XMLHttpRequestUnSafe && http.constructor == XMLHttpRequestUnSafe) 
            return;
        
        http.onreadystatechange = function(){};
        http.abort();
        this.availHTTP.push(http);
    },

    /**
     * @private
     */
    browserDetect : function(){
        if (this.$bdetect)
            return;
        this.$bdetect = true;

        var sAgent = navigator.userAgent.toLowerCase() || "";

        // Browser Detection, using feature inference methods where possible:
        // http://www.thespanner.co.uk/2009/01/29/detecting-browsers-javascript-hacks/
        // http://webreflection.blogspot.com/2009/01/32-bytes-to-know-if-your-browser-is-ie.html
        
        /**
         * Specifies whether the application is running in the Opera browser.
         * @type {Boolean}
         */
        this.isOpera      = (self.opera && Object.prototype.toString.call(self.opera) == "[object Opera]");
        
        /**
         * Specifies whether the application is running in the Konqueror browser.
         * @type {Boolean}
         */
        this.isKonqueror  = sAgent.indexOf("konqueror") != -1;
        
        /**
         * Specifies whether the application is running in the Safari browser.
         * @type {Boolean}
         */
        this.isSafari     = /a/.__proto__ == "//";
        
        /**
         * Specifies whether the application is running in the Safari browser version 2.4 or below.
         * @type {Boolean}
         */
        this.isSafariOld  = false;

        /**
         * Specifies whether the application is running on the Iphone.
         * @type {Boolean}
         */
        this.isIphone     = sAgent.indexOf("iphone") != -1 || sAgent.indexOf("aspen simulator") != -1;

        /**
         * Specifies whether the application is running in the Chrome browser.
         * @type {Boolean}
         */
        this.isChrome     = Boolean(/source/.test((/a/.toString + ""))) || sAgent.indexOf("chrome") != -1;
        
        /**
         * Specifies whether the application is running in a Webkit-based browser
         * @type {Boolean}
         */
        this.isWebkit     = this.isSafari || this.isChrome || this.isKonquerer;

        if (this.isWebkit) {
            var matches   = sAgent.match(/applewebkit\/(\d+)/);
            if (matches) {
                this.webkitRev   = parseInt(matches[1])
                this.isSafariOld = parseInt(matches[1]) < 420;
            }
        }

        /**
         * Specifies whether the application is running in a Gecko based browser.
         * @type {Boolean}
         */
        this.isGecko      = (function(o) { o[o] = o + ""; return o[o] != o + ""; })(new String("__count__"));

        /**
         * Specifies whether the application is running in the Firefox browser version 3.
         * @type {Boolean}
         */
        this.isGecko3     = this.isGecko && (function x(){})[-5] == "x";
        this.isGecko35    = this.isGecko && (/a/[-1] && Object.getPrototypeOf) ? true : false;
        this.versionGecko = this.isGecko ? parseFloat(sAgent.match(/(?:gecko)\/([\d\.]+)/i)[1]) : -1;
        this.versionFF    = this.isGecko ? parseFloat(sAgent.match(/(?:firefox)\/([\d\.]+)/i)[1]) : -1;

        var found;
        /**
         * Specifies whether the application is running in the Internet Explorer browser, any version.
         * @type {Boolean}
         */
        this.isIE         = ! + "\v1";
        if (this.isIE)
            this.isIE = parseFloat(sAgent.match(/msie ([\d\.]*)/)[1]);
        
        /**
         * Specifies whether the application is running in the Internet Explorer browser version 8.
         * @type {Boolean}
         */
        this.isIE8        = this.isIE == 8 && (found = true);
        
        /**
         * Specifies whether the application is running in the Internet Explorer browser version 7.
         * @type {Boolean}
         */
        this.isIE7        = !found && this.isIE == 7 && (found = true);

        //Mode detection
        if (this.isIE == 7 && document.documentMode == 7) {
            apf.isIE7        = true;
            apf.isIE8        = false;
            apf.isIE7Emulate = true;
            apf.isIE         = 7;
        }
        
        /**
         * Specifies whether the application is running in the Internet Explorer browser version 6.
         * @type {Boolean}
         */
        this.isIE6       = !found && this.isIE == 6 && (found = true);

        var os           = (navigator.platform.match(/mac|win|linux/i) || ["other"])[0].toLowerCase();
        /**
         * Specifies whether the application is running on the Windows operating system.
         * @type {Boolean}
         */
        this.isWin       = (os == "win");
        /**
         * Specifies whether the application is running in the OSX operating system..
         * @type {Boolean}
         */
        this.isMac       = (os == "mac");
        /**
         * Specifies whether the application is running in the OSX operating system..
         * @type {Boolean}
         */
        this.isLinux     = (os == "linux");

        /**
         * Specifies whether the application is running in the AIR runtime.
         * @type {Boolean}
         */
        this.isAIR       = sAgent.indexOf("adobeair") != -1;

        

        
        try {
            //this.isDeskrun = window.external.shell.runtime == 2;
        }
        catch(e) {
            /**
             * Specifies whether the application is running in the Deskrun runtime.
             * @type {Boolean}
             */
            this.isDeskrun = false;
        }
        
    },

    /**
     * @private
     */
    setCompatFlags : function(){
        //Set Compatibility
        this.TAGNAME                   = apf.isIE ? "baseName" : "localName";
        this.styleSheetRules           = apf.isIE ? "rules" : "cssRules";
        this.brokenHttpAbort           = apf.isIE6;
        this.canUseHtmlAsXml           = apf.isIE;
        this.supportNamespaces         = !apf.isIE;
        this.cannotSizeIframe          = apf.isIE;
        this.hasConditionCompilation   = apf.isIE;
        this.supportOverflowComponent  = apf.isIE;
        this.hasEventSrcElement        = apf.isIE;
        this.canHaveHtmlOverSelects    = !apf.isIE6 && !apf.isIE5;
        this.hasInnerText              = apf.isIE;
        this.hasMsRangeObject          = apf.isIE;
        this.descPropJs                = apf.isIE;
        this.hasClickFastBug           = apf.isIE;
        this.hasExecScript             = window.execScript ? true : false;
        this.canDisableKeyCodes        = apf.isIE;
        this.hasTextNodeWhiteSpaceBug  = apf.isIE || apf.isIE >= 8;
        this.hasCssUpdateScrollbarBug  = apf.isIE;
        this.canUseInnerHtmlWithTables = !apf.isIE;
        this.hasSingleResizeEvent      = !apf.isIE;
        this.hasStyleFilters           = apf.isIE;
        this.supportOpacity            = !apf.isIE;
        this.supportPng24              = !apf.isIE6 && !apf.isIE5;
        this.cantParseXmlDefinition    = apf.isIE50;
        this.hasDynamicItemList        = !apf.isIE || apf.isIE >= 7;
        this.canImportNode             = apf.isIE;
        this.hasSingleRszEvent         = !apf.isIE;
        this.hasXPathHtmlSupport       = !apf.isIE;
        this.hasFocusBug               = apf.isIE;
        this.hasReadyStateBug          = apf.isIE50;
        this.dateSeparator             = apf.isIE ? "-" : "/";
        this.canCreateStyleNode        = !apf.isIE;
        this.supportFixedPosition      = !apf.isIE || apf.isIE >= 7;
        this.hasHtmlIdsInJs            = apf.isIE && apf.isIE < 8 || apf.isWebkit;
        this.needsCssPx                = !apf.isIE;
        this.hasCSSChildOfSelector     = !apf.isIE || apf.isIE >= 8;
        this.styleAttrIsObj            = apf.isIE < 8;
        this.hasAutocompleteXulBug     = apf.isGecko;
        this.loadsLocalFilesSync       = apf.isIE || apf.isGecko;
        this.mouseEventBuffer          = apf.isIE ? 20 : 6;
        this.hasComputedStyle          = typeof document.defaultView != "undefined"
                                           && typeof document.defaultView.getComputedStyle != "undefined";
        this.supportCSSAnim            = apf.isWebkit && (apf.webkitRev > 525);//apf.isIphone;
        this.w3cRange                  = Boolean(window["getSelection"]);
        this.locale                    = (apf.isIE
                                            ? navigator.userLanguage
                                            : navigator.language).toLowerCase();
        this.characterSet              = document.characterSet || document.defaultCharset || "utf-8";
        var t = document.createElement("div");
        this.hasContentEditable        = (typeof t.contentEditable == "string"
                                       || typeof t.contentEditable == "boolean");
        // Try transform first for forward compatibility
        var props   = ["transform", "OTransform", "KhtmlTransform", "MozTransform", "WebkitTransform"],
            prefixR = ["", "O", "Khtml", "Moz", "Webkit"],
            prefixC = ["", "o-", "khtml-", "moz-", "webkit-"],
            events  = ["transitionend", "transitionend", "transitionend", "transitionend", "webkitTransitionEnd"],
            i       = 0,
            l       = 5;
        this.supportCSSAnim            = false;
        this.supportCSSTransition      = false;
        for (; i < l && !this.supportCSSAnim; ++i) {
            if (typeof t.style[props[i]] == "undefined") continue;
            this.supportCSSAnim     = props[i];
            this.runtimeStylePrefix = prefixR[i];
            this.classNamePrefix    = prefixC[i];
            this.cssAnimEvent       = events[i];
        }
        t = null;
        delete t;

        this.supportVML                = apf.isIE;
        this.supportSVG                = !apf.isIE;
        this.hasHtml5XDomain           = apf.versionGecko >= 3.5;
        this.supportCanvas             = !!document.createElement("canvas").getContext;
        this.supportCanvasText         = !!(this.supportCanvas
            && typeof document.createElement("canvas").getContext("2d").fillText == "function")

        this.hasVideo                  = !!document.createElement("video")["canPlayType"];
        this.hasAudio                  = !!document.createElement("audio")["canPlayType"];
        this.hasGeolocation            = !!navigator.geolocation;
        this.supportHashChange         = ("onhashchange" in self) && (!apf.isIE || apf.isIE >= 8);

        this.windowHorBorder           = 
        this.windowVerBorder           = apf.isIE8 && (!self.frameElement 
            || parseInt(self.frameElement.frameBorder)) ? 4 : 0;
        
        

        //Other settings
        this.maxHttpRetries = apf.isOpera ? 0 : 3;

        
        this.percentageMatch = new RegExp();
        this.percentageMatch.compile("([\\-\\d\\.]+)\\%", "g");
        
        
        this.reMatchXpath = new RegExp();
        this.reMatchXpath.compile("(^|\\|)(?!\\@|[\\w-]+::)", "g");

        
        apf.isGears      = !!apf.initGears() || 0;
        
    },

    
    /**
     * Restarts the application.
     */
    reboot : function(){
        apf.console.info("Restarting application...");

        location.href = location.href;
    },
    

    /**
     * Extends an object with one or more other objects by copying all their
     * properties.
     * @param {Object} dest the destination object.
     * @param {Object} src the object that is copies from.
     * @return {Object} the destination object.
     */
    extend : function(dest, src){
        var prop, i, x = !dest.notNull;
        if (arguments.length == 2) {
            for (prop in src) {
                if (x || src[prop])
                    dest[prop] = src[prop];
            }
            return dest;
        }

        for (i = 1; i < arguments.length; i++) {
            src = arguments[i];
            for (prop in src) {
                if (x || src[prop])
                    dest[prop] = src[prop];
            }
        }
        return dest;
    },
    
    $extend : function(dest, src){
        for (var prop in src) {
            dest[prop] = src[prop];
        }
        return dest;
    },
    
    
    /**
     * Sends and retrieves data from remote locations over http.
     * Example:
     * <code>
     *  var content = apf.ajax("http://www.ajax.org", {
     *      method   : "POST",
     *      data     : "<data />",
     *      async    : false,
     *      callback : function( data, state ) {
     *          if (state == apf.SUCCESS)
     *              alert("Success");
     *          else
     *              alert("Failure")
     *      }
     *  });
     *  alert(content);
     * </code>
     *
     * @param {String}   url       the url that is accessed.
     * @param {Object}   options   the options for the http request
     *   Properties:
     *   {Boolean} async          whether the request is sent asynchronously. Defaults to true.
     *   {mixed}   userdata       custom data that is available to the callback function.
     *   {String}  method         the request method (POST|GET|PUT|DELETE). Defaults to GET.
     *   {Boolean} nocache        whether browser caching is prevented.
     *   {String}  data           the data sent in the body of the message.
     *   {Boolean} useXML         whether the result should be interpreted as xml.
     *   {Boolean} autoroute      whether the request can fallback to a server proxy.
     *   {Boolean} caching        whether the request should use internal caching.
     *   {Boolean} ignoreOffline  whether to ignore offline catching.
     *   {Function} callback      the handler that gets called whenever the
     *                            request completes succesfully or with an error,
     *                            or when the request times out.
     */
    ajax : (function(){
        var f = function(){
            return this.oHttp.get.apply(this.oHttp, arguments);
        };
        
        f.exec = function(method, args, callback, options){
            if (method == "ajax" && args[0]) {
                var opt = args[1] || {};
                return this.oHttp.exec(opt.method || "GET", [args[0]], 
                    opt.callback, apf.extend(options || {}, opt));
            }
        };

        return f;
    })(),
    

    /**
     * Starts the application.
     * @private
     */
    start : function(){
        this.started = true;
        var sHref = location.href.split("#")[0].split("?")[0];

        //Set Variables
        this.host     = location.hostname && sHref.replace(/(\/\/[^\/]*)\/.*$/, "$1");
        this.hostPath = sHref.replace(/\/[^\/]*$/, "") + "/";

        
        apf.console.info("Starting Ajax.org Platform Application...");
        apf.console.warn("Debug build of Ajax.org Platform " + (apf.VERSION ? "version " + apf.VERSION : ""));
        

        //mozilla root detection
        //try{ISROOT = !window.opener || !window.opener.apf}catch(e){ISROOT = true}

        //Browser Specific Stuff
        //this.browserDetect();
        this.setCompatFlags();

        
        apf.$debugwin.start();
        

        //Load Browser Specific Code
        
        if (this.isIE) apf.runIE();
            //this.importClass(apf.runIE, true, self);
        
        
        if (apf.isWebkit) apf.runWebkit();
            //this.importClass(apf.runSafari, true, self);
        
        
        if (this.isOpera) apf.runOpera();
            //this.importClass(apf.runOpera, true, self);
        
        
        if (this.isGecko || !this.isIE && !apf.isWebkit && !this.isOpera)
            apf.runGecko();
            //this.importClass(apf.runGecko, true, self);
        

        

        
        // Start HTTP object
        this.oHttp = new this.http();
        

        
        // Load user defined includes
        this.Init.addConditional(this.parseAppMarkup, apf, ["body"]);
        //@todo, as an experiment I removed 'HTTP' and 'Teleport'
        

        //IE fix
        try {
            if (apf.isIE)
                document.execCommand("BackgroundImageCache", false, true);
        }
        catch(e) {}

        
        //apf.window.init();
        

        this.started = true;
        
        
        // DOMReady already fired, so plz continue the loading and parsing
        if (this.load_done)
            this.execDeferred();
        

        //try{apf.root = !window.opener || !window.opener.apf;}
        //catch(e){apf.root = false}
        this.root = true;
        
        
        for (var i = 0; i < apf.$required.length; i++) {
            apf.include(apf.$required[i]);
        }
        apf.require = apf.include;
        
        
        

    },

    nsqueue   : {},

    
    /**
     * @private
     */
    findPrefix : function(xmlNode, xmlns){
        var docEl;
        if (xmlNode.nodeType == 9) {
            if (!xmlNode.documentElement)
                return false;
            if (xmlNode.documentElement.namespaceURI == xmlns)
                return xmlNode.prefix || xmlNode.scopeName;
            docEl = xmlNode.documentElement;
        }
        else {
            if (xmlNode.namespaceURI == xmlns)
                return xmlNode.prefix || xmlNode.scopeName;
            docEl = xmlNode.ownerDocument.documentElement;
            if (docEl && docEl.namespaceURI == xmlns)
                return xmlNode.prefix || xmlNode.scopeName;

            while (xmlNode.parentNode) {
                xmlNode = xmlNode.parentNode;
                if (xmlNode.namespaceURI == xmlns)
                    return xmlNode.prefix || xmlNode.scopeName;
            }
        }

        if (docEl) {
            for (var i = 0; i < docEl.attributes.length; i++) {
                if (docEl.attributes[i].nodeValue == xmlns)
                    return docEl.attributes[i][apf.TAGNAME]
            }
        }

        return false;
    },
    

    /**
     * @private
     */
    importClass : function(ref, strip, win){
        if (!ref)
            throw new Error(apf.formatErrorString(1018, null,
                "importing class",
                "Could not load reference. Reference is null"));

        if (!strip)
            return apf.jsexec(ref.toString(), win);

        var q = ref.toString().replace(/^\s*function\s*\w*\s*\([^\)]*\)\s*\{/, "")
                              .replace(/\}\s*$/, "");

        return apf.jsexec(q, win);
    },

    /**
    * This method returns a string representation of the object
    * @return {String}    Returns a string representing the object.
    */
    toString : function(){
        return "[Ajax.org Platform (apf)]";
    },

    all : [],

    /**
    * This method implements all properties and methods to this object from another class
    * @param {Function}    classRef    Class reference
    * @private
    */
    implement : function(classRef) {
        // for speed, we check for the most common  case first
        if (arguments.length == 1) {
            
            if (!classRef) {
                throw new Error(apf.formatErrorString(0, this,
                    "Implementing class",
                    "Could not implement from '" + classRef[i] + "'", this));
            }
            
            classRef.call(this);//classRef
        }
        else {
            for (var a, i = 0, l = arguments.length; i < l; i++) {
                a = arguments[i];
                
                if (!a) {
                    throw new Error(apf.formatErrorString(0, this,
                        "Implementing class",
                        "Could not implement from '" + arguments[i] + "'", this));
                }
                
                arguments[i].call(this);//classRef
            }
        }

        return this;
    },

    /**
     * @private
     */
    uniqueHtmlIds : 0,

    /**
     * Adds a unique id attribute to an html element.
     * @param {HTMLElement} oHtml the object getting the attribute.
     */
    setUniqueHtmlId : function(oHtml){
        var id;
        oHtml.setAttribute("id", id = "q" + this.uniqueHtmlIds++);
        return id;
    },

    /**
     * Retrieves a new unique id
     */
    getUniqueId : function(){
        return this.uniqueHtmlIds++;
    },

    /**
     * Finds a aml element based on it's uniqueId
     */
    lookup : function(uniqueId){
        return this.all[uniqueId];
    },

    /**
     * Searches in the html tree from a certain point to find the
     * aml element that is responsible for rendering the specified html
     * element.
     * @param {HTMLElement} oHtml the html context to start the search from.
     */
    findHost : function(o){
        while (o && o.parentNode) { //!o.host && 
            try {
                if (o.host)
                    break;
            }
            catch(e){}
            
            o = o.parentNode;
        }
        return (o && o.host && typeof o.host != "string") ? o.host : false;
    },

    /**
     * Sets a reference to an object by name in the global javascript space.
     * @param {String} name the name of the reference.
     * @param {mixed}  o    the reference to the object subject to the reference.
     */
    setReference : function(name, o){
        return self[name] && self[name].hasFeature
            ? 0
            : (self[name] = o);
    },

    /**
     * The console outputs to the debug screen and offers differents ways to do
     * this.
     */
    console : {
        
        /**
         * @private
         */
        data : {
            time  : {
                messages : {}
            },

            log   : {
                messages : {}
            },
            
            custom   : {
                messages : {}
            },

            warn  : {
                messages : {}
            },

            error : {
                messages : {}
            },
            
            repeat : {
                messages : {}
            }
        },

        /**
         * @private
         */
        toggle : function(node, id){
            var sPath = apf.$debugwin ? apf.$debugwin.resPath : apf.basePath + "core/debug/resources/";
            if (node.style.display == "block") {
                node.style.display = "none";
                node.parentNode.style.backgroundImage = "url(" + sPath + "splus.gif)";
                node.innerHTML = "";
            }
            else {
                node.style.display = "block";
                node.parentNode.style.backgroundImage = "url(" + sPath + "smin.gif)";
                node.innerHTML = this.cache[id]
                    .replace(/\&/g, "&amp;")
                    .replace(/\t/g,"&nbsp;&nbsp;&nbsp;")
                    .replace(/ /g,"&nbsp;")
                    .replace(/\</g, "&lt;")
                    .replace(/\n/g, "<br />");

                var p  = node.parentNode.parentNode.parentNode,
                    el = node.parentNode.parentNode;
                if(p.scrollTop + p.offsetHeight < el.offsetTop + el.offsetHeight)
                    p.scrollTop = el.offsetTop + el.offsetHeight - p.offsetHeight;
            }
        },

        cache : [],
        history : [],
        typeLut : {time: "log", repeat: "log"},
        $lastmsg : "",
        $lastmsgcount : 0,

        $detectSameMessage : function(){
            apf.console.$lastmsg = "";
            if (apf.console.$lastmsgcount) {
                var msg = apf.console.$lastmsgcount + " times the same message";
                apf.console.$lastmsgcount = 0;
                apf.console.write(msg, "repeat");
                clearTimeout(apf.console.$timer);
            }
        },
        
        teleportList : [],
        teleport : function(log){
            if (this.teleportModel)
                log.setXml(this.teleportModel.data);
            
            this.teleportList.push(log);
        },
        setTeleportModel : function(mdl){
            if (this.teleportModel == mdl)
                return;
            
            this.teleportModel = mdl;
            var xml = apf.getXml("<teleport />");
            for (var i = 0; i < this.teleportList.length; i++) {
                this.teleportList[i].setXml(xml);
            }
            
            mdl.load(xml);
        },

        /**
         * @private
         * @event debug Fires when a message is sent to the console.
         *   object:
         *      {String} message the content of the message.
         */
        write : function(msg, type, subtype, data, forceWin, nodate){
            clearTimeout(this.$timer);
            if (msg == this.$lastmsg) {
                this.$lastmsgcount++;
                this.$timer = $setTimeout(this.$detectSameMessage, 1000);
                return;
            }

            this.$detectSameMessage();
            this.$lastmsg = msg;
            this.$timer = $setTimeout(this.$detectSameMessage, 1000);
            
            //if (!apf.debug) return;
            if (!Number.prototype.toPrettyDigit) {
                Number.prototype.toPrettyDigit = function() {
                    var n = this.toString();
                    return (n.length == 1) ? "0" + n : n;
                }
            }

            var dt   = new Date(),
                ms   = String(dt.getMilliseconds());
            while (ms.length < 3)
                ms += "0";
            var date = dt.getHours().toPrettyDigit()   + ":"
                     + dt.getMinutes().toPrettyDigit() + ":"
                     + dt.getSeconds().toPrettyDigit() + "." + ms;

            msg = (!nodate ? "<span class='console_date'>[" + date + "]</span> " : "")
                    + String(msg)
                        .replace(/(<[^>]+>)| /g, function(m, tag, sp){
                            if (tag) return tag;
                            return "&nbsp;";
                        })
                        //.replace(/\n/g, "\n<br />")
                        .replace(/\t/g,"&nbsp;&nbsp;&nbsp;");
            var sPath = apf.$debugwin && apf.$debugwin.resPath
                ? apf.$debugwin.resPath
                : apf.basePath + "core/debug/resources/";

            if (data) {
                msg += "<blockquote style='margin:2px 0 0 0;"
                    +  "background:url(" + sPath + "splus.gif) no-repeat 2px 3px'>"
                    +  "<strong style='width:120px;cursor:default;display:block;padding:0 0 0 17px' "
                    +  "onmousedown='(self.apf || window.opener.apf).console.toggle(this.nextSibling, "
                    +  (this.cache.push(data) - 1) + ")'>More information"
                    +  "</strong><div style='display:none;background-color:#EEEEEE;"
                    +  "padding:3px 3px 20px 3px;overflow:auto;max-height:200px'>"
                    +  "</div></blockquote>";
            }

            msg = "<div class='console_line console_" 
                + type + "' >" + msg + "</div>"; //\n<br style='line-height:0'/>

            //deprecated
            if (!subtype)
                subtype = "default";

            this.history.push([this.typeLut[type] || type, msg]);

            if (this.win && !this.win.closed)
                this.showWindow(msg);

            //if (apf.debugFilter.match(new RegExp("!" + subtype + "(\||$)", "i")))
            //    return;

            this.debugInfo.push(msg);

            if (apf.dispatchEvent)
                apf.dispatchEvent("debug", {message: msg, type: type});
        },
        
        clear : function(){
            this.history = [];
        },
        
        getAll : function(err, wrn, log) {
            var hash = {"error": err, "warn": wrn, "log": log, "custom": 1};
            var out = [];
            for (var i = 0, l = this.history.length; i < l; i++) {
                if (hash[this.history[i][0]])
                    out.push(this.history[i][1]);
            }
            return out.join("");
        },
        

        /**
         * Writes a message to the console.
         * @param {String} msg      the message to display in the console.
         * @param {String} subtype  the category for this message. This is used for filtering the messages.
         * @param {String} data     extra data that might help in debugging.
         */
        debug : function(msg, subtype, data){
            
            this.write(msg, "time", subtype, data);
            
        },

        /**
         * Writes a message to the console with the time icon next to it.
         * @param {String} msg      the message to display in the console.
         * @param {String} subtype  the category for this message. This is used for filtering the messages.
         * @param {String} data     extra data that might help in debugging.
         */
        time : function(msg, subtype, data){
            
            this.write(msg, "time", subtype, data);
            
        },

        /**
         * Writes a message to the console.
         * @param {String} msg      the message to display in the console.
         * @param {String} subtype  the category for this message. This is used for filtering the messages.
         * @param {String} data     extra data that might help in debugging.
         */
        log : function(msg, subtype, data){
            
            this.write(apf.htmlentities(msg).replace(/\n/g, "<br />"), "log", subtype, data);
            
        },

        /**
         * Writes a message to the console with the visual "info" icon and color
         * coding.
         * @param {String} msg      the message to display in the console.
         * @param {String} subtype  the category for this message. This is used for filtering the messages.
         * @param {String} data     extra data that might help in debugging.
         */
        info : function(msg, subtype, data){
            
            this.log(apf.htmlentities(msg).replace(/\n/g, "<br />"), subtype, data);
            
        },

        /**
         * Writes a message to the console with the visual "warning" icon and
         * color coding.
         * @param {String} msg      the message to display in the console.
         * @param {String} subtype  the category for this message. This is used for filtering the messages.
         * @param {String} data     extra data that might help in debugging.
         */
        warn : function(msg, subtype, data){
            
            this.write(apf.htmlentities(msg).replace(/\n/g, "<br />"), "warn", subtype, data);
            
        },

        /**
         * Writes a message to the console with the visual "error" icon and
         * color coding.
         * @param {String} msg      the message to display in the console.
         * @param {String} subtype  the category for this message. This is used for filtering the messages.
         * @param {String} data     extra data that might help in debugging.
         */
        error : function(msg, subtype, data){
            
            this.write(msg.replace(/\n/g, "<br />"), "error", subtype, data);
            
        },

        /**
         * Prints a listing of all properties of the object.
         * @param {mixed} obj the object for which the properties are displayed.
         */
        dir : function(obj){
            this.info(apf.vardump(obj, null, false).replace(/ /g, "&nbsp;").replace(/</g, "&lt;"));
        }
        
        
        ,
        debugInfo : [],
        debugType : "",

        /**
         * Shows a browser window with the contents of the console.
         * @param {String} msg a new message to add to the new window.
         */
        showWindow : function(msg){
            if (!this.win || this.win.closed) {
                this.win = window.open("", "debug");
                this.win.document.write(
                    '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">'
                  + '<body style="margin:0;font-family:Verdana;font-size:8pt;"></body>');
            }
            if (!this.win) {
                if (!this.haspopupkiller)
                    alert("Could not open debug window, please check your popupkiller");
                this.haspopupkiller = true;
            }
            else {
                this.win.document.write((msg || this.debugInfo.join(""))
                    .replace(/\{imgpath\}/g, apf.debugwin
                        ? apf.debugwin.resPath
                        : apf.basePath + "core/debug/resources/"));
            }
        }

        
    },

    htmlentities : function(s){return s},

    /**
     * Formats a Ajax.org Platform error message.
     * @param {Number}      number      the number of the error. This can be used to look up more information about the error.
     * @param {AMLElement}  control     the aml element that will throw the error.
     * @param {String}      process     the action that was being executed.
     * @param {String}      message     the actual error message.
     * @param {XMLElement}  amlContext  the xml relevant to the error. For instance a piece of Ajax.org Markup Language xml.
     */
    formatErrorString : function(number, control, process, message, amlContext, outputname, output){
        
        var str = [];
        if (amlContext && amlContext.ownerDocument) {
            if (amlContext.nodeType == 9)
                amlContext = amlContext.documentElement;

            //Determine file context
            if (amlContext.ownerDocument.documentElement) {
                var file = amlContext.ownerDocument.documentElement.getAttribute("filename");
                if (!file && amlContext.ownerDocument.documentElement.tagName == "html")
                    file = location.href;
                file = file
                    ? apf.removePathContext(apf.hostPath, file)
                    : "Unkown filename";
            }
            else file = "Unknown filename";

            //Get serialized version of context
            if (apf.$debugwin)
                var amlStr = apf.$debugwin.$serializeObject(amlContext);
            else
                var amlStr = (amlContext.outerHTML || amlContext.xml || amlContext.serialize())
                    .replace(/\<\?xml\:namespace prefix = j ns = "http\:\/\/ajax.org\/2005\/aml" \/\>/g, "")
                    .replace(/xmlns:a="[^"]*"\s*/g, "");

            //Determine line number
            var diff, linenr = 0, w = amlContext.previousSibling
                || amlContext.parentNode && amlContext.parentNode.previousSibling;
            while (w && w[apf.TAGNAME] != "body") {
                diff    = (w.outerHTML || w.xml || w.serialize()).split("\n").length;
                linenr += diff - 1;
                w       = w.previousSibling || w.parentNode && w.parentNode.previousSibling;
            }
            if (w && w[apf.TAGNAME] != "body")
                linenr = "unknown";
            else if(amlContext.ownerDocument 
              && amlContext.ownerDocument.documentElement.tagName == "html")
                linenr += apf.lineBodyStart;

            //Grmbl line numbers are wrong when \n's in attribute space

            //Set file and line number
            str.push("aml file: [line: " + linenr + "] " + file);
        }

        if (control)
            str.push("Element: "
              + (apf.$debugwin && !apf.isDebugWindow
                ? apf.$debugwin.$serializeObject(control)
                : "'" + (control.name
                    || (control.$aml ? control.getAttribute("id") : null)
                    || "{Anonymous}")
                    + "' [" + control.tagName + "]"));
        if (process)
            str.push("Process: " + process.replace(/ +/g, " "));
        if (message)
            str.push("Message: [" + number + "] " + message.replace(/ +/g, " "));
        if (outputname)
            str.push(outputname + ": " + output);
        if (amlContext && amlStr)
            str.push("Related Markup: " + amlStr);

        return (apf.lastErrorMessage = str.join("\n"));
        
    },

    /* Init */

    /**
     * Returns the directory portion of a url
     * @param {String} url the url to retrieve from.
     * @return {String} the directory portion of a url.
     */
    getDirname : function(url){
        //(?:\w+\:\/\/)?
        return ((url || "").match(/^([^#]*\/)[^\/]*(?:$|\#)/) || {})[1]; //Mike will check out how to optimize this line
    },
    
    /**
     * Returns the file portion of a url
     * @param {String} url the url to retrieve from.
     * @return {String} the file portion of a url.
     */
    getFilename : function(url){
        return ((url || "").split("?")[0].match(/(?:\/|^)([^\/]+)$/) || {})[1];
    },
    
    /**
     * Returns an absolute url based on url.
     * @param {String} base the start of the url to which relative url's work.
     * @param {String} url  the url to transform.
     * @return {String} the absolute url.
     */
    getAbsolutePath : function(base, url){
        return url.charAt(0) == "/"
            ? url
            : (!url || !base || url.match(/^\w+\:\/\//) ? url : base.replace(/\/$/, "") + "/" + url.replace(/^\//, ""));
    },

    /**
     * Loads javascript from a url.
     * 
     * @param {String}  sourceFile the url where the javascript is located.
     * @param {Boolean} [doBase]   check for basePath, otherwise prepend it
     * @param {String}  [type]     set the type of a script tag, for later use
     * @type  {void}
     */
    include : function(sourceFile, doBase, type, text){
        
        if (apf.started)
            apf.console.info("including js file: " + sourceFile);
        
        
        var sSrc = doBase ? apf.getAbsolutePath(apf.basePath || "", sourceFile) : sourceFile;
        var head     = document.getElementsByTagName("head")[0],//$("head")[0]
            elScript = document.createElement("script");
        //elScript.defer = true;
        if (type)
            elScript.setAttribute("_apf_type", type);
        if (text)
            elScript.text  = text;
        else 
            elScript.src   = sSrc;
        head.appendChild(elScript);
        
        return elScript;
    },
    
    $required : [],
    require : function(){
        var dir = apf.getDirname(location.href),
            i   = 0,
            l   = arguments.length;
        for (; i < l; i++)
            this.$required.push(apf.getAbsolutePath(dir, arguments[i]));
    },

    /**
     * @private
     */
    Init : {
        queue : [],
        cond  : {
            combined : []
        },
        done  : {},

        add   : function(func, o){
            if (this.inited)
                func.call(o);
            else if (func)
                this.queue.push([func, o]);
        },

        addConditional : function(func, o, strObj){
            if (typeof strObj != "string") {
                if (this.checkCombined(strObj))
                    return func.call(o);
                this.cond.combined.push([func, o, strObj]);
            }
            else if (self[strObj]) {
                func.call(o);
            }
            else {
                if (!this.cond[strObj])
                    this.cond[strObj] = [];
                this.cond[strObj].push([func, o]);

                this.checkAllCombined();
            }
        },

        checkAllCombined : function(){
            for (var i = 0; i < this.cond.combined.length; i++) {
                if (!this.cond.combined[i]) continue;

                if (this.checkCombined(this.cond.combined[i][2])) {
                    this.cond.combined[i][0].call(this.cond.combined[i][1])
                    this.cond.combined[i] = null;
                }
            }
        },

        checkCombined : function(arr){
            for (var i = 0; i < arr.length; i++) {
                if (!this.done[arr[i]])
                    return false;
            }

            return true;
        },

        run : function(strObj){
            this.inited = this.done[strObj] = true;

            this.checkAllCombined();

            var data = strObj ? this.cond[strObj] : this.queue;
            if (!data) return;
            for (var i = 0; i < data.length; i++)
                data[i][0].call(data[i][1]);
        }
    },

    
    
    

    /**
     * Determines the way apf tries to render this application. Set this value
     * before apf is starts parsing.
     *   Possible values:
     *   0    auto
     *   1    partial
     *   11   partial from a comment
     *   2    full from serialized document or file fallback
     *   21   full from file
     * @type {Number}
     */
    parseStrategy : 0,

    

    /**
     * @private
     */
    parseAppMarkup : function(docElement){
        var isEmptyDocument = false;
        
        

        

        

        
        if (isEmptyDocument && document.documentElement.outerHTML
          .split(">", 1)[0]
          .indexOf(apf.ns.aml) == -1) {
            
            apf.console.warn("The aml namespace declaration wasn't found. "
                           + "No aml elements were found in the body. Exiting");
            
            return false;
        }

        //Load current HTML document as 'second DOM'
        if (this.parseStrategy == 21 || !this.parseStrategy && !docElement) {
            return apf.oHttp.get((apf.alternativeAml 
              || document.body && document.body.getAttribute("xmlurl") 
              || location.href).split(/#/)[0], {
                
                type : "markup",
                
                callback: function(xmlString, state, extra){
                    if (state != apf.SUCCESS) {
                        var oError = new Error(apf.formatErrorString(0, null,
                            "Loading XML application data", "Could not load "
                          + "XML from remote source: " + extra.message));

                        if (extra.tpModule.retryTimeout(extra, state, null, oError) === true)
                            return true;

                        throw oError;
                    }

                    
                    apf.lineBodyStart = (xmlString.replace(/\n/g, "\\n")
                        .match(/(.*)<body/) || [""])[0].split("\\n").length;
                    

                    //@todo apf3.0 rewrite this flow
                    var str = xmlString.replace(/\<\!DOCTYPE[^>]*>/, "")
                      .replace(/^[\r\n\s]*/, ""); //.replace(/&nbsp;/g, " ") //should be html2xmlentity conversion
                    if (!apf.supportNamespaces)
                        str = str.replace(/xmlns\=\"[^"]*\"/g, "");
                    //var xmlNode = apf.getXmlDom(str);//apf.getAmlDocFromString(xmlString);

                    if (self.ERROR_HAS_OCCURRED)
                        return;

                    //Clear Body
                    if (apf.isIE)
                        document.body.innerHTML ="";
                    else {
                        var nodes = document.body.childNodes;
                        for (var i = nodes.length - 1; i >= 0; i--)
                            nodes[i].parentNode.removeChild(nodes[i]);
                    }

                    
                    document.documentElement.style.display = "block";
                    document.body.style.display = "block"; //might wanna make this variable based on layout loading...
                    

                    apf.initialize(str);

                }, ignoreOffline: true});
        }
        else {
            
            //might wanna make this variable based on layout loading...
            document.body.style.display = "block";
            

            if (!self.ERROR_HAS_OCCURRED)
                apf.initialize(docElement.outerHTML || docElement.xml);
        }
        
    },
    
    namespaces : {},
    setNamespace : function(namespaceURI, oNamespace){
        this.namespaces[namespaceURI] = oNamespace;
        oNamespace.namespaceURI = namespaceURI;
    },

    /**
     * @private
     */
    initialize : function(xmlStr){
        
        if (apf.initialized) return;
        apf.initialized = true;
        

        

        apf.console.info("Initializing...");
        clearInterval(apf.Init.interval);

        // Run Init
        apf.Init.run(); //Process load dependencies
        
        
        
        var bodyMarginTop = parseFloat(apf.getStyle(document.body, "marginTop"));
        apf.doesNotIncludeMarginInBodyOffset = (document.body.offsetTop !== bodyMarginTop);

        
        {
            apf.window.init(xmlStr);
        }
    },

    
    /**
     * @private
     */
    execDeferred: function() {
        // execute each function in the stack in the order they were added
        var len = apf.load_events.length;
        while (len--)
            (apf.load_events.shift())();
    },

    load_events: [],
    load_timer : null,
    load_done  : false,
    load_init  : null,

    /**
     * @private
     */
    addDomLoadEvent: function(func) {
        if (!this.$bdetect)
            this.browserDetect();

        if (apf.load_done)
            return func();

        // create event function stack
        //apf.done = arguments.callee.done;
        if (!apf.load_init) {
            apf.load_init = function() {
                if (apf.load_done) return;
                // kill the timer
                clearInterval(apf.load_timer);
                apf.load_timer = null;
                apf.load_done  = true;
                if (apf.started)
                    apf.execDeferred();
            };
        }

        apf.load_events.push(func);

        if (func && apf.load_events.length == 1) {
            // Catch cases where addDomLoadEvent() is called after the browser
            // event has already occurred.
            var doc = document, UNDEF = "undefined";
            if ((typeof doc.readyState != UNDEF && doc.readyState == "complete")
              || (typeof doc.readyState == UNDEF && (doc.getElementsByTagName("body")[0] || doc.body)))
                return apf.load_init();

            // for Mozilla/Opera9.
            // Mozilla, Opera (see further below for it) and webkit nightlies
            // currently support this event
            if (doc.addEventListener && !apf.isOpera) {
                // We're using "window" and not "document" here, because it results
                // in a memory leak, especially in FF 1.5:
                // https://bugzilla.mozilla.org/show_bug.cgi?id=241518
                // See also:
                // http://bitstructures.com/2007/11/javascript-method-callbacks
                // http://www-128.ibm.com/developerworks/web/library/wa-memleak/
                window.addEventListener("DOMContentLoaded", apf.load_init, false);
            }
            // If IE is used and is not in a frame
            else if (apf.isIE && window == top) {
                apf.load_timer = setInterval(function() {
                    try {
                        // If IE is used, use the trick by Diego Perini
                        // http://javascript.nwbox.com/IEContentLoaded/
                        doc.documentElement.doScroll("left");
                    }
                    catch(ex) {
                        $setTimeout(arguments.callee, 0);
                        return;
                    }
                    // no exceptions anymore, so we can call the init!
                    apf.load_init();
                }, 10);
            }
            else if (apf.isOpera) {
                doc.addEventListener("DOMContentLoaded", function() {
                    apf.load_timer = setInterval(function() {
                        for (var i = 0, l = doc.styleSheets.length; i < l; i++) {
                            if (doc.styleSheets[i].disabled)
                                return;
                        }
                        // all is fine, so we can call the init!
                        apf.load_init();
                    }, 10);
                }, false);
            }
            else if (apf.isWebkit && !apf.isIphone) {
                var aSheets = doc.getElementsByTagName("link"),
                    i       = aSheets.length,
                    iSheets;
                for (; i >= 0; i++) {
                    if (!aSheets[i] || aSheets[i].getAttribute("rel") != "stylesheet")
                        aSheets.splice(i, 0);
                }
                iSheets = aSheets.length;
                apf.load_timer  = setInterval(function() {
                    if (/loaded|complete/.test(doc.readyState)
                      && doc.styleSheets.length == iSheets)
                        apf.load_init(); // call the onload handler
                }, 10);
            }
            // for other browsers set the window.onload, but also execute the
            // old window.onload
            else {
                var old_onload = window.onload;
                window.onload  = function () {
                    apf.load_init();
                    if (old_onload)
                        old_onload();
                };
            }
        }
    },
    
    
    /**
     * @private
     */
    addListener : function(el, type, fn){
        if (el.addEventListener)
            el.addEventListener(type, fn, false);
        else if (el.attachEvent)
            el.attachEvent("on" + type, fn);
        return this;
    },
    
    /**
     * @private
     */
    removeListener : function(el, type, fn){
        if (el.removeEventListener)
            el.removeEventListener(type, fn, false);
        else if (el.detachEvent)
            el.detachEvent("on" + type, fn);
        return this;
    },

    stopEvent: function(e){
        this.stopPropagation(e).preventDefault(e);
        return false;
    },

    stopPropagation: function(e){
        if (e.stopPropagation)
            e.stopPropagation();
        else
            e.cancelBubble = true;
        return this;
    },

    preventDefault: function(e){
        if (e.preventDefault)
            e.preventDefault();
        else
            e.returnValue = false;
        return this;
    },

    /* Destroy */

    /**
     * Unloads the aml application.
     */
    unload : function(exclude){
        
        apf.console.info("Initiating self destruct...");
        

        this.isDestroying = true;

        
        this.popup.destroy();
        

        var node,
            i = 0,
            l = this.all.length;
        for (; i < l; i++) {
            node = this.all[i];
            if (node && node != exclude && node.destroy && !node.apf)
                node.destroy(false);
        }

        //this.dispatchEvent("DOMNodeRemovedFromDocument", {});//@todo apf3.0
        
        for (i = 0, l = this.availHTTP.length; i < l; i++)
            this.availHTTP[i] = null;
        
        this.availHTTP.length = 0;

        
        if (apf.xmldb)
            apf.xmldb.unbind(apf.window);
        

        this.isDestroying = false;
    }
};

/*
 * Replacement for getElementsByTagNameNS because some browsers don't support
 * this call yet.
 */
var $xmlns = function(xmlNode, tag, xmlns, prefix){
    if (!apf.supportNamespaces) {
        if (!prefix)
            prefix = apf.findPrefix(xmlNode, xmlns);

        if (xmlNode.style || xmlNode == document)
            return xmlNode.getElementsByTagName(tag)
        else {
            if (prefix)
                (xmlNode.nodeType == 9 ? xmlNode : xmlNode.ownerDocument)
                    .setProperty("SelectionNamespaces",
                        "xmlns:" + prefix + "='" + xmlns + "'");

            return xmlNode.selectNodes(".//" + (prefix ? prefix + ":" : "") + tag);
        }
    }
    
    return xmlNode.getElementsByTagNameNS(xmlns, tag);
};

var $setTimeout  = setTimeout;
var $setInterval = setInterval;

apf.setTimeout = function(f, t){
    apf.eventDepth++;
    return $setTimeout(function(){
        f();
        
        if (--apf.eventDepth == 0)
            apf.queue.empty();
    }, t);
}

document.documentElement.className += " has_apf";
document.documentElement.style.display = "none";

apf.browserDetect();
apf.Init.run("apf");





/*FILEHEAD(/var/lib/platform/source/trunk/core/class.js)SIZE(41552)TIME(1271234270)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * @term propertybinding With property binding you can define the way a 
 * property is calculated. <img src="http://www.rubendaniels.com/images/propbind.gif" align="right" />
 * This statement is usually based on a javascript 
 * expression including one or more properties on other objects. The value of 
 * the property will always be kept up to date. This means that when one of the 
 * dependent properties changes, the property is recalculated. See the picture 
 * for a graphical explanation. 
 * Example:
 * Let me give you an example to make it a bit straightforward. This example 
 * sets the visibility of the slider based on the state of the checkbox.
 * <code>
 *  <a:slider visible="{myCheckbox.value}" />
 *  <a:checkbox id="myCheckbox">Toggle this</a:checkbox>
 * </code>
 *
 * Expressions:
 * The use of { and } tell Ajax.org Platform(APF) that the visible property will 
 * be bound. By specifying myCheckbox.value APF knows that the value of 
 * myCheckbox should be retrieved for this property. Whenever the checkbox 
 * changes, the slider will show or hide.
 *
 * Bidirectional:
 * Sometimes it's necessary to make a binding from one property to another one, 
 * and vice versa. Think of a slider that is connected to the position property
 * of a video element. When the video plays, the value of the slider should be 
 * updated. When the slider is dragged the video should be updated. This works 
 * in the same way as above, but instead of using curly braces 
 * you use brackets: [ and ]. The next example keeps the state of a dropdown in 
 * sync with the state of the tab page.
 * <code>
 *  <a:tab activepage="[myDropdown.value]">
 *     <a:page caption="Page 1" />
 *     <!-- etc -->
 *  </a:tab>
 *  <a:dropdown id="myDropdown">
 *     <a:item value="0">Page 1</a:item>
 *     <!-- etc -->
 *  </a:dropdown>
 * </code>
 *
 * For more information visit {@link http://www.rubendaniels.com/2008/07/04/property-binding/ this blog article}.</a>
 *
 * Internals:
 * Property binding in apf is a flavor of a {@link http://en.wikipedia.org/wiki/Publish/subscribe publish/subscribe}
 * system. When a binding is established the element that receives the value sets
 * a listener on the property of another element. There can be any number of 
 * elements referenced in a single expression. When any of the properties that 
 * are listened to change, the subscriber gets notified to update the value
 * of it's property.
 */

/**
 * @term baseclass A baseclass in Ajax.org Platform (apf) is a class that 
 * adds properties, methods, attributes, bindings and actions to the class that
 * inherits from it. Javascript doesn't have most object oriented concepts like
 * classes, class inheritance, interfaces, protected members and so on. When
 * using apf you will find that some of these concepts have
 * been implemented in a way that enables the core developers of apf to think in
 * those concepts. The most important one is class inheritance. Because of the
 * freedoms that javascript allows, it is possible to implement
 * {@link http://en.wikipedia.org/wiki/Inheritance_(computer_science) inheritance}
 * and even {@link http://en.wikipedia.org/wiki/Multiple_inheritance multiple inheritance}.
 * 
 * Usage:
 * In apf multiple inheritance is used on all elements to assign specific traits
 * to aml elements. Check the list of baseclasses on the right to familiarize 
 * yourself with the traits that are available (i.e. dragdrop, rename, multiselect,
 * databinding, alignment, etc). At the article of each element that inherits
 * from a baseclass you will find an inheritance tree on the right. This tree
 * will show you <strong>from which baseclasses that element has received traits</strong>.
 * Compared to Java and other strict OOP languages, the inheritance tree is
 * inverted. To give an example, in Java for instance, a Lamborghini inherits from 
 * Car which inherits from Vehicle. In apf Audi inherits from Engine, Wheels,
 * Seats and Airco. So we can make the latest Lamborghini inherit from Airco too.
 *
 * Class:
 * The apf.Class baseclass provides all basic features a apf element needs, such
 * as event system, property binding and multiple inheritance with state defined
 * by each baseclass.
 * By setting the prototype of a function to an instance of apf.Class 
 * these  <i title="an inherited characteristic (merriam-webster)">traits</i> are
 * transferred to your class.
 *
 * API:
 * The first method is the one that tells an object to implement traits from a
 * baseclass.
 * It works as follows:
 * <code>
 *  var myClass = function(){
 *      this.$init();
 *  }
 *  myClass.prototype = new apf.Class();
 * </code>
 * There is a class tree that you can use to create your own elements. For 
 * instance to create a visible element that uses skinning you can inherit from
 * apf.Presentation:
 * <code>
 *  var myElement = function(){
 *      this.$init();
 *  }
 *  myElement.prototype = new apf.Presentation();
 * </code>
 * Please find a full description of the inheritance tree below.
 *
 * To check whether an object has inherited from baseclass use the following
 * syntax:
 * <code>
 *  myObj.hasFeature(apf.__PRESENTATION__);
 * </code>
 * Where the constant is the name of the baseclass in all caps.
 *
 * Apf supports multiple inheritance. Use the implement method to add a 
 * baseclass to your class that is not part of the inheritance tree:
 * <code>
 *  var myElement = function(){
 *      this.$init();
 *
 *      this.implement(apf.Rename);
 *  }
 *  myElement.prototype = new apf.MultiSelect();
 * </code>
 * 
 * Inheritance Tree:
 * <code>
 *  - apf.Class
 *      - apf.AmlNode
 *          - apf.AmlElement
 *              - apf.Teleport
 *              - apf.GuiElement
 *                  - apf.Presentation
 *                      - apf.BaseTab
 *                      - apf.DataBinding
 *                          - apf.StandardBinding
 *                              - apf.BaseButton
 *                              - apf.BaseSimple
 *                              - apf.Media
 *                          - apf.MultiselectBinding
 *                              - apf.MultiSelect
 *                                  - apf.BaseList
 * </code>
 * Generally elements inherit from AmlElement, Presentation, StandardBinding, 
 * MultiselectBinding, or one of the leafs.
 *
 * The following classes are implemented using the implement method:
 * <code>
 * - apf.Cache
 * - apf.ChildValue
 * - apf.ContentEditable
 * - apf.DataAction
 * - apf.Media
 * - apf.MultiCheck
 * - apf.Rename
 * - apf.Xforms
 * </code>
 *
 * The following classes are automatically implemented when needed by apf.GuiElement.
 * <code>
 * - apf.Alignment
 * - apf.Anchoring
 * - apf.Docking
 * - apf.DelayedRender
 * - apf.DragDrop
 * - apf.Focussable
 * - apf.Interactive
 * - apf.Transaction
 * - apf.Validation
 * </code>
 *
 * The following class is automatically implemented by apf.MultiselectBinding
 * <code>
 * - apf.VirtualViewport
 * </code>
 */

/**
 * All elements that implemented this {@link term.baseclass baseclass} have
 * {@link term.propertybinding property binding},
 * event handling and constructor & destructor hooks. The event system is 
 * implemented following the W3C specification, similar to the 
 * {@link http://en.wikipedia.org/wiki/DOM_Events event system of the HTML DOM}.
 *
 * @constructor
 * @baseclass
 *
 * @author      Ruben Daniels (ruben AT ajax DOT org)
 * @version     %I%, %G%
 * @since       0.8
 *
 * @event propertychange Fires when a property changes.
 *   object:
 *     {String} name          the name of the changed property
 *     {Mixed}  originalvalue the value it had before the change
 *     {Mixed}  value         the value it has after the change
 *
 */
apf.Class = function(){};

apf.Class.prototype = new (function(){
    // privates
    var FUN   = "function",
        OBJ   = "object",
        UNDEF = "undefined",
        SEL   = "model", //selected|selection|properties|
        PROP  = "prop.",
        MODEL = "model",
        VALUE = "value";

    this.$regbase   = 0;
    /**
     * Tests whether this object has implemented a {@link term.baseclass baseclass}.
     * @param {Number} test the unique number of the {@link term.baseclass baseclass}.
     */
    this.hasFeature = function(test){
        return this.$regbase & test;
    };
    
    this.$initStack    = [];
    this.$bufferEvents = [];
    this.$init = function(callback, nodeFunc, struct){
        if (typeof callback == FUN || callback === true) {
            this.$bufferEvents = this.$bufferEvents.slice();
            
            if (callback === true)
                return this;
            
            this.$initStack = this.$initStack.slice(); //Our own private stack
            this.$initStack.push(callback);
            
            return this;
        }

        this.addEventListener = realAddEventListener;
        this.$removalQueue = [];

        if (this.nodeType != 2) //small little hack
            this.$uniqueId = apf.all.push(this) - 1;

        this.$captureStack = {};
        this.$eventsStack  = {};
        this.$funcHandlers = {};

        var i = 0, l = this.$initStack.length;
        for (; i < l; i++)
            this.$initStack[i].apply(this, arguments);
        
        for (i = 0, l = this.$bufferEvents.length; i < l; i++)
            this.addEventListener.apply(this, this.$bufferEvents[i]);
        
        delete realAddEventListener;
        delete this.$initStack;
        delete this.$bufferEvents;
        
        if (struct && struct.htmlNode) {
            this.$pHtmlNode = struct.htmlNode;
            
            
                this.ownerDocument.$domParser.$continueParsing(this);
                
                
                apf.queue.empty();
                
            
        }
        
        return this;
    };
    
    this.implement = apf.implement;

    /**** Property Binding ****/

    this.$handlePropSet = function(prop, value){
        this[prop] = value;
    };
    
    
    
    /**
     * Bind a property of another compontent to a property of this element.
     *
     * @param  {String} myProp           the name of the property of this element
     *                                   of which the value is communicated to
     *                                   <code>bObject</code>.
     * @param  {Class}  bObject          the object which will receive the property
     *                                   change message.
     * @param  {String} bProp            the property of <code>bObject</code> which
     *                                   will be set using the value of
     *                                   <code>myProp</code> optionally
     *                                   processed using <code>strDynamicProp</code>.
     * @param  {String} [strDynamicProp] a javascript statement which contains the
     *                                   value of <code>myProp</code>. The string
     *                                   is used to calculate a new value.
     * @private
     */
    this.$bindProperty = function(myProp, bObject, bProp, fParsed){
        if (!fParsed)
            return bObject.$handlePropSet(bProp, this[myProp]);

        var eventName = PROP + myProp, eFunc, isBeingCalled, isLang;
        (this.$eventsStack[eventName] || (this.$eventsStack[eventName] = [])).push(eFunc = function(e){
            if (isBeingCalled) //Prevent circular refs
                return;
            
            
            isBeingCalled = true;
            
            try {
                if (fParsed.asyncs) { //if async
                    return fParsed.call(bObject, bObject.xmlRoot, function(value){
                        bObject.setProperty(bProp, value, true, false, 10);
                        
                        
                        
                        isBeingCalled = false;
                    }); 
                }
                else {
                    var value = fParsed.call(bObject, bObject.xmlRoot);
                }
            }
            catch(e) {
                apf.console.warn("[331] Could not execute binding for property "
                    + bProp + "\n\n" + e.message);
                
                isBeingCalled = false;
                
                return;
            }

            //Can't do this when using xml nodes, doesnt seem needed anyway
            //if (bObject[bProp] != value)
                bObject.setProperty(bProp, value, true, false, 10);//e.initial ? 0 : 
            
            
            
            isBeingCalled = false;
        });
        
        //eFunc({initial: true});
        
        return eFunc;
    };
    
    /**
     * Sets a dynamic property from a string.
     * The string used for this function is the same as used in AML to set a
     * dynamic property:
     * <code>
     *  <a:button visible="{rbTest.value == 'up'}" />
     *  <a:textbox id="rbTest" value="" />
     * </code>
     *
     * @param  {String}  prop   the name of the property of this element to set
     *                          using a dynamic rule.
     * @param  {String}  pValue the dynamic property binding rule.
     */
    this.$attrExcludePropBind = false;
    this.$setDynamicProperty = function(prop, pValue){
        var exclNr = this.$attrExcludePropBind[prop],
            options;

        //@todo apf3.0, please generalize this - cache objects, seems slow
        if (SEL.indexOf(prop) > -1 || exclNr == 3) {
            options = {
                xpathmode : 2,
                parsecode : true //@todo is this also good for exclNr 3 ?
            }
        }
        else if (exclNr == 2) {
            options = {nostring : true};
        }
        else if (exclNr === 0) {
            options = {parsecode : true 
             , nothrow : this.target.match(/-debug$/) ? true : false };
        }
        
        
        if (apf.config.debugLm)
            (options || (options = {})).nothrow = true;
        

        //Compile pValue through JSLT parser
        var fParsed = apf.lm.compile(pValue, options);

        //Special case for model due to needed extra signalling
        if (prop == MODEL)
            (this.$modelParsed = fParsed).instruction = pValue
        
        else if (exclNr === 0)
            this.$lastFParsed = fParsed;
        

        //if it's only text return setProperty()
        if (fParsed.type == 2) {
            this[prop] = !pValue; //@todo apf3.0 is this needed?
            return this.setProperty(prop, fParsed.str);
        }

        //if there's xpath: Add apf.DataBinding if not inherited. 
        //Add compiled binding rule. Load databinding if not loaded. 
        
        if (exclNr == 2 || fParsed.xpaths.length && exclNr != 1) {
            if (!this.hasFeature(apf.__DATABINDING__))
                this.implement(apf.StandardBinding);
            
            this.$addAttrBind(prop, fParsed, pValue);
        }
        

        //if there's prop binding: Add generated function to each obj/prop in the list
        var matches = exclNr && exclNr != 3 && prop != MODEL ? {} : fParsed.props, //@todo apf3.0 sign of broken abstraction, please fix this with a bit mask
            found   = false,
            _self   = this,
            o, node, bProp, p;

        for (p in matches) {
            

            o = p.split(".");
            if (o.length > 2) { //apf.offline.syncing
                bProp = o.pop();
                try{
                    node  = eval(o.join("."));
                }
                catch(e){
                    if (arguments[2]) {
                        apf.console.warn("[287] Could not execute binding test : "
                            + pValue.replace(/</g, "&lt;") + "\n\n" + e.message);
                    }
                    else {
                        apf.queue.add(prop + ":" + this.$uniqueId, function(){
                            _self.$clearDynamicProperty(prop);
                            _self.$setDynamicProperty(prop, pValue, true);
                        });
                    }
                    continue;
                }

                if (!node || typeof node != OBJ || (!node.$regbase && node.$regbase !== 0)) {
                    bProp = o[1];
                    node  = self[o[0]];
                }
                else {
                    o.push(bProp);
                }
            }
            else {
                bProp = o[1];
                node  = self[o[0]] || o[0] == "this" && this;
            }

            if (!node) {
                if (arguments[2]) {
                    apf.console.warn("[287] Could not execute binding test : "
                        + pValue.replace(/</g, "&lt;") + "\n\n" + o[0] + " does not exist");
                }
                else {
                    apf.queue.add(prop + ":" + this.$uniqueId, function(){
                        _self.$clearDynamicProperty(prop);
                        _self.$setDynamicProperty(prop, pValue, true);
                    });
                    return;
                }
            }

            if (!node.$bindProperty)
                continue;  //return

            if (!this.$funcHandlers[prop])
                this.$funcHandlers[prop] = [];
            this.$funcHandlers[prop].push({
                amlNode : node, 
                prop    : bProp, 
                handler : node.$bindProperty(bProp, this, prop, fParsed)
            });
            found = true;
        }

        if (found) {
            this.$funcHandlers[prop][0].handler({initial: true});
        }
        else {
            //@todo optimize this
            if (exclNr)
                return this.setProperty(prop, pValue);
            
            
            
            try {
                if (fParsed.asyncs) { //if async
                    return fParsed.call(this, this.xmlRoot, function(value){
                        _self.setProperty(prop, value, true);
    
                        
                    }); 
                }
                else {
                    var value = fParsed.call(this, this.xmlRoot);
                }
            }
            catch(e){
                apf.console.warn("[331] Could not execute binding test or: "
                    + pValue.replace(/</g, "&lt;") + "\n\n" + e.message);
                return;
            }
            
            this[prop] = !value; //@todo isnt this slow and unneccesary?
            this.setProperty(prop, value, true);

            
        }
    };
    
    //@todo setAttribute should delete this from apf.language when not doing
    //$setDynamicProperty
    this.$clearDynamicProperty = function(prop){
        if (this.$removeAttrBind)
            this.$removeAttrBind(prop);

        
        
        if (prop == MODEL)
            this.$modelParsed = null;
        
        //Remove any bounds if relevant
        var f, i, l, h = this.$funcHandlers[prop];
        if (h && typeof h != FUN) {
            for (i = 0, l = h.length; i < l; i++) {
                (f = h[i]).amlNode.removeEventListener(PROP + f.prop, f.handler);
            }
            delete this.$funcHandlers[prop];
        }
    };

    
    /**
     * Adds a listener to listen for changes to a certain property. 
     * Implemented as Mozilla suggested see
     * {@link https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/Object/watch their site}.
     */
    this.watch = function(propName, callback){
        var eventName = PROP + propName,
            wrapper   = function(e){
                callback.call(this, propName, e.oldvalue, e.value);
            };
        wrapper.callback = callback;
        
        (this.$eventsStack[eventName] || (this.$eventsStack[eventName] = []))
            .push(wrapper);
    };
    
    /**
     * Removes a listener to listen for changes to a certain property. 
     */
    this.unwatch = function(propName, callback){
        var list, eventName = PROP + propName;
        if (!(list = this.$eventsStack[eventName]))
            return;
        
        for (var i = 0, l = list.length; i < l; i++) {
            if (list[i].callback == callback) {
                list.remove(i);
                return;
            }
        }
    };
    

    

    /**
     * Gets an array of properties for this element which can be bound.
     */
    this.getAvailableProperties = function(){
        return this.$supportedProperties.slice();
    };

    /**
     * Sets the value of a property of this element.
     * Note: Only the value is set, dynamic properties will remain bound and the
     * value will be overridden.
     *
     * @param  {String}  prop        the name of the property of this element to
     *                               set using a dynamic rule.
     * @param  {String}  value       the value of the property to set.
     * @param  {Boolean} [forceOnMe] whether the property should be set even when
     *                               its the same value.
     */
    this.setProperty = function(prop, value, forceOnMe, setAttr, inherited){
        var s, r, arr, e, i, l,
            oldvalue = this[prop],
            isChanged = (typeof value == OBJ)
                ? value != (typeof oldvalue == OBJ ? oldvalue : null)
                : String(oldvalue) !== String(value),
            eventName = PROP + prop;//@todo prop event should be called too;
        
        //Check if property has changed
        if (isChanged) {
            
            
            if (!forceOnMe) { //Recursion protection
                //Check if this property is bound to data
                if (this.xmlRoot && typeof value != OBJ
                  && (!(s = this.$attrExcludePropBind[prop]))// || s == 2
                  && (r = (this.$attrBindings && this.$attrBindings[prop] 
                  || prop != VALUE && this.$bindings[prop] && this.$bindings[prop][0]))) {

                    //Check if rule has single xpath
                    if (r.cvalue.type == 3) {
                        //Set the xml value
                        return apf.setNodeValue(
                            this.$getDataNode(prop.toLowerCase(), this.xmlRoot, true),
                            value, true);
                    }
                }
                
            }

            if (this.$handlePropSet(prop, value, forceOnMe) === false)
                return;
            
            value = this[prop];
            
            if (setAttr)
                this.setAttribute(prop, value, true);
        }
        
        //Optimized event calling
        if (arr = this.$eventsStack[eventName]) {
            /*for (i = 0, l = arr.length; i < l; i++) {
                if (arr[i].call(this, e || (e = new apf.AmlEvent(eventName, {
                    prop     : prop, 
                    value    : value, 
                    oldvalue : oldvalue
                }))) === false) {
                    e.returnValue = false;
                }
            }*/
            if (this.dispatchEvent(eventName, {
                prop     : prop, 
                value    : value, 
                oldvalue : oldvalue
            }) === false) {
                e.returnValue = false;
            }
        }
        
        
        /*
            States:
                    -1 Set
             undefined Pass through
                     2 Inherited
                    10 Dynamic property
        */
        //@todo fix DOM mutation icw property inheritance
        //@todo this whole section should be about attribute inheritance and moved
        //      to AmlElement
        //@todo the check on $amlLoaded is not as optimized as can be because
        //      $loadAml is not called yet
        if ((aci || (aci = apf.config.$inheritProperties))[prop] && this.$amlLoaded) {
            //@todo this is actually wrong. It should be about removing attributes.
            if (inherited != 10 && !value) {
                delete this.$inheritProperties[prop];
                if (this.$setInheritedAttribute(prop))
                    return;
            }
            else if (inherited != 10) { //Keep the current setting (for dynamic properties)
                this.$inheritProperties[prop] = inherited || -1;
            }

            //cancelable, needed for transactions
            if ((!e || e.returnValue !== false) && this.childNodes) {
                (function recur(nodes) {
                    var i, l, node, n;
                    for (i = 0, l = nodes.length; i < l; i++) {
                        node = nodes[i];
                        if (node.nodeType != 1)
                            continue;
                        
                        //Pass through
                        if (!(n = node.$inheritProperties[prop]))
                            recur(node.childNodes);
                        //Set inherited property
                        else if(n > 0)
                            node.setProperty(prop, value, false, false, 2); //This is recursive already
                    }
                })(this.childNodes);
            }
        }
        
        
        return value;
    };
    var aci;

    /**
     * Gets the value of a property of this element.
     *
     * @param  {String}  prop   the name of the property of this element for which to get the value.
     */
    this.getProperty = function(prop){
        return this[prop];
    };

    /**** Event Handling ****/

    apf.eventDepth = 0;
    this.eventDepth = 0;

    /**
     * Calls all functions that are registered as listeners for an event.
     *
     * @param  {String}  eventName  the name of the event to dispatch.
     * @param  {Object}  [options]  the properties of the event object that will be created and passed through.
     *   Properties:
     *   {Boolean} bubbles  whether the event should bubble up to it's parent
     *   {Boolean} captureOnly whether only the captured event handlers should be executed
     * @return {mixed} return value of the event
     */
    //var allowEvents = {"DOMNodeInsertedIntoDocument":1,"DOMNodeRemovedFromDocument":1};
    this.dispatchEvent = function(eventName, options, e){
        var arr, result, rValue, i, l;

        apf.eventDepth++;
        this.eventDepth++;

        e = options && options.name ? options : e;

        /*if (this.disabled && !allowEvents[eventName]) {
            result = false;
        }
        else {*/
            
            if (options && !options.bubbles && options.currentTarget && options.currentTarget != this)
                throw new Error("Invalid use of options detected in dispatch Event");
            
        
            //@todo rewrite this and all dependencies to match w3c
            if ((!e || !e.currentTarget) && (!options || !options.currentTarget)) {
                if (!(options || (options = {})).currentTarget)
                    options.currentTarget = this;

                //Capture support
                if (arr = this.$captureStack[eventName]) {
                    for (i = 0, l = arr.length; i < l; i++) {
                        rValue = arr[i].call(this, e || (e = new apf.AmlEvent(eventName, options)));
                        if (typeof rValue != UNDEF)
                            result = rValue;
                    }
                }
            }
            
            //@todo this should be the bubble point
            
            if (options && options.captureOnly) {
                return e && typeof e.returnValue != UNDEF ? e.returnValue : result;
            }
            else {
                if (this["on" + eventName]) {
                    result = this["on" + eventName].call(this, e 
                        || (e = new apf.AmlEvent(eventName, options))); //Backwards compatibility
                }
    
                if (arr = this.$eventsStack[eventName]) {
                    for (i = 0, l = arr.length; i < l; i++) {
                        if (!arr[i]) continue;
                        rValue = arr[i].call(this, e 
                            || (e = new apf.AmlEvent(eventName, options)));
                        if (typeof rValue != UNDEF)
                            result = rValue;
                    }
                }
            }
        //}
        
        var p;
        while (this.$removalQueue.length) {
            p = this.$removalQueue.shift();
            p[0].remove(p[1]); 
        }
        
        
        if ((e && e.bubbles && !e.cancelBubble || !e && options && options.bubbles) && this != apf) {
            rValue = (this.parentNode || this.ownerElement || apf).dispatchEvent(eventName, options, e);
            // || (e = new apf.AmlEvent(eventName, options))

            if (typeof rValue != UNDEF)
                result = rValue;
        }
        
        
        if (--apf.eventDepth == 0 && this.ownerDocument 
          && !this.ownerDocument.$domParser.$parseContext
          && !apf.isDestroying
          
          && eventName != "debug"
          
          && apf.queue
        ) {
            apf.queue.empty();
        }
        
        this.eventDepth--;

        
        
        return e && typeof e.returnValue != UNDEF ? e.returnValue : result;
    };

    /**
     * Add a function to be called when a event is called.
     *
     * @param  {String}   eventName the name of the event for which to register
     *                              a function.
     * @param  {function} callback  the code to be called when event is dispatched.
     */
    this.addEventListener = function(a, b, c){
        this.$bufferEvents.push([a,b,c]);
    };
    
    var realAddEventListener = function(eventName, callback, useCapture){
        

        if (eventName.substr(0, 2) == "on")
            eventName = eventName.substr(2);

        var s, stack = useCapture ? this.$captureStack : this.$eventsStack;
        if (!(s = stack[eventName]))
            s = stack[eventName] = [];
        if (s.indexOf(callback) == -1)
            s.unshift(callback);
        
        //@todo is this the best way?
        for (var i = this.$removalQueue.length - 1; i >= 0; i--) {
            if (this.$removalQueue[i][0] == s && this.$removalQueue[i][1] == callback)
                this.$removalQueue.removeIndex(i);
        }
        
        var f;
        if (f = this.$eventsStack["$event." + eventName])
            f[0].call(this, callback);
    };

    /**
     * Remove a function registered for an event.
     *
     * @param  {String}   eventName the name of the event for which to unregister
     *                              a function.
     * @param  {function} callback  the function to be removed from the event stack.
     */
    this.removeEventListener = function(eventName, callback, useCapture){
        var stack = (useCapture ? this.$captureStack : this.$eventsStack)[eventName];
        
        //@todo is this the best way?
        if (stack)
            if (this.eventDepth)
                this.$removalQueue.push([stack, callback]);
            else
                stack.remove(callback);
    };

    /**
     * Checks if there is an event listener specified for the event.
     *
     * @param  {String}  eventName  the name of the event to check.
     * @return {Boolean} whether the event has listeners
     */
    this.hasEventListener = function(eventName){
        return (this.$eventsStack[eventName] && this.$eventsStack[eventName].length > 0);
    };

    /**
     * Destructor of a Class.
     * Calls all destructor functions and removes all mem leaking references.
     * This function is called when exiting the application or closing the window.
     * @param {Boolean} deep whether the children of this element should be destroyed.
     * @method
     */
    this.destroy = function(deep, clean){
        //Remove from apf.all
        if (typeof this.$uniqueId == UNDEF && this.nodeType != 2)
            return;
        
        this.$amlLoaded    = false;
        this.$amlDestroyed = true;
        
        if (this.$destroy)
            this.$destroy();

        this.dispatchEvent("DOMNodeRemoved", {
            bubbles : !apf.isDestroying
        });
        this.dispatchEvent("DOMNodeRemovedFromDocument");

        apf.all[this.$uniqueId] = undefined;

        if (!this.nodeFunc && this.nodeType != 2) { //If this is not a AmlNode, we're done.
            //Remove id from global js space
            try {
                if (this.id || this.name)
                    self[this.id || this.name] = null;
            }
            catch (ex) {}
            return;
        }

        if (this.$ext && !this.$ext.isNative && this.$ext.nodeType == 1 && this.localName != "a") {
            this.$ext.oncontextmenu = this.$ext.host = null;
            if (clean) {
                if (this.localName != "collection")
                    this.$ext.parentNode.removeChild(this.$ext);
            }
        }
        if (this.$int && !this.$int.isNative && this.$int.nodeType == 1 && this.localName != "a")
            this.$int.host = null;

        //if (this.$aml && this.$aml.parentNode)
            //this.$aml.parentNode.removeChild(this.$aml);
        this.$aml = null;

        //Clear all children too
        if (deep && this.childNodes) {
            var nodes = this.childNodes;
            for (i = nodes.length - 1; i >= 0; i--) {
                if (nodes[i].destroy)
                    nodes[i].destroy(true, clean && this.localName == "collection");
            }
            this.childNodes = null;
        }

        //Remove from DOM tree if we are still connected
        if (this.parentNode && this.removeNode)
            this.removeNode();
        else if (this.ownerElement && !this.ownerElement.$amlDestroyed)
            this.ownerElement.removeAttributeNode(this);

        //Remove from focus list - Should be in AmlNode
        
        if (this.$focussable && this.focussable)
            apf.window.$removeFocus(this);
        
        
        
        //Remove dynamic properties
        /*var f, i, l, h;
        for (prop in this.$funcHandlers) {
            h = this.$funcHandlers[prop];
            
            //Remove any bounds if relevant
            if (h && typeof h != FUN) {
                for (i = 0, l = h.length; i < l; i++) {
                    (f = h[i]).amlNode.removeEventListener(PROP + f.prop, f.handler);
                }
            }
        }*/
        
        
        if (this.attributes) {
            var attr = this.attributes;
            for (var i = attr.length - 1; i >= 0; i--) {
                
                this.$clearDynamicProperty(attr[i].nodeName);
                
                attr[i].destroy();
            }
        }

        
        if (deep !== false && this.childNodes && this.childNodes.length) {
            apf.console.warn("You have destroyed an Aml Node without destroying "
                           + "it's children. Please be aware that if you don't "
                           + "maintain a reference, memory might leak");
        }
        
        
        //Remove id from global js space
        try {
            if (this.id || this.name)
                self[this.id || this.name] = null;
        }
        catch (ex) {}
        
        
        apf.nameserver.remove(this.localName, this);
        
    };
})();

apf.extend(apf, new apf.Class().$init());
apf.Init.run("class");



/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/util/color.js)SIZE(7843)TIME(1258118722)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



apf.color = {
    colors: {
        aliceblue:"#f0f8ff",antiquewhite:"#faebd7",aqua:"#00ffff",
        aquamarine:"#7fffd4",azure:"#f0ffff",beige:"#f5f5dc",bisque:"#ffe4c4",
        black:"#000000",blanchedalmond:"#ffebcd",blue:"#0000ff",
        blueviolet:"#8a2be2",brown:"#a52a2a",burlywood:"#deb887",
        cadetblue:"#5f9ea0",chartreuse:"#7fff00",chocolate:"#d2691e",
        coral:"#ff7f50",cornflowerblue:"#6495ed",cornsilk:"#fff8dc",
        crimson:"#dc143c",cyan:"#00ffff",darkblue:"#00008b",darkcyan:"#008b8b",
        darkgoldenrod:"#b8860b",darkgray:"#a9a9a9",darkgrey:"#a9a9a9",
        darkgreen:"#006400",darkkhaki:"#bdb76b",darkmagenta:"#8b008b",
        darkolivegreen:"#556b2f",darkorange:"#ff8c00",darkorchid:"#9932cc",
        darkred:"#8b0000",darksalmon:"#e9967a",darkseagreen:"#8fbc8f",
        darkslateblue:"#483d8b",darkslategray:"#2f4f4f",
        darkslategrey:"#2f4f4f",darkturquoise:"#00ced1",darkviolet:"#9400d3",
        deeppink:"#ff1493",deepskyblue:"#00bfff",dimgray:"#696969",
        dimgrey:"#696969",dodgerblue:"#1e90ff",firebrick:"#b22222",
        floralwhite:"#fffaf0",forestgreen:"#228b22",fuchsia:"#ff00ff",
        gainsboro:"#dcdcdc",ghostwhite:"#f8f8ff",gold:"#ffd700",
        goldenrod:"#daa520",gray:"#808080",grey:"#808080",green:"#008000",
        greenyellow:"#adff2f",honeydew:"#f0fff0",hotpink:"#ff69b4",
        indianred:"#cd5c5c",indigo:"#4b0082",ivory:"#fffff0",khaki:"#f0e68c",
        lavender:"#e6e6fa",lavenderblush:"#fff0f5",lawngreen:"#7cfc00",
        lemonchiffon:"#fffacd",lightblue:"#add8e6",lightcoral:"#f08080",
        lightcyan:"#e0ffff",lightgoldenrodyellow:"#fafad2",lightgray:"#d3d3d3",
        lightgrey:"#d3d3d3",lightgreen:"#90ee90",lightpink:"#ffb6c1",
        lightsalmon:"#ffa07a",lightseagreen:"#20b2aa",lightskyblue:"#87cefa",
        lightslategray:"#778899",lightslategrey:"#778899",
        lightsteelblue:"#b0c4de",lightyellow:"#ffffe0",lime:"#00ff00",
        limegreen:"#32cd32",linen:"#faf0e6",magenta:"#ff00ff",maroon:"#800000",
        mediumaquamarine:"#66cdaa",mediumblue:"#0000cd",
        mediumorchid:"#ba55d3",mediumpurple:"#9370d8",mediumseagreen:"#3cb371",
        mediumslateblue:"#7b68ee",mediumspringgreen:"#00fa9a",
        mediumturquoise:"#48d1cc",mediumvioletred:"#c71585",
        midnightblue:"#191970",mintcream:"#f5fffa",mistyrose:"#ffe4e1",
        moccasin:"#ffe4b5",navajowhite:"#ffdead",navy:"#000080",
        oldlace:"#fdf5e6",olive:"#808000",olivedrab:"#6b8e23",orange:"#ffa500",
        orangered:"#ff4500",orchid:"#da70d6",palegoldenrod:"#eee8aa",
        palegreen:"#98fb98",paleturquoise:"#afeeee",palevioletred:"#d87093",
        papayawhip:"#ffefd5",peachpuff:"#ffdab9",peru:"#cd853f",pink:"#ffc0cb",
        plum:"#dda0dd",powderblue:"#b0e0e6",purple:"#800080",red:"#ff0000",
        rosybrown:"#bc8f8f",royalblue:"#4169e1",saddlebrown:"#8b4513",
        salmon:"#fa8072",sandybrown:"#f4a460",seagreen:"#2e8b57",
        seashell:"#fff5ee",sienna:"#a0522d",silver:"#c0c0c0",skyblue:"#87ceeb",
        slateblue:"#6a5acd",slategray:"#708090",slategrey:"#708090",
        snow:"#fffafa",springgreen:"#00ff7f",steelblue:"#4682b4",tan:"#d2b48c",
        teal:"#008080",thistle:"#d8bfd8",tomato:"#ff6347",turquoise:"#40e0d0",
        violet:"#ee82ee",wheat:"#f5deb3",white:"#ffffff",whitesmoke:"#f5f5f5",
        yellow:"#ffff00",yellowgreen:"#9acd32"
    },

    fixHSB: function (hsb) {
        return {
            h: Math.min(360, Math.max(0, hsb.h)),
            s: Math.min(100, Math.max(0, hsb.s)),
            b: Math.min(100, Math.max(0, hsb.b))
        };
    },

    fixRGB: function (rgb) {
        return {
            r: Math.min(255, Math.max(0, rgb.r)),
            g: Math.min(255, Math.max(0, rgb.g)),
            b: Math.min(255, Math.max(0, rgb.b))
        };
    },

    fixHex: function (hex) {
        var len = 6 - hex.length;
        if (len > 0) {
            var o = [], i = 0;
            for (; i < len; i++)
                o.push("0");
            o.push(hex);
            hex = o.join("");
        }
        return hex;
    },
    
    hexToRGB: function (hex) {
        hex = parseInt(((hex.indexOf("#") > -1) ? hex.substring(1) : hex), 16);
        return {r: hex >> 16, g: (hex & 0x00FF00) >> 8, b: (hex & 0x0000FF)};
    },

    hexToHSB: function (hex) {
        return this.RGBToHSB(this.hexToRGB(hex));
    },

    RGBToHSB: function (rgb) {
        var hsb = {
            h: 0,
            s: 0,
            b: 0
        };
        var min   = Math.min(rgb.r, rgb.g, rgb.b),
            max   = Math.max(rgb.r, rgb.g, rgb.b),
            delta = max - min;
        hsb.b = max;
        if (max != 0) { }
        hsb.s = max != 0 ? 255 * delta / max : 0;
        if (hsb.s != 0) {
            if (rgb.r == max)
                hsb.h = (rgb.g - rgb.b) / delta;
            else if (rgb.g == max)
                hsb.h = 2 + (rgb.b - rgb.r) / delta;
            else
                hsb.h = 4 + (rgb.r - rgb.g) / delta;
        }
        else
            hsb.h = -1;
        hsb.h *= 60;
        if (hsb.h < 0)
            hsb.h += 360;
        hsb.s *= 100/255;
        hsb.b *= 100/255;
        return hsb;
    },
    
    HSBToRGB: function(hsb) {
        var rgb = {},
            h   = Math.round(hsb.h),
            s   = Math.round(hsb.s * 255 / 100),
            v   = Math.round(hsb.b * 255 / 100);
        if (s == 0)
            rgb.r = rgb.g = rgb.b = v;
        else {
            var t1 = v,
                t2 = (255 - s) * v / 255,
                t3 = (t1 - t2) * (h % 60)/60;
            if (h == 360)
                h = 0;
            if (h < 60)
                rgb.r = t1, rgb.b = t2, rgb.g = t2 + t3;
            else if (h < 120)
                rgb.g = t1, rgb.b = t2, rgb.r = t1 - t3;
            else if (h < 180)
                rgb.g = t1, rgb.r = t2, rgb.b = t2 + t3;
            else if (h < 240)
                rgb.b = t1, rgb.r = t2, rgb.g = t1 - t3;
            else if (h < 300)
                rgb.b = t1, rgb.g = t2, rgb.r = t2 + t3;
            else if (h < 360)
                rgb.r = t1, rgb.g = t2, rgb.b = t1 - t3;
            else
                rgb.r = 0, rgb.g = 0, rgb.b = 0;
        }
        return {r: Math.round(rgb.r), g: Math.round(rgb.g), b: Math.round(rgb.b)};
    },

    RGBToHex: function(rgb) {
        var hex = [
                rgb.r.toString(16),
                rgb.g.toString(16),
                rgb.b.toString(16)
            ],
            i = 0;
        for (; i < 3; i++) {
            if (hex[i].length == 1)
                hex[i] = "0" + hex[i];
        }
        return hex.join("");
    },

    HSBToHex: function(hsb) {
        return this.RGBToHex(this.HSBToRGB(hsb));
    }
};




/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/util/ecmaext.js)SIZE(24212)TIME(1270838605)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



// start closure:
//(function(){

if (typeof isFinite == "undefined") {
    function isFinite(val){
        return val + 1 != val;
    }
}

apf.NUMBER   = 1;
apf.BOOLEAN  = 2;
apf.STRING   = 3;
apf.ARRAY    = 4;
apf.DATE     = 5;
apf.REGEXP   = 6;
apf.FUNCTION = 7;

Array.prototype.dataType    = apf.ARRAY;
Number.prototype.dataType   = apf.NUMBER;
Date.prototype.dataType     = apf.DATE;
Boolean.prototype.dataType  = apf.BOOLEAN;
String.prototype.dataType   = apf.STRING;
RegExp.prototype.dataType   = apf.REGEXP;
Function.prototype.dataType = apf.FUNCTION;

/**
 * Converts a javascript object to a cgi string.
 * @see core.convertXml
 */
apf.getCgiString = function(args, multicall, mcallname){
    var vars = [];

    function recur(o, stack) {
        var prop;
        if (apf.isArray(o)) {
            for (var j = 0; j < o.length; j++)
                recur(o[j], stack + "%5B%5D");//" + j + "
        } 
        else if (typeof o == "object") {
            for (prop in o) {
                if (apf.isSafariOld && (!o[prop] || typeof p[prop] != "object"))
                    continue;

                if (typeof o[prop] == "function")
                    continue;
                recur(o[prop], stack + "%5B" + encodeURIComponent(prop) + "%5D");
            }
        }
        else
            vars.push(stack + "=" + encodeURIComponent(o));
    };

    if (multicall) {
        vars.push("func=" + mcallname);
        for (var i = 0; i < args[0].length; i++)
            recur(args[0][i], "f%5B" + i + "%5D");
    } else {
        for (prop in args) {
            if (apf.isSafariOld && (!args[prop] || typeof args[prop] == "function"))
                continue;

            recur(args[prop], prop);
        }
    }

    return vars.join("&");
}

/**
 * Converts a cgi string to a javascript object.
 * @see core.convertXml
 */
apf.fromCgiString = function(args) {
    if (!args)
        return false;

    var obj = {};
    args = args.split("&");
    for (var data, i = 0; i < args.length; i++) {
        data = args[i].split("=");
        data[0] = decodeURIComponent(data[0]);
        var path = data[0].replace(/\]/g, "").split("[");

        var spare = obj;
        for (var j = 0; j < path.length; j++) {
            if (spare[path[j]])
                spare = spare[path[j]];
            else if (path.length == j+1) {
                if (path[j])
                    spare[path[j]] = decodeURIComponent(data[1]);
                else
                    spare.push(decodeURIComponent(data[1]));
                break; //assuming last
            }
            else{
                spare[path[j]] = !path[j+1] ? [] : {};
                spare = spare[path[j]];
            }
        }
    }

    return obj;
}




/**
 * Extends a Function object with properties from other objects, specified as
 * arguments.
 *
 * @param {mixed} obj1, obj2, obj3, etc.
 * @type Function
 * @see apf.extend
 */
Function.prototype.extend = function() {
    apf.extend.apply(this, [this].concat(Array.prototype.slice.call(arguments)));
    return this;
};

/**
 * Attach a Function object to an event as handler method. If apf.AbstractEvent
 * is available, the active event is extended with convinience accessors as
 * declared in apf.AbstractEvent
 *
 * @param {Object} The context the execute the Function within
 * @param {Boolean} Whether the passed event object should be extended with AbstractEvent
 * @param {mixed}  param1, param2, param3, etc.
 * @type Function
 * @see apf.AbstractEvent
 */
Function.prototype.bindWithEvent = function() {
    var __method = this, 
        args     = Array.prototype.slice.call(arguments),
        o        = args.shift(),
        ev       = args.shift();
    return function(event) {
        if (!event)
            event = window.event;
        
        return __method.apply(o, [event].concat(args)
            .concat(Array.prototype.slice.call(arguments)));
    }
};

/**
 * Copy an array, like this statement would: 'this.concat([])', but then do it
 * recursively.
 */
Array.prototype.copy = function(){
    var ar = [];
    for (var i = 0, j = this.length; i < j; i++)
        ar[i] = this[i] && this[i].copy ? this[i].copy() : this[i];

    return ar;
};

/**
 * Concatenate the current Array instance with one (or more) other Arrays, like
 * Array.concat(), but return the current Array instead of a new one that
 * results from the merge.
 *
 * @param {Array} array1, array2, array3, etc.
 * @type  {Array}
 */
Array.prototype.merge = function(){
    for (var i = 0, k = arguments.length; i < k; i++) {
        for (var j = 0, l = arguments[i].length; j < l; j++) {
            this.push(arguments[i][j]);
        }
    }
};

/**
 * Add the values of one or more arrays to the current instance by using the
 * '+=' operand on each value.
 *
 * @param {Array} array1, array2, array3, etc.
 * @type  {Array}
 * @see Array.copy
 */
Array.prototype.arrayAdd = function(){
    var s = this.copy();
    for (var i = 0, k = arguments.length; i < k; i++) {
        for (var j = 0, l = s.length; j < l; j++) {
            s[j] += arguments[i][j];
        }
    }

    return s;
};

/**
 * Check if an object is contained within the current Array instance.
 *
 * @param {mixed}   obj The value to check for inside the Array
 * @type  {Boolean}
 */
Array.prototype.equals = function(obj){
    for (var i = 0, j = this.length; i < j; i++)
        if (this[i] != obj[i])
            return false;
    return true;
};

/**
 * Make sure that an array instance contains only unique values (NO duplicates).
 *
 * @type {Array}
 */
Array.prototype.makeUnique = function(){
    var i, length, newArr = [];
    for (i = 0, length = this.length; i < length; i++)
        if (newArr.indexOf(this[i]) == -1)
            newArr.push(this[i]);

    this.length = 0;
    for (i = 0, length = newArr.length; i < length; i++)
        this.push(newArr[i]);

    return this;
};

/**
 * Check if this array instance contains a value 'obj'.
 *
 * @param {mixed}  obj    The value to check for inside the array
 * @param {Number} [from] Left offset index to start the search from
 * @type  {Boolean}
 * @see Array.indexOf
 */
Array.prototype.contains = function(obj, from){
    return this.indexOf(obj, from) != -1;
};

/**
 * Search for the index of the first occurence of a value 'obj' inside an array
 * instance.
 * July 29, 2008: added 'from' argument support to indexOf()
 *
 * @param {mixed}  obj    The value to search for inside the array
 * @param {Number} [from] Left offset index to start the search from
 * @type  {Number}
 */
Array.prototype.indexOf = Array.prototype.indexOf || function(obj, from){
    var len = this.length;
    for (var i = (from < 0) ? Math.max(0, len + from) : from || 0; i < len; i++) {
        if (this[i] === obj)
            return i;
    }
    return -1;
};

/**
 * Search for the index of the last occurence of a value 'obj' inside an array
 * instance.
 *
 * @param {mixed}  obj    The value to search for inside the array
 * @param {Number} [from] Left offset index to start the search from
 * @type  {Number}
 */
Array.prototype.lastIndexOf = Array.prototype.lastIndexOf || function(obj, from) {
    //same as indexOf(), but in reverse loop, JS spec 1.6
    var len = this.length;
    for (var i = (from >= len) ? len - 1 : (from < 0) ? from + len : len - 1; i >= 0; i--) {
        if (this[i] === obj)
            return i;
    }
    return -1;
};

/**
 * Like Array.push, but only invoked when the value 'item' is already present
 * inside the array instance.
 *
 * @param {mixed} item
 * @type  {Array}
 */
Array.prototype.pushUnique = function(item){
    if (this.indexOf(item) == -1)
        this.push(item);
    return this;
};

/**
 * @todo: Ruben: could you please comment on this function? Seems to serve a very
 * specific purpose...
 *
 * I also could not find an occurrence in our codebase.
 */
Array.prototype.search = function(){
    for (var i = 0, length = arguments.length; i < length; i++) {
        if (typeof this[i] != "array")
            continue;
        for (var j = 0; j < length; j++) {
            if (this[i][j] != arguments[j])
                break;
            else if (j == (length - 1))
                return this[i];
        }
    }
};

/**
 * Iterate through each value of an array instance from left to right (front to
 * back) and execute a callback Function for each value.
 *
 * @param {Function} fn
 * @type  {Array}
 */
Array.prototype.each =
Array.prototype.forEach = Array.prototype.forEach || function(fn) {
    for (var i = 0, l = this.length; i < l; i++)
        fn.call(this, this[i], i, this);
    return this;
}

/**
 * Search for a value 'obj' inside an array instance and remove it when found.
 *
 * @type {mixed} obj
 * @type {Array}
 */
Array.prototype.remove = function(obj){
    for (var i = this.length - 1; i >= 0; i--) {
        if (this[i] != obj)
            continue;

        this.splice(i, 1);
    }

    return this;
};

/**
 * Remove an item from an array instance which can be identified with key 'i'
 *
 * @param  {Number} i
 * @return {mixed}  The removed item
 */
Array.prototype.removeIndex = function(i){
    if (!this.length) return null;
    return this.splice(i, 1);
};

/**
 * Insert a new value at a specific object; alias for Array.splice.
 *
 * @param {mixed}  obj Value to insert
 * @param {Number} i   Index to insert 'obj' at
 * @type  {Number}
 */
Array.prototype.insertIndex = function(obj, i){
    this.splice(i, 0, obj);
};

/**
 * Reverses the order of the elements of an array; the first becomes the last,
 * and the last becomes the first.
 *
 * @type {Array}
 */
Array.prototype.invert =
Array.prototype.reverse = Array.prototype.reverse || function(){
    var l = this.length - 1;
    for (var temp, i = 0; i < Math.ceil(0.5 * l); i++) {
        temp        = this[i];
        this[i]     = this[l - i]
        this[l - i] = temp;
    }

    return this;
};



/*
 * Attempt to fully comply (in terms of functionality) with the JS specification,
 * up 'till version 1.7:
 * @link http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Objects:Array
 */

/**
 * Creates a new array with all of the elements of this array for which the
 * provided filtering function returns true.
 *
 * @param {Function} fn   Function to test each element of the array.
 * @param {Object}   bind Object to use as this when executing callback.
 * @type  {Array}
 */
Array.prototype.filter = Array.prototype.filter || function(fn, bind){
    var results = [];
    for (var i = 0, l = this.length; i < l; i++) {
        if (fn.call(bind, this[i], i, this))
            results.push(this[i]);
    }
    return results;
};

/**
 * Returns true if every element in this array satisfies the provided testing
 * function.
 *
 * @param {Function} fn   Function to test for each element.
 * @param {Object}   bind Object to use as this when executing callback.
 * @type  {Boolean}
 */
Array.prototype.every = Array.prototype.every || function(fn, bind){
    for (var i = 0, l = this.length; i < l; i++) {
        if (!fn.call(bind, this[i], i, this))
            return false;
    }
    return true;
};

/**
 * Creates a new array with the results of calling a provided function on every
 * element in this array.
 *
 * @param {Function} fn   Function that produces an element of the new Array from an element of the current one.
 * @param {Object}   bind Object to use as this when executing callback.
 * @type  {Array}
 */
Array.prototype.map = Array.prototype.map || function(fn, bind){
    var results = [];
    for (var i = 0, l = this.length; i < l; i++)
        results[i] = fn.call(bind, this[i], i, this);
    return results;
};

/**
 * Tests whether some element in the array passes the test implemented by the
 * provided function.
 *
 * @param {Function} fn   Function to test for each element.
 * @param {Object}   bind Object to use as this when executing callback.
 * @type  {Boolean}
 */
Array.prototype.some = Array.prototype.some || function(fn, bind){
    for (var i = 0, l = this.length; i < l; i++) {
        if (fn.call(bind, this[i], i, this))
            return true;
    }
    return false;
};



/**
 * Transform a number to a string and pad it with a zero digit its length is one.
 *
 * @type {String}
 */
Number.prototype.toPrettyDigit = Number.prototype.toPrettyDigit || function() {
    var n = this.toString();
    return (n.length == 1) ? "0" + n : n;
};

RegExp.prototype.getNativeFlags = function() {
    return (this.global     ? "g" : "") +
           (this.ignoreCase ? "i" : "") +
           (this.multiline  ? "m" : "") +
           (this.extended   ? "x" : "") +
           (this.sticky     ? "y" : "");
};

/**
 * Accepts flags; returns a new XRegExp object generated by recompiling
 * the regex with the additional flags (may include non-native flags).
 * the original regex object is not altered.
 */
RegExp.prototype.addFlags = function(flags){
    return new RegExp(this.source, (flags || "") + this.getNativeFlags());
};

/**
 * Casts the first character in a string to uppercase.
 *
 * @type {String}
 */
String.prototype.uCaseFirst = function(){
    return this.substr(0, 1).toUpperCase() + this.substr(1)
};

/**
 * Removes spaces and other space-like characters from the left and right ends
 * of a string
 *
 * @type {String}
 */
String.prototype.trim = function(){
    return this.replace(/[\s\n\r]*$/, "").replace(/^[\s\n\r]*/, "");
};

/**
 * Concatenate a string with itself n-times.
 *
 * @param {Number} times Number of times to repeat the String concatenation
 * @type  {String}
 */
String.prototype.repeat = function(times){
    return Array(times + 1).join(this);
};

/**
 * Count the number of occurences of substring 'str' inside a string
 *
 * @param {String} str
 * @type  {Number}
 */
String.prototype.count = function(str){
    return this.split(str).length - 1;
};

/**
 * Remove HTML or any XML-like tags from a string
 *
 * @type {String}
 */
String.prototype.stripTags = function() {
    return this.replace(/<\/?[^>]+>/gi, "");
};

/**
 * Wrapper for the global 'escape' function for strings
 *
 * @type {String}
 */
String.prototype.escape = function() {
    return escape(this);
};

/**
 * Returns an xml document
 * @type {XMLElement}
 */
String.prototype.toXml = function(){
    var node = apf.getXml("<root>" + this + "</root>");
    if (node.childNodes.length == 1) {
        return node.childNodes[0];
    }
    else {
        var docFrag = node.ownerDocument.createDocumentFragment(),
            nodes   = node.childNodes;
        while (nodes.length)
            docFrag.appendChild(nodes[0]);
        return docFrag;
    }
};


if (typeof window != "undefined" && typeof window.document != "undefined" 
  && typeof window.document.createElement == "function") {
    /**
     * Encode HTML entities to its HTML equivalents, like '&amp;' to '&amp;amp;'
     * and '&lt;' to '&amp;lt;'.
     *
     * @type {String}
     * @todo is this fast?
     */
    String.prototype.escapeHTML = function() {
        this.escapeHTML.text.data = this;
        return this.escapeHTML.div.innerHTML;
    };

    /**
     * Decode HTML equivalent entities to characters, like '&amp;amp;' to '&amp;'
     * and '&amp;lt;' to '&lt;'.
     *
     * @type {String}
     */
    String.prototype.unescapeHTML = function() {
        var div = document.createElement("div");
        div.innerHTML = this.stripTags();
        if (div.childNodes[0]) {
            if (div.childNodes.length > 1) {
                var out = [];
                for (var i = 0; i < div.childNodes.length; i++)
                    out.push(div.childNodes[i].nodeValue);
                return out.join("");
            }
            else
                return div.childNodes[0].nodeValue;
        }
        return "";
    };

    String.prototype.escapeHTML.div  = document.createElement("div");
    String.prototype.escapeHTML.text = document.createTextNode("");
    String.prototype.escapeHTML.div.appendChild(String.prototype.escapeHTML.text);

    if ("<\n>".escapeHTML() !== "&lt;\n&gt;")
        String.prototype.escapeHTML = null;

    if ("&lt;\n&gt;".unescapeHTML() !== "<\n>")
        String.prototype.unescapeHTML = null;
}

if (!String.prototype.escapeHTML) {
    String.prototype.escapeHTML = function() {
        return this.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;");
    };
}

if (!String.prototype.unescapeHTML) {
    String.prototype.unescapeHTML = function() {
        return this.stripTags().replace(/&lt;/g,"<").replace(/&gt;/g,">").replace(/&amp;/g,"&");
    };
}

/**
 * Trim a string down to a specific number of characters. Optionally, append an
 * ellipsis ('...') as a suffix.
 *
 * @param {Number}  nr
 * @param {Boolean} [ellipsis] Append an ellipsis
 * @type  {String}
 */
String.prototype.truncate = function(nr, ellipsis){
    return this.length >= nr
        ? this.substring(0, nr - (ellipsis ? 4 : 1)) + (ellipsis ? "..." : "")
        : this;
};

/**
 * Pad a string at the right or left end with a string 'pad' to a specific
 * number of characters. Highly optimized version for speed, not readability.
 *
 * @param {Number}  len   Specifies the amount of characters required to pad to.
 * @param {String}  pad   Specifies the character(s) to pad the string with
 * @param {Boolean} [dir] Specifies at which end to append the 'pad' character (left or right).
 * @type  {String}
 */
String.prototype.pad = function(len, pad, dir) {
    return dir ? (this + Array(len).join(pad)).slice(0, len)
        : (Array(len).join(pad) + this).slice(-len);
};

apf.PAD_LEFT  = false;
apf.PAD_RIGHT = true;

/**
 * Special String.split; optionally lowercase a string and trim all results from
 * the left and right.
 *
 * @param {String}  separator
 * @param {Number}  limit      Maximum number of items to return
 * @param {Boolean} bLowerCase Flag to lowercase the string prior to split
 * @type  {String}
 */
String.prototype.splitSafe = function(separator, limit, bLowerCase) {
    return (bLowerCase && this.toLowerCase() || this)
        .replace(/(?:^\s+|\n|\s+$)/g, "")
        .split(new RegExp("[\\s ]*" + separator + "[\\s ]*", "g"), limit || 999);
};

/**
 * Appends a random number with a specified length to this String instance.
 *
 * @see randomGenerator
 * @param {Number} length
 * @type  {String}
 */
String.prototype.appendRandomNumber = function(length) {
    for (var arr = [], i = 1; i <= length; i++)
        arr.push(apf.randomGenerator.generate(1, 9));
    // Create a new string from the old one, don't just create a copy
    return this.toString() + arr.join("");
};

/**
 * Prepends a random number with a specified length to this String instance.
 *
 * @see randomGenerator
 * @param {Number} length
 * @type  {String}
 */
String.prototype.prependRandomNumber = function(length) {
    for (var arr = [], i = 1; i <= length; i++)
        arr.push(apf.randomGenerator.generate(1, 9));
    // Create a new string from the old one, don't just create a copy
    return arr.join("") + this.toString();
};

/**
 * Returns a string produced according to the formatting string. It replaces
 * all <i>%s</i> occurrences with the arguments provided.
 *
 * @link http://www.php.net/sprintf
 * @type {String}
 */
String.prototype.sprintf = function() {
    // Create a new string from the old one, don't just create a copy
    var str = this.toString(),
        i   = 0,
        inx = str.indexOf("%s");
    while (inx >= 0) {
        var replacement = arguments[i++] || " ";
        str = str.substr(0, inx) + replacement + str.substr(inx + 2);
        inx = str.indexOf("%s");
    }
    return str;
};

//})(); //end closure




/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/util/iepngfix.js)SIZE(3570)TIME(1257329189)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/util/json.js)SIZE(18148)TIME(1271105953)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/**
 * Reliably determines whether a variable is a string of JSON.
 * @see http://json.org/
 *
 * @param {mixed}   value The variable to check
 * @type  {Boolean}
 */
apf.isJson = (function() {
    var escapes  = /\\["\\\/bfnrtu@]/g,
        values   = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,
        brackets = /(?:^|:|,)(?:\s*\[)+/g,
        invalid  = /^[\],:{}\s]*$/;

    return function(value) {
        if (!value) return false;
        return invalid.test(
            value.replace(escapes, '@').replace(values, ']').replace(brackets, '')
        );
    }
})();

if (!self["JSON"]) {
    self["JSON"] = (function() {
    // Will match a value in a well-formed JSON file.
    // If the input is not well-formed, may match strangely, but not in an
    // unsafe way.
    // Since this only matches value tokens, it does not match whitespace,
    // colons, or commas.
    // The second line of the regex string matches numbers, lines number 4,
    // 5 and 6 match a string and line number 5 specifically matches one
    // character.
    var jsonToken       = new RegExp(
'(?:false|true|null|[\\{\\}\\[\\]]|\
(?:-?\\b(?:0|[1-9][0-9]*)(?:\\.[0-9]+)?(?:[eE][+-]?[0-9]+)?\\b)\
|\
(?:\"\
(?:[^\\0-\\x08\\x0a-\\x1f\"\\\\]|\\\\(?:[\"/\\\\bfnrt]|u[0-9A-Fa-f]{4}))\
*\"))', "g"),
        // Matches escape sequences in a string literal
        escapeSequence  = new RegExp("\\\\(?:([^u])|u(.{4}))", "g"),
        // Decodes escape sequences in object literals
        escapes         = {
            "\"": "\"",
            "/": "/",
            "\\": "\\",
            "b": "\b",
            "f": "\f",
            "n": "\n",
            "r": "\r",
            "t": "\t"
        },
        unescapeOne     = function(_, ch, hex) {
            return ch ? escapes[ch] : String.fromCharCode(parseInt(hex, 16));
        },
        // A non-falsy value that coerces to the empty string when used as a key.
        EMPTY_STRING    = new String(""),
        SLASH           = "\\",
        // Constructor to use based on an open token.
        firstTokenCtors = { "{": Object, "[": Array },
        hop             = Object.hasOwnProperty,
        padd            = function(s, p){
            s = p + s;
            return s.substring(s.length - p.length);
        },
        jsonSerialize   = {
            //Object
            0: function(o){
                //XML support - NOTICE: Ajax.org Platform specific
                if (o.nodeType && o.ownerDocument && o.cloneNode(true)) // was o.nodeType && o.cloneNode
                    return "apf.xmldb.getXml("
                        + JSON.stringify(apf.getXmlString(o)) + ")"; // was this.string()

                //Normal JS object support
                var str = [];
                for (var prop in o) {
                    str.push('"' + prop.replace(/(["\\])/g, '\\$1') + '": '
                        + JSON.stringify(o[prop]));
                }

                return "{" + str.join(", ") + "}";
            },
            
            //String
            5: function(s){
                s = '"' + s.replace(/(["\\])/g, '\\$1') + '"';
                return s.replace(/(\n)/g, "\\n").replace(/\r/g, "");
            },

            //Number
            2: function(i){
                return i.toString();
            },

            //Boolean
            4: function(b){
                return b.toString();
            },

            //Date
            3: function(d){
                return '{"jsonclass":["sys.ISODate", ["'
                    + padd(d.getUTCFullYear(), "0000")
                    + padd(d.getUTCMonth() + 1, "00") 
                    + padd(d.getUTCDate(), "00") + "T" 
                    + padd(d.getUTCHours(), "00") + ":" 
                    + padd(d.getUTCMinutes(), "00") + ":" 
                    + padd(d.getUTCSeconds(), "00")
                    + '"]]}';
            },

            //Array
            1: function(a){
                for (var q = [], i = 0; i < a.length; i++)
                    q.push(JSON.stringify(a[i]));

                return "[" + q.join(", ") + "]";
            },
            
            // Method
            7: function(f){
                return;
            }
        };


    return {
        parse: function(json, opt_reviver) {
            // Split into tokens
            var toks = json.match(jsonToken),
                // Construct the object to return
                result;
            var tok  = toks[0];
            if ("{" == tok)
                result = {};
            else if ("[" == tok)
                result = [];
            else
                throw new Error(tok);

            // If undefined, the key in an object key/value record to use for the next
            // value parsed.
            var key, cont,
                stack = [result];
            // Loop over remaining tokens maintaining a stack of uncompleted objects and
            // arrays.
            for (var i = 1, n = toks.length; i < n; ++i) {
                tok = toks[i];
                switch (tok.charCodeAt(0)) {
                    default:  // sign or digit
                        cont = stack[0];
                        cont[key || cont.length] = +(tok);
                        key = void 0;
                        break;
                    case 0x22:  // '"'
                        tok = tok.substring(1, tok.length - 1);
                        if (tok.indexOf(SLASH) !== -1) {
                            tok = tok.replace(escapeSequence, unescapeOne);
                        }
                        cont = stack[0];
                        if (!key) {
                            if (cont instanceof Array) {
                                key = cont.length;
                            }
                            else {
                                key = tok || EMPTY_STRING;  // Use as key for next value seen.
                                break;
                            }
                        }
                        cont[key] = tok;
                        key = void 0;
                        break;
                    case 0x5b:  // '['
                        cont = stack[0];
                        stack.unshift(cont[key || cont.length] = []);
                        key = void 0;
                        break;
                    case 0x5d:  // ']'
                        stack.shift();
                        break;
                    case 0x66:  // 'f'
                        cont = stack[0];
                        cont[key || cont.length] = false;
                        key = void 0;
                        break;
                    case 0x6e:  // 'n'
                        cont = stack[0];
                        cont[key || cont.length] = null;
                        key = void 0;
                        break;
                    case 0x74:  // 't'
                        cont = stack[0];
                        cont[key || cont.length] = true;
                        key = void 0;
                        break;
                    case 0x7b:  // '{'
                        cont = stack[0];
                        stack.unshift(cont[key || cont.length] = {});
                        key = void 0;
                        break;
                    case 0x7d:  // '}'
                        stack.shift();
                        break;
                }
            }
            // Fail if we've got an uncompleted object.
            if (stack.length)
                throw new Error();

            if (opt_reviver) {
                // Based on walk as implemented in http://www.json.org/json2.js
                var walk = function(holder, key) {
                    var value = holder[key];
                    if (value && typeof value == "object") {
                        var toDelete = null;
                        for (var k in value) {
                            if (hop.call(value, k) && value !== holder) {
                                // Recurse to properties first.  This has the effect of causing
                                // the reviver to be called on the object graph depth-first.
                                // Since 'this' is bound to the holder of the property, the
                                // reviver can access sibling properties of k including ones
                                // that have not yet been revived.
                                // The value returned by the reviver is used in place of the
                                // current value of property k.
                                // If it returns undefined then the property is deleted.
                                var v = walk(value, k);
                                if (v !== void 0) {
                                    value[k] = v;
                                }
                                else {
                                    // Deleting properties inside the loop has vaguely defined
                                    // semantics in ES3 and ES3.1.
                                    if (!toDelete)
                                        toDelete = [];
                                    toDelete.push(k);
                                }
                            }
                        }
                        if (toDelete) {
                            for (var i = toDelete.length; --i >= 0;)
                                delete value[toDelete[i]];
                        }
                    }
                    return opt_reviver.call(holder, key, value);
                };
                result = walk({ "": result }, "");
            }
            return result;
        },
        stringify: function(o) {
            if (typeof args == "function" || apf.isNot(o))
                return "null";
            return jsonSerialize[o.dataType || 0](o);
        }
    };

    })();
}

/**
 * Creates a json string from a javascript object.
 * @param  {mixed}  o the javascript object to serialize.
 * @return {String} the json string representation of the object.
 * @todo allow for XML serialization
 */
apf.serialize = function(o){
    return self.JSON.stringify(o);
};

/**
 * Evaluate a serialized object back to JS with eval(). When the 'secure' flag
 * is set to 'TRUE', the provided string will be validated for being valid
 * JSON.
 *
 * @param  {String} str the json string to create an object from.
 * @return {Object} the object created from the json string.
 */
apf.unserialize = function(str){
    if (!str) return str;
    return self.JSON.parse(str);
};




/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/util/hotkey.js)SIZE(3233)TIME(1270838605)*/


//@todo maybe generalize this to pub/sub event system??
/**
 * @private
 */
apf.hotkeys = {};

/**
 * @private
 */
apf.keyMods = {"ctrl": 1, "alt": 2, "shift": 4, "meta": 8};

/**
 * @private
 */
apf.keyNames = {
    "32" : "Spacebar",
    "13" : "Enter",
    "9"  : "Tab",
    "27" : "Esc",
    "46" : "Del",
    "36" : "Home",
    "35" : "End",
    "107": "+",
    "37" : "Left Arrow",
    "38" : "Up Arrow",
    "39" : "Right Arrow",
    "40" : "Down Arrow",
    "33" : "Page Up",
    "34" : "Page Down",
    "112": "F1",
    "113": "F2",
    "114": "F3",
    "115": "F4",
    "116": "F5",
    "117": "F6",
    "118": "F7",
    "119": "F8",
    "120": "F9",
    "121": "F10",
    "122": "F11",
    "123": "F12"
};

/**
 * Registers a hotkey handler to a key combination.
 * Example:
 * <code>
 *   apf.registerHotkey('Ctrl-Z', undoHandler);
 * </code>
 * @param {String}   hotkey  the key combination to user. This is a
 * combination of Ctrl, Alt, Shift and a normal key to press. Use + to
 * seperate the keys.
 * @param {Function} handler the code to be executed when the key
 * combination is pressed.
 */
apf.registerHotkey = function(hotkey, handler){
    var hashId = 0, key;

    var keys = hotkey.splitSafe("\\-|\\+", null, true),
        bHasCtrl = false,
        bHasMeta = false;
    for (var i = 0; i < keys.length; i++) {
        if (apf.keyMods[keys[i]]) {
            hashId = hashId | apf.keyMods[keys[i]];
            if (apf.isMac) {
                bHasCtrl = (apf.keyMods[keys[i]] === apf.keyMods["ctrl"]);
                bHasMeta = (apf.keyMods[keys[i]] === apf.keyMods["meta"]);
            }
        }
        else
            key = keys[i];
    }

    if (bHasCtrl && !bHasMeta) //for improved Mac hotkey support
        hashId = hashId | apf.keyMods["meta"];

    
    if (!key) {
        throw new Error("missing key for hotkey: " + hotkey);
    }
    

    (apf.hotkeys[hashId] || (apf.hotkeys[hashId] = {}))[key] = handler;

    if (!apf.initHotkey) {
        apf.initHotkey = true;
        apf.addEventListener("hotkey", function(e){
            // enable meta-hotkey support for macs, like for Apple-Z, Apple-C, etc.
            if (apf.isMac && e.metaKey)
                e.ctrlKey = true;
            var hashId = 0 | (e.ctrlKey ? 1 : 0)
                | (e.shiftKey ? 4 : 0) | (e.metaKey ? 8 : 0); //(e.shiftKey ? 2 : 0) | 

            var key = apf.keyNames[e.keyCode];
            if (!hashId && !key) //Hotkeys should always have one of the modifiers
                return;

            var handler = (apf.hotkeys[hashId] || {})[(key
                || String.fromCharCode(e.keyCode)).toLowerCase()];
            if (handler) {
                handler();
                e.returnValue = false;
                
                
                apf.queue.empty();
                
            }
        });
    }
};

/**
 * Removes a registered hotkey.
 * @param {String} hotkey the hotkey combination.
 */
apf.removeHotkey = function(hotkey){
    apf.registerHotkey(hotkey, null);
};


/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/util/abstractevent.js)SIZE(4316)TIME(1265760065)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */
  



/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/util/style.js)SIZE(15053)TIME(1271108667)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * This method sets a single css rule
 * @param {String} name         the css name of the rule (i.e. '.cls' or '#id').
 * @param {String} type         the css property to change.
 * @param {String} value        the css value of the property.
 * @param {String} [stylesheet] the name of the stylesheet to change.
 */
apf.setStyleRule = function(name, type, value, stylesheet, win){
    name = name.toLowerCase();
    
    if (!stylesheet) {
        var sheets = (win || self).document.styleSheets;
        for (var j = sheets.length - 1; j >= 0; j--) {
            try {
                var rules = sheets[j][apf.styleSheetRules];
                for (var i = 0; i < rules.length; i++) {
                    if (rules.item(i).selectorText.toLowerCase() == name) {
                        rules.item(i).style[type] = value;
                        return true;
                    }
                }
            }
            catch(e){}
        }
    }
    else {
        var rules = (win || self).document.styleSheets[stylesheet || 0][apf.styleSheetRules];
        for (var i = 0; i < rules.length; i++) {
            if (rules.item(i).selectorText.toLowerCase() == name) {
                rules.item(i).style[type] = value;
                return true;
            }
        }
    }
    
    return false;
};

/**
 * This method gets a single css rule
 * @param {String} name         the css name of the rule (i.e. '.cls' or '#id').
 * @param {String} type         the css property to change.
 * @param {String} [stylesheet] the name of the stylesheet to change.
 */
apf.getStyleRule = function(name, type, stylesheet, win){
    name = name.toLowerCase();
    
    if (!stylesheet) {
        var sheets = (win || self).document.styleSheets;
        for (var j = sheets.length - 1; j >= 0; j--) {
            try {
                var rules = sheets[j][apf.styleSheetRules];
                for (var i = 0; i < rules.length; i++) {
                    if (rules.item(i).selectorText.toLowerCase() == name) {
                        return rules.item(i).style[type];
                    }
                }
            }
            catch(e){}
        }
    }
    else {
        var rules = (win || self).document.styleSheets[stylesheet || 0][apf.styleSheetRules];
        for (var i = 0; i < rules.length; i++) {
            if (rules.item(i).selectorText.toLowerCase() == name) {
                return rules.item(i).style[type];
            }
        }
    }
    
    return false;
}

/**
 * This method adds one class name to an HTMLElement and removes none or more.
 * @param {HTMLElement} oHtml        the HTMLElement to apply the css class to.
 * @param {String}      className    the name of the css class to apply.
 * @param {Array}       [exclusion]  a list of strings specifying names of css classes to remove.
 * @returns {HTMLElement}
 */
apf.setStyleClass = function(oHtml, className, exclusion, userAction){
    if (!oHtml || userAction && this.disabled)
        return;

    
    if (oHtml.nodeFunc) {
        throw new Error(apf.formatErrorString(0, this,
            "Setting style class",
            "Trying to set style class on aml node. Only xml or html nodes can \
             be passed to this function"));
    }
    

    if (className) {
        if (exclusion)
            exclusion[exclusion.length] = className;
        else
            exclusion = [className];
    }

    //Create regexp to remove classes
    //var re = new RegExp("(?:(^| +)" + (exclusion ? exclusion.join("|") : "") + "($| +))", "gi");
    var re = new RegExp("(^| +)(?:" + (exclusion ? exclusion.join("|") : "") + ")", "gi");

    //Set new class
    oHtml.className != null
        ? (oHtml.className = oHtml.className.replace(re, " ") + (className ? " " + className : ""))
        : oHtml.setAttribute("class", (oHtml.getAttribute("class") || "")
            .replace(re, " ") + (className ? " " + className : ""));

    return oHtml;
};

/**
 * This method imports a css stylesheet from a string
 * @param {String} cssString  the css definition
 * @param {Object} [doc]      the reference to the document where the css is applied on
 * @param {String} [media]    the media to which this css applies (i.e. 'print' or 'screen')
 */
apf.importCssString = function(cssString, doc, media){
    doc = doc || document;
    var htmlNode = doc.getElementsByTagName("head")[0];//doc.documentElement.getElementsByTagName("head")[0];

    
    if (!apf.supportOpacity) {
        cssString = cssString.replace(/opacity[ \s]*\:[ \s]*([\d\.]+)/g,
            function(m, m1){
                return "filter:progid:DXImageTransform.Microsoft.Alpha(opacity=" + (m1*100) + ")";
            });
    }
    

    if (apf.canCreateStyleNode) {
        //var head  = document.getElementsByTagName("head")[0];
        var style = doc.createElement("style");
        style.appendChild(doc.createTextNode(cssString));
        if (media)
            style.setAttribute('media', media);
        htmlNode.appendChild(style);
    }
    else {
        htmlNode.insertAdjacentHTML("beforeend", ".<style media='"
         + (media || "all") + "'>" + cssString + "</style>");

        /*if(document.body){
            document.body.style.height = "100%";
            $setTimeout('document.body.style.height = "auto"');
        }*/
    }
};

/**
 * This method retrieves the current value of a property on a HTML element
 * recursively. If the style isn't found on the element itself, it's parent is
 * checked.
 * @param {HTMLElement} el    the element to read the property from
 * @param {String}      prop  the property to read
 * @returns {String}
 */
apf.getStyleRecur = function(el, prop) {
    var value = apf.hasComputedStyle
        ? document.defaultView.getComputedStyle(el,'').getPropertyValue(
            prop.replace(/([A-Z])/g, function(m, m1){
                return "-" + m1.toLowerCase();
            }))
        : el.currentStyle[prop]

    return ((!value || value == "transparent" || value == "inherit")
      && el.parentNode && el.parentNode.nodeType == 1)
        ? this.getStyleRecur(el.parentNode, prop)
        : value;
};

/**
 * This method imports a stylesheet defined in a multidimensional array 
 * @param {Array}    def Required Multidimensional array specifying 
 * @param {Object}    win Optional Reference to a window
 * @method
 * @deprecated
 */    
apf.importStylesheet = function (def, win){
    for (var i = 0; i < def.length; i++) {
        if (!def[i][1]) continue;
        
        if (apf.isIE)
            (win || window).document.styleSheets[0].addRule(def[i][0],
                def[i][1]);
        else
            (win || window).document.styleSheets[0].insertRule(def[i][0]
                + " {" + def[i][1] + "}", 0);
    }
}

/**
 * This method determines if specified coordinates are within the HTMLElement.
 * @param {HTMLElement} el  the element to check
 * @param {Number}      x   the x coordinate in pixels
 * @param {Number}      y   the y coordinate in pixels
 * @returns {Boolean}
 */
apf.isInRect = function(oHtml, x, y){
    var pos = this.getAbsolutePosition(oHtml);
    if (x < pos[0] || y < pos[1] || x > oHtml.offsetWidth + pos[0] - 10
      || y > oHtml.offsetHeight + pos[1] - 10)
        return false;
    return true;
};

/**
 * Retrieves the parent which provides the rectangle to which the HTMLElement is
 * bound and cannot escape. In css this is accomplished by having the overflow
 * property set to hidden or auto.
 * @param {HTMLElement} o  the element to check
 * @returns {HTMLElement}
 */
apf.getOverflowParent = function(o){
    //not sure if this is the correct way. should be tested

    o = o.offsetParent;
    while (o && (this.getStyle(o, "overflow") != "hidden"
      || "absolute|relative".indexOf(this.getStyle(o, "position")) == -1)) {
        o = o.offsetParent;
    }
    return o || document.documentElement;
};

/**
 * Retrieves the first parent element which has a position absolute or
 * relative set.
 * @param {HTMLElement} o  the element to check
 * @returns {HTMLElement}
 */
apf.getPositionedParent = function(o){
    o = o.offsetParent;
    while (o && o.tagName.toLowerCase() != "body"
      && "absolute|relative".indexOf(this.getStyle(o, "position")) == -1) {
        o = o.offsetParent;
    }
    return o || document.documentElement;
};

/**
 * Retrieves the absolute x and y coordinates, relative to the browsers
 * drawing area or the specified refParent.
 * @param {HTMLElement} o           the element to check
 * @param {HTMLElement} [refParent] the reference parent
 * @param {Boolean}     [inclSelf]  whether to include the position of the element to check in the return value.
 * @returns {Array} the x and y coordinate of oHtml.
 */
apf.getAbsolutePosition = function(o, refParent, inclSelf){
    if ("getBoundingClientRect" in document.documentElement) { 
        if (apf.doesNotIncludeMarginInBodyOffset && o == document.body) {
            return [
                o.offsetLeft + (parseFloat(apf.getStyle(o, apf.descPropJs
                    ? "marginLeft"
                    : "margin-top")) || 0),
                  + (o.scrollLeft || 0),
                o.offsetTop  + (parseFloat(apf.getStyle(o, apf.descPropJs
                    ? "marginTop"
                    : "margin-top")) || 0)
                  + (o.scrollTop || 0)
            ];
        }
        
        var box  = o.getBoundingClientRect(), 
            top  = box.top,
            left = box.left,
            corr = (apf.isIE && apf.isIE < 8);

        if (refParent && refParent != document.body) {
            var pos = apf.getAbsolutePosition(refParent, null, true);
            top -= pos[1];
            left -= pos[0];
        }
        
        if (!(apf.isIE && o == document.documentElement)) {
            left += document.body.scrollLeft || document.documentElement.scrollLeft || 0;
            top  += document.body.scrollTop  || document.documentElement.scrollTop  || 0;
        }
        
        if (inclSelf && !refParent) {
            left += parseInt(apf.getStyle(o, apf.descPropJs 
                ? "borderLeftWidth" : "border-left-width")) || 0
            top  += parseInt(apf.getStyle(o, apf.descPropJs 
                ? "borderTopWidth" : "border-top-width")) || 0;
        }

        return [left - (corr ? 2 : 0), top - (corr ? 2 : 0)];
    }
    
    //@todo code below might be deprecated one day
    var wt = inclSelf ? 0 : o.offsetLeft, ht = inclSelf ? 0 : o.offsetTop;
    o = inclSelf ? o : o.offsetParent || o.parentNode ;

    if (apf.isIE8 && refParent) {
        bw = this.getStyle(o, "borderLeftWidth");
        wt -= (apf.isIE && o.currentStyle.borderLeftStyle != "none" 
          && bw == "medium" ? 2 : parseInt(bw) || 0);
        bh = this.getStyle(o, "borderTopWidth");
        ht -= (apf.isIE && o.currentStyle.borderTopStyle != "none" 
          && bh == "medium" ? 2 : parseInt(bh) || 0);
    }

    var bw, bh, fl;
    while (o && o != refParent) {//&& o.tagName.toLowerCase() != "html"
        //Border - Left
        bw = apf.isOpera || apf.isIE8 ? 0 : this.getStyle(o, apf.descPropJs
            ? "borderLeftWidth" : "border-left-width");

        wt += (apf.isIE && o.currentStyle.borderLeftStyle != "none" && bw == "medium"
            ? 2
            : parseInt(bw) || 0) + o.offsetLeft;

        if (apf.isIE && !apf.isIE8 && apf.getStyle(o, "styleFloat") == "none" 
          && apf.getStyle(o, "position") == "relative") {
            var q = o.previousSibling;
            while (q) {
                if (q.nodeType == 1) {
                    fl = apf.getStyle(q, "styleFloat");
                    if (fl == "left") {
                        wt -= parseInt(apf.getStyle(o, "marginLeft")) 
                            || 0;//-1 * (o.parentNode.offsetWidth - o.offsetWidth)/2; //assuming auto
                        break;
                    }
                    else if (fl == "right")
                        break;
                }
                q = q.previousSibling;
            }
        }

        //Border - Top
        bh = apf.isOpera || apf.isIE8 ? 0 : this.getStyle(o, apf.descPropJs
            ? "borderTopWidth" : "border-top-width");
        ht += (apf.isIE && o.currentStyle.borderTopStyle != "none" && bh == "medium"
            ? 2
            : parseInt(bh) || 0) + o.offsetTop;

        //Scrolling
        if (!apf.isGecko && o != refParent && (o.tagName != "HTML" || o.ownerDocument != document)) {
            wt -= o.scrollLeft;
            ht -= o.scrollTop;
        }
        
        //Table support
        if (o.tagName.toLowerCase() == "table") {
            ht -= parseInt(o.border || 0) + parseInt(o.cellSpacing || 0);
            wt -= parseInt(o.border || 0) + parseInt(o.cellSpacing || 0) * 2;
        }
        else if (o.tagName.toLowerCase() == "tr") {
            var cp;
            ht -= (cp = parseInt(o.parentNode.parentNode.cellSpacing));
            while (o.previousSibling)
                ht -= (o = o.previousSibling).offsetHeight + cp;
        }

        if (apf.isIE && !o.offsetParent && o.parentNode.nodeType == 1) {
            wt -= o.parentNode.scrollLeft;
            ht -= o.parentNode.scrollTop;
        }

        o = o.offsetParent;
    }

    return [wt, ht];
};

/**
 * Returns the viewport of the a window.
 *
 * @param  {WindowImplementation} [win] The window to take the measurements of.
 * @return {Object}                     Viewport object with fields x, y, w and h.
 * @type   {Object}
 */
apf.getViewPort = function(win) {
    win = win || window;
    var doc = (!win.document.compatMode
      || win.document.compatMode == "CSS1Compat")
        //documentElement for an iframe
        ? win.document.html || win.document.documentElement
        : win.document.body;

    // Returns viewport size excluding scrollbars
    return {
        x     : win.pageXOffset || doc.scrollLeft,
        y     : win.pageYOffset || doc.scrollTop,
        width : win.innerWidth  || doc.clientWidth,
        height: win.innerHeight || doc.clientHeight
    };
}




/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/util/plane.js)SIZE(4071)TIME(1270838605)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


/**
 * @private
 */
apf.plane = {
    init : function(){
        if (!this.plane) {
            this.plane                  = document.createElement("DIV");
            document.body.appendChild(this.plane);
            this.plane.style.background = "url(images/spacer.gif)";
            this.plane.style.position   = "absolute";
            this.plane.style.zIndex     = 100000000;
            this.plane.style.left       = 0;
            this.plane.style.top        = 0;
            //this.plane.style.backgroundColor = "red";
        }
    },

    lastCursor : null,
    show : function(o, dontAppend, copyCursor){
        this.init();

        var plane    = this.plane;
        this.current = o;
        //o.parentNode.appendChild(plane);
 
        if (!dontAppend) {
            this.lastZ = this.current.style.zIndex;
            this.current.style.zIndex = 100000;
        }
        else {
            this.plane.appendChild(o);
        }
        
        var pWidth = (plane.parentNode == document.body
            ? apf.getWindowWidth()
            : plane.parentNode.offsetWidth);
 
        var pHeight = (plane.parentNode == document.body
            ? apf.getWindowHeight()
            : plane.parentNode.offsetHeight);
        
        if (copyCursor) {
            if (this.lastCursor === null)
                this.lastCursor = document.body.style.cursor;
            document.body.style.cursor = apf.getStyle(o, "cursor");
        }
        
        this.plane.style.display = "block";
        //this.plane.style.left    = p.scrollLeft;
        //this.plane.style.top     = p.scrollTop;
        
        var diff = apf.getDiff(plane.parentNode);
        this.plane.style.width  = (pWidth - diff[0]) + "px";
        this.plane.style.height = (pHeight - diff[1]) + "px";

        return plane;
    },

    

    hide : function(){
        var isChild =
            
            apf.isChildOf(this.plane, document.activeElement);
            
        
        if (this.lastZ !== null) {
            if (this.current.style.zIndex == 100000)
                this.current.style.zIndex = this.lastZ;
            this.lastZ = null;
        }

        if (this.current.parentNode == this.plane)
            this.plane.parentNode.appendChild(this.current);
        
        this.plane.style.display  = "none";
        
        if (isChild) {
            if (!apf.isIE)
                document.activeElement.focus();
            apf.document.activeElement.$focus();
        }
        
        this.current = null;
        
        if (this.lastCursor !== null) {
            document.body.style.cursor = this.lastCursor;
            this.lastCursor = null;
        }
        
        return this.plane;
    }
};



/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/util/syntax.js)SIZE(12610)TIME(1270938958)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * Syntax highlights a code string using html.
 * @param {String} strCode the code to highlight.
 * @return {String} the highlighted string.
 */
apf.highlightXml = 
apf.highlightCode = function(strCode){
    var lines = strCode.split(/\n\r?/);
    for (var min = 1000, i = 0, l = lines.length; i < l; i++){
        min = Math.min(min, lines[i].match(/^(\s+)?[^\s]/) && RegExp.$1.length || 1000);
        if (!min) break;
    }

    strCode = strCode.replace(new RegExp("^ {" + min + "}", "gm"), "")
      .replace(/<!doctype([\s\S]+?)>|<!--([\s\S]+?)-->|<\?([\w\-]+)([\s\S]+?)\?>|<\!\[CDATA\[([\s\S]*?)\]\]>|<(\w+:)?script([\s\S]*?)>([\s\S]*?)<\/(?:\w+:)?script>|<([\/\w\:\-]+)([\s\S]*?)(\/?)>/g, 
        function(m, doctype, comment, ptarget, pcontents, cdata, sprefix, sattr, scontent, tagName, attrs, bl){
            if (doctype) {
                return "<span style=\"color:gray\">&lt;!doctype" + doctype.replace(/</g, "&lt;") + "&gt;</span>";
            }
            else if (comment) {
                return "<span style=\"color:green\">&lt;!--" + comment.replace(/</g, "&lt;") + "--&gt;</span>";
            }
            else if (ptarget) {
                return "<span style=\"color:orange\">&lt;?" + ptarget + "</span>" 
                    + apf.highlightJs(pcontents, true) 
                    + "<span style=\"color:orange\">?&gt;</span>";
            }
            else if (cdata) {
                return "<span style=\"color:gray\">&lt;![CDATA[" + cdata + "]]&gt;</span>";
            }
            else if (sprefix) {
                return "<span style=\"color:#127ac6\">&lt;" + sprefix + "script" + (attrs 
                      ? "</span>" + attrs.replace(/("[\s\S]*?")|([\w\-\:]+)/g, function(m, s, w){
                            if (s) return s;
                            return "<span style=\"color:red\">" + w + "</span>";
                        }) + "<span style=\"color:#127ac6\">&gt;</span>"
                      : "&gt;</span>")
                    + apf.highlightJs(scontent, true) 
                    + "<span style=\"color:#127ac6\">&lt;/" + sprefix + "script&gt;</span>";
            }
            else if (tagName) {
                return "<span style=\"color:#127ac6\">&lt;" 
                    + (tagName.substr(0, 2) == "a:" 
                        ? "<a href='element." + tagName.substr(2) + "'>" + tagName + "</a>" 
                        : tagName)
                    + (attrs 
                      ? "</span>" + attrs.replace(/("[\s\S]*?")|([\w\-\:]+)/g, function(m, s, w){
                            if (s) return s;
                            return "<span style=\"color:red\">" + w + "</span>";
                        }) + "<span style=\"color:#127ac6\">" + bl + "&gt;</span>"
                      : "&gt;</span>");
            }
        });

    return strCode;//.replace(/&lt;/g, "&amp;lt;");
}

/**
 * @private
 */
apf.removeStartWhitespaces = function(strCode){
    var lines = strCode.split(/\n\r?/);
    for (var min = 1000, i = 0, l = lines.length; i < l; i++){
        min = Math.min(min, lines[i].match(/^(\s+)?[^\s]/) && RegExp.$1.length || 1000);
        if (!min) break;
    }

    return strCode.replace(new RegExp("^ {" + min + "}", "gm"), "");
}

/**
 * @private
 */
apf.convertAmlToJson = function(strCode){
    var xml = apf.getXml("<a:app xmlns:a='" + apf.ns.apf + "'>" + strCode + "</a:app>", null, true);

    var script = [], bool = {"true":1, "false":1};
    var x = (function recur(nodes, depth, paout){
        var pre = new Array(depth+2).join("  "), output = [];
        
        for (var node, i = 0, l = nodes.length; i < l; i++) {
            node = nodes[i];
            if (node.nodeType == 3 || node.nodeType == 4) {
                if (node.nodeValue.replace(/[\s]*$/, "").replace(/^[\s]*/, "")) {
                    (paout || output).push("data", '"' + node.nodeValue.trim().replace(/"/g, "\\\"").replace(/\n/g, "\\\n") + '"');
                }
                continue;
            }
            else if (node.nodeType == 8) {
                output.push(pre + "//" + node.nodeValue);
                continue;
            }
            else if (node.nodeType != 1)
                continue; //ignore
            else if (node[apf.TAGNAME] == "script") {
                var s = node.childNodes;
                for (var j = 0, jl = s.length; j < jl; j++) {
                    if (s[j].nodeValue.trim() != "//")
                        script.push(s[j].nodeValue.replace(/^ {16}/gm, "").replace(/\/\/$/, "") + "\n");
                }
                continue;
            }
            
            var attr, childLength = node.childNodes.length + (attr = node.attributes).length;
            var max = 0, aout = [];
            output.push(pre + "new apf." + node[apf.TAGNAME] + (childLength || !depth ? "({" : "()" + (depth == 0 ? ";" : (i == l - 1 ? "" : ","))));
            if (!depth) {
                aout.push("htmlNode", "document.body");
                max = Math.max(8, max);
            }
            
            for (var a, j = 0, jl = attr.length; j < jl; j++) {
                aout.push((a = attr[j]).nodeName, a.nodeName.substr(0,2) == "on"
                    ? "function(){" + a.nodeValue + "}"
                    : (parseInt(a.nodeValue) == a.nodeValue || bool[a.nodeValue]
                        ? a.nodeValue
                        : '"' + a.nodeValue.replace(/"/g, "\\\"") + '"'));
                max = Math.max(a.nodeName.length, max);
            }
            
            var c = "";
            if (node[apf.TAGNAME] == "model" && node.childNodes.length) {
                aout.push("data", '"' + apf.serializeChildren(node).trim().replace(/"/g, "\\\"").replace(/\r?\n/g, "\\\n") + '"');
            }
            else if (childLength)
                var c = recur(node.childNodes, depth+2, aout);
            
            max = Math.max(c ? 10 : 4, max);
            
            max++;
            
            for (j = 0, jl = aout.length; j < jl; j+=2) {
                output.push(pre + "  " + aout[j].pad(max, " ", apf.PAD_RIGHT) 
                    + ": " + aout[j+1] + (j != jl - 2 || c ? "," : ""));
            }
            
            if (c) {
                output.push(pre + "  " + "childNodes".pad(max, " ", apf.PAD_RIGHT) + ": [");
                output.push(c.substr(0, c.length - 1));
                output.push(pre + "  ]");
            }

            if (childLength || !depth)
                output.push(pre + "})" + (depth == 0 ? ";" : (i == l - 1 ? "" : ",")))
        }

        return output.join("\n") + (depth == 0 ? "\n\n" + script.join("").trim() : "");
    })(xml.childNodes, 0);

    return x + "\n\n";
}

apf.highlightJs = function(x, notrim){
    if (!notrim) {
        var lines = x.split(/\n\r?/);
        for (var min = 1000, i = 0, l = lines.length; i < l; i++){
            min = Math.min(min, lines[i].match(/^(\s+)?[^\s]/) && RegExp.$1.length || 1000);
            if (!min) break;
        }
        x = x.replace(new RegExp("^ {" + min + "}", "gm"), "");
    }
    
    return x.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/(\/\*[\s\S]+\*\/)|(\/\/.*)$|("(?:[^"\\]+|\\[\s\S])*")|('(?:[^'\\]+|\\[\s\S])*')|(\W)(apf|break|continue|do|for|import|new|this|void|case|default|else|function|in|return|typeof|while|comment|delete|export|if|label|switch|var|with|abstract|implements|protected|boolean|instanceOf|public|byte|int|short|char|interface|static|double|long|synchronized|false|native|throws|final|null|transient|float|package|true|goto|private|catch|enum|throw|class|extends|try|const|finally|debugger|super)(\W)|(\W)(\w+)(\s*\()/gm,
        function(m, colong, co, str1, str2, nw, kw, nw2, fW, f, fws) {
            if (f)
                return fW + '<span style="color:#ff8000">' + f + '</span>' + fws;
            else if (co || colong)
                return '<span style="color:green">' + (co || colong) + '</span>';
            else if (str1 || str2)
                return '<span style="color:#808080">' + (str1 || str2) + '</span>';
            else if (nw)
                return nw + '<span style="color:#127ac6">' + kw + '</span>' + nw2;
        });
}

/**
 * Syntax highlights a code string using html.
 * @param {String} strCode the code to highlight.
 * @return {String} the highlighted string.
 */
apf.highlightCode2 = function(strCode){
  var comment=[],str=[];
  return strCode
        .replace(/(\/\*[\s\S]*?\*\/|\/\/.*)/g, function(a){ comment.push(a); return '###n'+(comment.length-1)+'###';})   
         .replace(/\"([\s\S]*?)\"/g, function(a,b){ str.push(b); return '###s'+(str.length-1)+'###';})         
         .replace(/\'([\s\S]*?)\'/g, function(a,b){ str.push(b); return '###q'+(str.length-1)+'###';}) 
         .replace(/(\<)|(\>)/g,function(n,a,b){ return "<span stylecolorwhite>"+(a?'@lt@':'@gt@')+"</span>"})
         .replace(/(\W)-?([\d\.]+)(\W)/g, "$1<span stylecolor#127ac6>$2</span>$3")
         .replace(/([\|\&\=\;\,\:\?\+\*\-]+)/g, "<span stylecolorwhite>$1</span>")
         .replace(/(\W)(break|continue|do|for|import|new|this|void|case|default|else|function|in|return|typeof|while|comment|delete|export|if|label|switch|var|with|abstract|implements|protected|boolean|instanceOf|public|byte|int|short|char|interface|static|double|long|synchronized|false|native|throws|final|null|transient|float|package|true|goto|private|catch|enum|throw|class|extends|try|const|finally|debugger|super)(\W)/g,
    "$1<span stylecolorgreen>$2</span>$3")
         .replace(/([\(\)\{\}\[\]])/g, "<span stylecoloryellow>$1</span>")
         .replace(/###n(\d+)###/g,function(a,b){ return "<span stylecolorpurple>"+comment[b].escapeHTML()+"</span>"; } )
         .replace(/###s(\d+)###/g,function(a,b){ return "<span stylecolorgray>\""+str[b].escapeHTML()+"\"</span>"; } )
         .replace(/###q(\d+)###/g,function(a,b){ return "<span stylecolorgray>'"+str[b].escapeHTML()+"'</span>"; } )
         .replace(/stylecolor(.*?)\>/g,"style='color:$1'>")
         .replace(/@(.*?)@/g,"&$1;");
}

/**
 * Formats a javascript string with good indentation. Also known as pretty printing.
 * @param {String} strJs the javascript to format.
 * @return {String} the formatted string.
 */
apf.formatJS = function(strJs){
    var d = 0, r = 0;
    var comment=[],str=[];
    return strJs
        .replace(/(\/\*[\s\S]*?\*\/|\/\/.*)/g, function(a){ comment.push(a); return '###n'+(comment.length-1)+'###';}) 
        .replace(/\"([\s\S]*?)\"/g, function(a,b){ str.push(b); return '###s'+(str.length-1)+'###';})         
        .replace(/\'([\s\S]*?)\'/g, function(a,b){ str.push(b); return '###q'+(str.length-1)+'###';}) 
        .replace(/;+/g, ';').replace(/{;/g, '{').replace(/({)|(})|(\()|(\))|(;)/g,
        function(m, co, cc, ro, rc, e){
            if (co) d++;
            if (cc) d--;
            if (ro){ r++; return ro;}
            if (rc){ r--; return rc;}

            var o = '';
            for (var i = 0; i < d; i++)
                o += '\t';
            if (co) return '{\n' + o;
            if (cc) return '\n' + o + '}';
            if (e) return (r>0)?e:(';\n' + o);
        }).replace(/;\s*\n\s*\n/g, ';\n').replace(/}var/g, '}\nvar')
        .replace(/([\n\s]*)###n(\d+)###[\n\s]*/g,function(a,b,c){ return b+comment[c]+b; } )
        .replace(/###s(\d+)###/g,function(a,b,c){ return "\""+str[b]+"\""; } )
        .replace(/###q(\d+)###/g,function(a,b,c){ return "'"+str[b]+"'"; } );
};



/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/util/xmldiff.js)SIZE(30022)TIME(1257329189)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/util/silverlight.js)SIZE(25659)TIME(1265032028)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/util/flash.js)SIZE(22608)TIME(1265032028)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


/**
 * Helper class that aids in creating and controlling Adobe Flash
 * elements.
 *
 * @author      Mike de Boer
 * @version     %I%, %G%
 * @since       1.0
 * @namespace apf
 * @private
 */
apf.flash = (function(){
    /**
     * Flash Player Version Detection, version 1.7
     * Detect Client Browser type
     *
     * @type {String}
     */
    function getControlVersion(){
        var version, axo;

        // NOTE : new ActiveXObject(strFoo) throws an exception if strFoo isn't in the registry
        try {
            // version will be set for 7.X or greater players
            axo = new ActiveXObject("ShockwaveFlash.ShockwaveFlash.7");
            version = axo.GetVariable("$version");
        }
        catch (e) {}

        if (!version) {
            try {
                // version will be set for 6.X players only
                axo = new ActiveXObject("ShockwaveFlash.ShockwaveFlash.6");
                // installed player is some revision of 6.0
                // GetVariable("$version") crashes for versions 6.0.22 through 6.0.29,
                // so we have to be careful.
                // default to the first public version
                version = "WIN 6,0,21,0";
                // throws if AllowScripAccess does not exist (introduced in 6.0r47)
                axo.AllowScriptAccess = "always";
                // safe to call for 6.0r47 or greater
                version = axo.GetVariable("$version");
            }
            catch (e) {}
        }

        if (!version) {
            try {
                // version will be set for 4.X or 5.X player
                axo = new ActiveXObject("ShockwaveFlash.ShockwaveFlash.3");
                version = axo.GetVariable("$version");
            }
            catch (e) {}
        }

        if (!version) {
            try {
                // version will be set for 3.X player
                axo = new ActiveXObject("ShockwaveFlash.ShockwaveFlash.3");
                version = "WIN 3,0,18,0";
            }
            catch (e) {}
        }

        if (!version) {
            try {
                // version will be set for 2.X player
                axo = new ActiveXObject("ShockwaveFlash.ShockwaveFlash");
                version = "WIN 2,0,0,11";
            }
            catch (e) {
                version = -1;
            }
        }

        return version;
    }

    /**
     * JavaScript helper, required to detect Flash Player PlugIn version
     * information.
     * @see getControlVersion() for Internet Explorer (ActiveX detection)
     *
     * @type {String}
     */
    function getSwfVersion(){
        // NS/Opera version >= 3 check for Flash plugin in plugin array
        var flashVer = -1,
            sAgent   = navigator.userAgent.toLowerCase();

        if (navigator.plugins != null && navigator.plugins.length > 0) {
            if (navigator.plugins["Shockwave Flash 2.0"] || navigator.plugins["Shockwave Flash"]) {
                var swVer2   = navigator.plugins["Shockwave Flash 2.0"] ? " 2.0" : "",
                    swfDescr = navigator.plugins["Shockwave Flash" + swVer2].description,
                    aDescr   = swfDescr.split(" "),
                    aTempMaj = aDescr[2].split("."),
                    nMajor   = aTempMaj[0],
                    nMinor   = aTempMaj[1],
                    sRev     = aDescr[3];
                if (sRev == "")
                    sRev = aDescr[4];
                if (sRev[0] == "d") {
                    sRev = sRev.substring(1);
                }
                else if (sRev[0] == "r") {
                    sRev = sRev.substring(1);
                    if (sRev.indexOf("d") > 0)
                        sRev = sRev.substring(0, sRev.indexOf("d"));
                }
                flashVer = nMajor + "." + nMinor + "." + sRev;
            }
        }
        // MSN/WebTV 2.6 supports Flash 4
        else if (sAgent.indexOf("webtv/2.6") != -1)
            flashVer = 4;
        // WebTV 2.5 supports Flash 3
        else if (sAgent.indexOf("webtv/2.5") != -1)
            flashVer = 3;
        // older WebTV supports Flash 2
        else if (sAgent.indexOf("webtv") != -1)
            flashVer = 2;
        else if (apf.isIE && !apf.isOpera)
            flashVer = getControlVersion();

        return flashVer;
    }

    /**
     * When called with reqMajorVer, reqMinorVer, reqRevision returns true if
     * that version or greater is available on the clients' system.
     *
     * @param {Number} reqMajorVer
     * @param {Number} reqMinorVer
     * @param {Number} reqRevision
     * @type {Boolean}
     */
    function detectFlashVersion(reqMajorVer, reqMinorVer, reqRevision){
        var versionStr = getSwfVersion();
        if (versionStr == -1)
            return false;
        if (versionStr != 0) {
            var aVersions;
            if (apf.isIE && !apf.isOpera) {
                // Given "WIN 2,0,0,11"
                var aTemp = versionStr.split(" "), // ["WIN", "2,0,0,11"]
                    sTemp = aTemp[1];              // "2,0,0,11"
                aVersions = sTemp.split(",");      // ['2', '0', '0', '11']
            }
            else {
                aVersions = versionStr.split(".");
            }
            var nMajor = aVersions[0],
                nMinor = aVersions[1],
                sRev   = aVersions[2];

            // is the major.revision >= requested major.revision AND the minor version >= requested minor
            if (nMajor > parseFloat(reqMajorVer))
                return true;
            if (nMajor == parseFloat(reqMajorVer)) {
                if (nMinor > parseFloat(reqMinorVer))
                    return true;
                if (nMinor == parseFloat(reqMinorVer)
                  && sRev >= parseFloat(reqRevision)) {
                    return true;
                }
            }
            return false;
        }
    }

    /**
     * Generate ActiveContent for a Flash or Shockwave movie, while ensuring
     * compatibility with the clients' browser.
     *
     * @param {Object} objAttrs
     * @param {Object} params
     * @param {Object} embedAttrs
     * @param {Boolean} stdout If TRUE, the resulting string will be passed to the output buffer through document.write()
     * @type {String}
     */
    function generateObj(objAttrs, params, embedAttrs, stdout){
        if (stdout == "undefined")
            stdout = false;
        var i, str = [];
        if (apf.isIE && !apf.isOpera) {
            str.push("<object ");
            for (i in objAttrs)
                str.push(i, "=\"", objAttrs[i], "\" ");
            str.push(">");
            for (i in params)
                str.push("<param name=\"", i, "\" value=\"", params[i], "\" />");
            str.push("</object>");
        }
        else {
            str.push("<embed ");
            for (i in embedAttrs)
                str.push(i, "=\"", embedAttrs[i], "\" ");
            str.push("></embed>");
        }
        var sOut = str.join("");

        if (stdout === true)
            document.write(sOut);

        return sOut;
    }

    /**
     * Use this function to generate the HTML tags for a Flash movie object.
     * It takes any number of arguments as parameters:
     * arguments: 'name1', 'value1', 'name2', 'value2', etc.
     *
     * @type {String}
     */
    function AC_FL_RunContent(options){
        var ret = AC_GetArgs(options,
            "movie", "clsid:d27cdb6e-ae6d-11cf-96b8-444553540000",
            "application/x-shockwave-flash");
        return generateObj(ret.objAttrs, ret.params, ret.embedAttrs);
    }

    /**
     * Generate the HTML for a Flash movie, with checks for general availability
     * of a compatible Flash Player. If not, it will redirect to the installer
     * (a seperate Flash Movie to upgrade) or diplay a link.
     *
     * @type {String}
     */
    function buildContent(options) {
        var v = isEightAvailable();
        if (isAvailable() && !v)
            return buildInstaller(options || {});
        if (v)
            return AC_FL_RunContent(options);
        return 'This content requires the \
            <a href="http://www.adobe.com/go/getflash/">Adobe Flash Player</a>.';
    }

    function embed(options) {
        var obj  = options.context,
            node = options.htmlNode,
            prop = options.property || "$player";
        delete options.context, delete options.htmlNode, delete options.property;
        
        var content = buildContent(options),
            // using timeouts INSIDE the callback, because I explicitly want to
            // wait for APF to finish drawing the elements, i.e. wait for DOM
            // elements to be drawn.
            cb      = function() {
                $setTimeout(function() {
                    node.innerHTML = content;
                    obj[prop]      = getElement(options.id);
                    //console.log("flash movie loaded: ", _self.player);

                    $setTimeout(function() {
                        var fail = null;
                        if (!obj[prop].parentNode) {
                            fail = "File Uploader error: The movie has to be enabled "
                                 + "manually because of Flashblock. No browser refresh is required.";
                        }
                        else if (obj[prop].style.display == "none") {
                            fail = "File Uploader error: Adblock Plus blocks or hides the "
                                 + "movie. Please enable it and refresh your browser.";
                        }
                        else if (!obj[prop].offsetWidth) {
                            fail = "File Uploader error: The Flash movie failed to load. "
                                 + "Please check if the file exists and the path is correct.";
                        }

                        if (fail) {
                            
                            apf.console.error(fail, "audio");
                            
                            obj.dispatchEvent("error", {message: fail});
                        }
                    }, 1000);
                }, 200);
            };

        return apf.loaded ? cb() : apf.addEventListener("load", cb);
    }

    /**
     * Build the <OBJECT> tag that will load the Adobe installer for Flash
     * upgrades.
     */
    function buildInstaller(options) {
        if (!options)
            options = {};
        var ret = AC_GetArgs(options,
            "movie", "clsid:d27cdb6e-ae6d-11cf-96b8-444553540000",
            "application/x-shockwave-flash"),
            MMPlayerType  = (apf.isIE == true) ? "ActiveX" : "PlugIn",
            MMredirectURL = window.location;
        document.title    = document.title.slice(0, 47) + " - Flash Player Installation";
        var MMdoctitle    = document.title;

        return AC_FL_RunContent({
            src              : "playerProductInstall",
            FlashVars        : "MMredirectURL=" + MMredirectURL + "&MMplayerType="
                + MMPlayerType + "&MMdoctitle=" + MMdoctitle + "",
            width            : "100%",
            height           : "100%",
            align            : "middle",
            id               : ret.embedAttrs["name"],
            quality          : "high",
            bgcolor          : "#000000",
            name             : ret.embedAttrs["name"],
            allowScriptAccess: "always",
            type             : "application/x-shockwave-flash",
            pluginspage      : "http://www.adobe.com/go/getflashplayer"
        });
    }

    var sSrc = "src|movie",
        sObj = "onafterupdate|onbeforeupdate|onblur|oncellchange|onclick|ondblclick"
             + "|ondrag|ondragend|ondragenter|ondragleave|ondragover|ondrop|onfinish"
             + "|onfocus|onhelp|onmousedown|onmouseup|onmouseover|onmousemove"
             + "|onmouseout|onkeypress|onkeydown|onkeyup|onload|onlosecapture"
             + "|onpropertychange|onreadystatechange|onrowsdelete|onrowenter"
             + "|onrowexit|onrowsinserted|onstart|onscroll|onbeforeeditfocus"
             + "|onactivate|onbeforedeactivate|ondeactivate|type|codebase|id",
        sEmb = "width|height|align|vspace|hspace|class|title|accesskey|name|tabindex";

    /**
     * Augments options from AC_FL_RunContent and AC_SW_RunContent to sane
     * object that can be used to generate <OBJECT> and <EMBED> tags (depending
     * on the clients' browser, but this function will generate both)
     *
     * @param {Object} options
     * @param {Object} srcParamName
     * @param {Object} classid
     * @param {Object} mimeType
     * @type {Object}
     */
    function AC_GetArgs(options, srcParamName, classid, mimeType){
        var i, name,
            ret  = {
                embedAttrs: {},
                params    : {},
                objAttrs  : {}
            };

        for (i in options) {
            name = i.toLowerCase();
            if (name == "classid") continue;
            
            if (name == "pluginspage") {
                ret.embedAttrs[i] = options[i];
            }
            else if (sSrc.indexOf(name) > -1) {
                ret.embedAttrs["src"]    = options[i];
                ret.params[srcParamName] = options[i];
            }
            else if (sObj.indexOf(name) > -1) {
                ret.objAttrs[i] = options[i];
            }
            else if (sEmb.indexOf(name) > -1) {
                ret.embedAttrs[i] = ret.objAttrs[i] = options[i];
            }
            else {
                ret.embedAttrs[i] = ret.params[i] = options[i];
            }
        }
        
        ret.objAttrs["classid"] = classid;
        if (mimeType)
            ret.embedAttrs["type"] = mimeType;
        return ret;
    }

    /**
     * Utility method; get an element from the browser's document object, by ID.
     *
     * @param {Object} id
     * @type {HTMLDomElement}
     */
    function getElement(id) {
        var elem;

        if (typeof id == "object")
            return id;
        if (apf.isIE) {
            return self[id];
        }
        else {
            elem = document[id] ? document[id] : document.getElementById(id);
            if (!elem)
                elem = apf.lookup(id);
            return elem;
        }
    }

    var hash     = {},
        uniqueID = 1;

    /**
     * FAVideoManager: add a FAVideo instance to the stack for callbacks later on
     * and return a unique Identifier for the FAVideo instance to remember.
     *
     * @param {Object} player
     * @type {Number}
     */
    function addPlayer(player) {
        hash[++uniqueID] = player;
        return uniqueID;
    }

    /**
     * FAVideoManager: retrieve the FAVideo instance that is paired to the
     * unique identifier (id).
     *
     * @param {Object} id
     * @type {FAVideo}
     */
    function getPlayer(id) {
        return hash[id];
    }

    /**
     * Directs a call from embedded FAVideo SWFs to the appropriate FAVideo
     * instance in Javascript
     *
     * @param {Object} id
     * @param {Object} methodName
     * @type {void}
     */
    function callMethod(id, methodName) {
        var player = hash[id];
        if (player == null)
            throw new Error(apf.formatErrorString(0, this, "Player with id: " + id + " not found"));
        if (player[methodName] == null)
            throw new Error(apf.formatErrorString(0, this, "Method " + methodName + " Not found"));

        
        apf.console.info("[FLASH] received method call for player '" + id + "', '" + methodName + "'");
        

        var args = [],
            i    = 2,
            l    = arguments.length;
        for (; i < l; i++)
            args.push(decode(arguments[i]));
        player[methodName].apply(player, args);
    }

    /**
     * Directs a call from a JS object to an embedded SWF
     *
     * @param {mixed}  o  DOM reference of the Flash movie (or its ID as a string)
     * @param {String} fn Name of the function to be called on the Flash movie, exposed by ExternalInterface
     * @type {void}
     */
    function remote(o, fn) {
        if (typeof o == "string")
            o = hash[o];
        var rs = o.CallFunction('<invoke name="' + fn + '" returntype="javascript">'
               + __flash__argumentsToXML(arguments, 2) + '</invoke>');
        return eval(rs);
    }

    /**
     * Encodes our data to get around ExternalInterface bugs that are still
     * present even in Flash 9.
     *
     * @param {Object} data
     */
    function encode(data) {
        if (!data || typeof data != "string")
            return data;
        // double encode all entity values, or they will be mis-decoded
        // by Flash when returned
        return data.replace(/\&([^;]*)\;/g, "&amp;$1;")
                   // entity encode XML-ish characters, or Flash's broken XML
                   // serializer breaks
                   .replace(/</g, "&lt;")
                   .replace(/>/g, "&gt;")
                   // transforming \ into \\ doesn't work; just use a custom encoding
                   .replace("\\", "&custom_backslash;")
                   // null character
                   .replace(/\0/g, "\\0")
                   .replace(/\"/g, "&quot;");
    }

    /**
     * Decodes our data to get around ExternalInterface bugs that are still
     * present even in Flash 9.
     *
     * @param {String} data
     */
    function decode(data) {
        // wierdly enough, Flash sometimes returns the result as an
        // 'object' that is actually an array, rather than as a String;
        // detect this by looking for a length property; for IE
        // we also make sure that we aren't dealing with a typeof string
        // since string objects have length property there
        if (data && data.length && typeof data != "string")
            data = data[0];
        if (!data || typeof data != "string")
            return data;

        // certain XMLish characters break Flash's wire serialization for
        // ExternalInterface; these are encoded into a custom encoding, rather
        // than the standard entity encoding, because otherwise we won't be able
        // to differentiate between our own encoding and any entity characters
        // that are being used in the string itself
        return data.replace(/\&custom_lt\;/g, "<")
                   .replace(/\&custom_gt\;/g, ">")
                   .replace(/\&custom_backslash\;/g, '\\')
                   // needed for IE; \0 is the NULL character
                   .replace(/\\0/g, "\0");
    }

    var aIsAvailable = {};
    /*
     * Checks whether a valid version of Adobe Flash is available on the clients'
     * system. Default version to check for is 6.0.65.
     *
     * @param {String} sVersion
     * @type {Boolean}
     */
    function isAvailable(sVersion) {
        if (typeof sVersion != "string")
            sVersion = "6.0.65";
        var aVersion = sVersion.split('.');
        while (aVersion.length < 3)
            aVersion.push('0');
        if (typeof aIsAvailable[sVersion] == "undefined")
            aIsAvailable[sVersion] = detectFlashVersion(parseInt(aVersion[0]),
                parseInt(aVersion[1]), parseInt(aVersion[2]));
        return aIsAvailable[sVersion];
    }

    /*
     * Shorthand function to call and cache isAvailable() with version
     * number 8.0.0
     *
     * @type {Boolean}
     */
    function isEightAvailable() {
        return isAvailable("8.0.0");
    }

    var oSandboxTypes = {
        remote          : "remote (domain-based) rules",
        localwithfile   : "local with file access (no internet access)",
        localwithnetwork: "local with network (internet access only, no local access)",
        localtrusted    : "local, trusted (local + internet access)"
    };

    function getSandbox(sType) {
        var oSandbox = {
            type       : null,
            description: null,
            noRemote   : false,
            noLocal    : false,
            error      : null
        };
        oSandbox.type = sType.toLowerCase();
        oSandbox.description = oSandboxTypes[(typeof oSandboxTypes[oSandbox.type] != "undefined"
            ? oSandbox.type
            : "unknown")];
        if (oSandbox.type == "localwithfile") {
            oSandbox.noRemote = true;
            oSandbox.noLocal  = false;
            oSandbox.error    = "Flash security note: Network/internet URLs will not \
                                 load due to security restrictions.\
                                 Access can be configured via Flash Player Global Security\
                                 Settings Page: \
                                 http://www.macromedia.com/support/documentation/en/flashplayer/help/settings_manager04.html";
        }
        else if (oSandbox.type == "localwithnetwork") {
            oSandbox.noRemote = false;
            oSandbox.noLocal  = true;
        }
        else if (oSandbox.type == "localtrusted") {
            oSandbox.noRemote = false;
            oSandbox.noLocal  = false;
        }

        return oSandbox;
    }

    return {
        isAvailable     : isAvailable,
        isEightAvailable: isEightAvailable,
        buildContent    : buildContent,
        embed           : embed,
        encode          : encode,
        decode          : decode,
        getElement      : getElement,
        addPlayer       : addPlayer,
        getPlayer       : getPlayer,
        callMethod      : callMethod,
        getSandbox      : getSandbox,
        remote          : remote
    };
})();



/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/util/cookie.js)SIZE(3074)TIME(1263307109)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */
 


/**
 * Sets a name/value pair which is stored in the browser and sent to the server
 * with every request. This is also known as a cookie. Be careful setting 
 * cookies, because they can take up a lot of bandwidth, especially for Ajax
 * applications.
 * 
 * @param {String}  name     cookie name
 * @param {String}  value    cookie value
 * @param {Date}    expire   expire date representing the number of milliseconds
 *                           since 1 January 1970 00:00:00 UTC.
 * @param {String}  path     path name
 * @param {String}  domain   domain name
 * @param {Boolean} secure   cookie may benefit all the documents and CGI programs
 *                           meet the requirements as to the path and domain
 *                           compatibility
 *     Possible values:
 *     true   may benefit
 *     false  can not benefit
 *     
 * @return {String} Returns a cookie name.
 */
apf.setcookie = function(name, value, expire, path, domain, secure) {
    var ck = name + "=" + escape(value) + ";";
    if (expire) ck += "expires=" + new Date(expire
        + new Date().getTimezoneOffset() * 60).toGMTString() + ";";
    if (path)   ck += "path=" + path + ";";
    if (domain) ck += "domain=" + domain + ";";
    if (secure) ck += "secure";

    document.cookie = ck;
    return value
};

/**
 * Gets the value of a stored name/value pair called a cookie.
 * 
 * @param {String} name the name of the stored cookie.
 * @return {String} Returns a value of the cookie or the empty string if it isn't found
 */
apf.getcookie = function (name) {
  var aCookie = document.cookie.split("; ");
  for (var i = 0; i < aCookie.length; i++) {
      var aCrumb = aCookie[i].split("=");
      if (name == aCrumb[0])
          return unescape(aCrumb[1]);
  }

  return "";
};

/**
 * Deletes a stored name/value pair called a cookie.
 * 
 * @param {String} name     the name of the stored cookie
 * @param {String} domain   the name of the domain of stored cookie
 */
apf.delcookie = function (name, domain){
    document.cookie = name + "=blah; expires=Fri, 31 Dec 1999 23:59:59 GMT;"
        + (domain ? 'domain='+domain : '');
};




/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/util/utilities.js)SIZE(18841)TIME(1271105953)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * Opens a window with the string in it
 * @param {String} str the html string displayed in the new window.
 */
apf.pasteWindow = function(str){
    var win = window.open("about:blank");
    win.document.write(str);
};



/**
 * @private
 */
apf.xmlEntityMap = {
    "quot": "34", "amp": "38", "apos": "39", "lt": "60", "gt": "62",
    "nbsp": "160", "iexcl": "161", "cent": "162", "pound": "163", "curren": "164",
    "yen": "165", "brvbar": "166", "sect": "167", "uml": "168", "copy": "169",
    "ordf": "170", "laquo": "171", "not": "172", "shy": "173", "reg": "174",
    "macr": "175", "deg": "176", "plusmn": "177", "sup2": "178", "sup3": "179",
    "acute": "180", "micro": "181", "para": "182", "middot": "183", "cedil": "184",
    "sup1": "185", "ordm": "186", "raquo": "187", "frac14": "188", "frac12": "189",
    "frac34": "190", "iquest": "191", "agrave": "192", "aacute": "193",
    "acirc": "194", "atilde": "195", "auml": "196", "aring": "197", "aelig": "198",
    "ccedil": "199", "egrave": "200", "eacute": "201", "ecirc": "202",
    "euml": "203", "igrave": "204", "iacute": "205", "icirc": "206", "iuml": "207",
    "eth": "208", "ntilde": "209", "ograve": "210", "oacute": "211", "ocirc": "212",
    "otilde": "213", "ouml": "214", "times": "215", "oslash": "216", "ugrave": "217",
    "uacute": "218", "ucirc": "219", "uuml": "220", "yacute": "221", "thorn": "222",
    "szlig": "223", "agrave": "224", "aacute": "225", "acirc": "226", "atilde": "227",
    "auml": "228", "aring": "229", "aelig": "230", "ccedil": "231", "egrave": "232",
    "eacute": "233", "ecirc": "234", "euml": "235", "igrave": "236", "iacute": "237",
    "icirc": "238", "iuml": "239", "eth": "240", "ntilde": "241", "ograve": "242",
    "oacute": "243", "ocirc": "244", "otilde": "245", "ouml": "246", "divide": "247",
    "oslash": "248", "ugrave": "249", "uacute": "250", "ucirc": "251", "uuml": "252",
    "yacute": "253", "thorn": "254", "yuml": "255", "oelig": "338", "oelig": "339",
    "scaron": "352", "scaron": "353", "yuml": "376", "fnof": "402", "circ": "710",
    "tilde": "732", "alpha": "913", "beta": "914", "gamma": "915", "delta": "916",
    "epsilon": "917", "zeta": "918", "eta": "919", "theta": "920", "iota": "921",
    "kappa": "922", "lambda": "923", "mu": "924", "nu": "925", "xi": "926",
    "omicron": "927", "pi": "928", "rho": "929", "sigma": "931", "tau": "932",
    "upsilon": "933", "phi": "934", "chi": "935", "psi": "936", "omega": "937",
    "alpha": "945", "beta": "946", "gamma": "947", "delta": "948", "epsilon": "949",
    "zeta": "950", "eta": "951", "theta": "952", "iota": "953", "kappa": "954",
    "lambda": "955", "mu": "956", "nu": "957", "xi": "958", "omicron": "959",
    "pi": "960", "rho": "961", "sigmaf": "962", "sigma": "963", "tau": "964",
    "upsilon": "965", "phi": "966", "chi": "967", "psi": "968", "omega": "969",
    "thetasym": "977", "upsih": "978", "piv": "982", "ensp": "8194", "emsp": "8195",
    "thinsp": "8201", "zwnj": "8204", "zwj": "8205", "lrm": "8206", "rlm": "8207",
    "ndash": "8211", "mdash": "8212", "lsquo": "8216", "rsquo": "8217",
    "sbquo": "8218", "ldquo": "8220", "rdquo": "8221", "bdquo": "8222",
    "dagger": "8224", "dagger": "8225", "bull": "8226", "hellip": "8230",
    "permil": "8240", "prime": "8242", "prime": "8243", "lsaquo": "8249",
    "rsaquo": "8250", "oline": "8254", "frasl": "8260", "euro": "8364",
    "image": "8465", "weierp": "8472", "real": "8476", "trade": "8482",
    "alefsym": "8501", "larr": "8592", "uarr": "8593", "rarr": "8594",
    "darr": "8595", "harr": "8596", "crarr": "8629", "larr": "8656", "uarr": "8657",
    "rarr": "8658", "darr": "8659", "harr": "8660", "forall": "8704", "part": "8706",
    "exist": "8707", "empty": "8709", "nabla": "8711", "isin": "8712",
    "notin": "8713", "ni": "8715", "prod": "8719", "sum": "8721", "minus": "8722",
    "lowast": "8727", "radic": "8730", "prop": "8733", "infin": "8734",
    "ang": "8736", "and": "8743", "or": "8744", "cap": "8745", "cup": "8746",
    "int": "8747", "there4": "8756", "sim": "8764", "cong": "8773", "asymp": "8776",
    "ne": "8800", "equiv": "8801", "le": "8804", "ge": "8805", "sub": "8834",
    "sup": "8835", "nsub": "8836", "sube": "8838", "supe": "8839", "oplus": "8853",
    "otimes": "8855", "perp": "8869", "sdot": "8901", "lceil": "8968",
    "rceil": "8969", "lfloor": "8970", "rfloor": "8971", "lang": "9001",
    "rang": "9002", "loz": "9674", "spades": "9824", "clubs": "9827",
    "hearts": "9829", "diams": "9830"
};

/**
 * see string#escapeHTML
 * @param {String} str the html to be escaped.
 * @return {String} the escaped string.
 */
apf.htmlentities = function(str){
    return str.escapeHTML();
};

/**
 * Escape an xml string making it ascii compatible.
 * @param {String} str the xml string to escape.
 * @return {String} the escaped string.
 *
 * @todo This function does something completely different from htmlentities, 
 *       the name is confusing and misleading.
 */
apf.xmlentities = function(str) {
    return str.replace(/&([a-z]+);/gi, function(a, m) {
        if (apf.xmlEntityMap[m = m.toLowerCase()])
            return '&#' + apf.xmlEntityMap[m] + ';';
        return a;
    });
};

/**
 * Unescape an html string.
 * @param {String} str the string to unescape.
 * @return {String} the unescaped string.
 */
apf.html_entity_decode = function(str){
    return (str || "").replace(/\&\#38;/g, "&").replace(/&lt;/g, "<")
        .replace(/&gt;/g, ">").replace(/&amp;/g, "&").replace(/&nbsp;/g, " ");
};



/**
 * Determines whether the keyboard input was a character that can influence
 * the value of an element (like a textbox).
 * @param {Number} charCode The ascii character code.
 */
apf.isCharacter = function(charCode){
    return (charCode < 112 || charCode > 122)
      && (charCode == 32 || charCode > 42 || charCode == 8);
};

/**
 * This random number generator has been added to provide a more robust and
 * reliable random number spitter than the native Ecmascript Math.random()
 * function.
 * is an implementation of the Park-Miller algorithm. (See 'Random Number
 * Generators: Good Ones Are Hard to Find', by Stephen K. Park and Keith W.
 * Miller, Communications of the ACM, 31(10):1192-1201, 1988.)
 * @author David N. Smith of IBM's T. J. Watson Research Center.
 * @author Mike de Boer (mike AT javeline DOT com)
 * @class randomGenerator
 */
apf.randomGenerator = {
    d: new Date(),
    seed: null,
    A: 48271,
    M: 2147483647,
    Q: null,
    R: null,
    oneOverM: null,

    /**
     * Generates a random Number between a lower and upper boundary.
     * The algorithm uses the system time, in minutes and seconds, to 'seed'
     * itself, that is, to create the initial values from which it will generate
     * a sequence of numbers. If you are familiar with random number generators,
     * you might have reason to use some other value for the seed. Otherwise,
     * you should probably not change it.
     * @param {Number} lnr Lower boundary
     * @param {Number} unr Upper boundary
     * @result A random number between <i>lnr</i> and <i>unr</i>
     * @type Number
     */
    generate: function(lnr, unr) {
        if (this.seed == null)
            this.seed = 2345678901 + (this.d.getSeconds() * 0xFFFFFF) + (this.d.getMinutes() * 0xFFFF);
        this.Q = this.M / this.A;
        this.R = this.M % this.A;
        this.oneOverM = 1.0 / this.M;
        return Math.floor((unr - lnr + 1) * this.next() + lnr);
    },

    /**
     * Returns a new random number, based on the 'seed', generated by the
     * <i>generate</i> method.
     * @type Number
     */
    next: function() {
        var hi = this.seed / this.Q;
        var lo = this.seed % this.Q;
        var test = this.A * lo - this.R * hi;
        if (test > 0)
            this.seed = test;
        else
            this.seed = test + this.M;
        return (this.seed * this.oneOverM);
    }
};

/**
 * Adds a time stamp to the url to prevent the browser from caching it.
 * @param {String} url the url to add the timestamp to.
 * @return {String} the url with timestamp.
 */
apf.getNoCacheUrl = function(url){
    return url
        + (url.indexOf("?") == -1 ? "?" : "&")
        + "nocache=" + new Date().getTime();
};

/**
 * Checks if the string contains curly braces at the start and end. If so it's
 * processed as javascript, else the original string is returned.
 * @param {String} str the string to parse.
 * @return {String} the result of the parsing.
 */
apf.parseExpression = function(str){
    if (!apf.parseExpression.regexp.test(str))
        return str;

    
    try {
    
        return eval(RegExp.$1);
    
    }
    catch(e) {
        throw new Error(apf.formatErrorString(0, null,
            "Parsing Expression",
            "Invalid expression given '" + str + "'"));
    }
    
};
apf.parseExpression.regexp = /^\{([\s\S]*)\}$/;

/**
 * @private
 */
apf.formatNumber = function(num, prefix){
    var nr = parseFloat(num);
    if (!nr) return num;

    var str = new String(Math.round(nr * 100) / 100).replace(/(\.\d?\d?)$/, function(m1){
        return m1.pad(3, "0", apf.PAD_RIGHT);
    });
    if (str.indexOf(".") == -1)
        str += ".00";

    return prefix + str;
};

/**
 * Execute a script in the global scope.
 *
 * @param {String} str  the javascript code to execute.
 * @return {String} the javascript code executed.
 */
apf.jsexec = function(str, win){
    if (!str)
        return str;
    if (!win)
        win = self;

    if (apf.isO3)
        eval(str, self);
    else if (apf.hasExecScript) {
        win.execScript(str);
    }
    else {
        var head = win.document.getElementsByTagName("head")[0];
        if (head) {
            var script = win.document.createElement('script');
            script.setAttribute('type', 'text/javascript');
            script.text = str;
            head.appendChild(script);
            head.removeChild(script);
        } else
            eval(str, win);
    }

    return str;
};

/**
 * Shorthand for an empty function.
 */
apf.K = function(){};



/**
 * Reliably determines whether a variable is a Number.
 *
 * @param {mixed}   value The variable to check
 * @type  {Boolean}
 */
apf.isNumber = function(value){
    return parseFloat(value) == value;
};

/**
 * Reliably determines whether a variable is an array.
 * @see http://thinkweb2.com/projects/prototype/instanceof-considered-harmful-or-how-to-write-a-robust-isarray/
 *
 * @param {mixed}   value The variable to check
 * @type  {Boolean}
 */
apf.isArray = function(value) {
    return Object.prototype.toString.call(value) === "[object Array]";
};

/**
 * Determines whether a string is true in the html attribute sense.
 * @param {mixed} value the variable to check
 *   Possible values:
 *   true   The function returns true.
 *   'true' The function returns true.
 *   'on'   The function returns true.
 *   1      The function returns true.
 *   '1'    The function returns true.
 * @return {Boolean} whether the string is considered to imply truth.
 */
apf.isTrue = function(c){
    return (c === true || c === "true" || c === "on" || typeof c == "number" && c > 0 || c === "1");
};

/**
 * Determines whether a string is false in the html attribute sense.
 * @param {mixed} value the variable to check
 *   Possible values:
 *   false   The function returns true.
 *   'false' The function returns true.
 *   'off'   The function returns true.
 *   0       The function returns true.
 *   '0'     The function returns true.
 * @return {Boolean} whether the string is considered to imply untruth.
 */
apf.isFalse = function(c){
    return (c === false || c === "false" || c === "off" || c === 0 || c === "0");
};

/**
 * Determines whether a value should be considered false. This excludes amongst
 * others the number 0.
 * @param {mixed} value the variable to check
 * @return {Boolean} whether the variable is considered false.
 */
apf.isNot = function(c){
    // a var that is null, false, undefined, Infinity, NaN and c isn't a string
    return (!c && typeof c != "string" && c !== 0 || (typeof c == "number" && !isFinite(c)));
};

/**
 * Creates a relative url based on an absolute url.
 * @param {String} base the start of the url to which relative url's work.
 * @param {String} url  the url to transform.
 * @return {String} the relative url.
 */
apf.removePathContext = function(base, url){
    if (!url)  return "";

    if (url.indexOf(base) > -1)
        return url.substr(base.length);

    return url;
};

/**
 * @private
 * @todo why is this done like this?
 */
apf.cancelBubble = function(e, o){
    e.cancelBubble = true;
    
    if (o.$focussable && !o.disabled)
        apf.window.$focus(o);
    
};



/**
 * Attempt to fix memory leaks
 * @private
 */
apf.destroyHtmlNode = function (element) {
    if (!element) return;

    if (!apf.isIE || element.ownerDocument != document) {
        if (element.parentNode)
            element.parentNode.removeChild(element);
        return;
    }

    var garbageBin = document.getElementById('IELeakGarbageBin');
    if (!garbageBin) {
        garbageBin    = document.createElement('DIV');
        garbageBin.id = 'IELeakGarbageBin';
        garbageBin.style.display = 'none';
        document.body.appendChild(garbageBin);
    }

    // move the element to the garbage bin
    garbageBin.appendChild(element);
    garbageBin.innerHTML = '';
};


/**
 * @private
 */
apf.getRules = function(node){
    var rules = {};

    for (var w = node.firstChild; w; w = w.nextSibling){
        if (w.nodeType != 1)
            continue;
        else {
            if (!rules[w[apf.TAGNAME]])
                rules[w[apf.TAGNAME]] = [];
            rules[w[apf.TAGNAME]].push(w);
        }
    }

    return rules;
};


apf.isCoord = function (n){
    return n || n === 0;
}

apf.getCoord = function (n, other){
    return n || n === 0 ? n : other;
}

/**
 * @private
 */
apf.getBox = function(value, base){
    if (!base) base = 0;

    if (value == null || (!parseInt(value) && parseInt(value) != 0))
        return [0, 0, 0, 0];

    var x = String(value).split(" ");
    for (var i = 0; i < x.length; i++)
        x[i] = parseInt(x[i]) || 0;
    switch (x.length) {
        case 1:
            x[1] = x[0];
            x[2] = x[0];
            x[3] = x[0];
            break;
        case 2:
            x[2] = x[0];
            x[3] = x[1];
            break;
        case 3:
            x[3] = x[1];
            break;
    }

    return x;
};

/**
 * @private
 */
apf.getNode = function(data, tree){
    var nc = 0;//nodeCount
    //node = 1
    if (data != null) {
        for (var i = 0; i < data.childNodes.length; i++) {
            if (data.childNodes[i].nodeType == 1) {
                if (nc == tree[0]) {
                    data = data.childNodes[i];
                    if (tree.length > 1) {
                        tree.shift();
                        data = this.getNode(data, tree);
                    }
                    return data;
                }
                nc++
            }
        }
    }

    return null;
};

/**
 * Retrieves the first xml node with nodeType 1 from the children of an xml element.
 * @param {XMLElement} xmlNode the xml element that is the parent of the element to select.
 * @return {XMLElement} the first child element of the xml parent.
 * @throw error when no child element is found.
 */
apf.getFirstElement = function(xmlNode){
    
    try {
        xmlNode.firstChild.nodeType == 1
            ? xmlNode.firstChild
            : xmlNode.firstChild.nextSibling
    }
    catch (e) {
        throw new Error(apf.formatErrorString(1052, null,
            "Xml Selection",
            "Could not find element:\n"
            + (xmlNode ? xmlNode.xml : "null")));
    }
    

    return xmlNode.firstChild.nodeType == 1
        ? xmlNode.firstChild
        : xmlNode.firstChild.nextSibling;
};

/**
 * Retrieves the last xml node with nodeType 1 from the children of an xml element.
 * @param {XMLElement} xmlNode the xml element that is the parent of the element to select.
 * @return {XMLElement} the last child element of the xml parent.
 * @throw error when no child element is found.
 */
apf.getLastElement = function(xmlNode){
    
    try {
        xmlNode.lastChild.nodeType == 1
            ? xmlNode.lastChild
            : xmlNode.lastChild.nextSibling
    }
    catch (e) {
        throw new Error(apf.formatErrorString(1053, null,
            "Xml Selection",
            "Could not find last element:\n"
            + (xmlNode ? xmlNode.xml : "null")));
    }
    

    return xmlNode.lastChild.nodeType == 1
        ? xmlNode.lastChild
        : xmlNode.lastChild.previousSibling;
};

/**
 * Selects the content of an html element. Currently only works in
 * internet explorer.
 * @param {HTMLElement} oHtml the container in which the content receives the selection.
 */
apf.selectTextHtml = function(oHtml){
    if (!apf.hasMsRangeObject) return;// oHtml.focus();

    var r = document.selection.createRange();
    try {r.moveToElementText(oHtml);} catch(e){}
    r.select();
};




/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/util/xml.js)SIZE(29630)TIME(1271196962)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


/**
 * Determines whether a node is a child of another node.
 *
 * @param {DOMNode} pNode      the potential parent element.
 * @param {DOMNode} childnode  the potential child node.
 * @param {Boolean} [orItself] whether the method also returns true when pNode is the childnode.
 * @return  {Number} the child position of the node. Or false if it's not a child.
 */
apf.isChildOf = function(pNode, childnode, orItself){
    if (!pNode || !childnode)
        return false;
    
    if (childnode.nodeType == 2)
        childnode = childnode.ownerElement || childnode.selectSingleNode("..");
    
    if (orItself && pNode == childnode)
        return true;

    var loopnode = childnode.parentNode;
    while(loopnode){
        if(loopnode == pNode)
            return true;
        loopnode = loopnode.parentNode;
    }

    return false;
};

/**
 * Determines whether a node is it's parent's only child.
 * @param {DOMNode} node     the potential only child.
 * @param {Array}   nodeType list of the node types that this child can be.
 * @returns {Boolean} whether the node is only child and optionally of one of the specified nodeTypes.
 */
apf.isOnlyChild = function(node, nodeType){
    if (!node || !node.parentNode || nodeType && nodeType.indexOf(node.nodeType) == -1)
        return false;

    var i, l, cnode, nodes = node.parentNode.childNodes;
    for (i = 0, l = nodes.length; i < l; i++) {
        cnode = nodes[i];
        if (cnode.nodeType == 1 && cnode != node)
            return false;
        if (cnode.nodeType == 3 && !cnode.nodeValue.trim())
            return false;
    }

    return true;
};

/**
 * Gets the position of a dom node within the list of child nodes of it's
 * parent.
 *
 * @param {DOMNode} node the node for which the child position is determined.
 * @return {Number} the child position of the node.
 */
apf.getChildNumber = function(node, fromList){
    var p = node.parentNode, j = 0;
    if (!p) return 0;
    if (!fromList)
        fromList = p.childNodes;
    
    if (apf.hasIndexOfNodeList)
        return fromList.indexOf(node);
        
    for (var i = 0, l = fromList.length; i < l; i++) {
        if (fromList[i] == node)
            return j;
        j++;
    }
    return j;
};

/**
 * Integrates nodes as children of a parent. Optionally attributes are
 * copied as well.
 *
 * @param {XMLNode} xmlNode the data to merge.
 * @param {XMLNode} parent  the node to merge on.
 * @param {Object}  options
 *   Properties:
 *   {Boolean} [copyAttributes] whether the attributes of xmlNode are copied as well.
 *   {Boolean} [clearContents]  whether the contents of parent is cleared.
 *   {Number}  [start]          This feature is used for the virtual viewport. More information will follow.
 *   {Number}  [length]         This feature is used for the virtual viewport. More information will follow.
 *   {Number}  [documentId]     This feature is used for the virtual viewport. More information will follow.
 *   {XMLElement} [marker]      This feature is used for the virtual viewport. More information will follow.
 * @return  {XMLNode}  the created xml node
 */
apf.mergeXml = function(XMLRoot, parentNode, options){
    if (typeof parentNode != "object")
        parentNode = getElementById(parentNode);

    if (options && options.clearContents) {
        //Signal listening elements
        var node, j, i,
            nodes = parentNode.selectNodes("descendant::node()[@" + apf.xmldb.xmlListenTag + "]");
        for (i = nodes.length - 1; i >= 0; i--) {
            var s = nodes[i].getAttribute(apf.xmldb.xmlListenTag).split(";");
            for (j = s.length - 1; j >= 0; j--) {
                node = apf.all[s[j]];
                if (node.dataParent && node.dataParent.xpath)
                    node.dataParent.parent.signalXmlUpdate[node.$uniqueId] = true;
                else if (node.$model)
                    node.$model.$waitForXml(node);
            }
        }
        
        //clean parent
        nodes = parentNode.childNodes;
        for (i = nodes.length - 1; i >= 0; i--)
            parentNode.removeChild(nodes[i]);
    }

    
    {
        beforeNode = options && options.beforeNode ? options.beforeNode : apf.getNode(parentNode, [0]);
        nodes      = XMLRoot.childNodes;

        if (parentNode.ownerDocument.importNode) {
            doc = parentNode.ownerDocument;
            for (i = 0, l = nodes.length; i < l; i++)
                parentNode.insertBefore(doc.importNode(nodes[i], true), beforeNode);
        }
        else
            for (i = nodes.length - 1; i >= 0; i--)
                parentNode.insertBefore(nodes[0], beforeNode);
    }

    if (options && options.copyAttributes) {
        var attr = XMLRoot.attributes;
        for (i = 0; i < attr.length; i++)
            if (attr[i].nodeName != apf.xmldb.xmlIdTag)
                parentNode.setAttribute(attr[i].nodeName, attr[i].nodeValue);
    }

    return parentNode;
};

/**
 * Sets the nodeValue of a dom node.
 *
 * @param {XMLElement} xmlNode       the xml node that should receive the nodeValue.
 *                                   When an element node is passed the first text node is set.
 * @param {String}     nodeValue     the value to set.
 * @param {Boolean}    applyChanges  whether the changes are propagated to the databound elements.
 * @param {UndoObj}    undoObj       the undo object that is responsible for archiving the changes.
 */
apf.setNodeValue = function(xmlNode, nodeValue, applyChanges, options){
    if (!xmlNode)
        return;
    
    var undoObj, xpath, newNodes;
    if (options) {
        undoObj  = options.undoObj;
        xpath    = options.xpath;
        newNodes = options.newNodes;
        
        undoObj.extra.oldValue = options.forceNew
            ? ""
            : apf.queryValue(xmlNode, xpath);

        undoObj.xmlNode        = xmlNode;
        if (xpath)
            xmlNode = apf.createNodeFromXpath(xmlNode, xpath, newNodes, options.forceNew);

        undoObj.extra.appliedNode = xmlNode;
    }
    
    if (xmlNode.nodeType == 1) {
        if (!xmlNode.firstChild)
            xmlNode.appendChild(xmlNode.ownerDocument.createTextNode("-"));

        xmlNode.firstChild.nodeValue = apf.isNot(nodeValue) ? "" : nodeValue;

        if (applyChanges)
            apf.xmldb.applyChanges("synchronize", xmlNode, undoObj);
    }
    else {
        var oldValue      = xmlNode.nodeValue;
        xmlNode.nodeValue = apf.isNot(nodeValue) ? "" : nodeValue;
        
        //AML support - getters/setters would be awesome
        if (xmlNode.$triggerUpdate)
            xmlNode.$triggerUpdate(null, oldValue);

        if (applyChanges)
            apf.xmldb.applyChanges("synchronize", xmlNode.parentNode
                || xmlNode.ownerElement || xmlNode.selectSingleNode(".."),
                undoObj);
    }
    
};

/**
 * Sets a value of an XMLNode based on an xpath statement executed on the data of this model.
 *
 * @param  {String}  xpath  the xpath used to select a XMLNode.
 * @param  {String}  value  the value to set.
 * @return  {XMLNode}  the changed XMLNode
 */
apf.setQueryValue = function(xmlNode, xpath, value){
    var node = apf.createNodeFromXpath(xmlNode, xpath);
    if (!node)
        return null;

    apf.setNodeValue(node, value, true);
    //apf.xmldb.setTextNode(node, value);
    return node;
};

/**
 * Queries an xml node using xpath for a string value.
 * @param {XMLElement} xmlNode the xml element to query.
 * @param {String}     xpath   the xpath query.
 * @return {String} the value of the query result or empty string.
 */
apf.queryValue = function (xmlNode, xpath){
    if (!xmlNode) 
        return "";
    if (xmlNode.nodeType == 2) 
        return xmlNode.nodeValue;

    if (xpath) {
        xmlNode = xmlNode.selectSingleNode(xpath);
        if (!xmlNode) 
            return "";
    }
   return xmlNode.nodeType == 1
        ? (!xmlNode.firstChild ? "" : xmlNode.firstChild.nodeValue)
        : xmlNode.nodeValue;
};

/**
 * Queries an xml node using xpath for a string value.
 * @param {XMLElement} xmlNode the xml element to query.
 * @param {String}     xpath   the xpath query.
 * @return {Arary} list of values which are a result of the query.
 */
apf.queryValues = function(xmlNode, xpath){
    var out = [];
    if (!xmlNode) return out;

    var nodes = xmlNode.selectNodes(xpath);
    if (!nodes.length) return out;

    for (var i = 0; i < nodes.length; i++) {
        var n = nodes[i];
        if (n.nodeType == 1)
            n = n.firstChild;
        out.push(n.nodeValue || "");
    }
    return out;
};

/**
 * Executes an xpath expression on any dom node. This is especially useful
 * for dom nodes that don't have a good native xpath processor such as html
 * in some versions of internet explorer and xml in webkit.
 *
 * @param {String}  sExpr        the xpath expression.
 * @param {DOMNode} contextNode  the xml node that is subject to the query.
 * @returns {Array} list of xml nodes found. The list can be empty.
 */
apf.queryNodes = function(sExpr, contextNode){
    if (contextNode && (apf.hasXPathHtmlSupport && contextNode.selectSingleNode || !contextNode.style))
        return contextNode.selectNodes(sExpr); //IE55
    //if (contextNode.ownerDocument != document)
    //    return contextNode.selectNodes(sExpr);

    return apf.XPath.selectNodes(sExpr, contextNode)
};

/**
 * Executes an xpath expression on any dom node. This is especially useful
 * for dom nodes that don't have a good native xpath processor such as html
 * in some versions of internet explorer and xml in webkit. This function
 * Only returns the first node found.
 *
 * @param {String}  sExpr        the xpath expression.
 * @param {DOMNode} contextNode  the dom node that is subject to the query.
 * @returns {XMLNode} the dom node found or null if none was found.
 */
apf.queryNode = function(sExpr, contextNode){
    if (contextNode && (apf.hasXPathHtmlSupport && contextNode.selectSingleNode || !contextNode.style))
        return contextNode.selectSingleNode(sExpr); //IE55
    //if (contextNode.ownerDocument != document)
    //    return contextNode.selectSingleNode(sExpr);

    var nodeList = apf.queryNodes(sExpr + (apf.isIE ? "" : "[1]"),
        contextNode ? contextNode : null);
    return nodeList.length > 0 ? nodeList[0] : null;
};

/**
 * Retrieves the attribute of an xml node or the first parent node that has
 * that attribute set. If no attribute is set the value is looked for on
 * the appsettings element.
 *
 * @param {XMLElement} xml    the xml node that is the starting point of the search.
 * @param {String}     attr   the name of the attribute.
 * @param {Function}   [func] callback that is run for every node that is searched.
 * @return {String} the found value, or empty string if none was found.
 */
apf.getInheritedAttribute = function(xml, attr, func){
    var result, avalue;

    //@todo optimize this and below
    if (xml.nodeValue != 1)
        xml = xml.parentNode;

    while (xml && (xml.nodeType != 1 || !(result = attr 
      && ((avalue = xml.getAttribute(attr)) || typeof avalue == "string") 
      || func && func(xml)))) {
        xml = xml.parentNode;
    }
    if (avalue == "")
        return "";

    return !result && attr && apf.config
        ? apf.config[attr]
        : result;
};

/**
 * Creates an xml node based on an xpath statement.
 *
 * @param {DOMNode} contextNode  the dom node that is subject to the query.
 * @param {String}  xPath        the xpath query.
 * @param {Array}   [addedNodes] this array is filled with the nodes added.
 * @param {Boolean} [forceNew]   whether a new node is always created.
 * @return {DOMNode} the last element found.
 * @todo generalize this to include attributes in if format []
 */
apf.createNodeFromXpath = function(contextNode, xPath, addedNodes, forceNew){
    var xmlNode, foundpath = "", paths = xPath.replace(/('.*?')|(".*?")|\|/g, function(m, m1, m2){
        if (m1 || m2) return m1 || m2;
        return "-%-|-%-";
    }).split("-%-|-%-")[0].split("/");
    if (!forceNew && (xmlNode = contextNode.selectSingleNode(xPath)))
        return xmlNode;
    
    var len = paths.length -1;
    if (forceNew) {
        if (paths[len].trim().match(/^\@(.*)$|^text\(\)$/))
            len--;
    }
    
    for (var addedNode, isAdding = false, i = 0; i < len; i++) {
        if (!isAdding && contextNode.selectSingleNode(foundpath
          + (i != 0 ? "/" : "") + paths[i])) {
            foundpath += (i != 0 ? "/" : "") + paths[i];// + "/";
            continue;
        }
        
        //Temp hack 
        var isAddId = paths[i].match(/(\w+)\[@([\w-]+)=(\w+)\]/);
        
        if (!isAddId && paths[i].match(/\@|\[.*\]|\(.*\)/)) {
            throw new Error(apf.formatErrorString(1041, this, 
                "Select via xPath", 
                "Could not use xPath to create xmlNode: " + xPath));
        }
        if (!isAddId && paths[i].match(/\/\//)) {
            throw new Error(apf.formatErrorString(1041, this, 
                "Select via xPath", 
                "Could not use xPath to create xmlNode: " + xPath));
        }
        

        if (isAddId)
            paths[i] = isAddId[1];

        isAdding = true;
        addedNode = contextNode.selectSingleNode(foundpath || ".")
            .appendChild(contextNode.ownerDocument.createElement(paths[i]));

        if (isAddId) {
            addedNode.setAttribute(isAddId[2], isAddId[3]);
            foundpath += (foundpath ? "/" : "") + isAddId[0];// + "/";
        }
        else
            foundpath += (foundpath ? "/" : "") + paths[i];// + "/";

        if (addedNodes)
            addedNodes.push(addedNode);
    }

    if (!foundpath)
        foundpath = ".";

    var newNode, lastpath = paths[len], 
        doc = contextNode.nodeType == 9 ? contextNode : contextNode.ownerDocument;
    do {
        if (lastpath.match(/^\@(.*)$/)) {
            (newNode || contextNode.selectSingleNode(foundpath))
                .setAttributeNode(newNode = contextNode.ownerDocument.createAttribute(RegExp.$1));
        }
        else if (lastpath.trim() == "text()") {
            newNode = (newNode || contextNode.selectSingleNode(foundpath))
                .appendChild(contextNode.ownerDocument.createTextNode(""));
        }
        else {
            var hasId = lastpath.match(/(\w+)\[@([\w-]+)=(\w+)\]/);
            if (hasId) lastpath = hasId[1];
            newNode = (newNode || contextNode.selectSingleNode(foundpath))
                .appendChild(doc.createElement(lastpath));
            if (hasId)
                newNode.setAttribute(hasId[2], hasId[3]);
            
            if (addedNodes)
                addedNodes.push(newNode);
        }
        
        foundpath += (foundpath ? "/" : "") + paths[len];
    } while((lastpath = paths[++len]));

    return newNode;
};

/**
 * @private
 */
apf.convertMethods = {
    /**
     * Gets a JSON object containing all the name/value pairs of the elements
     * using this element as it's validation group.
     *
     * @return  {String}  the string representation of a the json object
     */
    "json": function(xml){
        return JSON.stringify(apf.xml2json(xml));
        /*
        var result = {}, filled = false, nodes = xml.childNodes;
        for (var i = 0; i < nodes.length; i++) {
            if (nodes[i].nodeType != 1)
                continue;
            var name = nodes[i].tagName;
            filled = true;

            //array
            var sameNodes = xml.selectNodes(x);
            if (sameNodes.length > 1) {
                var z = [];
                for (var j = 0; j < sameNodes.length; j++) {
                    z.push(this.json(sameNodes[j], result));
                }
                result[name] = z;
            }
            else //single value
                result[name] = this.json(sameNodes[j], result);
        }

        return filled ? result : apf.queryValue(xml, "text()");*/
    },

    "cgivars": function(xml, basename){
        if (!basename) 
            basename = "";
        
        var value, name, sameNodes, j, l2,
            str   = [],
            nodes = xml.childNodes,
            done  = {},
            i     = 0,
            l     = nodes.length;
        for (; i < l; ++i) {
            if (nodes[i].nodeType != 1)
                continue;
            name = nodes[i].tagName;
            if (done[name])
                continue;

            //array
            sameNodes = xml.selectNodes(name);
            if (sameNodes.length > 1) {
                done[name] = true;
                for (j = 0, l2 = sameNodes.length; j < l2; j++) {
                    value = this.cgivars(sameNodes[j], basename + name + "[" + j + "]");
                    if (value)
                        str.push(value);
                }
            }
            else { //single value
                value = this.cgivars(nodes[i], basename + name);
                if (value)
                    str.push(value);
            }
        }

        var attr = xml.attributes;
        for (i = 0, l = attr.length; i < l; i++) {
            if (attr[i].nodeValue) {
                if (basename) 
                    str.push(basename + "[" + attr[i].nodeName + "]="
                        + escape(attr[i].nodeValue));
                else
                    str.push(attr[i].nodeName + "=" + escape(attr[i].nodeValue));
            }
        }

        if (str.length)
            return str.join("&");

        value = apf.queryValue(xml, "text()");
        if (basename && value)
            return basename + "=" + escape(value);

        return "";
    },

    "cgiobjects": function(xml, basename, isSub, includeEmpty){
        if (!basename)
            basename = "";
        
        var nodes = xml.childNodes, node;
        var output = [], tagNames = {};
        var nm = "", name, value;
        var a, i, j;
        var attr, attr_len;
        var isOnly;
        
        for (i = 0; i < nodes.length; i++) {
            node = nodes[i];
            
            if (node.nodeType == 1) {
                name = node.tagName;
                isOnly = node.parentNode.selectNodes(name).length == 1 
                    ? true 
                    : false;
                
                if (typeof tagNames[name] == "undefined") {
                    tagNames[name] = 0;
                }

                nm = basename 
                   + (isSub ? "[" : "") + name + (isSub ? "]" : "") 
                   + (isOnly ? "" : "[" + tagNames[name] + "]");
                
                attr     = node.attributes;
                attr_len = node.attributes.length;
                
                if (attr_len > 0) {
                    for (j = 0; j < attr_len; j++) {
                        if (!(a = attr[j]).nodeValue) 
                            continue;
                        
                        output.push(nm + "[_" + a.nodeName + "]=" 
                            + escape(a.nodeValue.trim()));
                    }
                }
                
                value = this.cgiobjects(node, nm, true);
                
                if (value.dataType !== 1) {
                    output.push(value);
                }
                else {
                    if (node.firstChild && node.firstChild.nodeValue.trim()) {
                        output.push(nm + (attr_len > 0 ? "[_]=" : "=") 
                            + escape(node.firstChild.nodeValue.trim()));
                    }
                    else {
                        if (attr_len == 0) {
                            if (includeEmpty) {
                                output.push(nm);
                            }
                        }
                    }
                }
                
                tagNames[name]++;
            }
        }

        if (!isSub && xml.getAttribute("id"))
            output.push("id=" + escape(xml.getAttribute("id")));

        if (output.length)
            return output.join("&");

        return output;
    }
};

/**
 * Converts xml to another format.
 *
 * @param {XMLElement} xml  the {@link term.datanode data node} to convert.
 * @param {String}     to   the format to convert the xml to.
 *   Possible values:
 *   json       converts to a json string
 *   cgivars    converts to cgi string.
 *   cgiobjects converts to cgi objects
 * @return {String} the result of the conversion.
 */
apf.convertXml = function(xml, to){
    return apf.convertMethods[to](xml);
};

/**
 * Returns the first text or cdata child of an {@link term.datanode data node}.
 *
 * @param {XMLElement} x the xml node to search.
 * @return {XMLNode} the found xml node, or null.
 */
apf.getTextNode = function(x){
    for (var i = 0, l = x.childNodes.length; i < l; ++i) {
        if (x.childNodes[i].nodeType == 3 || x.childNodes[i].nodeType == 4)
            return x.childNodes[i];
    }
    return false;
};

/**
 * @private
 */
apf.getBoundValue = function(amlNode, xmlRoot, applyChanges){
    if (!xmlRoot && !amlNode.xmlRoot)
        return "";

    var xmlNode = amlNode.$getDataNode("value", amlNode.xmlRoot);

    return xmlNode ? apf.queryValue(xmlNode) : "";
};

/**
 * @private
 */
apf.getArrayFromNodelist = function(nodelist){
    for (var nodes = [], j = 0, l = nodelist.length; j < l; ++j)
        nodes.push(nodelist[j]);
    return nodes;
};

apf.serializeChildren = function(xmlNode){
    var node,
        s     = [],
        nodes = xmlNode.childNodes,
        i     = 0,
        l     = nodes.length;
    for (; i < l; ++i) {
        s[i] = (node = nodes[i]).nodeType == 1 
            ? node.xml || node.serialize()
            : (node.nodeType == 8 ? "" : node.nodeValue);
    }
    return s.join("");
}

/**
 * Returns a string version of the {@link term.datanode data node}.
 *
 * @param {XMLElement} xmlNode the {@link term.datanode data node} to serialize.
 * @return {String} the serilized version of the {@link term.datanode data node}.
 */
apf.getXmlString = function(xmlNode){
    var xml = apf.xmldb.cleanNode(xmlNode.cloneNode(true));
    return xml.xml || xml.serialize();
};

/**
 * Creates xml nodes from an xml string recursively.
 *
 * @param {String}  strXml     the xml definition.
 * @param {Boolean} [noError]  whether an exception should be thrown by the parser
 *                             when the xml is not valid.
 * @param {Boolean} [preserveWhiteSpace]  whether whitespace that is present between
 *                                        XML elements should be preserved
 * @return {XMLNode} the created xml node.
 */
apf.getXml = function(strXml, noError, preserveWhiteSpace){
    return apf.getXmlDom(strXml, noError, preserveWhiteSpace).documentElement;
};

/**
 * Formats an xml string with good indentation. Also known as pretty printing.
 * @param {String} strXml the xml to format.
 * @return {String} the formatted string.
 */
apf.formatXml = function(strXml){
    strXml = strXml.trim();

    var lines = strXml.split("\n"),
        depth = 0,
        i     = 0,
        l     = lines.length;
    for (; i < l; ++i)
        lines[i] = lines[i].trim();
    lines = lines.join("\n").replace(/\>\n/g, ">").replace(/\>/g, ">\n")
        .replace(/\n\</g, "<").replace(/\</g, "\n<").split("\n");
    lines.removeIndex(0);//test if this is actually always fine
    lines.removeIndex(lines.length);

    for (i = 0, l = lines.length; i < l; i++)
        lines[i] = "    ".repeat((lines[i].match(/^\s*\<\//)
            ? (depth==0)?0:--depth
            : (lines[i].match(/^\s*\<[^\?][^>]+[^\/]\>/) ? depth++ : depth))) + lines[i];
    if (!strXml)
        return "";

    return lines.join("\n");
};

//@todo this function needs to be 100% proof, it's the core of the system
//for RSB: xmlNode --> Xpath statement
apf.xmlToXpath = function(xmlNode, xmlContext, useJid){
    if (!xmlNode) //@todo apf3.0
        return "";
    
    if (useJid === true && xmlNode.nodeType == 1 && xmlNode.getAttribute(apf.xmldb.xmlIdTag)) {
        return "//node()[@" + apf.xmldb.xmlIdTag + "='" 
            + xmlNode.getAttribute(apf.xmldb.xmlIdTag) + "']";
    }

    if (apf != this && this.lookup && this.select) {
        var unique, def = this.lookup[xmlNode.tagName];
        if (def) {
            //unique should not have ' in it... -- can be fixed...
            unique = xmlNode.selectSingleNode(def).nodeValue;
            return "//" + xmlNode.tagName + "[" + def + "='" + unique + "']";
        }
        
        for (var i = 0, l = this.select.length; i < l; i++) {
            if (xmlNode.selectSingleNode(this.select[i][0])) {
                unique = xmlNode.selectSingleNode(this.select[i][1]).nodeValue;
                return "//" + this.select[i][0] + "[" + this.select[i][1]
                    + "='" + unique + "']";
            }
        }
    }

    if (xmlNode == xmlContext)
        return ".";

    if (!xmlNode.parentNode && !xmlNode.ownerElement) {
        
        throw new Error(apf.formatErrorString(0, null, 
            "Converting XML to Xpath", 
            "Error xml node without parent and non matching context cannot\
             be converted to xml.", xmlNode));
        
        
        return false;
    }

    var str = [], lNode = xmlNode;
    if (lNode.nodeType == 2) {
        str.push("@" + lNode.nodeName);
        lNode = lNode.ownerElement || xmlNode.selectSingleNode("..");
    }
    
    var id;
    do {
        str.unshift((lNode.nodeType == 1 ? lNode.tagName : "text()") 
            + "[" + (useJid && (id = lNode.nodeType == 1 && lNode.getAttribute(apf.xmldb.xmlIdTag))
                ? "@" + apf.xmldb.xmlIdTag + "='" + id + "'"
                : (apf.getChildNumber(lNode, lNode.parentNode.selectNodes(lNode.tagName)) + 1))
             + "]");
        lNode = lNode.parentNode;
    } while(lNode && lNode.nodeType == 1 && lNode != xmlContext);

    return str.join("/");
};
    
//for RSB: Xpath statement --> xmlNode
apf.xpathToXml = function(xpath, xmlNode){
    if (!xmlNode) {
        
        throw new Error(apf.formatErrorString(0, null, 
            "Converting Xpath to XML", 
            "Error context xml node is empty, thus xml node cannot \
             be found for '" + xpath + "'"));
        
        
        return false;
    }
    
    return xmlNode.selectSingleNode(xpath);
};




/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/util/textdiff.js)SIZE(89290)TIME(1257329189)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/util/o3.js)SIZE(8157)TIME(1257329189)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/util/popup.js)SIZE(9457)TIME(1270838605)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * @private
 */
apf.popup = {
    cache      : {},
    focusFix   : {"INPUT":1,"TEXTAREA":1,"SELECT":1},
    
    setContent : function(cacheId, content, style, width, height){
        if (!this.popup) this.init();

        this.cache[cacheId] = {
            content : content,
            style   : style,
            width   : width,
            height  : height
        };
        content.style.position = "absolute";
        //if(content.parentNode) content.parentNode.removeChild(content);
        //if(style) apf.importCssString(style, this.popup.document);
        
        content.onmousedown  = function(e) {
            if (!e) e = event;

            
            if (apf.hasFocusBug 
              && !apf.popup.focusFix[(e.srcElement || e.target).tagName]) {
                apf.window.$focusfix();
            }
            
            
            //@todo can this cancelBubble just go?
            (e || event).cancelBubble = true;
        };
        
        return content.ownerDocument;
    },
    
    removeContent : function(cacheId){
        this.cache[cacheId] = null;
        delete this.cache[cacheId];
    },
    
    init : function(){
        //consider using iframe
        this.popup = {};
        
        apf.addEventListener("hotkey", function(e){
            if (e.keyCode == "27" || e.altKey) 
                apf.popup.forceHide();
        });
    },
    
    show : function(cacheId, options){
        options = apf.extend({
            x            : 0,
            y            : 0,
            animate      : false,
            ref          : null,
            width        : null,
            height       : null,
            callback     : null,
            draggable    : false,
            resizable    : false,
            allowTogether: false,
            autoCorrect  : true
        }, options);
        if (!this.popup)
           this.init();
        if ((!options.allowTogether || options.allowTogether != this.last) && this.last != cacheId)
            this.hide();

        var o = this.cache[cacheId];
        o.options = options;
        //if(this.last != cacheId) 
        //this.popup.document.body.innerHTML = o.content.outerHTML;

        var popup = o.content, moveUp = false;
        if (!o.content.style.zIndex)
            o.content.style.zIndex = 10000000;
        if (o.content.style.display && o.content.style.display.indexOf('none') > -1)
            o.content.style.display = "";

        if (options.ref) {
            var pos    = apf.getAbsolutePosition(options.ref, 
                            o.content.offsetParent || o.content.parentNode),//[ref.offsetLeft+2,ref.offsetTop+4];//
                top    = (options.y || 0) + pos[1],
                    //+ (apf.isWebkit ? window.pageYOffset : 0), <-- appears to be needed in NEW safari...
                p      = apf.getOverflowParent(o.content);
        
            if (options.width || o.width)
                popup.style.width = ((options.width || o.width) - 3) + "px";

            moveUp = options.autoCorrect && (top
                + (options.height || o.height || o.content.offsetHeight))
                > (p == document.documentElement
                  ? (apf.isIE ? p.offsetHeight : (window.innerHeight + window.pageYOffset))  + p.scrollTop
                  : p.offsetHeight + p.scrollTop);

            popup.style.top = (moveUp 
                ? (top - (options.height || o.height || o.content.offsetHeight) - (options.y || 0))
                : top) + "px"
            popup.style.left = ((options.x || 0) + pos[0]) + "px";
        }

        
        // set a className that specifies the direction, to help skins with
        // specific styling options.
        apf.setStyleClass(popup, moveUp ? "upward" : "downward", [moveUp ? "downward" : "upward"]);
        

        if (options.animate) {
            if (options.animate == "fade") {
                apf.tween.single(popup, {
                    type  : 'fade',
                    from  : 0,
                    to    : 1,
                    anim  : apf.tween.NORMAL,
                    steps : apf.isIE ? 5 : 10,
                    onfinish : function(){
                        if (apf.isIE)
                            popup.style.filter = "";
                    }
                });
            }
            else {
                var iVal, steps = apf.isIE8 ? 5 : 7, i = 0;
                iVal = setInterval(function(){
                    var value = ++i * ((options.height || o.height) / steps);

                    popup.style.height = value + "px";
                    if (moveUp)
                        popup.style.top = (top - value - (options.y || 0)) + "px";
                    else
                        popup.scrollTop = -1 * (i - steps) * ((options.height || o.height) / steps);
                    popup.style.display = "block";

                    if (i >= steps) {
                        clearInterval(iVal)
                        
                        if (options.callback)
                            options.callback(popup);
                    }
                }, 10);
            }
        }
        else {
            if (options.height || o.height)
                popup.style.height = (options.height || o.height) + "px";
            popup.style.top = (top) + "px";
            popup.style.display = "block";
            
            if (options.callback)
               options.callback(popup);
        }

        $setTimeout(function(){
            apf.popup.last = cacheId;
        });

        if (options.draggable) {
            options.id = cacheId;
            this.makeDraggable(options);
        }
    },
    
    hide : function(){
        if (this.isDragging) return;

        var o = this.cache[this.last];
        if (o) {
            if (o.content)
                o.content.style.display = "none";

            if (o.options && o.options.onclose) {
                o.options.onclose(apf.extend(o.options, {htmlNode: o.content}));
                o.options.onclose = false;
            }
        }
    },
    
    isShowing : function(cacheId){
        return this.last && this.last == cacheId 
            && this.cache[this.last]
            && this.cache[this.last].content.style.display != "none";
    },

    isDragging   : false,

    makeDraggable: function(options) {
        if (!apf.Interactive || this.cache[options.id].draggable) 
            return;

        var oHtml = this.cache[options.id].content;
        this.cache[options.id].draggable = true;
        var o = {
            $propHandlers : {},
            minwidth      : 10,
            minheight     : 10,
            maxwidth      : 10000,
            maxheight     : 10000,
            dragOutline   : false,
            resizeOutline : false,
            draggable     : true,
            resizable     : options.resizable,
            $ext          : oHtml,
            oDrag         : oHtml.firstChild
        };

        oHtml.onmousedown =
        oHtml.firstChild.onmousedown = function(e){
            if (!e) e = event;
            
            
            if (apf.hasFocusBug
              && !apf.popup.focusFix[(e.srcElement || e.target).tagName]) {
                apf.window.$focusfix();
            }
            
            
            (e || event).cancelBubble = true;
        }

        apf.implement.call(o, apf.Interactive);

        o.$propHandlers["draggable"].call(o, true);
        o.$propHandlers["resizable"].call(o, true);
    },
    
    forceHide : function(){
        if (this.last 
            
            && !apf.plane.current
            
            && this.isShowing(this.last)) {
            var o = apf.lookup(this.last);
            if (!o)
                this.last = null;
                
            else if (o.dispatchEvent("popuphide") !== false)
                this.hide();
        }
    },

    destroy : function(){
        for (var cacheId in this.cache) {
            if (this.cache[cacheId]) {
                this.cache[cacheId].content.onmousedown = null;
                apf.destroyHtmlNode(this.cache[cacheId].content);
                this.cache[cacheId].content = null;
                this.cache[cacheId] = null;
            }
        }
        
        if (!this.popup) return;
        //this.popup.document.body.c = null;
        //this.popup.document.body.onmouseover = null;
    }
}



/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/util/nameserver.js)SIZE(5428)TIME(1257329189)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * @private
 */
apf.nameserver = {
    lookup : {},
    
    add : function(type, item){
        if (!this.lookup[type])
            this.lookup[type] = [];
        
        
        if(this.onchange)
            this.onchange(type, item);
        
        
        return this.lookup[type].push(item) - 1;
    },
    
    register : function(type, id, item){
        if (!this.lookup[type])
            this.lookup[type] = {};

        
        if (this.onchange)
            this.onchange(type, item, id);
        

        return (this.lookup[type][id] = item);
    },
    
    remove : function(type, item){
        var list = this.lookup[type];
        if (list) {
            for (var prop in list) {
                if (list[prop] == item) {
                    delete list[prop];
                }
            }
        }
    },
    
    get : function(type, id){
        return this.lookup[type] ? this.lookup[type][id] : null;
    },
    
    getAll : function(type){
        var name, arr = [], l = this.lookup[type];
        if (!l) return arr;
        
        if (l.dataType == apf.ARRAY) {
            for (var i = 0; i < l.length; i++) {
                arr.push(l[i]);
            }
        }
        else {
            for (name in l) {
                
                
                
                arr.push(l[name]);
            }
        }
        
        return arr;
    }, 
    
    getAllNames : function(type){
        var name, arr = [];
        for (name in this.lookup[type]){
            if (parseInt(name) == name) continue;
            arr.push(name);
        }
        return arr;
    }
};






/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/history.js)SIZE(10274)TIME(1270194491)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/config.js)SIZE(8527)TIME(1270888661)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



apf.config = new apf.Class().$init();
apf.extend(apf.config, {
    //Defaults
    disableRightClick  : false,
    allowSelect        : false,
    allowBlur          : true,
    autoDisableActions : true,
    autoDisable        : false, /** @todo fix this to only autodisable when createmodel is not true */
    disableF5          : true,
    autoHideLoading    : true,
    disableSpace       : true,
    defaultPage        : "home",
    disableBackspace   : true,
    undokeys           : false,
    outline            : false,
    dragOutline        : false,
    resizeOutline      : false,
    autoDisableNavKeys : true,
    disableTabbing     : false,
    resourcePath       : null,
    initdelay          : true,
    liveText           : false,
    
    
    iphoneFullscreen   : true,
    iphoneStatusbar    : 'default', //other options: black-translucent, black
    iphoneIcon         : null,
    iphoneIconIsGlossy : false,
    iphoneFixedViewport: true,
    
    
    skinset            : "default",
    name               : self.window && window.location.href.replace(/[^0-9A-Za-z_]/g, "_"),

    tags               : {},
    defaults           : {},
    baseurl            : "",
    
    "model"            : "@default",
    "empty-message"    : "No items",
    "loading-message"  : "Loading...",
    "offline-message"  : "You are currently offline.",
    
    setDefaults : function(){
        
    },

    getDefault : function(type, prop){
        var d = this.defaults[type];
        if (!d)
            return;

        for (var i = d.length - 1; i >= 0; i--) {
            if (d[i][0] == prop)
                return d[i][1];
        }
    },

    setProperty : function(name, value){
        //this[name] = value;
        //@todo I dont want to go through all the code again, maybe later
        this[name.replace(/-(\w)/g, function(m, m1){
            return m1.toUpperCase()
        })] = this[name] = value;
        
        (this.$propHandlers && this.$propHandlers[name]
          || apf.GuiElement.propHandlers[name] || apf.K).call(this, value);
    },
    
    $inheritProperties : {},
    
    $propHandlers : {
        "baseurl" : function(value){
            this.baseurl = apf.parseExpression(value);
        },
        "language" : function(value){
            
        },
        //Activate Layout Rules [Maybe change idef to something more specific]
        
        "layout" : function(value){
            apf.queue.add("layout", function(){
                apf.setModel(apf.config.layout, apf.layout);
                //apf.layout.$loadFrom(value); //@todo apf3.0 test
            });
        },
        
        "resource-path" : function(value){
            this.resourcePath = apf.parseExpression(value || "")
              .replace(/resources\/?|\/$/g, '');
        },
        
        
        "skinset" : function(value) {
            if (this.$amlLoaded)
                apf.skins.changeSkinset(value);
        },
        
        
        "outline" : function(value) {
            this.dragOutline    =
            this.resizeOutline  =
            this.outline        = apf.isTrue(value);
        },
        "drag-outline" : function(value){
            this.dragOutline    = value
              ? apf.isTrue(value)
              : false;
        },
        "resize-outline" : function(value){
            this.resizeOutline  = value
              ? !apf.isFalse(value)
              : false;
        },
        
        
        
        "storage" : function(value) {
            if (value)
                apf.storage.init(value);
        },
        
        
        
        "disable-f5" : function(value){
            if (apf.isDeskrun && value)
                shell.norefresh = true;
        },
        
        
        "debug" : function(value) {
            
            if (value) {
                apf.$debugwin.activate();
                apf.addEventListener("load", function(){
                    //$setTimeout("apf.$debugwin.activate();", 200) //@todo has a bug in gecko, chrome
                    apf.removeEventListener("load", arguments.callee);
                });
            }
            
            apf.debug = value;
        }
    }
});






/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/offline.js)SIZE(20151)TIME(1257329189)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


apf.offline = {
    onLine : true
}



/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/offline/application.js)SIZE(11733)TIME(1257329186)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/offline/gears.js)SIZE(4720)TIME(1257329186)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/offline/transactions.js)SIZE(9618)TIME(1257329186)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/offline/detector.js)SIZE(4827)TIME(1259708671)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/offline/models.js)SIZE(5419)TIME(1265032028)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/offline/queue.js)SIZE(7008)TIME(1257329186)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/offline/state.js)SIZE(8067)TIME(1265032028)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */






/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/uirecorder.js)SIZE(23421)TIME(1271196962)*/




/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/printer.js)SIZE(4937)TIME(1266969664)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/tween.js)SIZE(34292)TIME(1270838605)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * The animation library that is used for the animations inside elements
 * @default_private
 */
apf.tween = (function(apf) {

var modules = {
        //Animation Modules
    left: function(oHtml, value){
        oHtml.style.left = value + PX;
    },
    right: function(oHtml, value){
        oHtml.style.left  = "";
        oHtml.style.right = value + PX;
    },
    top: function(oHtml, value){
        oHtml.style.top = value + PX;
    },
    bottom: function(oHtml, value){
        oHtml.style.top    = "";
        oHtml.style.bottom = value + PX;
    },
    width: function(oHtml, value, center){
        oHtml.style.width = value + PX;
    },
    height: function(oHtml, value, center){
        oHtml.style.height = value + PX;
    },
    scrollTop: function(oHtml, value, center){
        oHtml.scrollTop = value;
    },
    scrollLeft: function(oHtml, value, center){
        oHtml.scrollLeft = value;
    },
    "height-rsz": function(oHtml, value, center){
        oHtml.style.height = value + PX;
        if (apf.hasSingleResizeEvent)
            window.onresize();
    },
    mwidth: function(oHtml, value, info) {
        var diff = apf.getDiff(oHtml);
        oHtml.style.width = value + PX;
        oHtml.style.marginLeft = -1 * (value / 2 + (parseInt(apf.getStyle(oHtml,
            "borderLeftWidth")) || diff[0]/2) + (info.margin || 0)) + PX;
    },
    mheight: function(oHtml, value, info) {
        var diff = apf.getDiff(oHtml);
        oHtml.style.height = value + PX;
        oHtml.style.marginTop = (-1 * value / 2 - (parseInt(apf.getStyle(oHtml,
            "borderTopWidth")) || diff[1]/2) + (info.margin || 0)) + PX;
    },
    scrollwidth: function(oHtml, value){
        oHtml.style.width = value + PX;
        oHtml.scrollLeft  = oHtml.scrollWidth;
    },
    scrollheight_old: function(oHtml, value){
        try {
            oHtml.style.height = value + PX;
            oHtml.scrollTop    = oHtml.scrollHeight;
        }
        catch (e) {
            alert(value)
        }
    },
    scrollheight: function(oHtml, value, info){
        var diff = apf.getHeightDiff(oHtml),
            oInt = info.$int || oHtml;

        oHtml.style.height = Math.max((value + (info.diff || 0)), 0) + PX;
        oInt.scrollTop     = oInt.scrollHeight - oInt.offsetHeight - diff + (info.diff || 0);
    },
    scrolltop: function(oHtml, value){
        oHtml.style.height = value + PX;
        oHtml.style.top    = (-1 * value - 2) + PX;
        oHtml.scrollTop    = 0;//oHtml.scrollHeight - oHtml.offsetHeight;
    },
    clipright: function(oHtml, value, center){
        oHtml.style.clip       = "rect(auto, auto, auto, " + value + "px)";
        oHtml.style.marginLeft = (-1 * value) + PX;
    },
    fade: function(oHtml, value){
        if (!apf.supportOpacity && apf.hasStyleFilters)
            oHtml.style.filter  = "alpha(opacity=" + parseInt(value * 100) + ")";
        else
            oHtml.style.opacity = value;
    },
    bgcolor: function(oHtml, value){
        oHtml.style.backgroundColor = value;
    },
    textcolor: function(oHtml, value){
        oHtml.style.color = value;
    },
    htmlcss : function(oHtml, value, obj){
        if (apf.hasStyleFilters && obj.type == "filter")
            oHtml.style.filter = "progid:DXImageTransform.Microsoft.Alpha(opacity=" + value + ")";
        else
            oHtml.style[obj.type] = value + (obj.needsPx ? PX : "");
    },
    transformscale: function(oHtml, value, obj) {
        oHtml.style[obj.type] = SCALEA + parseFloat(value) + SCALEB;
    },
    transformrotate: function(oHtml, value, obj) {
        oHtml.style[obj.type] = ROTATEA + parseFloat(value) + ROTATEB;
    },
    transformvalscale: function(value) {
        return SCALEA + parseFloat(value) + SCALEB;
    },
    transformvalrotate: function(value) {
        return ROTATEA + parseFloat(value) + ROTATEB;
    }
};

var ID        = "id",
    PX        = "px",
    NUM       = "number",
    TRANSVAL  = "transformval",
    TRANSFORM = "transform",
    SCALE     = "scale",
    SCALEA    = "scale(",
    ROTATEA   = "rotate(",
    SCALEB    = ")",
    ROTATEB   = "deg)",
    CSSTIMING = ["linear", "ease-in", "ease-out", "ease", "ease-in-out", "cubic-bezier"],
    CSSPROPS  = {
        "left"        : "left",
        "right"       : "right",
        "top"         : "top",
        "bottom"      : "bottom",
        "width"       : "width",
        "height"      : "height",
        "scrollTop"   : false,
        "scrollLeft"  : false,
        "mwidth"      : false,
        "mheight"     : false,
        "scrollwidth" : false,
        "scrollheight": false,
        "fade"        : "opacity",
        "opacity"     : "opacity",
        "bgcolor"     : "background-color",
        "textcolor"   : "color",
        "transform"   : "transform"
    },
    __pow   = Math.pow,
    __round = Math.round,
    RUNNING  = 0,
    STOPPING = 1,
    STOPPED  = 2,

    queue = {},

    current= null,

    setQueue = function(oHtml, stepFunction){
        if (!oHtml.getAttribute(ID))
            apf.setUniqueHtmlId(oHtml);

        if (!queue[oHtml.getAttribute(ID)])
            queue[oHtml.getAttribute(ID)] = [];

        queue[oHtml.getAttribute(ID)].push(stepFunction);

        if (queue[oHtml.getAttribute(ID)].length == 1)
            stepFunction(0);
    },

    nextQueue = function(oHtml){
        var q = queue[oHtml.getAttribute(ID)];
        if (!q) return;

        q.shift(); //Remove current step function

        if (q.length)
            q[0](0);
    },

    clearQueue = function(oHtml, bStop){
        var q = queue[oHtml.getAttribute(ID)];
        if (!q) return;

        if (bStop && current && current.control)
            current.control.stop = true;
        q.length = 0;
    },

    /**
     * Calculates all the steps of an animation between a
     * begin and end value based on 3 tween strategies
     */
    calcSteps = function(func, fromValue, toValue, nrOfSteps){
        var i     = 0,
            l     = nrOfSteps - 1,
            steps = [fromValue];

        // backward compatibility...
        if (typeof func == NUM) {
            if (!func)
                func = apf.tween.linear;
            else if (func == 1)
                func = apf.tween.easeInCubic;
            else if (func == 2)
                func = apf.tween.easeOutCubic;
        }

        /*
        func should have the following signature:
        func(t, x_min, dx)
        where 0 <= t <= 1, dx = x_max - x_min

        easeInCubic: function(t, x_min, dx) {
            return dx * pow(t, 3) + x_min;
        }
        */
        for (i = 0; i < l; ++i)
            steps.push(func(i / nrOfSteps, fromValue, toValue - fromValue));
        steps.push(toValue);
        return steps;
    },

    /**
     * Calculates all the steps of an animation between a
     * begin and end value for colors
     */
    calcColorSteps = function(animtype, fromValue, toValue, nrOfSteps){
        var d2, d1,
            c   = apf.color.colors,
            a   = parseInt((c[fromValue] || fromValue).slice(1), 16),
            b   = parseInt((c[toValue] || toValue).slice(1), 16),
            i   = 0,
            out = [];

        for (; i < nrOfSteps; i++){
            d1 = i / (nrOfSteps - 1), d2 = 1 - d1;
            out[out.length] = "#" + ("000000" +
                ((__round((a & 0xff) * d2 + (b & 0xff) * d1) & 0xff) |
                (__round((a & 0xff00) * d2 + (b & 0xff00) * d1) & 0xff00) |
                (__round((a & 0xff0000) * d2 + (b & 0xff0000) * d1) & 0xff0000)).toString(16)).slice(-6);
        }

        return out;
    },

    /**
     * Tweens a single property of a single element or html element from a
     * start to an end value.
     * Example:
     * <code>
     *  apf.tween.single(myDiv, {
     *      type : "left",
     *      from : 10,
     *      to   : 100,
     *      anim : apf.tween.EASEIN
     *  });
     * </code>
     * Example:
     * Multiple animations can be run after eachother
     * by calling this function multiple times.
     * <code>
     *  apf.tween.single(myDiv, options).single(myDiv2, options2);
     * </code>
     * @param {Element}  oHtml the object to animate.
     * @param {Object}   info  the animation settings.
     *   Properties:
     *   {String}   type        the property to be animated. These are predefined
     *                          property handlers and can be added by adding a
     *                          method to apf.tween with the name of the property
     *                          modifier. Default there are several handlers available.
     *      Possible values:
     *      left            Sets the left position
     *      right           Sets the right position
     *      top             Sets the top position
     *      bottom          Sets the bottom position
     *      width           Sets the horizontal size
     *      height          Sets the vertical size
     *      scrollTop       Sets the scoll position
     *      mwidth          Sets the width and the margin-left to width/2
     *      mheight         Sets the height ant the margin-top to height/2
     *      scrollwidth     Sets the width an sets the scroll to the maximum size
     *      scrollheight    Sets the height an sets the scroll to the maximum size
     *      scrolltop       Sets the height and the top as the negative height value
     *      fade            Sets the opacity property
     *      bgcolor         Sets the background color
     *      textcolor       Sets the text color
     *   {Number, String} from  the start value of the animation
     *   {Number, String} to    the end value of the animation
     *   {Number}   [steps]     the number of steps to divide the tween in
     *   {Number}   [interval]  the time between each step
     *   {Number}   [anim]      the distribution of change between the step over the entire animation
     *   {Boolean}  [color]     whether the specified values are colors
     *   {Mixed}    [userdata]  any data you would like to have available in your callback methods
     *   {Function} [onfinish]  a function that is called at the end of the animation
     *   {Function} [oneach]    a function that is called at each step of the animation
     *   {Object}   [control]   an object that can stop the animation at any point
     *     Properties:
     *     {Boolean} stop       whether the animation should stop.
     */
    single = function(oHtml, info){
        info = apf.extend({steps: 3, interval: 20, anim: apf.tween.linear, control: {}}, info);

        if (oHtml.nodeFunc > 100) {
            info.$int = oHtml.$int;
            oHtml     = oHtml.$ext;
        }
        try{ //@TODO hack where currentStyle is still undefined
            if ("fixed|absolute|relative".indexOf(apf.getStyle(oHtml, "position")) == -1)
                oHtml.style.position = "relative";
        }catch(e){}
        
        var useCSSAnim  = (apf.supportCSSAnim && apf.supportCSSTransition && CSSPROPS[info.type]),
            isTransform = (info.type == TRANSFORM);

        info.method = useCSSAnim ? info.type : isTransform
            ? modules[TRANSFORM + (info.subType || SCALE)]
            : modules[info.type] || modules.htmlcss;

        var useCSSAnim  = (apf.supportCSSAnim && apf.supportCSSTransition && CSSPROPS[info.type]),
            isTransform = (info.type == TRANSFORM);

        info.method = useCSSAnim ? info.type : isTransform
            ? modules[TRANSFORM + (info.subType || SCALE)]
            : modules[info.type] || modules.htmlcss;

        
        if (!info.method)
            throw new Error(apf.formatErrorString(0, this,
                "Single Value Tween",
                "Could not find method for tweening operation '"
                + info.type + "'"));
        

        if (useCSSAnim) {
            var type = CSSPROPS[info.type];
            if (type === false)
                return apf.tween;
            info.type = type || info.type;
            if (isTransform) {
                if (!info.subType)
                    info.subType = SCALE;
                info.type = apf.supportCSSAnim;
            }

            var transform = (isTransform)
                ? modules[TRANSVAL + (info.subType || SCALE)]
                : null;

            oHtml.style[info.type] = isTransform
                ? transform(info.from)
                : info.from + (needsPix[info.type] ? PX : "");
            $setTimeout(function() {
                oHtml.style[info.type] = isTransform
                    ? transform(info.to)
                    : info.to + (needsPix[info.type] ? PX : "");
                oHtml.offsetTop; //force style recalc
                oHtml.style[apf.cssPrefix + "Transition"] = info.type + " " + ((info.steps
                    * info.interval) / 1000) + "s "
                    + CSSTIMING[info.anim || 0];
                var f = function() {
                    if (info.onfinish)
                        info.onfinish(oHtml, info.userdata);
                    oHtml.style[apf.cssPrefix + "Transition"] = "";
                    oHtml.removeEventListener(apf.cssAnimEvent, f);
                };
                oHtml.addEventListener(apf.cssAnimEvent, f);
            });
            return apf.tween;
        }

        if (info.control)
            info.control.stop = function(){
                info.control.state = STOPPING;
                clearQueue(oHtml);
                if (info.onstop)
                    info.onstop(oHtml, info.userdata);
            }

        var steps = info.color
                ? calcColorSteps(info.anim, info.from, info.to, info.steps)
                : calcSteps(info.anim, parseFloat(info.from), parseFloat(info.to), info.steps),
            stepFunction = function(step){
                if (info.control && info.control.state) {
                    info.control.state = STOPPED;
                    return;
                }
                
                current = info;

                if (info.onbeforeeach
                  && info.onbeforeeach(oHtml, info.userdata) === false)
                    return;

                try {
                   info.method(oHtml, steps[step], info);
                }
                catch (e) {}

                if (info.oneach)
                    info.oneach(oHtml, info.userdata);

                if (step < info.steps)
                    return $setTimeout(function(){stepFunction(step + 1)}, info.interval);

                current = null;
                if (info.control)
                    info.control.state = STOPPED;
                if (info.onfinish)
                    info.onfinish(oHtml, info.userdata);

                nextQueue(oHtml);
            };

        setQueue(oHtml, stepFunction);

        return apf.tween;
    },

    /**
     * Tweens multiple properties of a single element or html element from a
     * start to an end value.
     * Example:
     * Animating both the left and width at the same time.
     * <code>
     *  apf.tween.multi(myDiv, {
     *      anim   : apf.tween.EASEIN
     *      tweens : [{
     *          type : "left",
     *          from : 10,
     *          to   : 100,
     *      },
     *      {
     *          type : "width",
     *          from : 100,
     *          to   : 400,
     *      }]
     *  });
     * </code>
     * Example:
     * Multiple animations can be run after eachother
     * by calling this function multiple times.
     * <code>
     *  apf.tween.multi(myDiv, options).multi(myDiv2, options2);
     * </code>
     * @param {Element}  oHtml the object to animate.
     * @param {Object} info the settings of the animation.
     *   Properties:
     *   {Number}   [steps]     the number of steps to divide the tween in
     *   {Number}   [interval]  the time between each step
     *   {Number}   [anim]      the distribution of change between the step over
     *                          the entire animation
     *   {Function} [onfinish]  a function that is called at the end of the animation
     *   {Function} [oneach]    a function that is called at each step of the animation
     *   {HTMLElement} [oHtml]  another html element to animate.
     *   {Object}   [control]   an object that can stop the animation at any point
     *     Properties:
     *     {Boolean} stop       whether the animation should stop.
     *   {Array}    [tweens]    a collection of simple objects specifying the single
     *                          value animations that are to be executed simultaneously.
     *                          (for the properties of these single tweens see the
     *                          single tween method).
     */
    multi = function(oHtml, info){
        info = apf.extend({steps: 3, interval: 20, anim: apf.tween.linear, control: {}}, info);

        if (oHtml.nodeFunc > 100) {
            info.$int = oHtml.$int;
            oHtml = oHtml.$ext;
        }

        var animCSS, isTransform,
            useCSSAnim  = apf.supportCSSAnim && apf.supportCSSTransition,
            hasCSSAnims = false,
            cssDuration = ((info.steps * info.interval) / 1000),
            cssAnim     = CSSTIMING[info.anim || 0],
            steps       = [],
            stepsTo     = [],
            i           = 0,
            l           = info.tweens.length;

        for (; i < l; i++) {
            var data = info.tweens[i];

            if (data.oHtml && data.oHtml.nodeFunc > 100) {
                data.$int  = data.oHtml.$int;
                data.oHtml = data.oHtml.$ext;
            }

            animCSS     = (useCSSAnim && CSSPROPS[data.type]);
            isTransform = (data.type == TRANSFORM);
            if (isTransform) {
                if (!data.subType)
                    data.subType = SCALE;
                data.type = apf.supportCSSAnim;
            }

            data.method = animCSS
                ? data.type
                : isTransform
                    ? modules[TRANSFORM + (data.subType)]
                    : modules[data.type] || modules.htmlcss;


            
            if (!data.method)
                throw new Error(apf.formatErrorString(0, this,
                    "Multi Value Tween",
                    "Could not find method for tweening operation '"
                    + data.type + "'"));
            

            if (animCSS) {
                var type = isTransform ? data.type : CSSPROPS[data.type];
                data.type = type || data.type;
                var transform = modules[TRANSVAL + (data.subType)]

                oHtml.style[data.type] = isTransform
                    ? transform(data.from)
                    : data.from + (needsPix[data.type] ? PX : "");
                stepsTo.push([data.type, isTransform
                    ? transform(data.to)
                    : data.to + (needsPix[data.type] ? PX : "")]);
                steps.push(data.type + " " + cssDuration + "s " + cssAnim + " 0");

                hasCSSAnims = true;
            }
            else {
                steps.push(data.color
                    ? calcColorSteps(info.anim, data.from, data.to, info.steps)
                    : calcSteps(info.anim, parseFloat(data.from), parseFloat(data.to), info.steps));
            }
        }

        if (hasCSSAnims) {
            oHtml.style[apf.cssPrefix + "Transition"] = steps.join(",");
            oHtml.offsetTop; //force style recalc
            var count = 0,
                func  = function() {
                    count++;
                    if (count == stepsTo.length) {
                        if (info.onfinish)
                            info.onfinish(oHtml, info.userdata);
                        oHtml.style[apf.cssPrefix + "Transition"] = "";
                        oHtml.removeEventListener(apf.cssAnimEvent, func);
                    }
                };
            oHtml.addEventListener(apf.cssAnimEvent, func, false);
            for (var k = 0, j = stepsTo.length; k < j; k++)
                oHtml.style[stepsTo[k][0]] = stepsTo[k][1];
            return apf.tween;
        }
        
        if (info.control)
            info.control.stop = function(){
                info.control.state = STOPPING;
                clearQueue(oHtml);
                if (info.onstop)
                    info.onstop(oHtml, info.userdata);
            }

        var tweens       = info.tweens,
            stepFunction = function(step){
                if (info.control && info.control.state) {
                    info.control.state = STOPPED;
                    return;
                }
                
                current = info;

                try {
                    for (var i = 0; i < steps.length; i++) {
                        tweens[i].method(tweens[i].oHtml || oHtml,
                          steps[i][step], tweens[i]);
                    }
                } catch (e) {}

                if (info.oneach)
                    info.oneach(oHtml, info.userdata);

                if (step < info.steps)
                    return $setTimeout(function(){stepFunction(step + 1)}, info.interval);

                current = null;
                if (info.control)
                    info.control.state = STOPPED;
                if (info.onfinish)
                    info.onfinish(oHtml, info.userdata);

                nextQueue(oHtml);
            };

        setQueue(oHtml, stepFunction);

        return apf.tween;
    },

    /**
     * Tweens an element or html element from it's current state to a css class.
     * Example:
     * Multiple animations can be run after eachother by calling this function
     * multiple times.
     * <code>
     *  apf.tween.css(myDiv, 'class1').multi(myDiv2, 'class2');
     * </code>
     * @param {Element}  oHtml the object to animate.
     * @param {String} className the classname that defines the css properties to be set or removed.
     * @param {Object} info the settings of the animation.
     *   Properties:
     *   {Number}   [steps]     the number of steps to divide the tween in
     *   {Number}   [interval]  the time between each step
     *   {Number}   [anim]      the distribution of change between the step over the entire animation
     *   {Function} [onfinish]  a function that is called at the end of the animation
     *   {Function} [oneach]    a function that is called at each step of the animation
     *   {Object}   [control]   an object that can stop the animation at any point
     *     Properties:
     *     {Boolean} stop       whether the animation should stop.
     * @param {Boolean} remove whether the class is set or removed from the element or html element
     */
    css = function(oHtml, className, info, remove){
        (info = info || {}).tweens = [];

        if (oHtml.nodeFunc > 100)
            oHtml = oHtml.$ext;

        if (remove)
            apf.setStyleClass(oHtml, "", [className]);

        var resetAnim = function(remove, callback){
            if (remove)
                apf.setStyleClass(oHtml, "", [className]);
            else
                apf.setStyleClass(oHtml, className);

            //Reset CSS values
            for (var i = 0; i < info.tweens.length; i++){
                if (info.tweens[i].type == "filter")
                    continue;

                oHtml.style[info.tweens[i].type] = "";
            }

            if (callback)
                callback.apply(this, arguments);
        }

        var onfinish  = info.onfinish,
            onstop    = info.onstop;
        info.onfinish = function(){resetAnim(remove, onfinish);}
        info.onstop   = function(){resetAnim(!remove, onstop);}

        var result, newvalue, curvalue, j, isColor, style, rules, i,
            tweens = {};
        for (i = 0; i < document.styleSheets.length; i++) {
            rules = document.styleSheets[i][apf.styleSheetRules];
            for (j = rules.length - 1; j >= 0; j--) {
                var rule = rules[j];

                if (!rule.style || !rule.selectorText.match("\." + className + "$"))
                    continue;

                for (style in rule.style) {
                    if (!rule.style[style] || cssProps.indexOf("|" + style + "|") == -1)
                        continue;

                    if (style == "filter") {
                        if (!rule.style[style].match(/opacity\=([\d\.]+)/))
                            continue;
                        newvalue = RegExp.$1;

                        result   = (apf.getStyleRecur(oHtml, style) || "")
                            .match(/opacity\=([\d\.]+)/);
                        curvalue = result ? RegExp.$1 : 100;
                        isColor  = false;

                        if (newvalue == curvalue) {
                            if (remove) curvalue = 100;
                            else newvalue = 100;
                        }
                    }
                    else {
                        newvalue = remove && oHtml.style[style] || rule.style[style];
                        if (remove) oHtml.style[style] = "";
                        curvalue = apf.getStyleRecur(oHtml, style);
                        isColor = style.match(/color/i) ? true : false;
                    }

                    tweens[style] = {
                        type    : style,
                        from    : (isColor ? String : parseFloat)(remove
                                    ? newvalue
                                    : curvalue),
                        to      : (isColor ? String : parseFloat)(remove
                                    ? curvalue
                                    : newvalue),
                        color   : isColor,
                        needsPx : needsPix[style.toLowerCase()] || false
                    };
                }
            }
        }

        for (var prop in tweens)
            info.tweens.push(tweens[prop]);

        if (remove)
            apf.setStyleClass(oHtml, className);

        return multi(oHtml, info);
    },

    cssRemove = function(oHtml, className, info){
        css(oHtml, className, info, true);
    },

    needsPix = {
        "left"       : true,
        "top"        : true,
        "bottom"     : true,
        "right"      : true,
        "width"      : true,
        "height"     : true,
        "fontSize"   : true,
        "lineHeight" : true,
        "textIndent" : true
    },

    cssProps = "|backgroundColor|backgroundPosition|color|width|filter"
             + "|height|left|top|bottom|right|fontSize"
             + "|letterSpacing|lineHeight|textIndent|opacity"
             + "|paddingLeft|paddingTop|paddingRight|paddingBottom"
             + "|borderLeftWidth|borderTopWidth|borderRightWidth|borderBottomWidth"
             + "|borderLeftColor|borderTopColor|borderRightColor|borderBottomColor"
             + "|marginLeft|marginTop|marginRight|marginBottom"
             + "|transform|", // transforms are special and get special treatment
    cssTransforms = "|scale|rotate|";

return {
    single: single,
    multi: multi,
    css: css,
    cssRemove: cssRemove,
    clearQueue: clearQueue,
    addModule: function(name, func, force) {
        if (typeof name != "string" || typeof func != "function" || (modules[name] && !force))
            return this;
        modules[name] = func;
        return this;
    },
    /** Linear tweening method */
    NORMAL: 0,
    /** Ease-in tweening method */
    EASEIN: 1,
    /** Ease-out tweening method */
    EASEOUT: 2,

    linear: function(t, x_min, dx) {
        return dx * t + x_min;
    },
    easeInQuad: function(t, x_min, dx) {
        return dx * __pow(t, 2) + x_min;
    },
    easeOutQuad: function(t, x_min, dx) {
        return -dx * t * (t - 2) + x_min;
    },
    easeInOutQuad: function(t, x_min, dx) {
        if ((t /= .5) < 1)
            return dx / 2 * t * t + x_min;
        return -dx / 2 * ((--t) * (t - 2) - 1) + x_min;
    },
    easeInCubic: function(t, x_min, dx) {
        return dx * Math.pow(t, 3) + x_min;
    },
    easeOutCubic: function(t, x_min, dx) {
        return dx * (__pow(t - 1, 3) + 1) + x_min;
    },
    easeInOutCubic: function(t, x_min, dx) {
        if ((t /= .5) < 1)
            return dx / 2 * __(t, 3) + x_min;
        return dx / 2 * (__(t - 2, 3) + 2) + x_min;
    },
    easeInQuart: function(t, x_min, dx) {
        return dx * __pow(t, 4) + x_min;
    },
    easeOutQuart: function(t, x_min, dx) {
        return -dx * (__pow(t - 1, 4) - 1) + x_min;
    },
    easeInOutQuart: function(t, x_min, dx) {
        if ((t /= .5) < 1)
            return dx / 2 * __pow(t, 4) + x_min;
        return -dx / 2 * (__pow(t - 2, 4) - 2) + x_min;
    },
    easeInQuint: function(t, x_min, dx) {
        return dx * __pow(t, 5) + x_min;
    },
    easeOutQuint: function(t, x_min, dx) {
        return dx * (__pow(t - 1, 5) + 1) + x_min;
    },
    easeInOutQuint: function(t, x_min, dx) {
        if ((t /= .5) < 1)
            return dx / 2 * __pow(t, 5) + x_min;
        return dx / 2 * (__pow(t - 2, 5) + 2) + x_min;
    },
    easeInSine: function(t, x_min, dx) {
        return -dx * Math.cos(t * (Math.PI / 2)) + dx + x_min;
    },
    easeOutSine: function(t, x_min, dx) {
        return dx * Math.sin(t * (Math.PI / 2)) + x_min;
    },
    easeInOutSine: function(t, x_min, dx) {
        return -dx / 2 * (Math.cos(Math.PI * t) - 1) + x_min;
    },
    easeInExpo: function(t, x_min, dx) {
        return (t == 0) ? x_min : dx * __pow(2, 10 * (t - 1)) + x_min;
    },
    easeOutExpo: function(t, x_min, dx) {
        return (t == 1) ? x_min + dx : dx * (-__pow(2, -10 * t) + 1) + x_min;
    },
    easeInOutExpo: function(t, x_min, dx) {
        if (t == 0)
            return x_min;
        if (t == 1)
            return x_min + dx;
        if ((t /= .5) < 1)
            return dx / 2 * __pow(2, 10 * (t - 1)) + x_min;
        return dx / 2 * (-__pow(2, -10 * --t) + 2) + x_min;
    },
    easeInCirc: function(t, x_min, dx) {
        return -dx * (Math.sqrt(1 - t * t) - 1) + x_min;
    },
    easeOutCirc: function(t, x_min, dx) {
        return dx * Math.sqrt(1 - (t -= 1) * t) + x_min;
    },
    easeInOutCirc: function(t, x_min, dx) {
        if ((t /= .5) < 1)
            return -dx / 2 * (Math.sqrt(1 - t * t) - 1) + x_min;
        return dx / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + x_min;
    },
    easeInElastic: function(t, x_min, dx) {
        var s = 1.70158,
            p = .3,
            a = dx;
        if (t == 0)
            return x_min;
        if (t == 1)
            return x_min + dx;
        if (!a || a < Math.abs(dx)) {
            a = dx;
            s = p / 4;
        }
        else
            s = p / (2 * Math.PI) * Math.asin (dx / a);
        return -(a * __pow(2, 10 * (t -= 1)) * Math.sin((t * 1 - s) * (2 * Math.PI) / p)) + x_min;
    },
    easeOutElastic: function(t, x_min, dx) {
        var s = 1.70158,
            p = .3,
            a = dx;
        if (t == 0)
            return x_min;
        if (t == 1)
            return x_min + dx;
        if (a < Math.abs(dx)) {
            a = dx;
            s = p / 4;
        }
        else {
            s = p / (2 * Math.PI) * Math.asin(dx / a);
        }
        return a * __pow(2, -10 * t) * Math.sin((t - s) * (2 * Math.PI) / p) + dx + x_min;
    },
    easeInOutElastic: function(t, x_min, dx) {
        var s = 1.70158,
            p = 0,
            a = dx;
        if (t == 0)
            return x_min;
        if ((t / 2) == 2)
            return x_min + dx;
        if (!p)
            p = .3 * 1.5;
        if (a < Math.abs(dx)) {
            a = dx;
            s = p / 4;
        }
        else {
            s = p / (2 * Math.PI) * Math.asin(dx / a);
        }
        if (t < 1)
            return -.5 * (a * __pow(2, 10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p)) + x_min;
        return a * __pow(2, -10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p) * .5 + dx + x_min;
    },
    easeInBack: function(t, x_min, dx) {
        var s = 1.70158;
        return dx * __pow(t, 2) * ((s + 1) * t - s) + x_min;
    },
    easeOutBack: function(t, x_min, dx) {
        var s = 1.70158;
        return dx * ((t -= 1) * t * ((s + 1) * t + s) + 1) + x_min;
    },
    easeInOutBack: function(t, x_min, dx) {
        var s = 1.70158;
        if ((t / 2) < 1)
            return dx / 2 * (t * t * (((s *= (1.525)) + 1) * t - s)) + x_min;
        return dx / 2 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2) + x_min;
    },
    easeInBounce: function(t, x_min, dx) {
        return dx - apf.tween.easeOutBounce(1 - t, 0, dx) + x_min;
    },
    easeOutBounce: function(t, x_min, dx) {
        if (t < (1 / 2.75))
            return dx * (7.5625 * t * t) + x_min;
        else if (t < (2 / 2.75))
            return dx * (7.5625 * (t -= (1.5 / 2.75)) * t + .75) + x_min;
        else if (t < (2.5 / 2.75))
            return dx * (7.5625 * (t -= (2.25 / 2.75)) * t + .9375) + x_min;
        else
            return dx * (7.5625 * (t -= (2.625 / 2.75)) * t + .984375) + x_min;
    },
    easeInOutBounce: function(t, x_min, dx) {
        if (t < 1 / 2)
            return apf.tween.easeInBounce(t * 2, 0, dx) * .5 + x_min;
        return apf.tween.easeOutBounce(t * 2 - 1, 0, dx) * .5 + dx * .5 + x_min;
    }
};

})(apf);




/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/draw.js)SIZE(67157)TIME(1257329189)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/date.js)SIZE(29151)TIME(1257329189)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */

/**
 * @term dateformat Format a date based on small strings of characters representing
 * a variable.
 * Syntax:
 * <code>
 * d      day of the month as digits, no leading zero for single-digit days
 * dd     day of the month as digits, leading zero for single-digit days
 * ddd    day of the week as a three-letter abbreviation
 * dddd   day of the week as its full name
 * m      month as digits, no leading zero for single-digit months
 * mm     month as digits, leading zero for single-digit months
 * mmm    month as a three-letter abbreviation
 * mmmm   month as its full name
 * yy     year as last two digits, leading zero for years less than 2010
 * yyyy   year represented by four digits
 * h      hours, no leading zero for single-digit hours (12-hour clock)
 * hh     hours, leading zero for single-digit hours (12-hour clock)
 * H      hours, no leading zero for single-digit hours (24-hour clock)
 * HH     hours, leading zero for single-digit hours (24-hour clock)
 * M      minutes, no leading zero for single-digit minutes
 * MM     minutes, leading zero for single-digit minutes
 * s      seconds, no leading zero for single-digit seconds
 * ss     seconds, leading zero for single-digit seconds
 * </code>
 */


// Some common format strings
/**
 * @private
 */
apf.date = (function() {

return {
    masks : {
        "default":      "ddd mmm dd yyyy HH:MM:ss",
        shortDate:      "m/d/yy",
        mediumDate:     "mmm d, yyyy",
        longDate:       "mmmm d, yyyy",
        fullDate:       "dddd, mmmm d, yyyy",
        shortTime:      "h:MM TT",
        mediumTime:     "h:MM:ss TT",
        longTime:       "h:MM:ss TT Z",
        isoDate:        "yyyy-mm-dd",
        isoTime:        "HH:MM:ss",
        isoDateTime:    "yyyy-mm-dd'T'HH:MM:ss",
        isoUtcDateTime: "UTC:yyyy-mm-dd'T'HH:MM:ss'Z'"
    },

    // Internationalization strings
    i18n : {
        /**
         * Defines what day starts the week
         *
         * Monday (1) is the international standard.
         * Redefine this to 0 if you want weeks to begin on Sunday.
         */
        beginWeekday : 1,
        dayNames : [
            "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat",
            "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday",
            "Friday", "Saturday"
        ],

        dayNumbers : {
            "Sun" : 0, "Mon" : 1, "Tue" : 2, "Wed" : 3, "Thu" : 4, "Fri" : 5,
            "Sat" : 6, "Sunday" : 0, "Monday" : 1, "Tuesday" : 2,
            "Wednesday" : 3, "Thursday" : 4, "Friday" : 5, "Saturday" : 6
        },
        monthNames : [
            "Jan", "Feb", "Mar", "Apr", "May", "Jun",
            "Jul", "Aug", "Sep", "Oct", "Nov", "Dec",
            "January", "February", "March", "April", "May", "June",
            "July", "August", "September", "October", "November", "December"
        ],
        monthNumbers : {
            "Jan" : 0, "Feb" : 1, "Mar" : 2, "Apr" : 3, "May" : 4, "Jun" : 5,
            "Jul" : 6, "Aug" : 7, "Sep" : 8, "Oct" : 9, "Nov" : 10, "Dec" : 11
        }
    }
    
};

})();

apf.date.dateFormat = (function () {
    var	token = /d{1,4}|m{1,4}|yy(?:yy)?|([HhMsTt])\1?|[LloSZ]|"[^"]*"|'[^']*'/g,
        timezone = /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g,
        timezoneClip = /[^-+\dA-Z]/g,
        pad = function (val, len) {
            val = String(val);
            len = len || 2;
            while (val.length < len) val = "0" + val;
            return val;
        };

    // Regexes and supporting functions are cached through closure
    return function (date, mask, utc) {
        var dF = apf.date;

        // You can't provide utc if you skip other args (use the "UTC:" mask prefix)
        if (arguments.length == 1 && (typeof date == "string"
            || date instanceof String) && !/\d/.test(date)) {
            mask = date;
            date = undefined;
        }

        // Passing date through Date applies Date.parse, if necessary
        date = date ? new Date(date) : new Date();

        if (isNaN(date)) return "NaN";//throw new SyntaxError("invalid date");

        mask = String(dF.masks[mask] || mask || dF.masks["default"]);

        // Allow setting the utc argument via the mask
        if (mask.slice(0, 4) == "UTC:") {
            mask = mask.slice(4);
            utc = true;
        }

        var	_ = utc ? "getUTC" : "get",
            d = date[_ + "Date"](),
            D = date[_ + "Day"](),
            m = date[_ + "Month"](),
            y = date[_ + "FullYear"](),
            H = date[_ + "Hours"](),
            M = date[_ + "Minutes"](),
            s = date[_ + "Seconds"](),
            L = date[_ + "Milliseconds"](),
            o = utc ? 0 : date.getTimezoneOffset(),
            flags = {
                d   : d,
                dd  : pad(d),
                ddd : dF.i18n.dayNames[D],
                dddd: dF.i18n.dayNames[D + 7],
                m   : m + 1,
                mm  : pad(m + 1),
                mmm : dF.i18n.monthNames[m],
                mmmm: dF.i18n.monthNames[m + 12],
                yy  : String(y).slice(2),
                yyyy: y,
                h   : H % 12 || 12,
                hh  : pad(H % 12 || 12),
                H   : H,
                HH  : pad(H),
                M   : M,
                MM  : pad(M),
                s   : s,
                ss  : pad(s),
                l   : pad(L, 3),
                L   : pad(L > 99 ? Math.round(L / 10) : L),
                t   : H < 12 ? "a"  : "p",
                tt  : H < 12 ? "am" : "pm",
                T   : H < 12 ? "A"  : "P",
                TT  : H < 12 ? "AM" : "PM",
                Z   : utc
                          ? "UTC"
                          : (String(date).match(timezone) 
                              || [""]).pop().replace(timezoneClip, ""),
                o   : (o > 0 ? "-" : "+") 
                         + pad(Math.floor(Math.abs(o) / 60) * 100
                         + Math.abs(o) % 60, 4),
                S   : ["th", "st", "nd", "rd"]
                      [d % 10 > 3 ? 0 : (d % 100 - d % 10 != 10) * d % 10]
            };

        return mask.replace(token, function ($0) {
            return $0 in flags ? flags[$0] : $0.slice(1, $0.length - 1);
        });
    };
})();


/**
 * Create a object representation of date from datetime string parsing it with
 * datetime format string
 * 
 * @param {String}   datetime   the date and time wrote in allowed format
 * @param {String}   format     style of displaying date, created using various
 *                              masks
 *     Possible masks:
 *     d      day of the month as digits, no leading zero for single-digit days
 *     dd     day of the month as digits, leading zero for single-digit days
 *     ddd    day of the week as a three-letter abbreviation
 *     dddd   day of the week as its full name
 *     m      month as digits, no leading zero for single-digit months
 *     mm     month as digits, leading zero for single-digit months
 *     mmm    month as a three-letter abbreviation
 *     mmmm   month as its full name
 *     yy     year as last two digits, leading zero for years less than 2010
 *     yyyy   year represented by four digits
 *     h      hours, no leading zero for single-digit hours (12-hour clock)
 *     hh     hours, leading zero for single-digit hours (12-hour clock)
 *     H      hours, no leading zero for single-digit hours (24-hour clock)
 *     HH     hours, leading zero for single-digit hours (24-hour clock)
 *     M      minutes, no leading zero for single-digit minutes
 *     MM     minutes, leading zero for single-digit minutes
 *     s      seconds, no leading zero for single-digit seconds
 *     ss     seconds, leading zero for single-digit seconds
 */
apf.date.getDateTime = function(datetime, format) {
    var token = /d{1,4}|m{1,4}|yy(?:yy)?|([HhMsTt])\1?|[LloSZ]|"[^"]*"|'[^']*'/g;
    var timezone = /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC:)(?:[-+]\d{4})?)\b/g;
    var alteration = 0;
    var time, y = new Date().getFullYear(), m = 1, d = 1,
        h = 12, M = 0, s = 0;
    var i18n = apf.date.i18n;

    if (!format) {
        throw new Error(apf.formatErrorString(0, null,
            "date-format", "Date format is null"));
    }

    format = format.replace(timezone, "");

    var str = format.replace(token, function(str, offset, p) {
        var part = datetime.substring(p + alteration, p + alteration + str.length);

        switch (str) {
            case 'd':
            case 'm':
            case 'h':
            case 'H':
            case 'M':
            case 's':
                if (!/[\/, :\-](d|m|h|H|M|s)$|^(d|m|h|H|M|s)[\/, :\-]|[\/, :\-](d|m|h|H|M|s)[\/, :\-]/.test(format)) {
                    throw new Error(apf.formatErrorString(0, null,
                        "date-format", "Dates without leading zero needs separators"));
                }

                var value = parseInt(datetime.substring(p + alteration,
                    p + alteration + 2));

                if (value.toString().length == 2)
                    alteration++;
    
                return str == 'd'
                    ? d = value
                    : (str == 'm'
                        ? m = value
                        : (str == 'M'
                            ? M = value
                            : (str == 's'
                                ? s = value
                                : h = value))); 
            case 'dd':
                return d = part; //01-31
            case 'dddd':
                //changeing alteration because "dddd" have no information about day number
                alteration += i18n.dayNames[i18n.dayNumbers[part.substring(0,3)] + 7].length - 4;
                break;
            case 'mm':
                return m = part; //01 - 11
            case 'mmm':
                return m = i18n.monthNumbers[part] + 1;
            case 'mmmm':
                var monthNumber = i18n.monthNumbers[part.substring(0, 3)];
                alteration += i18n.monthNames[monthNumber + 12].length - 4;
                return m = monthNumber + 1;
            case 'yy':
                return y = parseInt(part) < 70 ? "20" + part : part;
            case 'yyyy':
                return y = part;
            case 'hh':
                return h = part;
            case 'HH':
                return h = part;
            case 'MM':
                return M = part;
            case 'ss':
                return s = part;
            case "'T'":
            case "'Z'":
                //because in date we have only T
                alteration -= 2;
                break;
         }
    });

    return new Date(y, m-1, d, h, M, s);
};

// For convenience...
Date.prototype.format = function (mask, utc) {
    return apf.date.dateFormat(this, mask, utc);
};

Date.parse = function (datetime, format) {
    return apf.date.getDateTime(datetime, format);
};






/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/xmldb.js)SIZE(35119)TIME(1271026883)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * The xml database object provides local storage for xml data. This object
 * routes all changes to the xml data to the data bound objects. It further
 * provides utility functions for xml handling.
 *
 * @constructor
 * @apfclass
 *
 * @author      Ruben Daniels (ruben AT ajax DOT org)
 * @version     %I%, %G%
 * @since       0.8
 *
 * @default_private
 */
apf.xmldb = new (function(){
    this.xmlDocTag    = "a_doc";
    this.xmlIdTag     = "a_id";
    this.xmlListenTag = "a_listen";
    this.htmlIdTag    = "id";
    this.disableRSB   = false;

    this.$xmlDocLut   = [];
    this.$nodeCount   = {};

    /**
     * @private
     */
    this.getElementById = function(id, doc){
        if (!doc)
            doc = this.$xmlDocLut[id.split("\|")[0]];
        if (!doc)
            return false;

        return doc.selectSingleNode("descendant-or-self::node()[@"
            + this.xmlIdTag + "='" + id + "']");
    };

    /**
     * @private
     */
    this.getNode = function(htmlNode){
        if (!htmlNode || !htmlNode.getAttribute(this.htmlIdTag))
            return false;

        return this.getElementById(htmlNode.getAttribute(this.htmlIdTag)
            .split("\|", 2).join("|"));
    };

    /**
     * @private
     */
    this.getNodeById = function(id, doc){
        var q = id.split("\|");
        q.pop();
        return this.getElementById(q.join("|"), doc);//id.split("\|", 2).join("|")
    };

    /**
     * @private
     */
    this.getDocumentById = function(id){
        return this.$xmlDocLut[id];
    };

    /**
     * @private
     */
    this.getDocument = function(node){
        return this.$xmlDocLut[node.getAttribute(this.xmlIdTag).split("\|")[0]];
    };

    /**
     * @private
     */
    this.getID = function(xmlNode, o){
        return xmlNode.getAttribute(this.xmlIdTag) + "|" + o.$uniqueId;
    };

    /**
     * @private
     */
    this.getElement = function(parent, nr){
        var nodes = parent.childNodes;
        for (var j = 0, i = 0; i < nodes.length; i++) {
            if (nodes[i].nodeType != 1)
                continue;
            if (j++ == nr)
                return nodes[i];
        }
    };

    /**
     * Sets the model of an element
     *
     * @param {Model} The model to be set
     * 
     */
    this.setModel = function(model){
        apf.nameserver.register("model", model.data.ownerDocument
            .documentElement.getAttribute(this.xmlDocTag), model);
    };

    /**
     * Find the model of an element
     *
     * @param {XMLNode} xmlNode the {@link term.datanode data node} to find its model.
     *
     */
    this.findModel = function(xmlNode){
        return apf.nameserver.get("model", xmlNode.ownerDocument
            .documentElement.getAttribute(this.xmlDocTag));
    };

    /**
     * @private
     */
    this.getXmlId = function(xmlNode){
        return xmlNode.getAttribute(this.xmlIdTag) ||
          this.nodeConnect(apf.xmldb.getXmlDocId(xmlNode), xmlNode);
    }

    /**
     * Gets the html representation of an xml node for a certain element.
     *
     * @param {XMLNode} xmlNode  the {@link term.datanode data node} which is represented by the hml element.
     * @param {AMLNode} oComp    the element that has created the representation.
     * @return {HTMLNode} the html node representing the xml node.
     */
    this.getHtmlNode = function(xmlNode, oComp){
        if (xmlNode && xmlNode.nodeType == 1 && xmlNode.getAttribute(this.xmlIdTag)) {
            return oComp.$findHtmlNode(xmlNode.getAttribute(this.xmlIdTag)
                + "|" + oComp.$uniqueId);
        }
        return null;
    }
    
    /**
     * Finds the html representation of an xml node for a certain element.
     *
     * @param {XMLNode} xmlNode  the {@link term.datanode data node} which is represented by the hml element.
     * @param {AMLNode} oComp    the element that has created the representation.
     * @return {HTMLNode} the html node representing the xml node.
     */
    this.findHtmlNode = function(xmlNode, oComp){
        do {
            if (xmlNode.nodeType == 1 && xmlNode.getAttribute(this.xmlIdTag)) {
                return oComp.$findHtmlNode(xmlNode.getAttribute(this.xmlIdTag)
                    + "|" + oComp.$uniqueId);
            }
            if (xmlNode == oComp.xmlRoot)
                return null;
    
            xmlNode = xmlNode.parentNode;
        }
        while (xmlNode && xmlNode.nodeType != 9)
    
        return null;
    };
    
    /**
     * Finds the {@link term.datanode data node} that is represented by the html node.
     *
     * @param {HTMLNode} htmlNode  the html node representing the an xml node.
     * @return {XMLNode} the {@link term.datanode data node} for which the html node is it's representation.
     */
    this.findXmlNode = function(htmlNode){
        if (!htmlNode)
            return false;
        
        var id;
        while (htmlNode && htmlNode.nodeType == 1 && (
          htmlNode.tagName.toLowerCase() != "body" && !(id = htmlNode.getAttribute(this.htmlIdTag))
          || (id || (id = htmlNode.getAttribute(this.htmlIdTag))) && id.match(/^q/)
        )) {
            if (htmlNode.host && htmlNode.host.$ext == htmlNode)
                return htmlNode.host.xmlRoot;
    
            htmlNode = htmlNode.parentNode;
        }
        if (!htmlNode || htmlNode.nodeType != 1)
            return false;
    
        if (htmlNode.tagName.toLowerCase() == "body")
            return false;
    
        return this.getNode(htmlNode);
    };
    
    this.getXml = apf.getXml;

    /**
     * @private
     */
    this.nodeConnect = function(documentId, xmlNode, htmlNode, o){
        if (!this.$nodeCount[documentId])
            this.$nodeCount[documentId] = 0;

        var xmlId;
        xmlId = xmlNode.getAttribute(this.xmlIdTag)
          || xmlNode.setAttribute(this.xmlIdTag, (xmlId = documentId
               + "|" + ++this.$nodeCount[documentId])) || xmlId;

        if (!o)
            return xmlId;

        var htmlId = xmlId + "|" + o.$uniqueId;
        if (htmlNode)
            htmlNode.setAttribute(this.htmlIdTag, htmlId);

        return htmlId;
    };

    /**
     * @private
     */
    this.$listeners = [];
    this.addNodeListener = function(xmlNode, o, uId){
        
        if (!o || (!o.$xmlUpdate && !o.setProperty))
            throw new Error(apf.formatErrorString(1040, null, 
                "Adding Node listener", 
                "Interface not supported."));
        

        var id, listen = String(xmlNode.getAttribute(this.xmlListenTag) || "");
        //id || (id = String(o.$uniqueId));
        
        if (!uId) uId = String(o.$uniqueId);
        if (uId.charAt(0) == "p") {
            uId = uId.split("|");
            id = this.$listeners.push(function(){
                //@todo apf3.0 should this be exactly like in class.js?
                //@todo optimize this to check the async flag: parsed[3] & 4
                
                var amlNode = apf.all[uId[1]]; //It's possible the aml node dissapeared in this loop.
                if (amlNode) {
                    var model = apf.all[uId[3]];
                    var xpath = model.$propBinds[uId[1]][uId[2]].listen; //root
                    
                    amlNode.$execProperty(uId[2], xpath
                        ? model.data.selectSingleNode(xpath)
                        : model.data);
                }
            }) - 1;
        }
        else {
            //@todo apf3 potential cleanup problem
            id = "e" + uId;
            if (!this.$listeners[id]) {
                this.$listeners[id] = function(args){
                    var amlNode = apf.all[uId];
                    if (amlNode)
                        amlNode.$xmlUpdate.apply(amlNode, args);
                };
            }
        }

        if (!listen || listen.indexOf(id + ";") == -1)
            xmlNode.setAttribute(this.xmlListenTag, (listen ? listen + id : id) + ";");

        return xmlNode;
    };

    /**
     * @todo  Use this function when an element really unbinds from a
     *        piece of data and does not uses it for caching
     * @private
     */
    this.removeNodeListener = function(xmlNode, o, id){
        var listen = xmlNode.getAttribute(this.xmlListenTag);
        var nodes = (listen ? listen.split(";") : []);
        if (!id) id = o.$uniqueId

        for (var newnodes = [], i = 0; i < nodes.length; i++) {
            if (nodes[i] != id)
                newnodes.push(nodes[i]);
        }

        xmlNode.setAttribute(this.xmlListenTag, newnodes.join(";"));

        return xmlNode;
    };

    /**
     * Sets the value of a text node. If the node doesn't exists it is created.
     * Changes are propagated to the databound elements listening for changes
     * on the data changed.
     *
     * @param {XMLElement} pNode     the parent of the text node.
     * @param {String}     value     the value of the text node.
     * @param {String}     [xpath]   the xpath statement which selects the text node.
     * @param {UndoObj}    [undoObj] the undo object that is responsible for archiving the changes.
     */
    this.setTextNode = 
    apf.setTextNode  = function(pNode, value, xpath, undoObj){
        var tNode;

        if (xpath) {
            tNode = pNode.selectSingleNode(xpath);
            if (!tNode)
                return;
            pNode = tNode.nodeType == 1 ? tNode : null;
        }
        if (pNode.nodeType != 1)
            tNode = pNode;
        else if (pNode || !tNode) {
            tNode = pNode.selectSingleNode("text()");

            if (!tNode)
                tNode = pNode.appendChild(pNode.ownerDocument.createTextNode(""));//createCDATASection
        }

        //Action Tracker Support
        if (undoObj)
            undoObj.extra.oldValue = tNode.nodeValue;

        //Apply Changes
        tNode.nodeValue = value;
        
        if (tNode.$regbase)
            tNode.$setValue(value);

        this.applyChanges("text", tNode.parentNode, undoObj);

        
    };

    /**
     * Sets an attribute on a node. Changes are propagated to the databound
     * elements listening for changes on the data changed.
     *
     * @param {XMLElement} xmlNode   the xml node to set the attribute on.
     * @param {String}     name      the name of the attribute.
     * @param {String}     value     the value of the attribute.
     * @param {String}     [xpath]   the xpath statement to select the attribute.
     * @param {UndoObj}    [undoObj] the undo object that is responsible for archiving the changes.
     */
    this.setAttribute = 
    apf.setAttribute  = function(xmlNode, name, value, xpath, undoObj){
        //Apply Changes
        (xpath ? xmlNode.selectSingleNode(xpath) : xmlNode).setAttribute(name, value);
        
        this.applyChanges("attribute", xmlNode, undoObj);
        
    };

    /**
     * Removes an attribute of an xml node. Changes are propagated to the
     * databound elements listening for changes on the data changed.
     *
     * @param {XMLElement} xmlNode   the xml node to delete the attribute from
     * @param {String}     name      the name of the attribute.
     * @param {String}     [xpath]   the xpath statement to select the attribute.
     * @param {UndoObj}    [undoObj] the undo object that is responsible for archiving the changes.
     */
    this.removeAttribute = 
    apf.removeAttribute  = function(xmlNode, name, xpath, undoObj){
        //if(xmlNode.nodeType != 1) xmlNode.nodeValue = value;

        //Action Tracker Support
        if (undoObj) undoObj.name = name;

        //Apply Changes
        (xpath ? xmlNode.selectSingleNode(xpath) : xmlNode).removeAttribute(name);
        this.applyChanges("attribute", xmlNode, undoObj);

        
    };

    /**
     * Replace one node with another. Changes are propagated to the
     * databound elements listening for changes on the data changed.
     *
     * @param {XMLElement} oldNode   the xml node to remove.
     * @param {XMLElement} newNode   the xml node to set.
     * @param {String}     [xpath]   the xpath statement to select the attribute.
     * @param {UndoObj}    [undoObj] the undo object that is responsible for archiving the changes.
     */
    this.replaceNode = 
    apf.replaceNode  = function(newNode, oldNode, xpath, undoObj){
        //if(xmlNode.nodeType != 1) xmlNode.nodeValue = value;

        //Apply Changes
        if (xpath)
            oldNode = oldNode.selectSingleNode(xpath);

        //Action Tracker Support
        if (undoObj) {
            undoObj.oldNode = oldNode;
            undoObj.xmlNode = newNode;
        }
        var parentNode = oldNode.parentNode;
        parentNode.replaceChild(newNode, oldNode);
        this.copyConnections(oldNode, newNode);

        this.applyChanges("replacechild", newNode, undoObj);

        
        
        return newNode;
    };

    /**
     * Creates a new element under a parent xml node. Changes are propagated
     * to the databound elements listening for changes on the data changed.
     *
     * @param {XMLElement} pNode       the parent xml node to add the new element to.
     * @param {String}     tagName     the tagName of the {@link term.datanode data node} to add.
     * @param {Array}      attr        list of the attributes to set. Each item is another array with the name and value.
     * @param {XMLElement} beforeNode  the xml node which indicates the insertion point.
     * @param {String}     [xpath]     the xpath statement to select the attribute.
     * @param {UndoObj}    [undoObj]   the undo object that is responsible for archiving the changes.
     */
    this.addChildNode = 
    apf.addChildNode  = function(pNode, tagName, attr, beforeNode, undoObj){
        //Create New Node
        var xmlNode = pNode.insertBefore(pNode.ownerDocument
            .createElement(tagName), beforeNode);

        //Set Attributes
        for (var i = 0; i < attr.length; i++)
            xmlNode.setAttribute(attr[i][0], attr[i][1]);

        //Action Tracker Support
        if (undoObj)
            undoObj.extra.addedNode = xmlNode;

        this.applyChanges("add", xmlNode, undoObj);

        

        return xmlNode;
    };

    /**
     * Appends an xml node to a parent. Changes are propagated
     * to the databound elements listening for changes on the data changed.
     *
     * @param {XMLElement} pNode       the parent xml node to add the element to.
     * @param {XMLElement} xmlNode     the xml node to insert.
     * @param {XMLElement} beforeNode  the xml node which indicates the insertion point.
     * @param {Boolean}    unique      whether the parent can only contain one element with a certain tagName.
     * @param {String}     [xpath]     the xpath statement to select the parent node.
     * @param {UndoObj}    [undoObj]   the undo object that is responsible for archiving the changes.
     */
    this.appendChild = 
    apf.appendChild  = function(pNode, xmlNode, beforeNode, unique, xpath, undoObj){
        if (unique && pNode.selectSingleNode(xmlNode.tagName))
            return false;

        if (undoObj)
            this.cleanNode(xmlNode);

        // @todo: only do this once!
        if (pNode.ownerDocument.importNode && pNode.ownerDocument != xmlNode.ownerDocument)
            xmlNode = pNode.ownerDocument.importNode(xmlNode, true); //Safari issue not auto importing nodes

        //Add xmlNode to parent pNode or one selected by xpath statement
        if (xpath) {
            var addedNodes = [];
            var pNode = apf.createNodeFromXpath(pNode, xpath, addedNodes);
            if (addedNodes.length) {
                pNode.appendChild(xmlNode);
                while(addedNodes.length) {
                    if (pNode == addedNodes.pop() && addedNodes.length)
                        pNode = pNode.parentNode;
                }
            }
        }
        else if (xmlNode.parentNode)
            this.removeNode(xmlNode);

        pNode.insertBefore(xmlNode, beforeNode);

        //detect if xmlNode should be removed somewhere else
        //- [17-2-2004] changed pNode (2nd arg applychange) into xmlNode

        this.applyChanges("add", xmlNode, undoObj);

        

        return xmlNode;
    };

    /**
     * Moves an xml node to a parent node. Changes are propagated
     * to the databound elements listening for changes on the data changed.
     *
     * @param {XMLElement} pNode       the new parent xml node of the node.
     * @param {XMLElement} xmlNode     the xml node to move.
     * @param {XMLElement} beforeNode  the xml node which indicates the insertion point.
     * @param {String}     [xpath]     the xpath statement to select the parent node.
     * @param {UndoObj}    [undoObj]   the undo object that is responsible for archiving the changes.
     */
    this.moveNode = 
    apf.moveNode  = function(pNode, xmlNode, beforeNode, xpath, undoObj){
        //Action Tracker Support
        if (!undoObj)
            undoObj = {extra:{}};

        undoObj.extra.oldParent  = xmlNode.parentNode;
        undoObj.extra.beforeNode = xmlNode.nextSibling;
        undoObj.extra.parent     = (xpath ? pNode.selectSingleNode(xpath) : pNode);

        this.applyChanges("move-away", xmlNode, undoObj);

        

        //Set new id if the node change document (for safari this should be fixed)
        if (!apf.isWebkit
          && apf.xmldb.getXmlDocId(xmlNode) != apf.xmldb.getXmlDocId(pNode)) {
            xmlNode.removeAttributeNode(xmlNode.getAttributeNode(this.xmlIdTag));
            this.nodeConnect(apf.xmldb.getXmlDocId(pNode), xmlNode);
        }

        if (apf.isWebkit && pNode.ownerDocument != xmlNode.ownerDocument)
            xmlNode = pNode.ownerDocument.importNode(xmlNode, true); //Safari issue not auto importing nodes

        undoObj.extra.parent.insertBefore(xmlNode, beforeNode);
        this.applyChanges("move", xmlNode, undoObj);
    };

    /**
     * Removes an xml node from it's parent. Changes are propagated
     * to the databound elements listening for changes on the data changed.
     *
     * @param {XMLElement} xmlNode     the xml node to remove from the dom tree.
     * @param {String}     [xpath]     the xpath statement to select the parent node.
     * @param {UndoObj}    [undoObj]   the undo object that is responsible for archiving the changes.
     */
    this.removeNode = 
    apf.removeNode  = function(xmlNode, xpath, undoObj){
        if (xpath)
            xmlNode = xmlNode.selectSingleNode(xpath);

        //ActionTracker Support
        if (undoObj) {
            undoObj.extra.parent      = xmlNode.parentNode;
            undoObj.extra.removedNode = xmlNode;
            undoObj.extra.beforeNode  = xmlNode.nextSibling;
        }

        

        //Apply Changes
        this.applyChanges("remove", xmlNode, undoObj);
        var p = xmlNode.parentNode;
        p.removeChild(xmlNode);
        this.applyChanges("redo-remove", xmlNode, null, p);//undoObj
        
        //@todo clean xmlNode after removal??
    };

    /**
     * Removes a list of xml nodes from their parent. Changes are propagated
     * to the databound elements listening for changes on the data changed.
     *
     * @param {Array}   xmlNodeList list of xml nodes to remove.
     * @param {UndoObj} [undoObj]   the undo object that is responsible for archiving the changes.
     */
    this.removeNodeList = 
    apf.removeNodeList  = function(xmlNodeList, undoObj){
        //if(xpath) xmlNode = xmlNode.selectSingleNode(xpath);
        for (var rData = [], i = 0; i < xmlNodeList.length; i++) { //This can be optimized by looping nearer to xmlUpdate
            //ActionTracker Support
            if (undoObj) {
                rData.push({
                    pNode      : xmlNodeList[i].parentNode,
                    removedNode: xmlNodeList[i],
                    beforeNode : xmlNodeList[i].nextSibling
                });
            }

            //Apply Changes
            this.applyChanges("remove", xmlNodeList[i], undoObj);
            var p = xmlNodeList[i].parentNode;
            p.removeChild(xmlNodeList[i]);
            this.applyChanges("redo-remove", xmlNodeList[i], null, p);//undoObj
        }

        if (undoObj)
            undoObj.extra.removeList = rData;

        
    };

    /**
     * Looks for this.$listeners and executes their $xmlUpdate methods.
     * @private
     */
    var notifyQueue = {}, notifyTimer;
    this.$hasQueue = false;
    this.applyChanges = function(action, xmlNode, undoObj, nextloop){
        if (undoObj && undoObj.$dontapply) return;
        

        if (undoObj && !undoObj.xmlNode) //@todo are we sure about this?
            undoObj.xmlNode = xmlNode;

        //Set Variables
        var oParent  = nextloop,
            loopNode = (xmlNode.nodeType == 1 ? xmlNode : xmlNode.parentNode);

        //var xmlId = xmlNode.getAttribute(this.xmlIdTag);

        if (!this.delayUpdate && "|remove|move-away|".indexOf("|" + action + "|") > -1)
            this.notifyQueued(); //empty queue

        var listen, uId, uIds, i, j, hash, info, amlNode, runTimer, found;
        while (loopNode && loopNode.nodeType == 1) {
            //Get List of Node this.$listeners ID's
            listen = loopNode.getAttribute(this.xmlListenTag);

            if (listen) {
                uIds = listen.split(";");

                for (i = 0; i < uIds.length; i++) {
                    uId = uIds[i];
                    
                    //Property support
                    /*if (uId.charAt(0) == "p") {
                        uId = uId.split("|");
                        
                        //@todo apf3.0 should this be exactly like in class.js?
                        //@todo optimize this to check the async flag: parsed[3] & 4
                        
                        amlNode = apf.all[uId[1]]; //It's possible the aml node dissapeared in this loop.
                        if (amlNode) {
                            var model = apf.all[uId[3]];
                            var xpath = model.$propBinds[uId[1]][uId[2]].root;
                            
                            amlNode.$execProperty(uId[2], xpath
                                ? model.data.selectSingleNode(xpath)
                                : model.data);
                        }
                        continue;
                    }*/
                    
                    hash = notifyQueue[uId];
                    if (!hash)
                        notifyQueue[uId] = hash = [];

                    // Filtering
                    if ("|update|attribute|text|".indexOf("|" + action + "|") > -1) {
                        found = false;
                        for (j = 0; j < hash.length; j++) {
                            if (hash[j] && xmlNode == hash[j][1]
                              && "|update|attribute|text|"
                              .indexOf("|" + hash[j][0] + "|") > -1) {
                                hash[j] = null;
                                found = true;
                                continue;
                            }
                        }

                        hash.push(["update", xmlNode, loopNode, undoObj, oParent]);
                        runTimer = true;
                        continue;
                    }

                    //!this.delayUpdate && <- that doesnt work because of information that is destroyed
                    if ("|remove|move-away|add|".indexOf("|" + action + "|") > -1) {
                        if (this.$listeners[uId]) {
                            this.$listeners[uId]([action, xmlNode,
                                loopNode, undoObj, oParent]);
                        }
                        /*amlNode = apf.all[uId];
                        if (amlNode)
                            amlNode.$xmlUpdate(action, xmlNode,
                                loopNode, undoObj, oParent);*/
                    }
                    else {
                        hash.push([action, xmlNode, loopNode, undoObj, oParent]);
                        runTimer = true;
                    }
                }
            }

            //Go one level up
            loopNode = loopNode.parentNode || nextloop;
            if (loopNode == nextloop)
                nextloop = null;
        }

        if (undoObj && !this.delayUpdate) {
            //Ok this was an action let's not delay execution
            apf.xmldb.notifyQueued();
        }
        else if (runTimer) {
            clearTimeout(notifyTimer);
            //@todo find a better solution for this (at the end of a event stack unroll)
            notifyTimer = $setTimeout(function(){
                //this.$hasQueue = true;
                apf.xmldb.notifyQueued();
            });
        }
    };

    /**
     *  @todo in actiontracker - add stack auto purging
     *        - when undo item is purged which was a removed, remove cache item
     *  @todo shouldn't the removeNode method remove all this.$listeners?
     *  @todo rename to processQueue
     *  @private
     */
    this.notifyQueued = function(){
        this.$hasQueue = false;
        
        clearTimeout(notifyTimer);
        for (var uId in notifyQueue) {
            if (!uId) continue;
            
            var q       = notifyQueue[uId];
            var func    = this.$listeners[uId];
            //!amlNode || 
            if (!q)
                continue;

            //Run queue items
            for (var i = 0; i < q.length; i++) {
                if (!q[i])
                    continue;

                //Update xml data
                //amlNode.$xmlUpdate.apply(amlNode, q[i]);
                func(q[i]);
            }
        }

        notifyQueue = {}; // update shouldn't add anything to the queue
    }

    /**
     * @private
     */
    this.notifyListeners = function(xmlNode){
        //This should be done recursive
        var listen = xmlNode.getAttribute(apf.xmldb.xmlListenTag);
        if (listen) {
            listen = listen.split(";");
            for (var j = 0; j < listen.length; j++) {
                apf.all[listen[j]].$xmlUpdate("synchronize", xmlNode, xmlNode);
                //load(xmlNode);
            }
        }
    };

    

    /**
     * @private
     */
    this.copyConnections = function(fromNode, toNode){
        //This should copy recursive
        try {
            toNode.setAttribute(this.xmlListenTag, fromNode.getAttribute(this.xmlListenTag));
        }
        catch (e) {}
        try {
            toNode.setAttribute(this.xmlIdTag, fromNode.getAttribute(this.xmlIdTag));
        }
        catch (e) {}
    };

    /**
     * @private
     */
    this.cleanNode = function(xmlNode){
        try {
            var i, nodes = xmlNode.selectNodes("descendant-or-self::node()[@" + this.xmlListenTag + "]");
            for (i = nodes.length - 1; i >= 0; i--)
                nodes[i].removeAttribute(this.xmlListenTag);
            nodes = xmlNode.selectNodes("descendant-or-self::node()[@" + this.xmlIdTag + "]");
            for (i = nodes.length - 1; i >= 0; i--)
                nodes[i].removeAttribute(this.xmlIdTag);
            nodes = xmlNode.selectNodes("descendant-or-self::node()[@" + this.xmlDocTag + "]");
            for (i = nodes.length - 1; i >= 0; i--)
                nodes[i].removeAttribute(this.xmlDocTag);
            nodes = xmlNode.selectNodes("descendant-or-self::node()[@a_loaded]");
            for (i = nodes.length - 1; i >= 0; i--)
                nodes[i].removeAttribute("a_loaded");
            
            // var nodes = xmlNode.selectNodes("descendant-or-self::node()[@a_selection]");
            // for (var i = nodes.length - 1; i >= 0; i--)
            //     nodes[i].removeAttributeNode(nodes[i].getAttributeNode("a_selection"));
            
        }
        catch (e) {}

        return xmlNode;
    };
    
    /**
     * Returns a copy of the passed {@link term.datanode data node}. Bound
     * data nodes contain special attributes to track them. These attributes
     * are removed from the copied node when using this method.
     *
     * @param {XMLElement} xmlNode the {@link term.datanode data node} to copy.
     * @return {XMLElement} the copy of the {@link term.datanode data node}.
     */
    this.copy         = 
    this.getCleanCopy = 
    apf.getCleanCopy  = function(xmlNode){
        return apf.xmldb.cleanNode(xmlNode.cloneNode(true));
    };

    /**
     * Unbind all APF Elements from a certain Form
     * @private
     */
    this.unbind = function(frm){
        //Loop through objects of all apf
        for (var lookup = {}, i = 0; i < frm.apf.all.length; i++)
            if (frm.apf.all[i] && frm.apf.all[i].unloadBindings)
                lookup[frm.apf.all[i].unloadBindings()] = true;

        //Remove Listen Nodes
        for (var k = 0; k < this.$xmlDocLut.length; k++) {
            
            if (!this.$xmlDocLut[k]) continue;
            

            var Nodes = this.$xmlDocLut[k].selectNodes("//self::node()[@"
                + this.xmlListenTag + "]");
            if (!Nodes) continue;

            //Loop through Nodes and rebuild listen array
            for (var i = 0; i < Nodes.length; i++) {
                var listen = Nodes[i].getAttribute(this.xmlListenTag).split(";");
                for (var nListen = [], j = 0; j < listen.length; j++)
                    if (!lookup[listen[j]])
                        nListen.push(listen[j]);

                //Optimization??
                if (nListen.length != listen.length)
                    Nodes[i].setAttribute(this.xmlListenTag, nListen.join(";"));
            }
        }
    };

    /**
     * @private
     * @todo xml doc leakage
     */
    this.getXmlDocId = function(xmlNode, model){
        var docEl = xmlNode.ownerDocument.documentElement;
        if (!apf.isChildOf(docEl, xmlNode))
            docEl = xmlNode;

        var docId = (docEl || xmlNode).getAttribute(this.xmlDocTag)
            || this.$xmlDocLut.indexOf(docEl || xmlNode.ownerDocument || xmlNode);

        if (!docId || docId == -1) {
            docId = this.$xmlDocLut.push(docEl || xmlNode.ownerDocument || xmlNode) - 1;
            if (docEl)
                docEl.setAttribute(this.xmlDocTag, docId);
        }

        if (model)
            apf.nameserver.register("model", docId, model);

        return docId;
    };
});




/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/resize.js)SIZE(13139)TIME(1257329189)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/queue.js)SIZE(1857)TIME(1269009601)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 *
 */
apf.queue = {
    //@todo apf3.0
    q : {},
    
    timer : null,
    add : function(id, f){
        this.q[id] = f;
        if (!this.timer)
            this.timer = $setTimeout("apf.queue.empty()");
    },
    
    remove : function(id){
        delete this.q[id];
    },
    
    empty : function(prop){
        clearTimeout(this.timer);
        this.timer = null;
        
        
        if (apf.layout && apf.layout.$hasQueue)
            apf.layout.processQueue();
        
        
        if (apf.xmldb && apf.xmldb.$hasQueue)
            apf.xmldb.notifyQueued();
        
        
        var q = this.q;
        for (var prop in q){
            var f = q[prop];
            if (f) {
                delete q[prop];
                f();
            }
        }
    }
};



/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/storage.js)SIZE(9011)TIME(1271105953)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


/**
 * Stores javascript structures based on a name and a namespace. This object
 * is used by {@link element.offline apf offline support} as well as the 
 * {@link core.registry registry} and the {@link teleport.http http object} for 
 * caching. All but the memory storage provider, provide persistent storage. 
 * This means the data is kept between browser sessions. This allows apf to
 * have inter-session communication. For instance offline support uses it to
 * store data that could not be send to the server. When the application does 
 * go online (and this could be several sessions later), the data is send to the
 * server.
 *
 * Remarks:
 * The HTML5 specification advices an interface for local persistent storage.
 * Not all browsers have implemented this yet. There are several plugins and/or
 * browser containers that provide solutions for this. Among them are google 
 * gears and adobe's flash. Storage providers for these and others are available.
 *
 * @default_private
 */
apf.storage = {
    modules : {},

    /**
     * Initializes the main storage engine based on the specified provider.
     * @param {String} name the name of the provider that will provider storage
     *   Possible values:
     *   memory     data is stored in memory and is lost when the application exits.
     *   air        data is stored in the air name/value storage.
     *   air.file   data is stored in the air file based storage.
     *   air.sql    data is stored in the air sqlite storage.
     *   flash      data is stored in a small flash container.
     *   gears      data is stored using the sqlite interface of gears.
     *   html5      data is stored in a local storage object specified by the WHATWG html5 standard.
     */
    init : function(name){
        if(!name) name = this.autodetect();
        var provider = this.getProvider(name);

        //Install the provider
        apf.storage = apf.extend(this, provider);
        apf.storage.init = null;
        
        
        apf.console.info("Installed storage provider '" + name + "'");
        
        
        return provider;
    },
    
    /** 
     * Retrieves a storage provider without installing it as the central storage provider.
     * @param {String} name the name of the storage provider.
     *   Possible values:
     *   memory     data is stored in memory and is lost when the application exits.
     *   air        data is stored in the air name/value storage.
     *   air.file   data is stored in the air file based storage.
     *   air.sql    data is stored in the air sqlite storage.
     *   flash      data is stored in a small flash container.
     *   gears      data is stored using the sqlite interface of gears.
     *   gears      data is stored using the sqlite interface of gears.
     *   html5      data is stored in a local storage object specified by the WHATWG html5 standard.
     */
    getProvider : function(name){
        var provider = apf.storage.modules[name];

        if(!provider || typeof provider != "object") {
            
            apf.console.warn("Could not find storage provider '" + name + "'");
            
            
            return false;
        }
        
        if (!provider.isAvailable()) {
            
            apf.console.warn(
                "Storage provider '" + name + "' is not available");
            
            
            return false;
        }

        if(!provider.initialized 
          && (!provider.init || provider.init() === false)) {
            
            apf.console.warn(
                "Could not install storage provider '" + name + "");
            
            
            return false;
        }
        
        provider.name = name;
        apf.extend(provider, this.base);

        return provider;
    },

    /**
     *  Checks if a provider is available.
     */
    autodetect : function(){
        for (var name in this.modules) {
            if ("memory|cookie".indexOf(name) > -1)
                continue;

            if (this.modules[name].isAvailable()) {
                return name;
            }
        }
        
        return !location.host && this.modules.cookie
            ? "cookie"
            : (this.modules.memory
                ? "memory" 
                : null);
    },

    /**
     * @private
     */
    base : {
        namespace : "default",
        
        isValidKeyArray : function(keys) {
            return (!keys || !keys.join)
                ? false
                : /^[0-9A-Za-z_\.\-]*$/.test(keys.join(""));
        },
        
        isValidKey : function(keyName){
            return (keyName === null || keyName === undefined)
                ? false
                : /^[0-9A-Za-z_\.\-]*$/.test(keyName);
        },
        
        //Optimization for slow API's
        getAllPairs : function(namespace, store){
            var keys   = this.getKeys(namespace);
            
            if (!keys || !keys.length)
                return;
                
            var values = this.getMultiple(keys, namespace);
            for (var i = 0; i < keys.length && values; i++) {
                if (values[i])
                    store[keys[i]] = values[i];
            }

            return keys.length;
        }
    }
    
    
};



/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/selection.js)SIZE(32178)TIME(1265032028)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/html.js)SIZE(15347)TIME(1270838605)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/sort.js)SIZE(7583)TIME(1269561668)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * Object handling sorting in a similar way as xslt.
 *
 * @constructor
 * @todo use a struct instead of lots of local variables, and stop using eval
 *
 * @author      Ruben Daniels (ruben AT ajax DOT org)
 * @version     %I%, %G%
 * @since       0.8
 *
 * @private
 */
apf.Sort = function(xmlNode){
    var settings = {};
    //order, xpath, type, method, getNodes, dateFormat, dateReplace, sort_dateFmtStr, getValue;
    
    //use this function to parse the each node
    this.parseXml = function(xmlNode, clear){
        if (clear) settings = {};

        settings.order     = xmlNode.order;
        settings.getValue  = xmlNode.csort || xmlNode.$compile("sort");
        settings.getNodes  = self[xmlNode["nodes-method"]];

        settings.ascending = (settings.order || "").indexOf("desc") == -1;
        settings.order     = null;

        if (xmlNode["data-type"])
            settings.method = sort_methods[xmlNode["data-type"]];
        else if (xmlNode["sort-method"]) {
            settings.method = self[xmlNode["sort-method"]];
            
            
            if (!settings.method) {
                throw new Error(apf.formatErrorString(0, null, 
                    "Sorting nodes",
                    "Invalid or missing sort function name provided '" 
                    + xmlNode["sort-method"] + "'", xmlNode));
            }
            
        }
        else
            settings.method = sort_methods["alpha"];
        
        var str = xmlNode["date-format"];
        if (str) {
            settings.sort_dateFmtStr = str;
            settings.method = sort_methods["date"];
            var result = str.match(/(D+|Y+|M+|h+|m+|s+)/g);
            if (result) {
                for (var pos = {}, i = 0; i < result.length; i++) 
                    pos[result[i].substr(0, 1)] = i + 1;
                settings.dateFormat = new RegExp(str.replace(/([^\sDYMhms])/g, '\\$1')
                    .replace(/YYYY/, "(\\d\\d\\d\\d)")
                    .replace(/(DD|YY|MM|hh|mm|ss)/g, "(\\d\\d)"));
                settings.dateReplace = "$" + pos["M"] + "/$" + pos["D"] + "/$" + pos["Y"];
                if (pos["h"]) 
                    settings.dateReplace += " $" + pos["h"] + ":$" + pos["m"] + ":$" + pos["s"];
            }
        }
    };
    
    this.set = function(struct, clear){
        if (clear) settings = {};
        
        apf.extend(settings, struct);

        if (!settings.ascending)
            settings.ascending = struct.order 
                ? struct.order.indexOf("desc") == -1
                : true;
        
        settings.order = null;
        
        if (struct["type"]) 
            settings.method = sort_methods[struct["type"]];
        else if (struct["method"])
            settings.method = self[struct["method"]];
        else if (!settings.method) 
            settings.method = sort_methods["alpha"];
        
        if (!settings.getValue) {
            settings.getValue = function(item){
                return apf.queryValue(item, settings.xpath);
            }
        }
    };
    
    this.get = function(){
        return apf.extend({}, settings);
    };
    
    //use this function in __xmlUpdate [this function isnt done yet]
    this.findSortSibling = function(pNode, xmlNode){
        var nodes = getNodes ? getNodes(pNode, xmlNode) : this.getTraverseNodes(pNode);
        
        for (var i = 0; i < nodes.length; i++) 
            if (!compare(xmlNode, nodes[i], true, sortSettings)) 
                return nodes[i];
        
        return null;
    };
    
    // Sorting methods for sort()
    var sort_intmask = ["", "0", "00", "000", "0000", "00000", "000000",
        "0000000", "00000000", "000000000", "0000000000", "00000000000",
        "000000000000", "0000000000000", "00000000000000"];
    var sort_methods = {
        "alpha" : function (n){
            return n.toString().toLowerCase()
        },

        "number" : function (t){
            return (t.length < sort_intmask.length
                ? sort_intmask[sort_intmask.length - t.length]
                : "") + t;
        },

        "date" : function (t, args){
            var sort_dateFormat = settings.dateFormat;
            var sort_dateReplace = settings.dateReplace;
            var sort_dateFmtStr = settings.sort_dateFmtStr;
            
            var d;//|| (args && sort_dateFmtStr != args[0])
            if (!sort_dateFormat) {
                d = new Date(t);
            }
            else if (sort_dateFmtStr == '*') 
                d = Date.parse(t);
            else 
                d = (new Date(t.replace(sort_dateFormat, sort_dateReplace))).getTime();
            t = "" + d.getTime();//parseInt(d);
            if (t == "NaN") 
                t = "0";
            return (t.length < sort_intmask.length ? sort_intmask[sort_intmask.length
                - t.length] : "") + t;
        }
    };

    /*
     sort(xpath, sort_xpath, sort_alpha, boolDesc, from, len)
     jsort(n,f,p,ps,sm,desc,sp,ep)
     */
    //var order, xpath, type, method, getNodes, dateFormat, dateReplace, sort_dateFmtStr, getValue;
    this.apply = function(n, args, func, start, len){
        var sa = [], i = n.length;
        
        // build string-sortable list with sort method
        while (i--) {
            var v = settings.getValue(n[i]);
            if (n) 
                sa[sa.length] = {
                    toString: function(){
                        return this.v;
                    },
                    xmlNode : n[i],
                    v       : (settings.method || sort_methods.alpha)(v || "", args, n[i])
                };
        }
        
        // sort it
        sa.sort();
        
        //iterate like foreach
        var end = len ? Math.min(sa.length, start + len) : sa.length;
        if (!start) 
            start = 0;
        
        if (func) {
            if (settings.ascending) 
                for (i = start; i < end; i++) 
                    f(i, end, sa[i].xmlNode, sa[i].v);
            else 
                for (i = end - 1; i >= start; i--) 
                    f(end - i - 1, end, sa[i].xmlNode, sa[i].v);
        }
        else {
            //this could be optimized by reusing n... time it later
            var res = [];
            if (settings.ascending) 
                for (i = start; i < end; i++) 
                    res[res.length] = sa[i].xmlNode;
            else 
                for (i = end - 1; i >= start; i--) 
                    res[res.length] = sa[i].xmlNode;
            return res;
        }
    };
    
    if (xmlNode) 
        this.parseXml(xmlNode);
};




/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/skins.js)SIZE(12694)TIME(1270937593)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * @private
 */
apf.skins = {
    skins  : {},
    css    : [],
    events : ["onmousemove", "onmousedown", "onmouseup", "onmouseout",
        "onclick", "ondragcopy", "ondragstart"],

    /* ***********
     Init
     ************/
    Init: function(xmlNode, refNode, path){
        /*
         get data from refNode || xmlNode
         - name
         - icon-path
         - media-path

         all paths of the xmlNode are relative to the src attribute of refNode
         all paths of the refNode are relative to the index.html
         images/ is replaced if there is a refNode to the relative path from index to the skin + /images/
         */
        var name      = (refNode ? refNode.getAttribute("id") : null)
            || xmlNode.getAttribute("id");
        var base      = (refNode ? refNode.getAttribute("src").match(/\//) || path : "")
            ? (path || refNode.getAttribute("src")).replace(/\/[^\/]*$/, "") + "/"
            : ""; //@todo make this absolute?

        var mediaPath = null, iconPath = null;
        mediaPath = xmlNode.getAttribute("media-path");
        if (mediaPath !== null)
            mediaPath = apf.getAbsolutePath(base || apf.hostPath, mediaPath);
        else if (refNode) {
            mediaPath = refNode.getAttribute("media-path");
            if (mediaPath !== null)
                mediaPath = apf.getAbsolutePath(apf.hostPath, mediaPath);
            else
                mediaPath = apf.getAbsolutePath(base || apf.hostPath, "images/");
        }
        
        iconPath = xmlNode.getAttribute("icon-path");
        if (iconPath !== null)
            iconPath = apf.getAbsolutePath(base || apf.hostPath, iconPath);
        else if (refNode) {
            iconPath = refNode.getAttribute("icon-path");
            if (iconPath !== null)
                iconPath = apf.getAbsolutePath(apf.hostPath, iconPath);
            else
                iconPath = apf.getAbsolutePath(base || apf.hostPath, "icons/");
        }
        
        if (!name)
            name = "default";

        if (xmlNode.getAttribute("id"))
            document.body.className += " " + xmlNode.getAttribute("id");

        var names = name.split("|");
        name = names[0];

        if (!this.skins[name] || name == "default") {
            this.skins[name] = {
                base     : base,
                name     : name,
                iconPath : iconPath,
                mediaPath: mediaPath,
                templates: {},
                originals: {},
                xml      : xmlNode
            }
            
            if (names.length > 1) {
                for (var i = 0; i < names.length; i++)
                    this.skins[names[i]] = this.skins[name];
            }
        }
        
        if (!this.skins["default"] && this.$first == refNode)
            this.skins["default"] = this.skins[name];

        var nodes = xmlNode.childNodes;
        for (var i = nodes.length - 1; i >= 0; i--) {
            if (nodes[i].nodeType != 1)
                continue;

            //this.templates[nodes[i].tagName] = nodes[i];
            this.skins[name].templates[nodes[i].getAttribute("name")] = nodes[i];
            if (nodes[i].ownerDocument)
                this.importSkinDef(nodes[i], base, name);
        }

        this.purgeCss(mediaPath, iconPath);
        
        if (this.queue[name]) {
            for (var prop in this.queue[name]) {
                this.queue[name][prop]();
            }
        }
    },

    /**
     * This method loads a stylesheet from a url
     * @param {String}    filename Required The url to load the stylesheet from
     * @param {String}    title Optional Title of the stylesheet to load
     * @method
     */
    loadStylesheet: function(filename, title){
        var o;
        with (o = document.getElementsByTagName("head")[0].appendChild(document.createElement("LINK"))) {
            rel   = "stylesheet";
            type  = "text/css";
            href  = filename;
            title = title;
        }

        return o;
    },

    /* ***********
     Import
     ************/
    importSkinDef: function(xmlNode, basepath, name){
        var i, l, nodes = $xmlns(xmlNode, "style", apf.ns.aml), tnode, node;
        for (i = 0, l = nodes.length; i < l; i++) {
            node = nodes[i];

            if (node.getAttribute("src"))
                this.loadStylesheet(node.getAttribute("src").replace(/src/, basepath + "/src"));
            else {
                var test = true;
                if (node.getAttribute("condition")) {
                    try {
                        test = eval(node.getAttribute("condition"));
                    }
                    catch (e) {
                        test = false;
                    }
                }

                if (test) {
                    //#-ifndef __PROCESSED
                    tnode = node.firstChild;
                    while (tnode) {
                        this.css.push(tnode.nodeValue);
                        tnode = tnode.nextSibling;
                    }
                    /*#-else
                    this.css.push(nodes[i].firstChild.nodeValue);
                    #-endif*/
                }
            }
        }

        nodes = $xmlns(xmlNode, "alias", apf.ns.apf);
        var t = this.skins[name].templates;
        for (i = 0; i < nodes.length; i++) {
            if (!nodes[i].firstChild)
                continue;
            t[nodes[i].firstChild.nodeValue.toLowerCase()] = xmlNode;
        }
    },

    loadedCss : "",
    purgeCss: function(imagepath, iconpath){
        if (!this.css.length)
            return;

        var cssString = this.css.join("\n").replace(/images\//g, imagepath).replace(/icons\//g, iconpath);
        apf.importCssString(cssString);

        

        this.css = [];
    },

    loadCssInWindow : function(skinName, win, imagepath, iconpath){
        this.css = [];
        var name = skinName.split(":");
        var skin = this.skins[name[0]];
        var template = skin.templates[name[1]];
        this.importSkinDef(template, skin.base, skin.name);
        var cssString = this.css.join("\n").replace(/images\//g, imagepath).replace(/icons\//g, iconpath);
        apf.importCssString(cssString);

        this.css = [];
    },

    /* ***********
     Retrieve
     ************/
    setSkinPaths: function(skinName, amlNode){
        skinName = skinName.split(":");
        var name = skinName[0];
        var type = skinName[1];

        
        if (!this.skins[name]) {
            throw new Error(apf.formatErrorString(1076, null,
                "Retrieving Skin",
                "Could not find skin '" + name + "'", amlNode.$aml));
        }
        

        amlNode.iconPath  = this.skins[name].iconPath;
        amlNode.mediaPath = this.skins[name].mediaPath;
    },

    getTemplate: function(skinName, noError){
        skinName = skinName.split(":");
        var name = skinName[0];
        var type = skinName[1];

        if (!this.skins[name]) {
            if (noError)
                return false;
            
            
            throw new Error(apf.formatErrorString(1077, null,
                "Retrieving Template",
                "Could not find skin '" + name + "'"));
            
            
            return false;
        }

        if (!this.skins[name].templates[type])
            return false;

        var skin      = this.skins[name].templates[type];
        var originals = this.skins[name].originals[type];
        if (!originals) {
            originals = this.skins[name].originals[type] = {};

            
            if (!$xmlns(skin, "presentation", apf.ns.aml)[0]) {
                throw new Error(apf.formatErrorString(1078, null,
                    "Retrieving Template",
                    "Missing presentation tag in '" + name + "'"));
            }
            

            var nodes = $xmlns(skin, "presentation", apf.ns.aml)[0].childNodes;
            for (var i = 0; i < nodes.length; i++) {
                if (nodes[i].nodeType != 1) continue;
                originals[nodes[i].baseName || nodes[i][apf.TAGNAME]] = nodes[i];
            }
        }

        /*for (var item in originals) {
            pNodes[item] = originals[item];
        }*/

        return originals;
    },

    getCssString : function(skinName){
        return apf.queryValue($xmlns(this.skins[skinName.split(":")[0]].xml,
            "style", apf.ns.aml)[0], "text()");
    },

    
    
    queue : {},
    waitForSkin : function(skinset, id, callback){
        if (this.skins[skinset])
            return;
        
        (this.queue[skinset] || (this.queue[skinset] = {}))[id] = callback;
        return true;
    },

    
    iconMaps : {},
    addIconMap : function(options){
        this.iconMaps[options.name] = options;
        if (options.size)
            options.width = options.height = options.size;
        else {
            if (!options.width)
                options.width = 1;
            if (!options.height)
                options.height = 1;
        }
    },
    

    setIcon : function(oHtml, strQuery, iconPath){
        if (!strQuery) {
            oHtml.style.backgroundImage = "";
            return;
        }

        if (oHtml.tagName.toLowerCase() == "img") {
            oHtml.setAttribute("src", strQuery
                ? (iconPath || "") + strQuery
                : "");
            return;
        }

        
        var parts = strQuery.split(":"); //@todo apf3.x optimize this
        var map = this.iconMaps[parts[0]];
        if (map) {
            var left, top, coords = parts[1].split(",");
            left = (coords[(map.type == "vertical") ? 1 : 0] || 0) * map.width;
            top  = (coords[(map.type == "vertical") ? 0 : 1] || 0) * map.height;

            oHtml.style.backgroundImage = "url(" + (iconPath || "")
                + map.src + ")";
            oHtml.style.backgroundPosition = ((-1 * left) - map.offset[0])
                + "px " + ((-1 * top) - map.offset[1]) + "px";
        }
        else
        

        //Assuming image url
        {
            
            //@todo check here if it is really a url
            

            oHtml.style.backgroundImage = "url(" + (iconPath || "")
                + strQuery + ")";
        }
    }
};



/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/flow.js)SIZE(70808)TIME(1258476515)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/layout.js)SIZE(75006)TIME(1270937593)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * Takes care of the spatial order of elements within the display area
 * of the browser. Layouts can be saved to xml and loaded again. Window
 * elements are dockable, which means the user can change the layout as he/she
 * wishes. The state of the layout can be saved as xml at any time.
 *
 * Example:
 * This example shows 5 windows which have a layout defined in layout.xml.
 * <code>
 *  <a:appsettings layout="[mdlLayouts::layout[1]]" />
 *  <a:model id="mdlLayouts" src="layout.xml" />
 *  
 *  <a:window title="Main Window" id="b1" />
 *  <a:window title="Tree Window" id="b2" />
 *  <a:window title="Window of Oppertunity" id="b3" />
 *  <a:window title="Small window" id="b4" />
 *  <a:window title="Some Window" id="b5" />
 * </code>
 *
 * This is the layout file containing two layouts (layout.xml).
 * <code>
 *  <layouts>
 *      <layout name="Layout 1" margin="2,2,2,2">
 *          <vbox edge="splitter">
 *              <node name="b1" edge="2"/>
 *              <hbox edge="2">
 *                  <vbox weight="1">
 *                      <node name="b2"/>
 *                      <node name="b3"/>
 *                  </vbox>
 *                  <node name="b4" weight="1" />
 *              </hbox>
 *              <node name="b5" height="20" />
 *          </vbox>
 *      </layout>
 *
 *      <layout name="Layout 2">
 *          <vbox edge="splitter">
 *              <node name="b1" edge="2" />
 *              <node name="b2" height="100" />
 *              <hbox edge="2">
 *                  <node name="b3" width="20%" />
 *                  <node name="b4" width="100" />
 *              </hbox>
 *              <node name="b5" height="20" />
 *          </vbox>
 *      </layout>
 *  </layouts>
 * </code>
 *
 * By binding on the layout.xml you can easily create a layout manager.
 * <code>
 *  <a:list id="lstLayouts"
 *    model          = "mdlLayouts"
 *    allowdeselect  = "false"
 *    onafterselect  = "
 *      if(!this.selected || apf.layout.isLoadedXml(this.selected))
 *          return;
 *     
 *      apf.layout.saveXml();
 *      apf.layout.loadXml(this.selected);
 *    "
 *    onbeforeremove = "return confirm('Do you want to delete this layout?')">
 *      <a:bindings>
 *          <a:caption match="[@name]" />
 *          <a:icon value="layout.png" />
 *          <a:each match="[layout]" />
 *      </a:bindings>
 *      <a:actions>
 *          <a:rename match="[.]" />
 *          <a:remove match="[.]" />
 *      </a:actions>
 *  </a:list>
 *  <a:button
 *    onclick = "
 *      if (!lstLayouts.selected)
 *          return;
 *     
 *      var newLayout = apf.layout.getXml(document.body);
 *      newLayout.setAttribute('name', 'New');
 *      apf.xmldb.appendChild(lstLayouts.selected.parentNode, newLayout);
 *      lstLayouts.select(newLayout, null, null, null, null, true);
 *      apf.layout.loadXml(newLayout);
 *      lstLayouts.startRename();
 *    ">
 *    Add Layout
 *  </a:button>
 * </code>
 *
 * @default_private
 * @todo a __WITH_DOM_REPARENTING should be added which can remove many of the functions of this element.
 */
apf.layout = {
    
    layouts : {},

    addParent : function(oHtml, pMargin){
        var id;
        if (!(id = oHtml.getAttribute("id")))
            id = apf.setUniqueHtmlId(oHtml);

        return this.layouts[id] = {
            layout   : new apf.layoutParser(oHtml, pMargin),
            controls : []
        };
    },

    

    
    splitters     : {},
    freesplitters : [],
    vars          : {},

    getSplitter : function(layout){
        if (!this.splitters[this.getHtmlId(layout.parentNode)])
            this.splitters[this.getHtmlId(layout.parentNode)] = [];

        if (this.freesplitters.length){
            var splitter = this.freesplitters.pop();
        }
        else {
            var splitter = new apf.splitter();//this.parentNode
            var o = apf.findHost(layout.parentNode) || apf.document.documentElement;
            splitter.parentNode = o;
            splitter.skinset = apf.getInheritedAttribute(o, "skinset"); //@todo use skinset here. Has to be set in presentation
            splitter.dispatchEvent("DOMNodeInsertedIntoDocument");//{relatedParent : nodes[j].parentNode}
        }

        this.splitters[this.getHtmlId(layout.parentNode)].push(splitter);

        return splitter;
    },

    clearSplitters : function(layout){
        var ar = this.splitters[this.getHtmlId(layout.parentNode)];
        if (!ar) return;

        for (var i = 0; i < ar.length; i++) {
            this.freesplitters.push(ar[i]);
            if (!ar[i].$ext.parentNode) continue;

            ar[i].$ext.parentNode.removeChild(ar[i].$ext);
        }
        ar.length = 0;
    },
    

    

    get : function(oHtml, pMargin){
        var layout = this.layouts[oHtml.getAttribute("id")];
        if (!layout)
            layout = this.addParent(oHtml, pMargin);
        return layout;
    },

    /**
     * Determines whether an xmlNode is of the layout that's currently loaded
     * @param {XMLElement} xmlNode the xml layout description node.
     */
    isLoadedXml : function(xmlNode){
        var nodes   = xmlNode.childNodes;
        var node    = xmlNode.selectSingleNode(".//node[@name]");//was node()
        var amlNode = node ? self[node.getAttribute("name")] : null;

        
        if (!amlNode) {
            throw new Error(apf.formatErrorString(0, null,
                "Loading Alignment from XML",
                "Could not find AML node" + (node ? " by name '"
                + node.getAttribute("name") + "'" : ""), xmlNode));
        }
        

        var pNode = amlNode.$ext.parentNode;
        var pId   = this.getHtmlId(pNode);

        return (this.loadedXml[pId] == xmlNode);
    },

    /**
     * Loads a layout using a data instruction.
     * Example:
     * <code>
     *  apf.layout.$loadFrom(%[mdlLayout::layout[1]]);
     * </code>
     * Remarks:
     * The aml elements referenced in the layout definition should exist when
     * this function is called.
     * @param {String} instruction the {@link term.datainstruction data instruction} specifying where to load the data from.
     */
    $loadFrom : function(instruction){
        apf.getData(instruction, {callback: function(xmlNode){
            if (!xmlNode) return;

            
            if (!xmlNode) {
                throw new Error(apf.formatErrorString(0, null,
                    "Loading default layout",
                    "Could not find default layout using processing \
                     instruction: '" + instruction + "'"));

                return;
            }
            

            apf.layout.loadXml(xmlNode);
        }});
    },

    loadedXml : {},
    cacheXml  : {},
    /**
     * Loads a layout from an xml element.
     * Remarks:
     * The aml elements referenced in the layout definition should exist when
     * this function is called.
     * @param {XMLElement} xmlNode the xml element containing the layout description.
     */
    loadXml   : function(xmlNode){
        var nodes   = xmlNode.childNodes;
        var node    = xmlNode.selectSingleNode(".//node[@name]");//was node()
        var amlNode = node ? self[node.getAttribute("name")] : null;

        
        if(!amlNode) {
            throw new Error(apf.formatErrorString(0, null,
                "Loading Alignment from XML",
                "Could not find AML node" + (node ? " by name '"
                + node.getAttribute("name") + "'" : ""), xmlNode));
        }
        

        var pNode   = amlNode.$ext.parentNode;
        var layout  = this.get(pNode, apf.getBox(xmlNode.getAttribute("margin") || ""));
        var pId     = this.getHtmlId(pNode);

        this.metadata = [];

        for (var i = 0; i < nodes.length; i++) {
            if (nodes[i].nodeType != 1) continue;

            layout.root = this.parseXml(nodes[i], layout);
            break;
        }

        this.compile(pNode);
        if (apf.window.inited)
            this.activateRules(pNode);

        this.loadedXml[pId] = xmlNode;
    },

    metadata : [],
    getData  : function(type, layout){
        return {
            vbox        : (type == "vbox"),
            hbox        : (type == "hbox"),
            node        : "vbox|hbox".indexOf(type) == -1,
            children    : [],
            isRight     : false,
            isBottom    : false,
            edgeMargin  : 0,
            splitter    : null,
            minwidth    : 0,
            minheight   : 0,
            weight      : 1,
            pHtml       : layout.parentNode,
            size        : [300,200],
            position    : [0,0],
            last        : {},

            
            toString    : function(){
                var me = apf.vardump(this, null, false);
                for (var i = 0; i < this.children.length; i++) {
                    me += "\n{Child " + i + "\n===========\n"
                          + this.children[i].toString() + "}";
                }

                return me;
            },
            

            copy : function(){
                var copy = apf.extend({}, this);
                
                copy.toString = this.toString;
                

                if (!this.node) {
                    copy.children = [];
                    for (var i = 0; i < this.children.length; i++) {
                        copy.children[i] = this.children[i].copy();
                        copy.children[i].parent = copy;
                    }
                }
                return copy;
            },

            

            hidden         : false,
            hiddenChildren : [],
            prehide        : function(adminOnly){
                if (this.hidden == 3) {
                    this.hidden = true;
                    if (this.hid)
                        apf.lookup(this.hid).visible = false;
                    if (this.oHtml)
                        this.oHtml.style.display = "none";
                    return;
                }

                if (this.hidden && !adminOnly)
                    return;

                if (!this.parent)
                    return; //I think we're done here...

                //Record current position
                this.hidepos = {
                    prev : this.parent.children[this.stackId - 1],
                    next : this.parent.children[this.stackId + 1]
                }

                this.hidden = true;

                //Check if parent is empty
                var nodes, child, c = 0, i, l, sets = ["children", "hiddenChildren"];
                while(sets.length) {
                    nodes = this.parent[sets.pop()];
                    for (i = 0, l = nodes.length; i < l; i++) {
                        child = nodes[i];
                        if (child != this && !child.hidden) { // || apf.layout.dlist.contains(child)
                            c = 1;
                            break;
                        }
                    }
                }
                if (!c)
                    this.parent.prehide(adminOnly);

                if (adminOnly)
                    return this.hide(true);
                
                if (apf.layout.dlist.contains(this)) {
                    apf.layout.dlist.remove(this);
                    return false;
                }
                else
                    apf.layout.dlist.pushUnique(this);
            },
            preshow : function(adminOnly){
                if (!this.hidden)
                    return;

                this.hidden = false;

                if (adminOnly)
                    return this.show(true);

                //Check if parent is shown
                if (this.parent.hidden) // || apf.layout.dlist.contains(this.parent) @todo please make hidden a 4 state property
                    this.parent.preshow();

                if (apf.layout.dlist.contains(this)) {
                    apf.layout.dlist.remove(this);
                    return false;
                }
                else
                    apf.layout.dlist.pushUnique(this);
            },

            hide : function(adminOnly){
                //Remove from parent
                var nodes = this.parent.children;
                nodes.removeIndex(this.stackId);
                for (var i = 0; i < nodes.length; i++)
                    nodes[i].stackId = i;

                //Add to hidden
                this.parent.hiddenChildren.push(this);

                if (adminOnly)
                    return;

                if (this.hidden != 3) {
                    if (this.hid)
                        apf.lookup(this.hid).visible = false;
                    if (this.oHtml)
                        this.oHtml.style.display = "none";
                }
            },

            show : function(adminOnly){
                //Check if position is still available
                var nodes = this.parent.children;
                if (this.hidepos.prev && this.hidepos.prev.parent == this.parent
                  && !this.hidepos.prev.hidden && !apf.layout.dlist.contains(this.hidepos.prev)) { //@todo please make hidden a 4 state property
                    if (nodes.length < this.hidepos.prev.stackId+ 1 )
                        nodes.push(this);
                    else
                        nodes.insertIndex(this, this.hidepos.prev.stackId + 1);
                }
                else if (this.hidepos.next && this.hidepos.next.parent == this.parent
                  && !this.hidepos.next.hidden && !apf.layout.dlist.contains(this.hidepos.next)) { //@todo please make hidden a 4 state property
                    if (this.hidepos.next.stackId == 0)
                        nodes.unshift(this);
                    else if (nodes.length < this.hidepos.next.stackId - 1)
                        nodes.push(this);
                    else
                        nodes.insertIndex(this, this.hidepos.next.stackId - 1);
                }
                else if (!this.hidepos.prev) {
                    nodes.unshift(this);
                }
                else if(!this.hidepos.next) {
                    nodes.push(this);
                }
                else {
                    if (this.stackId < nodes.length)
                        nodes.insertIndex(this, this.stackId);
                    else
                        nodes.push(this);
                }

                for (var i = 0; i < nodes.length; i++)
                    if (nodes[i])
                        nodes[i].stackId = i;

                //Remove from hidden
                this.parent.hiddenChildren.remove(this);

                if (!adminOnly) {
                    if (this.hidden != 3) {
                        if (this.hid)
                            apf.lookup(this.hid).visible = true;
                        if (this.oHtml)
                            this.oHtml.style.display = "block";
                    }
                }

                this.hidden  = false;
                this.hidepos = null;
            },

            remove : function(){
                var p = this.parent;
                if (!p)
                    return;

                if (this.hidden || p.hiddenChildren.contains(this)) {
                    p.hiddenChildren.remove(this);
                    apf.layout.dlist.remove(this);
                }
                else {
                    var nodes = p.children;
                    nodes.remove(this);

                    for (var i = 0; i < nodes.length; i++)
                        nodes[i].stackId = i;
                }

                for (var prop in this.last) {
                    if (prop == "splitter") {
                        if (p.originalMargin) {
                            if (p.parent.pOriginalMargin) {
                                p.parent.splitter       = null;
                                p.parent.edgeMargin     = p.parent.pOriginalMargin[0];
                                p.parent.pOriginalMargin = null;
                                delete p.last.splitter;
                            }

                            p.splitter       = null;
                            p.edgeMargin     = p.originalMargin[0];
                            p.originalMargin = null;
                        }
                    }

                    this[prop] = p[prop] || this.last[prop];
                }
                this.last = {};

                if (!p.children.length && !p.hiddenChildren.length)
                    p.remove();

                this.parent = null;
            },

            add : function(parent){
                this.parent = parent;

                if (this.hidden) {
                    var nodes = parent.hiddenChildren;
                    nodes.push(this);
                    //clear stack id?
                }
                else {
                    var nodes = parent.children;
                    nodes.push(this);

                    for (var i = 0; i < nodes.length; i++) {
                        if (nodes[i])
                            nodes[i].stackId = i;
                    }
                }
            }
        };
    },

    //@todo rewrite this. Layout seperate from markup should not be stored in xml but in CSS.
    parseXml : function(x, layout, amlNode, norecur){
        var aData = this.getData(typeof amlNode == "string"
            ? amlNode
            : x.localName || x[apf.TAGNAME], layout.layout);

        if (aData.node) {
            if (!amlNode) {
                amlNode = self[x.getAttribute("name")];
                
                if (!amlNode) {
                    throw new Error(apf.formatErrorString(0, null,
                        "Parsing Alignment from XML",
                        "Could not find AML node" + x.getAttribute("name"), x));
                }
                
            }

            //if (!amlNode.visible)
                //amlNode.show(true);//amlNode.setProperty("visible", true);//not the most optimal position

            aData.oHtml   = amlNode.$ext;
            amlNode.aData = aData;

            //if (!amlNode.hasFeature(apf.__ALIGNMENT__)) {
                /*amlNode.implement(apf.Alignment);
                if (amlNode.hasFeature(apf.__ANCHORING__))
                    amlNode.$disableAnchoring();*/
                
                //amlNode.align = -1;
                amlNode.$setLayout("alignment");
            //}

            var aml = amlNode;
            if (aml.getAttribute("width"))
                aData.fwidth = aml.getAttribute("width");
            if (aml.getAttribute("height"))
                aData.fheight = aml.getAttribute("height");
            /*if (amlNode.minwidth)
                aData.minwidth = amlNode.minwidth;
            if (amlNode.minheight)
                aData.minheight = amlNode.minheight;*/

            if (!this.getHtmlId(aData.oHtml))
                apf.setUniqueHtmlId(aData.oHtml);
            aData.id = this.getHtmlId(aData.oHtml);
            if (aData.oHtml.style)
                aData.oHtml.style.position = "absolute";
            aData.hid = amlNode.$uniqueId;
        }
        else {
            aData.id = this.metadata.push(aData) - 1;
        }

        if (x.getAttribute("align"))
            aData.template = x.getAttribute("align");
        if (x.getAttribute("lean"))
            aData.isBottom = x.getAttribute("lean").match(/bottom/);
        if (x.getAttribute("lean"))
            aData.isRight = x.getAttribute("lean").match(/right/);
        if (x.getAttribute("edge") && x.getAttribute("edge") != "splitter")
            aData.edgeMargin = x.getAttribute("edge");
        if (x.getAttribute("weight"))
            aData.weight = parseFloat(x.getAttribute("weight"));
        if (x.getAttribute("splitter") || x.getAttribute("edge") == "splitter")
            aData.splitter = x.getAttribute("splitter")
                || (x.getAttribute("edge") == "splitter" ? 4 : false);
        if (x.getAttribute("width"))
            aData.fwidth = String(apf.parseExpression(x.getAttribute("width")));
        if (x.getAttribute("height"))
            aData.fheight = String(apf.parseExpression(x.getAttribute("height")));
        //@todo calculate inner minheight en minwidth
        /*if (x.getAttribute("minwidth"))
            aData.minwidth = x.getAttribute("minwidth");*/
        /*if (x.getAttribute("minheight"))
            aData.minheight = x.getAttribute("minheight");
        if (x.getAttribute("lastheight"))
            aData.lastfheight = x.getAttribute("lastheight");*/
        if (x.getAttribute("lastsplitter"))
            aData.lastsplitter = x.getAttribute("lastsplitter");
        if (x.getAttribute("hidden"))
            aData.hidden = (x.getAttribute("hidden") == 3)
                ? x.getAttribute("hidden")
                : apf.isTrue(x.getAttribute("hidden"));
        else if (x.getAttribute("visible") == "false")
            aData.hidden = true;
        if (x.getAttribute("state"))
            aData.state = x.getAttribute("state");
        if (x.getAttribute("stack"))
            aData.stackId = parseInt(x.getAttribute("stack"));
        if (x.getAttribute("position"))
            aData.position = x.getAttribute("position").split(",");
        if (x.getAttribute("size"))
            aData.size = x.getAttribute("size").split(",");

        //@todo Amazing hackery, can we please try to be consistent across all layout methods
        if (aData.fwidth && aData.fwidth.indexOf("/") > -1) {//match(/[\(\)\+\-=\/\*]/)){
            aData.fwidth = eval(aData.fwidth);
            if (aData.fwidth <= 1)
                aData.fwidth = (aData.fwidth * 100) + "%";
        }
        if (aData.fheight && aData.fheight.indexOf("/") > -1) {//.match(/[\(\)\+\-=\/\*]/)){
            aData.fheight = eval(aData.fheight);
            if (aData.fheight <= 1)
                aData.fheight = (aData.fheight * 100) + "%";
        }

        aData.edgeMargin = Math.max(aData.splitter || 0, aData.edgeMargin || 0);

        //guessing this is docking... unsure
        

        aData.xml = x;

        return aData;
    },

    

    checkInheritance : function(node){
        
        var lastNode = node.children[node.children.length - 1];
        if (node.originalMargin) {
            if (node.parent.pOriginalMargin) {
                node.parent.splitter       = null;
                node.parent.edgeMargin     = node.parent.pOriginalMargin[0];
                node.parent.pOriginalMargin = null;
                node.splitter              = node.last.splitter;
                delete node.last.splitter;
            }

            node.splitter       = null;
            var lNode           = node.originalMargin[1];
            node.edgeMargin     = node.originalMargin[0];
            lNode.splitter      = lNode.splitter === false
                                    ? false
                                    : lNode.last.splitter;
            node.originalMargin = null;
            delete lNode.last.splitter;
        }

        if (lastNode && lastNode.template
          && (lastNode.splitter || lastNode.splitter === null
          && node.originalMargin) && node.parent) {
            if (!node.splitter) {
                lastNode.last.splitter =
                node.splitter          = lastNode.splitter;
                node.originalMargin    = [node.edgeMargin, lastNode];
                node.edgeMargin        = Math.max(node.edgeMargin, node.splitter);
            }
            lastNode.splitter = null;

            if (node.parent && node.stackId == node.parent.children.length - 1
              && (node.parent.parent && node.parent.parent.children.length > 1)) {
                if (!node.parent.splitter) {
                    node.last.splitter         =
                    node.parent.splitter       = node.splitter;
                    node.parent.last.splitter  = null;
                    node.parent.edgeMargin     = Math.max(
                        node.parent.edgeMargin, node.parent.splitter);
                    node.parent.pOriginalMargin = [node.parent.edgeMargin];
                }
                node.splitter = null;
            }
            else if (node.parent.pOriginalMargin) {
                node.parent.splitter       = null;
                node.parent.edgeMargin     = node.parent.pOriginalMargin[0];
                node.parent.pOriginalMargin = null;
                node.splitter              = node.last.splitter;
                delete node.last.splitter;
            }
        }
        

        for (var i = 0; i < node.children.length; i++) {
            if (!node.children[i].node)
                this.checkInheritance(node.children[i]);
        }

        var firstNode = node.children[0];
        if (firstNode && node.parent) {
            if (node.vbox) {
                /*
                    Width is inherited when parent doesn't have width or it
                    already inherited it and wasn't set later (and is thus
                    different from cached version (in .last)
                */
                if (!node.fwidth && firstNode.fwidth
                  || firstNode.last.fwidth && firstNode.fwidth !== null
                  && firstNode.last.fwidth == node.fwidth) {
                    firstNode.last.fwidth =
                    node.fwidth           = firstNode.fwidth;
                    firstNode.fwidth      = null;
                }

                //@todo test this with reparenting
                var pNode = node.parent;
                if ((pNode && !pNode.fheight && firstNode.fheight
                  || firstNode.last.fheight && firstNode.fheight !== null
                  && firstNode.last.fheight == pNode.fheight) && node.children.length == 1) {
                    firstNode.last.fheight =
                    pNode.fheight           = firstNode.fheight;
                    firstNode.fheight      = null;
                }
            }
            else {
                /*
                    Height is inherited when parent doesn't have height or it
                    already inherited it and wasn't set later (and is thus
                    different from cached version (in .last)
                */
                if ((!node.fheight && firstNode.fheight
                  || firstNode.last.fheight && firstNode.fheight !== null
                  && firstNode.last.fheight == node.fheight) && node.children.length == 1) {
                    firstNode.last.fheight =
                    node.fheight           = firstNode.fheight;
                    firstNode.fheight      = null;
                }
            }

            //@todo oops parent is always overriden... :(
            if (firstNode.weight || firstNode.last.weight
              && firstNode.last.weight == node.weight) {
                firstNode.last.weight =
                node.weight           = firstNode.weight;
            }
        }
    },

    compileAlignment : function(aData){
        if (!aData.children.length) {
            //All children were removed, we're removing the layout rule
            this.removeRule(aData.pHtml, "layout");

            var l = this.layouts[aData.pHtml.getAttribute("id")];
            
            if (l)
                apf.layout.clearSplitters(l.layout);
            
            return;
        }

        
        var n = aData.children;
        for (var f = false, i = 0; i < n.length; i++) {
            if (n[i].template == "bottom") {
                if (n[i].splitter) {
                    n[i - 1].splitter = n[i].splitter;
                    n[i].splitter = null;
                }

                n[i - 1].edgeMargin = Math.max(n[i].edgeMargin,
                    n[i - 1].edgeMargin || 0, n[i - 1].splitter || 0);
                n[i].edgeMargin = null;
            }
            
            if (n[i].hidden)
                n[i].prehide(true);
        }

        
        this.checkInheritance(aData);
        

        

        //this.compile(aData.pHtml); //oHtml
        var l = this.layouts[aData.pHtml.getAttribute("id")];
        l.layout.compile(aData.copy());
        l.layout.reset();
    },

    
    addAlignNode : function(amlNode, pData){
        var align = (typeof amlNode.align == "undefined"
            ? amlNode.getAttribute("align")
            : amlNode.align).split("-");
        var s = pData.children;
        var a = amlNode.aData;

        if (typeof amlNode.splitter == "undefined") {
            if (align[1] == "splitter")
                a.splitter = align[2] || 4
            else
                a.splitter = false;
        }

        a.edgeMargin = Math.max(a.edgeMargin, a.splitter || 0);
        align = align[0];
        a.template = align;

        if (align == "top") {
            for (var p = s.length, i = 0; i < s.length; i++) {
                if (s[i].template != "top") {
                    p = i;
                    break;
                }
            }
            for (var i = s.length - 1; i >= p; i--) {
                s[i + 1] = s[i];
                s[i].stackId = i + 1;
            }

            s[p] = a;
            s[p].stackId = p;
            a.parent = pData;
        }
        else if (align == "bottom") {
            a.stackId = s.push(a) - 1;
            a.parent = pData;
        }
        else {
            //find hbox
            var hbox = null;
            for (var p = -1, i = 0; i < s.length; i++) {
                if (s[i].hbox) {
                    hbox = s[i];
                    break;
                }
                else if (s[i].node && s[i].template == "top")
                    p = i;
            }

            //create hbox
            if (!hbox) {
                var l = apf.layout.get(pData.pHtml);
                hbox = apf.layout.parseXml(apf.xmldb.getXml("<hbox />"), l, null, true);
                hbox.parent = pData;
                if (p > -1) {
                    for (var i = s.length - 1; i > p; i--) {
                        s[i + 1] = s[i];
                        s[i].stackId++;
                    }
                    s[p + 1] = hbox;
                    hbox.stackId = p + 1;
                }
                else
                    hbox.stackId = s.unshift(hbox) - 1;
            }

            //find col
            var col, n = hbox.children.concat(hbox.hiddenChildren);
            for (var i = 0; i < n.length; i++) {
                if (n[i].template == align) {
                    col = n[i];
                    break;
                }
            }

            n = hbox.children;
            //create col
            if (!col) {
                var l = apf.layout.get(pData.pHtml);
                col = apf.layout.parseXml(apf.xmldb.getXml("<vbox />"), l, null, true);
                col.parent = hbox;
                col.template = align;

                if (align == "left") {
                    if (!a.fwidth) {
                        var ncol;
                        for (var found = false, i = 0; i < n.length; i++) {
                            if (n[i].template == "middle") {
                                found = n[i];
                                break;
                            }
                        }

                        if (found && !found.children.length) {
                            n.remove(found);
                            for(var i = 0; i < n.length; i++)
                                n[i].stackId = i;
                        }
                    }

                    n.unshift(col);
                    for (var i = 0; i < n.length; i++)
                        n[i].stackId = i;
                }
                else if (align == "right") {
                    if (a.fwidth) {
                        var ncol;
                        for (var found = false, i = 0; i < n.length; i++) {
                            if (n[i].template == "middle" || n[i].template == "left" && !n[i].fwidth) {
                                found = true;
                                break;
                            }
                        }

                        //create middle layer if none is specified
                        if (!found) {
                            ncol = apf.layout.parseXml(apf.xmldb.getXml("<vbox />"), l, null, true);
                            ncol.parent = hbox;
                            ncol.template = "middle";

                            ncol.stackId = n.push(ncol) - 1;
                        }
                    }

                    col.stackId = n.push(col) - 1;
                }
                else if (align == "middle") {
                    for (var f, i = 0; i < n.length; i++)
                        if (n[i].template == "right")
                            f = i;
                    var rcol = n[f];
                    if (rcol) {
                        n[f] = col;
                        col.stackId = f;
                        rcol.stackId = n.push(rcol) - 1;
                    }
                    else {
                        col.stackId = n.push(col) - 1;
                    }
                }
            }

            a.stackId = col.children.push(a) - 1;
            a.parent = col;

            if (col.hidden) {
                col.preshow(true);
            }
        }
    },
    

    compile : function(oHtml){
        var l = this.layouts[oHtml.getAttribute("id")];
        if (!l) return false;

        var root = l.root.copy();//is there a point to copying?
        
        l.layout.compile(root);
        l.layout.reset();
    },

    removeAll : function(aData) {
        aData.children.length = null
        this.compileAlignment(aData);

        var htmlId = this.getHtmlId(aData.pHtml);
        if (!this.rules[htmlId])
            delete this.qlist[htmlId];
    },

    
    
    

    timer : null,
    qlist : {},
    dlist : [],
    $hasQueue : false,
    
    queue : function(oHtml, obj, compile){
        this.$hasQueue = true;
        
        var id;
        if (!(id = this.getHtmlId(oHtml)))
            id = apf.setUniqueHtmlId(oHtml);
            
        if (this.qlist[id]) {
            if (obj)
                this.qlist[id][2].push(obj);
            if (compile)
                this.qlist[id][1] = compile;
            return;
        }

        this.qlist[id] = [oHtml, compile, [obj]];

        if (!this.timer)
            this.timer = $setTimeout("apf.layout.processQueue()");
    },

    processQueue : function(){
        var i, id, l, qItem, list;

        for (i = 0; i < this.dlist.length; i++) {
            if (this.dlist[i].hidden)
                this.dlist[i].hide();
            else
                this.dlist[i].show();
        }

        do {
            var qlist = this.qlist;
            this.qlist = {};
            
            this.$hasQueue = false;
            
            for (id in qlist) {
                qItem = qlist[id];
    
                if (qItem[1])
                    apf.layout.compileAlignment(qItem[1]);
    
                list = qItem[2];
                for (i = 0, l = list.length; i < l; i++) {
                    if (list[i])
                        list[i].$updateLayout();
                }
    
                apf.layout.activateRules(qItem[0]);
            }
        } while (this.$hasQueue);
        
        if (apf.hasSingleRszEvent)
            apf.layout.forceResize();

        this.dlist = [];
        
        clearTimeout(this.timer);
        this.timer = null;
    },
    
    

    rules     : {},
    onresize  : {},

    getHtmlId : function(oHtml){
        //if(apf.hasSingleRszEvent) return 1;
        //else
        return oHtml.getAttribute ? oHtml.getAttribute("id") : 1;
    },

    /**
     * Adds layout rules to the resize event of the browser. Use this instead
     * of onresize events to add rules that specify determine the layout.
     * @param {HTMLElement} oHtml       the element that triggers the execution of the rules.
     * @param {String}      id          the identifier for the rules within the resize function of this element. Use this to easily update or remove the rules added.
     * @param {String}      rules       the javascript code that is executed when the html element resizes.
     * @param {Boolean}     [overwrite] whether the rules are added to the resize function or overwrite the previous set rules with the specified id.
     */
    setRules : function(oHtml, id, rules, overwrite){
        if (!this.getHtmlId(oHtml))
            apf.setUniqueHtmlId(oHtml);
        if (!this.rules[this.getHtmlId(oHtml)])
            this.rules[this.getHtmlId(oHtml)] = {};

        var ruleset = this.rules[this.getHtmlId(oHtml)][id];
        if (!overwrite && ruleset) {
            this.rules[this.getHtmlId(oHtml)][id] = rules + "\n" + ruleset;
        }
        else
            this.rules[this.getHtmlId(oHtml)][id] = rules;
    },

    /**
     * Retrieves the rules set for the resize event of an html element specified by an identifier
     * @param {HTMLElement} oHtml       the element that triggers the execution of the rules.
     * @param {String}      id          the identifier for the rules within the resize function of this element.
     */
    getRules : function(oHtml, id){
        return id
            ? this.rules[this.getHtmlId(oHtml)][id]
            : this.rules[this.getHtmlId(oHtml)];
    },

    /**
     * Removes the rules set for the resize event of an html element specified by an identifier
     * @param {HTMLElement} oHtml       the element that triggers the execution of the rules.
     * @param {String}      id          the identifier for the rules within the resize function of this element.
     */
    removeRule : function(oHtml, id){
        var htmlId = this.getHtmlId(oHtml);
        if (!this.rules[htmlId])
            return;

        var ret = this.rules[htmlId][id] ||  false;
        delete this.rules[htmlId][id];

        var prop;
        for (prop in this.rules[htmlId]) {

        }
        if (!prop)
            delete this.rules[htmlId]

        if (apf.hasSingleRszEvent) {
            if (this.onresize[htmlId])
                this.onresize[htmlId] = null;
            else {
                var p = oHtml.parentNode;
                while (p && p.nodeType == 1 && !this.onresize[p.getAttribute("id")]) {
                    p = p.parentNode;
                }
    
                if (p && p.nodeType == 1) {
                    var x = this.onresize[p.getAttribute("id")];
                    if (x.children)
                        delete x.children[htmlId]
                }
            }
        }
        
        return ret;
    },

    /**
     * Activates the rules set for an html element
     * @param {HTMLElement} oHtml       the element that triggers the execution of the rules.
     */
    activateRules : function(oHtml, no_exec){
        if (!oHtml) { //!apf.hasSingleRszEvent &&
            var prop, obj;
            for(prop in this.rules) {
                obj = document.getElementById(prop);
                if (!obj || obj.onresize) // || this.onresize[prop]
                    continue;
                this.activateRules(obj);
            }

             if (apf.hasSingleRszEvent && window.onresize)
                window.onresize();
            return;
        }

        var rsz, id, rule, rules, strRules = [];
        if (!apf.hasSingleRszEvent) {
            rules = this.rules[this.getHtmlId(oHtml)];
            if (!rules){
                oHtml.onresize = null;
                return false;
            }

            for (id in rules) { //might need optimization using join()
                if (typeof rules[id] != "string")
                    continue;
                strRules.push(rules[id]);
            }

            //apf.console.info(strRules.join("\n"));
            rsz = apf.needsCssPx
                ? new Function(strRules.join("\n"))
                : new Function(strRules.join("\n").replace(/ \+ 'px'|try\{\}catch\(e\)\{\}\n/g,""))

            oHtml.onresize = rsz;
            if (!no_exec)
                rsz();
        }
        else {
            var htmlId = this.getHtmlId(oHtml);
            rules = this.rules[htmlId];
            if (!rules){
                //@todo keep .children
                //delete this.onresize[htmlId];
                return false;
            }

            for (id in rules) { //might need optimization using join()
                if (typeof rules[id] != "string")
                    continue;
                strRules.push(rules[id]);
            }
            
            var p = oHtml.parentNode;
            while (p && p.nodeType == 1 && !this.onresize[p.getAttribute("id")]) {
                p = p.parentNode;
            }

            var f = new Function(strRules.join("\n"));//.replace(/try\{/g, "").replace(/}catch\(e\)\{\s*\}/g, "\n")
            if (this.onresize[htmlId])
                f.children = this.onresize[htmlId].children;
                
            if (p && p.nodeType == 1) {
                var x = this.onresize[p.getAttribute("id")];
                (x.children || (x.children = {}))[htmlId] = f;
            }
            else this.onresize[htmlId] = f;
            if (!no_exec)
                f();

            if (!window.onresize) {
                /*var f = apf.layout.onresize;
                window.onresize = function(){
                    var s = [];
                    for (var name in f)
                        s.unshift(f[name]);
                    for (var i = 0; i < s.length; i++)
                        s[i]();
                }*/
                
                var rsz = function(f){
                    //@todo fix this
                    try{
                        var c = [];
                        for (var name in f)
                            c.unshift(f[name]);
                        for (var i = 0; i < c.length; i++){
                            c[i]();
                            if (c[i].children) {
                                rsz(c[i].children);
                            }
                        }
                    }
                    catch(e){
                        
                    }
                }
                
                window.onresize = function(){
                    rsz(apf.layout.onresize);
                }
            }
        }
    },

    /**
     * Forces calling the resize rules for an html element
     * @param {HTMLElement} oHtml  the element for which the rules are executed.
     */
    forceResize : function(oHtml){
        if (apf.hasSingleRszEvent)
            return window.onresize && window.onresize();

        /* @todo this should be done recursive, old way for now
        apf.hasSingleRszEvent
            ? this.onresize[this.getHtmlId(oHtml)]
            :
        */

        var rsz = oHtml.onresize;
        if (rsz)
            rsz();

        var els = oHtml.getElementsByTagName("*");
        for (var i = 0, l = els.length; i < l; i++) {
            if (els[i].onresize)
                els[i].onresize();
        }
    },

    paused : {},

    /**
     * Disables the resize rules for the html element temporarily.
     * @param {HTMLElement} oHtml  the element for which the rules are paused.
     * @param {Function}    func   the resize code that is used temporarily for resize of the html element.
     */
    pause  : function(oHtml, replaceFunc){
        if (apf.hasSingleRszEvent) {
            var htmlId = this.getHtmlId(oHtml);
            this.paused[htmlId] = this.onresize[htmlId] || true;

            if (replaceFunc) {
                this.onresize[htmlId] = replaceFunc;
                this.onresize[htmlId].children = this.paused[htmlId].children;
                replaceFunc();
            }
            else
                delete this.onresize[htmlId];
        }
        else {
            this.paused[this.getHtmlId(oHtml)] = oHtml.onresize || true;

            if (replaceFunc) {
                oHtml.onresize = replaceFunc;
                replaceFunc();
            }
            else
                oHtml.onresize = null;
        }
    },

    /**
     * Enables paused resize rules for the html element
     * @param {HTMLElement} oHtml  the element for which the rules have been paused.
     */
    play : function(oHtml){
        if (!this.paused[this.getHtmlId(oHtml)])
            return;

        if (apf.hasSingleRszEvent) {
            var htmlId = this.getHtmlId(oHtml);
            var oldFunc = this.paused[htmlId];
            if (typeof oldFunc == "function") {
                this.onresize[htmlId] = oldFunc;
                //oldFunc();
            }
            else
                delete this.onresize[htmlId];

            if (window.onresize)
                window.onresize();

            this.paused[this.getHtmlId(oHtml)] = null;
        }
        else {
            var oldFunc = this.paused[this.getHtmlId(oHtml)];
            if (typeof oldFunc == "function") {
                oHtml.onresize = oldFunc;
                oldFunc();
            }
            else
                oHtml.onresize = null;

            this.paused[this.getHtmlId(oHtml)] = null;
        }
    }
};
apf.layout.load = apf.layout.loadXml;//@todo temp need to rename




/**
 * @private
 */
apf.getWindowWidth = function(){
    return apf.isIE ? document.documentElement.offsetWidth - apf.windowHorBorder : window.innerWidth;
}
/**
 * @private
 */
apf.getWindowHeight = function(){
    return apf.isIE ? document.documentElement.offsetHeight - apf.windowVerBorder : window.innerHeight;
}

/**
 * @constructor
 * @private
 */
apf.layoutParser = function(parentNode, pMargin){
    pMargin  = (pMargin && pMargin.length == 4) ? pMargin : [0, 0, 0, 0];
    this.pMargin = pMargin;
    this.RULES   = [];

    this.parentNode = parentNode;

    if (!this.parentNode.getAttribute("id"))
        apf.setUniqueHtmlId(this.parentNode);

    var knownVars        = {};
    var minWidth         = 0;
    var minHeight        = 0;
    this.createSplitters = true;

    this.setMargin = function(sMargin){
        pMargin = sMargin;
    };

    this.reset = function(){
        this.RULES = [];
        knownVars  = {};
        this.lastType = this.globalEdge = this.globalSplitter = null;
    };

    this.compile = function(root, noapply){
        this.addRule("var v = apf.layout.vars");

        this.globalSplitter = root.splitter;
        this.globalEdge     = root.edgeMargin;

        if (this.globalSplitter || this.globalEdge)
            this.setglobals(root);

        this.preparse(root);
        this.parserules(root);
        
        if (this.createSplitters) {
            apf.layout.clearSplitters(this);
            this.parsesplitters(root);
        }
        
        //Sort by checking dependency structure
        this.RULES = new DepTree().calc(this.RULES);
        var str = ("try{" + this.RULES.join("}catch(e){}\ntry{") + "}catch(e){}\n")
            .replace(/([^=]+\.style[^=]+) = (.*?)\}/g, "$1 = ($2) + 'px'}");

        if (!apf.hasHtmlIdsInJs) //@todo speed?
            str = str.replace(/q([\w|]+)\.(offset|style)/g, 'document.getElementById("q$1").$2');

        //optimization
        //if(this.parentNode != document.body)
            //"if(document.getElementById('" + this.parentNode.id + "').offsetHeight){" + str + "};";

        this.lastRoot = root;

        if (!noapply) {
            apf.layout.setRules(this.parentNode, "layout", str, true);
            apf.layout.queue(this.parentNode);
        }
        else
            return str;

        return false;
    };

    this.addRule = function(rule){
        this.RULES.push(rule);
    };

    this.setglobals = function(node, isLast){
        if (!isLast && this.globalEdge && !node.edgeMargin 
          && (!node.xml || !node.xml.getAttribute("edge"))) {
            if (!node.splitter)
                node.splitter = this.globalSplitter;
            node.edgeMargin = Math.max(this.globalSplitter, this.globalEdge);
        }

        if (node.node) return;

        for (var i = 0; i < node.children.length; i++) {
            this.setglobals(node.children[i], i == node.children.length - 1);
        }
    };

    this.preparse = function(node){
        /*
            Define:
            - minwidth
            - minheight
            - calcheight
            - calcwidth
            - restspace
            - innerspace
        */

        if (node.node) {
            return;
        }
        else {
            var type            = node.vbox ? "height" : "width";
            var cmhwp           = 0;
            var cmwwp           = 0;
            var ctph            = 0;
            //Calculate resultSpace
            node.childweight    = 0;
            node.childminwidth  = 0;
            node.childminheight = 0;
            var rules           = ["v." + type + "_" + node.id], extra = [];
            var nodes           = node.children;

            for (var i = 0; i < nodes.length; i++) {
                if (i < nodes.length-1)
                    rules.push(" - " + nodes[i].edgeMargin);
                var f = nodes[i]["f" + type];
                if (f) {
                    //if(f.indexOf("%") > -1) ctph += parseFloat(f);

                    extra.push(
                        (f.indexOf("%") > -1)
                            ? " - (" + (nodes[i]["calc" + type] = "v.innerspace_"
                                + node.id + " * " + parseFloat(f)/100) + ")"
                            : " - (" + f + ")"
                    );
                }
                else {
                    node.childweight += nodes[i].weight;
                    nodes[i]["calc" + type] = "Math." + (i%2 == 0 ? "ceil" : "floor")
                        + "(v.restspace_" + node.id + " * (" + nodes[i].weight
                        + "/v.weight_" + node.id + "))";
                }

                var g = (node.vbox ? "width" : "height");
                var v = nodes[i]["f" + g];
                if (!v)
                    nodes[i]["calc" + g] = (node.vbox ? "v.width_" : "v.height_")
                        + node.id;
                else
                    nodes[i]["calc" + g] = v.indexOf("%") > -1 ? "v.innerspace_"
                        + node.id + " * " + parseFloat(v)/100 : v

                if (nodes[i].node && nodes[i].xml.visible !== false)
                    nodes[i].oHtml.style.display = "block";
                else
                    this.preparse(nodes[i]);

                if (node.vbox) {
                    /*if(!nodes[i].fheight){
                        cmhwp = Math.max(cmhwp, Math.max(nodes[i].childminheight || 0, nodes[i].minheight || 0, 10)/nodes[i].weight);
                        node.childminheight += nodes[i].edgeMargin;
                    }
                    else */
                    node.childminheight += Math.max(nodes[i].childminheight || 0,
                        nodes[i].minheight || 0, 10) + nodes[i].edgeMargin;
                    node.childminwidth   = Math.max(node.childminwidth,
                        nodes[i].minwidth || nodes[i].childminwidth || 10);
                }
                else {
                    /*if(!nodes[i].fwidth){
                        cmwwp = Math.max(cmwwp, Math.max(nodes[i].childminwidth || 0, nodes[i].minwidth || 0, 10)/nodes[i].weight);
                        node.childminwidth += nodes[i].edgeMargin;
                    }
                    else */
                    node.childminwidth += Math.max(nodes[i].minwidth || 0,
                        nodes[i].childminwidth || 0, 10) + nodes[i].edgeMargin;
                    node.childminheight = Math.max(node.childminheight,
                        nodes[i].minheight || nodes[i].childminheight || 10);
                }
            }

            /*if (node.vbox) {
                if (cmhwp) {
                    if (ctph)
                        node.childminheight += (cmhwp * node.childweight / (100 - ctph)) * ctph;
                    node.childminheight += cmhwp * node.childweight;
                }
            } else {
                if (cmwwp) {
                    if (ctph)
                        node.childminwidth += (cmwwp * node.childweight / (100 - ctph)) * ctph;
                    node.childminwidth += cmwwp * node.childweight;
                }
            }*/

            node.innerspace = rules.join("");
            node.restspace  = node.innerspace + " " + extra.join("");

            if (!node.parent) {
                var hordiff = 0, verdiff = 0;
                if (this.parentNode.tagName.toLowerCase() != "body") {
                    var diff    = apf.getDiff(this.parentNode);
                    verdiff = diff[0];
                    hordiff = diff[1];
                }

                var strParentNodeWidth  = (this.parentNode.tagName.toLowerCase() == "body"
                    ? "apf.getWindowWidth()"
                    : "document.getElementById('" + this.parentNode.id + "').offsetWidth");
                var strParentNodeHeight = (this.parentNode.tagName.toLowerCase() == "body"
                    ? "apf.getWindowHeight()"
                    : "document.getElementById('" + this.parentNode.id + "').offsetHeight");
                node.calcwidth  = "Math.max(" + minWidth + ", " + strParentNodeWidth
                    + " - " + (pMargin[1]) + " - " + pMargin[3] + " - " + hordiff + ")";
                node.calcheight = "Math.max(" + minHeight + ", " + strParentNodeHeight
                    + " - " + (pMargin[2]) + " - " + pMargin[0] + " - " + verdiff + ")";
            }
        }
    };

    this.parserules = function(oItem){
        if (!oItem.node) {
            this.addRule("v.width_" + oItem.id + " = Math.max(" + oItem.childminwidth
                + "," + oItem.minwidth + "," + (oItem.calcwidth || oItem.fwidth) + ")");
            this.addRule("v.height_" + oItem.id + " = Math.max(" + oItem.childminheight
                + "," + oItem.minheight + "," + (oItem.calcheight || oItem.fheight) + ")");
            this.addRule("v.weight_" + oItem.id + " = " + oItem.childweight);
            this.addRule("v.innerspace_" + oItem.id + " = " + oItem.innerspace);
            this.addRule("v.restspace_" + oItem.id + " = " + oItem.restspace);

            var aData = apf.layout.metadata[oItem.id];
            aData.calcData = oItem;
            oItem.original = aData;

            if (!oItem.parent) {
                this.addRule("v.left_" + oItem.id + " = " + pMargin[3]);
                this.addRule("v.top_"  + oItem.id + " = " + pMargin[0]);

                for (var i = 0; i < oItem.children.length; i++)
                    this.parserules(oItem.children[i]);

                return;
            }
            else {
                var vtop  = ["v.top_"  + oItem.id, " = "];
                var vleft = ["v.left_" + oItem.id, " = "];
            }
        }
        else {
            var vtop  = [oItem.id, ".style.top = "];
            var vleft = [oItem.id, ".style.left = "];

            if (oItem.hid) {
                var aData = apf.lookup(oItem.hid).aData;
                aData.calcData = oItem;
                oItem.original = aData;
            }

            var oEl     = oItem.oHtml;//document.getElementById(oItem.id);
            var diff    = apf.getDiff(oEl);
            var verdiff = diff[1];
            var hordiff = diff[0];

            if (oItem.calcwidth)
                this.addRule(oItem.id + ".style.width = -" + hordiff
                    + " + Math.max( " + oItem.calcwidth + ", " + oItem.minwidth + ")");
            else
                oEl.style.width = Math.max(0, oItem.fwidth - hordiff) + "px";

            if (oItem.calcheight)
                this.addRule(oItem.id + ".style.height = -" + verdiff
                    + " + Math.max( " + oItem.calcheight + ", " + oItem.minheight + ")");
            else
                oEl.style.height = Math.max(0, oItem.fheight - verdiff) + "px";
        }

        var oLastSame = oItem.parent.children[oItem.stackId - 1];
        var oNextSame = oItem.parent.children[oItem.stackId + 1];

        //TOP
        if (oItem.parent.vbox) {
            if (oItem.parent.isBottom) {
                if (!oNextSame)
                    vtop.push("v.top_", oItem.parent.id, " + v.height_",
                        oItem.parent.id, " - ", oItem.id, ".offsetHeight");
                else {
                    if (oNextSame.node)
                        vtop.push(oNextSame.id, ".offsetTop - ", oNextSame.edgeMargin,
                            " - ", oItem.id, ".offsetHeight");
                    else
                        vtop.push("v.top_" + oNextSame.id, " - ", oNextSame.edgeMargin,
                            " - ", (oItem.node ? oItem.id + ".offsetHeight" : "v.height_" + oItem.id));
                }
            }
            else if (!oItem.stackId)
                vtop.push("v.top_" + oItem.parent.id);
            else if (oLastSame) {
                if (oLastSame.node)
                    vtop.push(oLastSame.id, ".offsetTop + ", oLastSame.id,
                        ".offsetHeight + ", oLastSame.edgeMargin);
                else
                    vtop.push("v.top_", oLastSame.id, " + v.height_",
                        oLastSame.id, " + ", oLastSame.edgeMargin);
            }
        }
        else
            vtop.push("v.top_" + oItem.parent.id);

        //LEFT
        if (oItem.parent.hbox) {
            if (oItem.parent.isRight) {
                if (!oNextSame) {
                    vleft.push("v.left_", oItem.parent.id, " + v.width_",
                        oItem.parent.id, " - ", (oItem.node ? oItem.id + ".offsetWidth" : "v.width_" + oItem.id), null);
                }
                else {
                    if (oNextSame.node)
                        vleft.push(oNextSame.id, ".offsetLeft - ",
                            oNextSame.edgeMargin, " - ", (oItem.node ? oItem.id + ".offsetWidth" : "v.width_" + oItem.id));
                    else
                        vleft.push("v.left_" + oNextSame.id, " - ", oNextSame.edgeMargin,
                            " - ", (oItem.node ? oItem.id + ".offsetWidth" : "v.width_" + oItem.id));
                }
            }
            else if (!oItem.stackId)
                vleft.push("v.left_" + oItem.parent.id);
            else if (oLastSame) {
                if (oLastSame.node)
                    vleft.push(oLastSame.id, ".offsetLeft + ", oLastSame.id,
                        ".offsetWidth + ", oLastSame.edgeMargin);
                else
                    vleft.push("v.left_", oLastSame.id, " + v.width_",
                        oLastSame.id, " + ", oLastSame.edgeMargin);
            }
        }
        else
            vleft.push("v.left_" + oItem.parent.id);

        if (vleft.length > 2)
            this.addRule(vleft.join(""));
        if (vtop.length > 2)
            this.addRule(vtop.join(""));

        if (!oItem.node) {
            for (var i = 0; i < oItem.children.length; i++)
                this.parserules(oItem.children[i]);
        }
    };

    this.parsesplitters = function(oItem){
        //&& oItem.stackId != oItem.parent.children.length - 1
        if (oItem.parent && oItem.splitter > 0) {
            apf.layout.getSplitter(this).init(oItem.splitter, oItem.hid, oItem);
        }

        if (!oItem.node) {
            for (var i = 0; i < oItem.children.length; i++)
                this.parsesplitters(oItem.children[i]);
        }
    };

    function DepTree(){
        this.parselookup = {};
        this.nRules      = [];
        this.doneRules   = {};

        this.maskText = function(str, m1, m2, m3){
            return m1 + ".offset" + m2.toUpperCase();
        }

        this.handleVar = function(match, m1, m2, m3){
            var vname = "a" + m1.replace(/\|/g, "_") + "_style_" + m2.toLowerCase();
            return knownVars[vname] ? vname : match;
        }

        //@todo this function needs some serious optimization (according to the profiler)
        this.parseRule = function(rule){
            var aRule        = rule.split(" = "),
                id           = aRule[0].replace(/^([_\w\d\|]+)\.style\.(\w)/, this.maskText),
                vname        = "a" + aRule[0].replace(/[\.\|]/g, "_");
            knownVars[vname] = true;

            var depsearch    = aRule[1].split(/[ \(\)]/),// " "
                deps         = [],
                ruleB;
            for (var i = 0; i < depsearch.length; i++) {
                if (depsearch[i].match(/^([_\w\d\|]+)\.offset(\w+)$/) && !depsearch[i].match(/PNODE/)) {
                    deps.push(depsearch[i]);
                }
            }

            if (vname.match(/width|height/i)) {
                aRule[1] = aRule[1].replace(/^(\s*[\-\d]+[\s\-\+]+)/, "");
                ruleB    = aRule[0] + " = " + RegExp.$1 + vname;
            }
            else
                ruleB = aRule[0] + " = " + vname;

            if (rule.match(/^v\./)) {
                return {
                    id        : id,
                    rule_p1   : aRule[0] + " = ",
                    rule_p2   : aRule[1],
                    ruleb      : null,
                    deps      : deps,
                    processed : false
                };
            }

            return {
                id        : id,
                rule_p1   : "var " + vname + " = ",
                rule_p2   : aRule[1],
                ruleb     : ruleB,
                deps      : deps,
                processed : false
            };
        }

        //@todo test safari
        this.calc = function(aRules){
            var i, prop, str = "";
            for (i = 0; i < aRules.length; i++) {
                if (aRules[i].match(/^var/)) {
                    this.nRules.push(aRules[i]);
                    continue;
                }
                var o = this.parseRule(aRules[i], i);
                this.parselookup[o.id] = o;
            }

            //build referential tree (graph)
            for (prop in this.parselookup) {
                this.processNode(this.parselookup[prop]);
            }

            //Walk Tree
            for (prop in this.parselookup) {
                var root = this.parselookup[prop];
                //if(root.processed) continue;
                this.walkRules(root);
            }

            //Set last rules
            for (prop in this.parselookup) {
                this.nRules.push(this.parselookup[prop].ruleb);
            }

            return this.nRules;
        }

        this.walkRules = function(root){
            if (this.doneRules[root.id]) return;

            for (var i = 0; i < root.deps.length; i++) {
                if (root.deps[i] && !root.deps[i].walked && !this.doneRules[root.deps[i].id]) {
                    root.deps[i].walked = true;
                    this.walkRules(root.deps[i]);
                }
            }

            this.doneRules[root.id] = true;
            this.nRules.push(root.rule_p1 + root.rule_p2
                .replace(/([_\w\d\|]+)\.offset(\w+)/g, this.handleVar));
        }

        this.processNode = function(o){
            for (var i = 0; i < o.deps.length; i++) {
                var l = typeof o.deps[i] == "string"
                    ? this.parselookup[o.deps[i]]
                    : o.deps[i];
                if (!l) {
                    o.deps[i] = null;
                    continue;
                }

                o.deps[i] = l;//.copy();
                if (!l.processed) {
                    l.processed = true;
                    this.processNode(l);
                }
            }
        }
    }
};



/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/language.js)SIZE(8586)TIME(1263859264)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/data.js)SIZE(15824)TIME(1270838605)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * @term datainstruction Data instructions offer a single and consistent way for
 * storing and retrieving
 * data from different data sources. For instance from a webserver using REST
 * or RPC, or from local data sources such as gears, air, o3, html5, as well as
 * from in memory sources from javascript or cookies. There is often an xml
 * element which is relevant to storing information. This element can be
 * accessed using xpath statements in the data instruction using curly braces.
 *
 *  - for complex model expr. replace model.
 *  - use property binding for selection, instead of setConnections
 *  <a:bar model="{tree.selected}">
 *      <a:textbox value="[persons/person/text]" />
 *      <a:textbox value="[persons/person/text1]" />
 *      <a:textbox value="[persons/person/text2]" />
 *      <a:textbox value="[persons/person/text3]" />
 *      <a:textbox value="[persons/person/text4]" />
 *  </a:bar>
 *  - create exec function for async objects
 *  - have list of async objects
 *
 * Syntax:
 * Using data instructions to retrieve data
 * <code>
 *  model="name_of_model"
 *  model="[name_of_model::xpath]"
 *  model="{element.selected}"
 *  model="[local(element.selected) {xpath}]"
 *  model="{element.choose}"
 *      model="[local(element.choose) {xpath}]"
 *      model="[local(element.root) {xpath}]"
 *      load="<specialtag>[comm.doCall([@id], test(), 5+10).xml]</specialtag>"
 *      get="example.jsp"
 *      get="http://www.bla.nl?blah=10&foo=[@bar]&example=[10+5]"
 *      get="{comm.submit('abc', [@bar])}"
 *      get="[local(comm.submit('abc', [@bar])) return [xpath]]"
 *      get="[submit('abc', [@bar])]"
 *      get="{xmpp.login(username, password)}"
 *      get="{webdav.getRoot()}"
 *      get="[10+5]"
 * </code>
 *
 * Syntax:
 * Using data instructions to store data
 * <code>
 *  set="http://www.bla.nl?blah=10&foo={/bar}&example=[10+5]"
 *  set="post http://www.bla.nl?blah=10&foo={/bar}&example=[10+5]"
 * <a:add set="[[@uid] = comm.addPerson('abc', {/bar})]" />
 *  set="[submit('abc', {/bar})]"
 *  set="[example=[@name]]"
 *  set="[apf.setcookie('something', [.])]"
 *  set="[o3.fs.get('/var/test.xml').data = [.]]"
 * </code>
 *
 * [
 *  function test(){
 *      var blah = comm.blah();
 *      return blah;
 *  }
 * ]
 * <a:add set="[test([.])]" />
 *
 * See:
 * <ul>
 *  <li>{@link teleport.cgi the cgi teleport module}</li>
 *  <li>{@link teleport.rpc the rpc teleport module}</li>
 *  <li>{@link teleport.webdav the webdav teleport module}</li>
 *  <li>{@link teleport.xmpp the xmpp teleport module}</li>
 * </ul>
 */

/**
 * Stores data using a {@link term.datainstruction data instruction}.
 *
 * @param {String}      instruction  the {@link term.datainstruction data instruction} to be used to store the data.
 * @param {Object}      [options]    the options for this instruction
 *   Properties:
 *   {Boolean} multicall    whether this call should not be executed immediately but saved for later sending using the purge() command.
 *   {mixed}   userdata     any data that is useful to access in the callback function.
 *   {Array}   args         the arguments of the call, overriding any specified in the data instruction.
 *   {XMLElement}  [xmlContext] the subject of the xpath queries
 *   {Function}    [callback]   the code that is executed when the call returns, either successfully or not.
 */
apf.saveData = 

/**
 * Retrieves data using a {@link term.datainstruction data instruction}.
 * Example:
 * Several uses for a data instruction
 * <code>
 *  <!-- loading aml from an xml file -->
 *  <a:bar aml="moreaml.xml" />
 *
 *  <a:bindings>
 *    <!-- loads data using an remote procedure protocol -->
 *    <a:load   get = "{comm.getData()}" />
 *
 *    <!-- inserts data using an remote procedure protocol -->
 *    <a:insert get = "{comm.getSubData([@id])}" />
 *  </a:bindings>
 *
 *  <a:actions>
 *    <!-- notifies the server that a file is renamed -->
 *    <a:rename set = "update_file.jsp?id=[@id]&name=[@name]" />
 *
 *    <!-- adds a node by retrieving it's xml from the server. -->
 *    <a:add    get = "new_user.xml" />
 *  </a:actions>
 *
 *  <!-- creates a model which is loaded into a list -->
 *  <a:list model="{webdav.getRoot()}" />
 *
 *  <!-- loads data into a model and when submitted sends the altered data back -->
 *  <a:model load="load_contact.jsp" submission="save_contact.jsp" />
 * </code>
 *
 * @param {String}      instruction  the {@link term.datainstruction data instruction} to be used to retrieve the data.
 * @param {XMLElement}  [xmlContext] the subject of the xpath queries
 * @param {Object}      [options]    the options for this instruction
 *   Properties:
 *   {Boolean} multicall    whether this call should not be executed immediately but saved for later sending using the purge() command.
 *   {mixed}   userdata     any data that is useful to access in the callback function.
 *   {mixed}   data         data to use in the call
 *   {Array}   args         the arguments of the call, overriding any specified in the data instruction.
 * @param {Function}    [callback]   the code that is executed when the call returns, either successfully or not.
 */
apf.getData = function(instruction, options){
    if (!instruction) return false;

    //Instruction type detection
    var result, chr = instruction.charAt(0), callback = options.callback;

    
    var gCallback  = function(data, state, extra){
        var _self = this;
        $setTimeout(function(){
            s2.call(_self, data, state, extra);
        });
    }
    
    var s2 = 
    

    function(data, state, extra){
        var callback = options.callback
        
        if (state != apf.SUCCESS)
            return callback(data, state, extra || {});

        //Change this to warning?
        /*if (!data) {
            throw new Error(apf.formatErrorString(0, null,
                "Loading new data", "Could not load data. \n\
                Data instruction: '" + instruction + "'"));
        }*/

        return callback(data, state, extra || {});
    }
    
    if (!options) options = {}; //@todo optimize?
    var fParsed = options.fParsed || (instruction.indexOf("{") > -1 || instruction.indexOf("[") > -1
        ? apf.lm.compile(instruction, {
            withopt     : true, 
            precall     : options._pc == -1 ? false : options._pc, //for the actiontracker
            alwayscb    : true, 
            simplexpath : true
          })
        : {str: instruction, type: 2}); 

    //@todo hack because we're not using compileNode.. an imperfection..
    if (fParsed.type == 3){
        if (fParsed.xpaths[0]) {
            var model = fParsed.xpaths[0], xpath = fParsed.xpaths[1];
            
            //@todo can this be async?
            if (model == "#" || xpath == "#") { //When there is a set model and not a generated xpath
                var m = (apf.lm.compile(instruction, {
                    xpathmode: 5
                }))();
                
                //@todo apf3 this needs to be fixed in live markup
                if (typeof m != "string") {
                    model = m.model && m.model.$isModel && m.model;
                    if (model)
                        xpath = m.xpath;
                    else if (m.model) {
                        model = apf.xmldb.findModel(m.model);
                        xpath = apf.xmlToXpath(m.model, model.data) + (m.xpath ? "/" + m.xpath : ""); //@todo make this better
                    }
                    else {
                        throw new Error();
                    }
                }
                else model = null;
            }
            else {
                model = apf.nameserver.get("model", model)
            }
            
            
            if (!model) {
                throw new Error("Could not find model '" + model + "' in " + instruction); //@todo apf3.0 make proper error
            }
            
        
            return gCallback(model.data.selectSingleNode(xpath), apf.SUCCESS, {});
        }
        else {
            
            if (!options.xmlNode) {
                throw new Error(apf.formatErrorString(0, null,
                    "Loading data",
                    "Xpath found without model and no xmlNode specified" 
                    + instruction));
            }
            
            
            return gCallback(options.xmlNode.data.selectSingleNode(fParsed.xpaths[1]), apf.SUCCESS, {});
        }
    }
    
    //xml generation
    if (chr == "<") {
        //string only
        if (fParsed.type == 2)
            result = fParsed.str;
        else
            return fParsed(options.xmlNode, gCallback, options);
    }
    //jslt fetching data
    else if ((chr == "[" || chr == "{")) { //(fParsed.asyncs || fParsed.models) && 
        return fParsed(options.xmlNode, gCallback, options);
    }
    //url
    else {
        if (fParsed.type == 1 || fParsed.type == 3) {
            var callback2 = callback;
            callback = options.callback = function(data, state, extra){
                if (options._pc === true)
                    return;
                
                if (state != apf.SUCCESS)
                    return callback2.apply(this, arguments);

                var url = data.split(" "), method = "get";
                if (url.length > 1 && url[0].length < 10) {
                    method = url.shift();
                    url    = url.join(" ");
                }
                else url = data;
                
                callback = options.callback = callback2;
                apf.oHttp.exec(method, [url], gCallback, options);
            }
            fParsed(options.xmlNode, gCallback, options);
        }
        else {
            if (options._pc === true)
                return;
            
            var url = instruction.split(" "), method = "get";
            if (url.length > 1 && url[0].length < 10) {
                method = url.shift();
                url    = url.join(" ");
            }
            else {
                url = instruction;
            }
            
            apf.oHttp.exec(method, [url], gCallback, options);
        }
    }
    
    if (result) {
        if (callback)
            gCallback(result, apf.SUCCESS, {});
        else {
            //apf.console.warn("Returning data directly in apf.getData(). \
                //This means that all callback communication ends in void!");
            return result;
        }
    }
};


/**
 * Creates a model object based on a {@link term.datainstruction data instruction}.
 *
 * @param {String} instruction  the {@link term.datainstruction data instruction} to be used to retrieve the data for the model.
 * @param {AmlNode} amlNode     the element the model is added to.
 */
apf.setModel = function(instruction, amlNode){
    if (!instruction) return;

    //Find existing model
    var fParsed = instruction.indexOf("{") > -1 || instruction.indexOf("[") > -1
        ? apf.lm.compile(instruction, {
            //precall  : false, 
            alwayscb : true
        })
        : {
            type: 2,
            str : instruction
        };

    if (instruction == "@default" || fParsed.type == 2) {
        var model = apf.nameserver.get("model", instruction);
        if (model)
            return model.register(amlNode);
        else if (instruction == "@default")
            return;
        
        //@todo apf3.0 check here if string is valid url (relative or absolute)
        if (instruction.indexOf(".") == -1 && instruction.indexOf("/") == -1) {
            
            apf.console.warn("Could not find model '" + instruction + "'");
            
            return;
        }
    }

    //Just an xpath doesnt work. We don't have context
    //var l, x;
    if (fParsed.type == 3) {//This won't work for complex xpaths
        if (fParsed.models) { //check for # in xpaths[i] to determine if its calculated
            if (fParsed.xpaths.length == 2 && fParsed.xpaths[0] != '#' && fParsed.xpaths [1] != '#') {
                
                if (!apf.nameserver.get("model", fParsed.xpaths[0])) {
                    throw new Error("Could not find model '" + fParsed.xpaths[0] + "' in " + instruction); //@todo apf3.0 make proper error
                }
                
                
                apf.nameserver.get("model", fParsed.xpaths[0]).register(amlNode, fParsed.xpaths[1]);
                return;
            }
        }
        
        else {
            //throw new Error(apf.formatErrorString(0, amlNode,
            apf.console.warn("Xpath found without model. This might fail if no\
                context is specified using local(): " + instruction);
        }
        
    }

    if (amlNode.clear)
        amlNode.clear("loading");

    //Complex data fetch (possibly async) - data is loaded only once. 
    //Potential property binding has to take of the rest
    apf.getData(instruction, {
      parsed   : fParsed, 
      xmlNode  : amlNode && amlNode.xmlRoot,
      callback : function(data, state, extra){
        //@todo apf3.0 call onerror on amlNode
        if (state != apf.SUCCESS) {
            throw new Error(apf.formatErrorString(0, null,
                "Loading new data", "Could not load data into model. \
                \nMessage: " + extra.message + "\
                \nInstruction: '" + instruction + "'"));
        }
        
        if (!data)
            return amlNode.clear && amlNode.clear();

        if (typeof data == "string") {
            if (data.charAt(0) == "<")
                data = apf.getXml(data);
            else {
                //Assuming web service returned url
                if (data.indexOf("http://") == 0)
                    return apf.setModel(data, amlNode);
                else {
                    throw new Error("Invalid data from server");//@todo apf3.0 make proper apf error handling. apf.onerror
                }
            }
        }
        
        var model = apf.xmldb.findModel(data); //See if data is already loaded into a model
        if (model)
            model.register(amlNode, apf.xmlToXpath(data, model.data)); //@todo move function to xml library
        else
            new apf.model().register(amlNode).load(data);
    }});
};





/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/storage/gears.js)SIZE(12266)TIME(1270937593)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 *  Storage provider that uses Google Gears to store data.
 */
apf.storage.modules.gears = 
apf.storage.modules["gears.sql"] = {
    // instance methods and properties
    table_name  : "STORAGE",
    initialized : false,
    
    $available  : null,
    $db         : null,
    
    init: function(){
        this.factory = apf.nameserver.get("google", "gears");
        this.database_name = apf.config.name.substr(0, 46) + ".apf.offline.gears";

        this.$db = this.factory.create('beta.database', '1.0');
        this.$db.open(this.database_name);

        // create the table that holds our data
        try {
            this.$sql("CREATE TABLE IF NOT EXISTS " + this.table_name + "( "
                        + " namespace TEXT, "
                        + " key TEXT, "
                        + " value TEXT "
                        + ")"
                    );
            this.$sql("CREATE UNIQUE INDEX IF NOT EXISTS namespace_key_index" 
                        + " ON " + this.table_name
                        + " (namespace, key)");
           
            this.initialized = true;
        }
        catch(e) {
            apf.console.warn(e.message);
            return false;
        }
    },
    
    $sql: function(query, params){
        var rs = this.$db.execute(query, params);
        
        return this.$normalizeResults(rs); //can I do this after I close db?
    },
    
    destroy : function(){
        //if (!apf.isIE)
        this.$db.close();
    },
    
    $normalizeResults: function(rs){
        var results = [];
        if (!rs) return [];
    
        while (rs.isValidRow()) {
            var row = {};
        
            for (var i = 0; i < rs.fieldCount(); i++) {
                var fieldName = rs.fieldName(i);
                var fieldValue = rs.field(i);
                row[fieldName] = fieldValue;
            }
        
            results.push(row);
        
            rs.next();
        }
    
        rs.close();
        
        return results;
    },
    
    isAvailable: function(){
        // is Google Gears available and defined?
        return apf.isGears;
    },

    put: function(key, value, namespace){
        
        if (this.isValidKey(key) == false)
            throw new Error(apf.formatErrorString(0, null, 
                "Setting name/value pair", 
                "Invalid key given: " + key));
        
        
        if (!namespace)
            namespace = this.namespace;

		
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null, 
                "Setting name/value pair", 
                "Invalid namespace given: " + namespace));
        
        
        value = apf.serialize(value);
        
        // try to store the value    
        try {
            this.$sql("DELETE FROM " + this.table_name
                        + " WHERE namespace = ? AND key = ?",
                        [namespace, key]);
            this.$sql("INSERT INTO " + this.table_name
                        + " VALUES (?, ?, ?)",
                        [namespace, key, value]);
        }
        catch(e) {
            
            throw new Error(apf.formatErrorString(0, null, 
                "Setting name/value pair", 
                "Error setting name/value pair: " + e.message));
            
            return false;
        }
        
        return true;
    },

    get: function(key, namespace){
        
        if (this.isValidKey(key) == false)
            throw new Error(apf.formatErrorString(0, null, 
                "Getting name/value pair", 
                "Invalid key given: " + key));
        
		
        if (!namespace)
            namespace = this.namespace;
		
		
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null, 
                "Getting name/value pair", 
                "Invalid namespace given: " + namespace));
        
        
        // try to find this key in the database
        var results = this.$sql("SELECT * FROM " + this.table_name
                                    + " WHERE namespace = ? AND "
                                    + " key = ?",
                                    [namespace, key]);

        if (!results.length)
            return null;

        return apf.unserialize(results[0].value);
    },
    
    getNamespaces: function(){
        var results = [ this.namespace ];
        
        var rs = this.$sql("SELECT namespace FROM " + this.table_name
                            + " DESC GROUP BY namespace");
        for (var i = 0; i < rs.length; i++) {
            if (rs[i].namespace != this.namespace)
                results.push(rs[i].namespace);
        }
        
        return results;
    },

    getKeys: function(namespace){
        if (!namespace)
            namespace = this.namespace;

        
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null, 
                "Retrieving keys", 
                "Invalid namespace given: " + namespace));
        
        
        var rs = this.$sql("SELECT key FROM " + this.table_name
                            + " WHERE namespace = ?",
                            [namespace]);
        
        var results = [];
        for (var i = 0; i < rs.length; i++)
            results.push(rs[i].key);
        
        return results;
    },

    clear: function(namespace){
        if (!namespace)
            namespace = this.namespace;
	    
        
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null, 
                "Clearing storage", 
                "Invalid namespace given: " + namespace));
        
        
        this.$sql("DELETE FROM " + this.table_name 
                    + " WHERE namespace = ?",
                    [namespace]);
    },
    
    remove: function(key, namespace){
        if (!namespace)
            namespace = this.namespace;

        
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null, 
                "Removing key", 
                "Invalid namespace given: " + namespace));
        
        
        this.$sql("DELETE FROM " + this.table_name 
                    + " WHERE namespace = ? AND"
                    + " key = ?",
                    [namespace, key]);
    },
    
    putMultiple: function(keys, values, namespace) {
        
        if(this.isValidKeyArray(keys) === false
                        || ! values instanceof Array
                        || keys.length != values.length){
            throw new Error(apf.formatErrorString(0, null,
                "Setting multiple name/value pairs",
                "Invalid arguments: keys = [" + keys + "], \
                                    values = [" + values + "]"));
        }
        

        if (!namespace)
            namespace = this.namespace;

		
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null, 
                "Setting multiple name/value pairs", 
                "Invalid namespace given: " + namespace));
        

        // try to store the value    
        try {
            this.$sql.open();
            this.$sql.db.execute("BEGIN TRANSACTION");
            var stmt = "REPLACE INTO " + this.table_name + " VALUES (?, ?, ?)";
            for(var i=0;i<keys.length;i++) {
                // serialize the value;
                // handle strings differently so they have better performance
                var value = apf.serialize(values[i]);

                this.$sql.db.execute(stmt, [namespace, keys[i], value]);
            }
            this.$sql.db.execute("COMMIT TRANSACTION");
            this.$sql.close();
        }
        catch(e) {
            
            throw new Error(apf.formatErrorString(0, null, 
                "Writing multiple name/value pair", 
                "Error writing file: " + e.message));
            
            return false;
        }
        
        return true;
    },

    getMultiple: function(keys, namespace){
        
        if (this.isValidKeyArray(keys) === false)
            throw new Error(apf.formatErrorString(0, null, 
                "Getting name/value pair", 
                "Invalid key array given: " + keys));
        
		
        if (!namespace)
            namespace = this.namespace;

		
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null, 
                "Getting multiple name/value pairs", 
                "Invalid namespace given: " + namespace));
        
        
        var stmt = "SELECT * FROM " + this.table_name    + 
            " WHERE namespace = ? AND "    + " key = ?";
        
        var results = [];
        for (var i = 0; i < keys.length; i++) {
            var result = this.$sql(stmt, [namespace, keys[i]]);
            results[i] = result.length
                ? apf.unserialize(result[0].value)
                : null;
        }
        
        return results;
    },
    
    removeMultiple: function(keys, namespace){
        
        if (this.isValidKeyArray(keys) === false)
            throw new Error(apf.formatErrorString(0, null, 
                "Removing name/value pair", 
                "Invalid key array given: " + keys));
        
        if (!namespace)
            namespace = this.namespace;

        
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null, 
                "Removing multiple name/value pairs", 
                "Invalid namespace given: " + namespace));
        
        
        this.$sql.open();
        this.$sql.db.execute("BEGIN TRANSACTION");
        var stmt = "DELETE FROM " + this.table_name + " WHERE namespace = ? AND key = ?";

        for (var i = 0; i < keys.length; i++)
            this.$sql.db.execute(stmt, [namespace, keys[i]]);

        this.$sql.db.execute("COMMIT TRANSACTION");
        this.$sql.close();
    },                 
    
    isPermanent: function(){
        return true;
    },

    getMaximumSize: function(){
        return this.SIZE_NO_LIMIT;
    },

    hasSettingsUI: function(){
        return false;
    },
    
    showSettingsUI: function(){
        throw new Error(this.declaredClass 
            + " does not support a storage settings user-interface");
    },
    
    hideSettingsUI: function(){
        throw new Error(this.declaredClass 
            + " does not support a storage settings user-interface");
    }
};



/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/storage/air.js)SIZE(9669)TIME(1257329186)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



// summary: 
//		Storage provider that uses features in the Adobe AIR runtime to achieve
//		permanent storage
			
apf.storage.modules.air = {
    init: function(){
        this.ByteArray = window.runtime.flash.utils.ByteArray;
        this.EncryptedLocalStore = window.runtime.flash.data.EncryptedLocalStore;
    },

    isAvailable: function(){
        return apf.isAIR;
    },
	
    _getItem: function(key){
        var storedValue = this.EncryptedLocalStore.getItem("__apf_" + key);
        return storedValue ? storedValue.readUTFBytes(storedValue.length) : "";
    },
	
    _setItem: function(key, value){
        var bytes = new this.ByteArray();
        bytes.writeUTFBytes(value);
        this.EncryptedLocalStore.setItem("__apf_" + key, bytes);
    },
	
    _removeItem: function(key){
        this.EncryptedLocalStore.removeItem("__apf_" + key);
    },
	
    put: function(key, value, namespace){
        
        if (this.isValidKey(key) == false)
            throw new Error(apf.formatErrorString(0, null,
                "Setting name/value pair", "Invalid key given: " + key));
        
        
        if(!namespace)
            namespace = this.namespace;
		    
        
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null,
                "Setting name/value pair", "Invalid namespace given: " + namespace));
        
		
        // try to store the value
        try {
            var namespaces = this._getItem("namespaces") || '';
            if(namespaces.indexOf('|' + namespace + '|') == -1)
                this._setItem("namespaces", namespaces + namespace + '|');

            var keys = this._getItem(namespace + "_keys") || '';
            if(keys.indexOf('|' + key + '|') == -1)
                this._setItem(namespace + "_keys", keys + key + '|');

            this._setItem('_' + namespace + '_' + key, value);
        }
        catch(e) {
            
            throw new Error(apf.formatErrorString(0, null,
                "Setting name/value pair", "Error writing: " + e.message));
            
            
            return false;
        }
		
        return true;
    },
	
    get: function(key, namespace){
        
        if (this.isValidKey(key) == false)
            throw new Error(apf.formatErrorString(0, null, "Getting name/value pair", "Invalid key given: " + key));
        
		
        if (!namespace)
            namespace = this.namespace;
		
        
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null,
                "Getting name/value pair", "Invalid namespace given: " + namespace));
        
		
        return this._getItem('_' + namespace + '_' + key);
    },
	
    getNamespaces: function(){
        var results = [ this.namespace ];
        var namespaces = (this._getItem("namespaces") || '').split('|');
        for (var i=0;i<namespaces.length;i++){
            if (namespaces[i] && namespaces[i] != this.namespace)
                results.push(namespaces[i]);
        }
        return results;
    },

    getKeys: function(namespace){
        if (!namespace)
            namespace = this.namespace;
		    
        
        if(this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null, "Getting keys",
                "Invalid namespace given: " + namespace));
        

        var results = [];
        var keys = (this._getItem(namespace + "_keys") || '').split('|');
        for (var i = 0; i < keys.length; i++) {
            if (keys[i])
                results.push(keys[i]);
        }
		
        return results;
    },
	
    clear: function(namespace){
        if (!namespace)
            namespace = this.namespace;
	    
        
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null, "Clearing storage",
                "Invalid namespace given: " + namespace));
        
        
        var namespaces = this._getItem("namespaces") || '';
        if (namespaces.indexOf('|' + namespace + '|') != -1)
            this._setItem("namespaces", namespaces.replace('|' + namespace + '|', '|'));

        var keys = (this._getItem(namespace + "_keys") || '').split('|');
        for (var i = 0; i < keys.length; i++)
            if (keys[i].length)
                this._removeItem(namespace + "_" + keys[i]);

        this._removeItem(namespace + "_keys");
    },
	
    remove: function(key, namespace){
        if (!namespace)
            namespace = this.namespace;
	    
        
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null, "Removing key",
                "Invalid namespace given: " + namespace));
        
		
        var keys = this._getItem(namespace + "_keys") || '';
        if (keys.indexOf('|' + key + '|') != -1)
            this._setItem(namespace + "_keys", keys.replace('|' + key + '|', '|'));

        this._removeItem('_' + namespace + '_' + key);
    },
	
    putMultiple: function(keys, values, namespace) {
        
        if (this.isValidKeyArray(keys) === false
            || ! values instanceof Array
            || keys.length != values.length){
            throw new Error(apf.formatErrorString(0, null, 
                "Setting multiple name/value pairs", "Invalid arguments: keys = ["
                + keys + "], values = [" + values + "]"));
        }
        
		
        if (!namespace)
            namespace = this.namespace;

        
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null, 
                "Setting multiple name/value pairs", "Invalid namespace given: "
                + namespace));
        

        // try to store the value
        try {
            for (var i = 0; i < keys.length; i++)
                this.put(keys[i], value[i], null, namespace);
        }
        catch(e) {
            
            throw new Error(apf.formatErrorString(0, null,
                "Writing multiple name/value pair", "Error writing file: "
                + e.message));
            
            return false;
        }
		
        return true;
    },

    getMultiple: function(keys, namespace){
        
        if (this.isValidKeyArray(keys) === false)
            throw new Error(apf.formatErrorString(0, null,
                "Getting name/value pair", "Invalid key array given: " + keys));
        
		
        if (!namespace)
            namespace = this.namespace;

        
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null, 
                "Getting multiple name/value pairs", "Invalid namespace given: "
                + namespace));
        

        var results = [];
        for (var i = 0; i < keys.length; i++)
            results[i] = this.get(keys[i], namespace);

        return results;
    },
	
    removeMultiple: function(keys, namespace){
        
        if (this.isValidKeyArray(keys) === false)
            throw new Error(apf.formatErrorString(0, null,
                "Removing name/value pair", "Invalid key array given: " + keys));
        
		
        if (!namespace)
            namespace = this.namespace;

        
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null, 
                "Removing multiple name/value pairs", "Invalid namespace given: "
                + namespace));
        
        
        for (var i = 0; i < keys.length; i++)
            this.remove(keys[i], namespace);
    },
	
    isPermanent: function(){
        return true;
    },

    getMaximumSize: function(){
        return this.SIZE_NO_LIMIT;
    },

    hasSettingsUI: function(){
        return false;
    },
	
    showSettingsUI: function(){
        throw new Error(this.declaredClass
            + " does not support a storage settings user-interface");
    },
	
    hideSettingsUI: function(){
        throw new Error(this.declaredClass
            + " does not support a storage settings user-interface");
    }
};



/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/storage/memory.js)SIZE(10208)TIME(1257329186)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * Storage module using javascript objects to store the data. When the 
 * application restarts or closes this data is be purged. This module is used
 * when no other storage mechanism is available to still allow for some of the
 * features that depend on a storage mechanism to be available.
 * @default_private
 */
apf.storage.modules.memory = {
    initialized: true,
    store      : {},
    
    isAvailable: function(){
        return true;
    },

    /**
     * Stores a key value pair in a namespace.
     * @param {String} key       the identifier of the information.
     * @param {mixed}  value     the information to store.
     * @param {String} namespace the named context into which to store the key value pair.
     */
    put: function(key, value, namespace){
        
        if (this.isValidKey(key) == false)
            throw new Error(apf.formatErrorString(0, null, 
                "Setting name/value pair", 
                "Invalid key given: " + key));
        
        
        if (!namespace)
		    namespace = this.namespace;

		
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null, 
                "Setting name/value pair", 
                "Invalid namespace given: " + namespace));
        
        
        // serialize the value;
        value = apf.serialize(value);
        
        // store the value    
        if (!this.store[namespace])
            this.store[namespace] = {};
        
        this.store[namespace][key] = value;
    },
    
    /**
     * Retrieves a keys in a namespace.
     * @param {String} key       the identifier of the information.
     * @param {String} namespace the named context of the keys to retrieve.
     * @return {mixed} the value that correspond to the key in the namespace.
     */
    get: function(key, namespace){
        
        if (this.isValidKey(key) == false)
            throw new Error(apf.formatErrorString(0, null, 
                "Getting name/value pair", 
                "Invalid key given: " + key));
        
		
		if (!namespace)
		    namespace = this.namespace;
		
		
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null, 
                "Getting name/value pair", 
                "Invalid namespace given: " + namespace));
        

        if (!this.store[namespace] || !this.store[namespace][key])
            return null;
          
        return apf.unserialize(this.store[namespace][key]);
    },
    
    /**
     * Retrieves all the namespaces in use.
     * @return {Array} list of namespaces.
     */
    getNamespaces: function(){
        var results = [ this.namespace ];
        
        for (var ns in this.store)
            results.push(ns);
        
        return results;
    },

    /**
     * Retrieves all the keys of a namespace.
     * @param {String} namespace the named context of the keys to retrieve.
     * @return {Array} the list of keys in the namespace.
     */
    getKeys: function(namespace){
        if (!namespace)
		    namespace = this.namespace;

        
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null, 
                "Clearing storage", 
                "Invalid namespace given: " + namespace));
        
        
        var results = [];
        for (var prop in this.store[namespace])
            results.push(prop);
        
        return results;
    },

    /** 
     * Removes all keys from a namespace
     */
    clear: function(namespace){
        if (!namespace)
		    namespace = this.namespace;
	    
        
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null, 
                "Clearing storage", 
                "Invalid namespace given: " + namespace));
        
        
        delete this.store[namespace]
    },
    
    /**
     * Removes a key in a namespace.
     * @param {String} key       the identifier of the information.
     * @param {String} namespace the named context of the keys to remove.
     */
    remove: function(key, namespace){
        if (!namespace)
		    namespace = this.namespace;

        
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null, 
                "Removing key", 
                "Invalid namespace given: " + namespace));
        
        
        if (this.store[namespace])
            delete this.store[namespace][key];
    },
    
    /**
     * Stores a key value pair in a namespace.
     * @param {Array}  keys      a list of keys that identify the information stored.
     * @param {Array}  values    a list of values to store.
     * @param {String} namespace the named context into which to store the key value pair.
     */
    putMultiple: function(keys, values, namespace) {
        
        if (this.isValidKeyArray(keys) === false
          || ! values instanceof Array
          || keys.length != values.length) {
            throw new Error(apf.formatErrorString(0, null,
                "Setting multiple name/value pairs",
                "Invalid arguments: keys = [" + keys + "], \
                                    values = [" + values + "]"));
        }
        

        if (!namespace)
            namespace = this.namespace;

        
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null, 
                "Setting multiple name/value pairs", 
                "Invalid namespace given: " + namespace));
        

         // store the value    
        if (!this.store[namespace])
            this.store[namespace] = {};
        
        // try to store the value    
        for (var i = 0; i < keys.length; i++) {
            this.store[namespace][keys[i]] = apf.serialize(values[i]);
        }
        
        return true;
    },

    /**
     * Retrieves all the values of several keys in a namespace.
     * @param {Array}  keys      a list of keys that identify the information retrieved.
     * @param {String} namespace the named context into which to store the key value pair.
     * @returns {Array} list of values that have been retrieved.
     */
    getMultiple: function(keys, namespace){
        
        if (this.isValidKeyArray(keys) === false)
            throw new Error(apf.formatErrorString(0, null, 
                "Getting name/value pair", 
                "Invalid key array given: " + keys));
        
		
		if (!namespace)
		    namespace = this.namespace;

		
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null, 
                "Getting multiple name/value pairs", 
                "Invalid namespace given: " + namespace));
        
        
         if (!this.store[namespace])
            return [];
        
        var results = [];
        for (var i = 0; i < keys.length; i++){
            if (this.store[namespace][keys[i]])
                results.push(apf.unserialize(this.store[namespace][keys[i]]));
        }
        
        return results;
    },
    
    /**
     * Removes a key in a namespace.
     * @param {Array}  keys      a list of keys that identify the information to be removed.
     * @param {String} namespace the named context of the keys to remove.
     */
    removeMultiple: function(keys, namespace){
        
        if (this.isValidKeyArray(keys) === false)
            throw new Error(apf.formatErrorString(0, null, 
                "Removing name/value pair", 
                "Invalid key array given: " + keys));
        

        if (!namespace)
            namespace = this.namespace;

        
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null, 
                "Removing multiple name/value pairs", 
                "Invalid namespace given: " + namespace));
        
        
        if (!this.store[namespace])
            return;
        
        for (var  i = 0; i < keys.length; i++)
            delete this.store[namespace][keys[i]];
    },                 
    
    isPermanent: function(){
        return false;
    },

    getMaximumSize: function(){
        return this.SIZE_NO_LIMIT;
    },

    hasSettingsUI: function(){
        return false;
    },
    
    showSettingsUI: function(){
        throw new Error(this.declaredClass 
            + " does not support a storage settings user-interface");
    },
    
    hideSettingsUI: function(){
        throw new Error(this.declaredClass 
            + " does not support a storage settings user-interface");
    }
};



/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/storage/flash.js)SIZE(15458)TIME(1257329186)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



// summary:
//        Storage provider that uses features in Flash to achieve permanent
//        storage
// description:

apf.storage.modules.flash = {
    initialized   : false,
    asyncInit     : true,

    _available    : null,
    _statusHandler: null,
    _flashReady   : false,
    _pageReady    : false,

    delayCalls    : [],

    init: function(){
        this.name = "flashStorage";
        this.id   = apf.flash.addPlayer(this);

        // IE/Flash has an evil bug that shows up some time: if we load the
        // Flash and it isn't in the cache, ExternalInterface works fine --
        // however, the second time when its loaded from the cache a timing
        // bug can keep ExternalInterface from working. The trick below
        // simply invalidates the Flash object in the cache all the time to
        // keep it loading fresh. -- Brad Neuberg
        
        this.STORAGE_SWF = (apf.config.resourcePath || apf.basePath)
            + "resources/apfStorage.swf?cachebust="
            + new Date().getTime();
        

        var flash = apf.flash.buildContent(
            "src",              this.STORAGE_SWF,
            "width",            "215",
            "height",           "138",
            "align",            "middle",
            "id",               this.name,
            "quality",          "high",
            "bgcolor",          "#ffffff",
            "allowFullScreen",  "true",
            "name",             this.name,
            "flashvars",        "playerID=" + this.id,
            "allowScriptAccess","always",
            "type",             "application/x-shockwave-flash",
            "pluginspage",      "http://www.adobe.com/go/getflashplayer",
            "menu",             "true");

        this.container = document.createElement('div');
        this.container.id           =  this.name + "_Container";
        this.container.className    = "apfVideo";
        with (this.container.style) {
            width = height = "0px";
            overflow = "hidden";
        }
        document.body.appendChild(this.container);
        this.container.innerHTML    = flash;

        //this.container = document.getElementById(this.name + "_Container");
        this.player    = apf.flash.getElement(this.name);

        // get available namespaces
        this._allNamespaces = this.getNamespaces();

        this._flashReady = this._pageReady = true;
    },

    /**
     * Sets the visibility of this Flash object.
     *
     * @param {Boolean} visible
     */
    setVisible: function(visible){
        if (visible == true) {
            this.container.style.position   = "absolute"; // IE -- Brad Neuberg
            this.container.style.visibility = "visible";
        }
        else {
            with (this.container.style) {
                position = "absolute";
                x = "-1000px";
                y = "-1000px";
                visibility = "hidden";
            }
        }
        return this;
    },

    /**
     * All public methods use this proxy to make sure that methods called before
     * initialization are properly called after the player is ready.
     *
     * @param {String} param1
     * @param {String} param2
     * @param {String} param3
     * @type {Object}
     */
    callMethod: function() {
        if (!this.initialized || typeof this.player.callMethod != "function") {
            this.delayCalls.push(arguments);
        }
        else {
            var args = [this.player, "callMethod"],
                f    = apf.flash,
                i    = 0,
                l    = arguments.length;
            for (; i < l; i++)
                args.push(f.encode(args[i]));
            f.remote.apply(null, args);
        }
    },

    /**
     * Call methods that were made before the player was initialized.
     *
     * @type {Object}
     */
    delayedCallTimer: null,
    makeDelayCalls  : function() {
        clearTimeout(this.delayedCallTimer);

        if (!this.delayCalls.length) {
            if (typeof this['onready'] == "function")
                this.onready();
            return this;
        }

        this.callMethod.apply(this, this.delayCalls[0]);
        this.delayCalls.splice(0, 1);

        //run timeout, we're interfacing with Flash here :S
        var _self = this;
        this.delayedCallTimer = window.setTimeout(function() {
            _self.makeDelayCalls();
        }, 1);

        return this;
    },

    ready : function(callback){
        if (this.initialized)
            callback();
        else
            this.onready = callback;
    },

    event: function(sEventName, oData) {
        //apf.console.info('Event called: ' + sEventName + ', ' + oData);
        if (sEventName == "status") {
            // Called if the storage system needs to tell us about the status
            // of a put() request.
            var ds  = apf.storage;

            if (statusResult == ds.PENDING) {
                //dfo.center();
                this.setVisible(true);
            }
            else
                this.setVisible(false);

            if (ds._statusHandler)
                ds._statusHandler.call(null, oData.status, oData.keyName, oData.namespace);
        }
        else if (sEventName == "loaded") {
            this.initialized = true;
            this.setVisible(false).makeDelayCalls();
        }
    },

    //    Set a new value for the flush delay timer.
    //    Possible values:
    //      0 : Perform the flush synchronously after each "put" request
    //    > 0 : Wait until 'newDelay' ms have passed without any "put" request to flush
    //     -1 : Do not  automatically flush
    setFlushDelay: function(newDelay){
        if (newDelay === null || typeof newDelay === "undefined" || isNaN(newDelay))
            throw new Error("Invalid argunment: " + newDelay);

        this.callMethod('setFlushDelay', String(newDelay));
    },

    getFlushDelay: function(){
        return Number(this.callMethod('getFlushDelay'));
    },

    flush: function(namespace){
        //@fixme: is this test necessary?  Just use !namespace
        if (namespace == null || typeof namespace == "undefined") {
            namespace = apf.storage.namespace;
        }
        this.callMethod('flush', namespace);
    },

    /**
     * @todo replace this with mikes flash detection code
     */
    isAvailable: function(){
        return location.protocol != "file:" && apf.flash.isEightAvailable();
    },

    put: function(key, value, namespace){
        
        if (this.isValidKey(key) == false)
            throw new Error(apf.formatErrorString(0, null,
                "Setting name/value pair", "Invalid key given: " + key));
        

        if (!namespace)
            namespace = this.namespace;

        
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null,
                "Setting name/value pair", "Invalid namespace given: " + namespace));
        

        this.callMethod('put', key, apf.serialize(value), namespace);
    },

    putMultiple: function(keys, values, namespace){
        
        if (this.isValidKeyArray(keys) === false
                || ! values instanceof Array
                || keys.length != values.length){
            throw new Error(apf.formatErrorString(0, null,
                "Setting multiple name/value pairs", "Invalid arguments: keys = ["
                + keys + "], values = [" + values + "]"));
        }
        

        if (!namespace)
            namespace = this.namespace;

        
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null, "Setting multiple name/value pairs", "Invalid namespace given: " + namespace));
        

        //    Convert the arguments on strings we can pass along to Flash
        var metaKey = keys.join(",");
        var lengths = [];
        for (var i = 0; i < values.length; i++) {
            values[i]  = apf.unserialize(values[i]);
            lengths[i] = values[i].length;
        }
        var metaValue   = values.join("");
        var metaLengths = lengths.join(",");
        this.callMethod('putMultiple', metaKey, metaValue, metaLengths, namespace);
    },

    get: function(key, namespace){
       
        if (this.isValidKey(key) == false)
            throw new Error(apf.formatErrorString(0, null, "Getting name/value pair", "Invalid key given: " + key));
        

        if (!namespace)
            namespace = this.namespace;

        
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null,
                "Getting name/value pair", "Invalid namespace given: " + namespace));
        

        var results = this.callMethod('get', key, namespace);
        if (results == "")
            return null;

        return apf.unserialize(apf.flash.decode(results));
    },

    getMultiple: function(keys, namespace){
        
        if (this.isValidKeyArray(keys) === false)
            throw new Error(apf.formatErrorString(0, null,
                "Getting name/value pair", "Invalid key array given: " + keys));
        

        if (!namespace)
            namespace = this.namespace;

        
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null,
                "Getting multiple name/value pairs", "Invalid namespace given: "
                + namespace));
        

        var metaKey     = keys.join(",");
        var metaResults = this.callMethod('getMultiple', metaKey, namespace);
        if (!metaResults)
            return null;
        var results     = eval("(" + metaResults.replace(/""([^",\]]+)/g, '"\\"$1')
            .replace(/([^",]+)""/g, '$1\\""') + ")");

        // destringify each entry back into a real JS object
        for (var i = 0; i < results.length; i++)
            results[i] = (results[i] == "") ? null : apf.unserialize(apf.flash.decode(results[i]));

        return results;
    },

    _destringify: function(results){
        // destringify the content back into a
        // real JavaScript object;
        // handle strings differently so they have better performance
        if (typeof results == "string" && (/^string:/.test(results)))
            results = results.substring("string:".length);
        else
            results = eval(results);

        return results;
    },

    getKeys: function(namespace){
       if (!namespace)
            namespace = this.namespace;

        
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null, "Clearing storage",
                "Invalid namespace given: " + namespace));
        

        var results = this.callMethod('getKeys', namespace);

        // Flash incorrectly returns an empty string as "null"
        if (results == this || results == null || results == "null")
          results = "";

        results = results.split(",");
        results.sort();

        return results;
    },

    getNamespaces: function(){
        var results = this.callMethod('getNamespaces');

        // Flash incorrectly returns an empty string as "null"
        if (results == this || results == null || results == "null")
            results = apf.storage.namespace || "default";

        results = results.split(",");
        results.sort();

        return results;
    },

    clear: function(namespace){
        if (!namespace)
            namespace = this.namespace;

        
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null, "Clearing storage",
                "Invalid namespace given: " + namespace));
        

        this.callMethod('clear', namespace);
    },

    remove: function(key, namespace){
        if (!namespace)
            namespace = this.namespace;

        
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null, "Removing key",
                "Invalid namespace given: " + namespace));
        

        this.callMethod('remove', key, namespace);
    },

    removeMultiple: function(/*array*/ keys, /*string?*/ namespace){ /*Object*/
        
        if (this.isValidKeyArray(keys) === false)
            throw new Error(apf.formatErrorString(0, null,
                "Getting name/value pair", "Invalid key array given: " + keys));
        

        if (!namespace)
            namespace = this.namespace;

        
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null,
                "Getting multiple name/value pairs", "Invalid namespace given: "
                + namespace));
        

        var metaKey = keys.join(",");
        this.callMethod('removeMultiple', metaKey, namespace);
    },

    isPermanent: function(){
        return true;
    },

    getMaximumSize: function(){
        return this.SIZE_NO_LIMIT;
    },

    hasSettingsUI: function(){
        return false;
    },

    showSettingsUI: function(){
        throw new Error(apf.formatErrorString(0, null, this.declaredClass
            + " does not support a storage settings user-interface"));
    },

    hideSettingsUI: function(){
        throw new Error(apf.formatErrorString(0, null, this.declaredClass
            + " does not support a storage settings user-interface"));
    },

    getResourceList: function(){ /* Array[] */
        // @todo: implement offline support icw Flash storage
        return [];
    }
};



/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/storage/cookie.js)SIZE(10313)TIME(1271105953)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * Storage module using browsers cookies objects to store the data. 
 * Only use this storage when using the file protocol, or if you're absolutely
 * certain that you know what you are doing.
 * @default_private
 * @todo only the put/get/remove methods are implemented correctly
 */
apf.storage.modules.cookie = {
    initialized: true,
    
    isAvailable: function(){
        return true;
    },

    /**
     * Stores a key value pair in a namespace.
     * @param {String} key       the identifier of the information.
     * @param {mixed}  value     the information to store.
     * @param {String} namespace the named context into which to store the key value pair.
     */
    put: function(key, value, namespace){
        
        if (this.isValidKey(key) == false)
            throw new Error(apf.formatErrorString(0, null, 
                "Setting name/value pair", 
                "Invalid key given: " + key));
        
        
        if (!namespace)
		    namespace = this.namespace;

		
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null, 
                "Setting name/value pair", 
                "Invalid namespace given: " + namespace));
        
        
        // serialize the value;
        value = apf.serialize(value);
        
        // store the value    
        apf.setcookie(namespace + "~" + key, value, 
            new Date().getTime() + (60*60*24*365*10000));
    },
    
    /**
     * Retrieves a keys in a namespace.
     * @param {String} key       the identifier of the information.
     * @param {String} namespace the named context of the keys to retrieve.
     * @return {mixed} the value that correspond to the key in the namespace.
     */
    get: function(key, namespace){
        
        if (this.isValidKey(key) == false)
            throw new Error(apf.formatErrorString(0, null, 
                "Getting name/value pair", 
                "Invalid key given: " + key));
        
		
		if (!namespace)
		    namespace = this.namespace;
		
		
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null, 
                "Getting name/value pair", 
                "Invalid namespace given: " + namespace));
        

        var value = apf.getcookie(namespace + "~" + key);
        return value ? apf.unserialize(value) : null;
    },
    
    /**
     * Retrieves all the namespaces in use.
     * @return {Array} list of namespaces.
     */
    getNamespaces: function(){
        throw new Error("Not Implemented");
        var results = [ this.namespace ];
        
        for (var ns in this.store)
            results.push(ns);
        
        return results;
    },

    /**
     * Retrieves all the keys of a namespace.
     * @param {String} namespace the named context of the keys to retrieve.
     * @return {Array} the list of keys in the namespace.
     */
    getKeys: function(namespace){
        throw new Error("Not Implemented");
        if (!namespace)
		    namespace = this.namespace;

        
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null, 
                "Clearing storage", 
                "Invalid namespace given: " + namespace));
        
        
        var results = [];
        for (var prop in this.store[namespace])
            results.push(prop);
        
        return results;
    },

    /** 
     * Removes all keys from a namespace
     */
    clear: function(namespace){
        throw new Error("Not Implemented");
        if (!namespace)
		    namespace = this.namespace;
	    
        
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null, 
                "Clearing storage", 
                "Invalid namespace given: " + namespace));
        
        
        delete this.store[namespace]
    },
    
    /**
     * Removes a key in a namespace.
     * @param {String} key       the identifier of the information.
     * @param {String} namespace the named context of the keys to remove.
     */
    remove: function(key, namespace){
        if (!namespace)
		    namespace = this.namespace;

        
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null, 
                "Removing key", 
                "Invalid namespace given: " + namespace));
        
        
        apf.delcookie(namespace + "~" + key);
    },
    
    /**
     * Stores a key value pair in a namespace.
     * @param {Array}  keys      a list of keys that identify the information stored.
     * @param {Array}  values    a list of values to store.
     * @param {String} namespace the named context into which to store the key value pair.
     */
    putMultiple: function(keys, values, namespace) {
        throw new Error("Not Implemented");
        
        if (this.isValidKeyArray(keys) === false
          || ! values instanceof Array
          || keys.length != values.length) {
            throw new Error(apf.formatErrorString(0, null,
                "Setting multiple name/value pairs",
                "Invalid arguments: keys = [" + keys + "], \
                                    values = [" + values + "]"));
        }
        

        if (!namespace)
            namespace = this.namespace;

        
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null, 
                "Setting multiple name/value pairs", 
                "Invalid namespace given: " + namespace));
        

         // store the value    
        if (!this.store[namespace])
            this.store[namespace] = {};
        
        // try to store the value    
        for (var i = 0; i < keys.length; i++) {
            this.store[namespace][keys[i]] = apf.serialize(values[i]);
        }
        
        return true;
    },

    /**
     * Retrieves all the values of several keys in a namespace.
     * @param {Array}  keys      a list of keys that identify the information retrieved.
     * @param {String} namespace the named context into which to store the key value pair.
     * @returns {Array} list of values that have been retrieved.
     */
    getMultiple: function(keys, namespace){
        throw new Error("Not Implemented");
        
        if (this.isValidKeyArray(keys) === false)
            throw new Error(apf.formatErrorString(0, null, 
                "Getting name/value pair", 
                "Invalid key array given: " + keys));
        
		
		if (!namespace)
		    namespace = this.namespace;

		
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null, 
                "Getting multiple name/value pairs", 
                "Invalid namespace given: " + namespace));
        
        
         if (!this.store[namespace])
            return [];
        
        var results = [];
        for (var i = 0; i < keys.length; i++){
            if (this.store[namespace][keys[i]])
                results.push(apf.unserialize(this.store[namespace][keys[i]]));
        }
        
        return results;
    },
    
    /**
     * Removes a key in a namespace.
     * @param {Array}  keys      a list of keys that identify the information to be removed.
     * @param {String} namespace the named context of the keys to remove.
     */
    removeMultiple: function(keys, namespace){
        throw new Error("Not Implemented");
        
        if (this.isValidKeyArray(keys) === false)
            throw new Error(apf.formatErrorString(0, null, 
                "Removing name/value pair", 
                "Invalid key array given: " + keys));
        

        if (!namespace)
            namespace = this.namespace;

        
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null, 
                "Removing multiple name/value pairs", 
                "Invalid namespace given: " + namespace));
        
        
        if (!this.store[namespace])
            return;
        
        for (var  i = 0; i < keys.length; i++)
            delete this.store[namespace][keys[i]];
    },                 
    
    isPermanent: function(){
        return false;
    },

    getMaximumSize: function(){
        return this.SIZE_NO_LIMIT;
    },

    hasSettingsUI: function(){
        return false;
    },
    
    showSettingsUI: function(){
        throw new Error(this.declaredClass 
            + " does not support a storage settings user-interface");
    },
    
    hideSettingsUI: function(){
        throw new Error(this.declaredClass 
            + " does not support a storage settings user-interface");
    }
};



/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/storage/html5.js)SIZE(8228)TIME(1270937593)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 *        Storage provider that uses WHAT Working Group features in Firefox 2 
 *        to achieve permanent storage.
 *        The WHAT WG storage API is documented at 
 *        http://www.whatwg.org/specs/web-apps/current-work/#scs-client-side
 */
apf.storage.modules.html5 = {
    domain     : (location.hostname == "localhost")
                    ? "localhost.localdomain"
                    : location.hostname,
    initialized: true,
    storage : apf.isIE
                ? self.localStorage
                : self.globalStorage,
    
    isAvailable: function(){
        try {
            // see: https://bugzilla.mozilla.org/show_bug.cgi?id=357323
            var myStorage = this.storage[location.href];
        }
        catch(e){
            return false;
        }

        return true;
    },

    put: function(key, value, namespace){
        
        if(this.isValidKey(key) == false)
            throw new Error(apf.formatErrorString(0, null,
                "Setting name/value pair", "Invalid key given: " + key));
        

        // get our full key name, which is namespace + key
        key = this.getFullKey(key, namespace);
        
        // serialize the value;
        value = apf.serialize(value);
        
        // try to store the value
        try {
            var myStorage = this.storage[this.domain];
            myStorage.setItem(key, value);
        }
        catch(e) {
            // indicate we failed
            
            throw new Error(apf.formatErrorString(0, null, "Setting name/value pair",
                "Could not set name/value pair"));
        
        }
    },

    get: function(key, namespace){
        
        if (this.isValidKey(key) == false)
            throw new Error(apf.formatErrorString(0, null,
                "Setting name/value pair", "Invalid key given: " + key));
        

        // get our full key name, which is namespace + key
        key = this.getFullKey(key, namespace);
        
        // sometimes, even if a key doesn't exist, Firefox
        // will return a blank string instead of a null --
        // this _might_ be due to having underscores in the
        // keyname, but I am not sure.
        
        // @fixme: Simplify this bug into a testcase and
        // submit it to Firefox
        var myStorage = this.storage[this.domain];
        var results = myStorage.getItem(key);
        
        if (results == null || results == "")
            return null;
        
        return apf.unserialize(results);
    },
    
    getNamespaces: function(){
        var results = [ this.namespace ];
        
        // simply enumerate through our array and save any string
        // that starts with __
        var found = {};
        var myStorage = this.storage[this.domain];
        var tester = /^__([^_]*)_/;
        for (var i = 0; i < myStorage.length; i++) {
            var currentKey = myStorage.key(i);
            if (tester.test(currentKey) == true){
                var currentNS = currentKey.match(tester)[1];
                // have we seen this namespace before?
                if (typeof found[currentNS] == "undefined") {
                    found[currentNS] = true;
                    results.push(currentNS);
                }
            }
        }
        
        return results;
    },

    getKeys: function(namespace){
        if(!namespace)
            namespace = this.namespace;
		    
        
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null, "Getting keys",
                "Invalid namespace given: " + namespace));
        
        
        // create a regular expression to test the beginning
        // of our key names to see if they match our namespace;
        // if it is the default namespace then test for the presence
        // of no namespace for compatibility with older versions
        // of dojox.storage
        var namespaceTester = new RegExp(namespace == this.namespace
            ? "^([^_]{2}.*)$"
            : "^__" + namespace + "_(.*)$");
        
        var myStorage = this.storage[this.domain];
        var keysArray = [];
        for (var i = 0; i < myStorage.length; i++) {
            var currentKey = myStorage.key(i);
            if (namespaceTester.test(currentKey) == true) {
                // strip off the namespace portion
                currentKey = currentKey.match(namespaceTester)[1];
                keysArray.push(currentKey);
            }
        }
        
        return keysArray;
    },

    clear: function(namespace){
        if (!namespace)
            namespace = this.namespace;
	    
        
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null, "Clearing storage", "Invalid namespace given: " + namespace));
        
        
        // create a regular expression to test the beginning
        // of our key names to see if they match our namespace;
        // if it is the default namespace then test for the presence
        // of no namespace for compatibility with older versions
        // of dojox.storage
        var namespaceTester = new RegExp(namespace == this.namespace
            ? "^[^_]{2}"
            : "^__" + namespace + "_");
        
        var myStorage = this.storage[this.domain];
        for (var i = myStorage.length-1; i >= 0; i--) {
            if (namespaceTester.test(myStorage.key(i)) == true)
                myStorage.removeItem(myStorage.key(i));
        }
    },
    
    remove: function(key, namespace){
        // get our full key name, which is namespace + key
        key = this.getFullKey(key, namespace);
        
        var myStorage = this.storage[this.domain];
        myStorage.removeItem(key);
    },
    
    isPermanent: function(){
        return true;
    },

    getMaximumSize: function(){
        return 0;
    },

    hasSettingsUI: function(){
        return false;
    },
    
    showSettingsUI: function(){
        throw new Error(apf.formatErrorString(0, null, this.declaredClass
            + " does not support a storage settings user-interface"));
    },
    
    hideSettingsUI: function(){
        throw new Error(apf.formatErrorString(0, null, this.declaredClass
            + " does not support a storage settings user-interface"));
    },
    
    getFullKey: function(key, namespace){
        if (!namespace)
            namespace = this.namespace;
        
        
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null, "Clearing storage",
                "Invalid namespace given: " + namespace));
        
        
        // don't append a namespace string for the default namespace,
        // for compatibility with older versions of dojox.storage
        return namespace == this.namespace
            ? key
            : "__" + namespace + "_" + key;
    }
};



/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/storage/air.file.js)SIZE(10053)TIME(1265328064)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



// summary: 
//		Storage provider that uses features in the Adobe AIR runtime to achieve
//		permanent storage

apf.storage.modules['air.file'] = {
    initialized: false,
	
    init: function(){
        this.File = window.runtime.flash.filesystem.File;
        this.FileStream = window.runtime.flash.filesystem.FileStream;
        this.FileMode = window.runtime.flash.filesystem.FileMode;
        
        this.storagePath = "__APF_" + (apf.config.name
            ? apf.config.name.toUpperCase()
            : "STORAGE") + "/";

        // need to initialize our storage directory
        try {
            var dir = this.File.applicationStorageDirectory.resolvePath(this.storagePath);
            if (!dir.exists)
                dir.createDirectory();
            this.initialized = true;
        }
        catch(e) {
            apf.console.warn(e.message);
            return false;
        }
    },

    isAvailable: function(){
        return apf.isAIR;
    },
	
    put: function(key, value, namespace){
        
        if (this.isValidKey(key) == false)
            throw new Error(apf.formatErrorString(0, null,
                "Setting name/value pair",
                "Invalid key given: " + key));
        
        
        if (!namespace)
            namespace = this.namespace;

        
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null,
                "Setting name/value pair",
                "Invalid namespace given: " + namespace));
        
		
        // try to store the value
        try {
            this.remove(key, namespace);
			
            var dir = this.File.applicationStorageDirectory.resolvePath(this.storagePath + namespace);
            if (!dir.exists)
                dir.createDirectory();
			
            var file = dir.resolvePath(key);
            var stream = new this.FileStream();
            stream.open(file, this.FileMode.WRITE);
            stream.writeObject(value);
            stream.close();
        } 
        catch(e) {
            
            throw new Error(apf.formatErrorString(0, null,
                "Setting name/value pair",
                "Error writing file: " + e.message));
            
			
            return false;
        }
		
        return true;
    },
	
    get: function(key, namespace){
        
        if (this.isValidKey(key) == false)
            throw new Error(apf.formatErrorString(0, null,
                "Getting name/value pair",
                "Invalid key given: " + key));
        
		
        if (!namespace)
            namespace = this.namespace;
		
        
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null,
                "Getting name/value pair",
                "Invalid namespace given: " + namespace));
        
		
        var file = this.File.applicationStorageDirectory.resolvePath(this.storagePath + namespace + '/' + key);
        if (!file.exists || file.isDirectory)
            return false;

        var stream = new this.FileStream();
        stream.open(file, this.FileMode.READ);
        var results = stream.readObject();
        stream.close();
		
        return results;
    },
	
    getNamespaces: function(){
        var results = [ this.namespace ];
        var dir = this.File.applicationStorageDirectory.resolvePath(this.storagePath);
        var files = dir.getDirectoryListing();
        for (var i = 0; i < files.length; i++) {
            if (files[i].isDirectory && files[i].name != this.namespace)
                results.push(files[i].name);
        }
		
        return results;
    },

    getKeys: function(namespace){
        if (!namespace)
            namespace = this.namespace;

        
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null,
                "Clearing storage",
                "Invalid namespace given: " + namespace));
        

        var results = [];
        var dir = this.File.applicationStorageDirectory.resolvePath(this.storagePath + namespace);
        if (dir.exists && dir.isDirectory){
            var files = dir.getDirectoryListing();
            for (var i = 0; i < files.length; i++)
                results.push(files[i].name);
        }
        return results;
    },
	
    clear: function(namespace){
        if (!namespace)
            namespace = this.namespace;
	    
        
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null,
                "Clearing storage",
                "Invalid namespace given: " + namespace));
        
		
        var dir = this.File.applicationStorageDirectory.resolvePath(this.storagePath + namespace);
        if (dir.exists && dir.isDirectory)
            dir.deleteDirectory(true);
    },
	
    remove: function(key, namespace){
        if (!namespace)
            namespace = this.namespace;

        
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null,
                "Removing key",
                "Invalid namespace given: " + namespace));
        

        var file = this.File.applicationStorageDirectory.resolvePath(this.storagePath + namespace + '/' + key);
        if (file.exists && !file.isDirectory)
            file.deleteFile();
    },
	
    putMultiple: function(keys, values, namespace) {
        
        if (this.isValidKeyArray(keys) === false
            || ! values instanceof Array
            || keys.length != values.length){
            throw new Error(apf.formatErrorString(0, null,
                "Setting multiple name/value pairs",
                "Invalid arguments: keys = [" + keys + "], values = [" + values + "]"));
        }
        
		
        if (!namespace)
            namespace = this.namespace;

        
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null,
                "Setting multiple name/value pairs",
                "Invalid namespace given: " + namespace));
        

        // try to store the value
        try {
            for (var i = 0; i < keys.length; i++)
                this.put(keys[i], values[i], null, namespace);
        }
        catch(e) {
            
            throw new Error(apf.formatErrorString(0, null,
                "Writing multiple name/value pair",
                "Error writing file: " + e.message));
            
            return false;
        }
		
        return true;
    },

    getMultiple: function(keys, namespace){
        
        if (this.isValidKeyArray(keys) === false)
            throw new Error(apf.formatErrorString(0, null,
                "Getting name/value pair",
                "Invalid key array given: " + keys));
        
		
        if (!namespace)
            namespace = this.namespace;

        
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null,
                "Getting multiple name/value pairs",
                "Invalid namespace given: " + namespace));
        

        var results = [];
        for (var i = 0; i < keys.length; i++)
            results[i] = this.get(keys[i], namespace);

        return results;
    },
	
    removeMultiple: function(keys, namespace){
        
        if (this.isValidKeyArray(keys) === false)
            throw new Error(apf.formatErrorString(0, null,
                "Removing name/value pair",
                "Invalid key array given: " + keys));
        
		
        if (!namespace)
            namespace = this.namespace;

        
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null,
                "Removing multiple name/value pairs",
                "Invalid namespace given: " + namespace));
        
		
        for (var i = 0; i < keys.length; i++)
            this.remove(keys[i], namespace);
    },
	
    isPermanent: function(){
        return true;
    },

    getMaximumSize: function(){
        return this.SIZE_NO_LIMIT;
    },

    hasSettingsUI: function(){
        return false;
    },
	
    showSettingsUI: function(){
        throw new Error(this.declaredClass
            + " does not support a storage settings user-interface");
    },
	
    hideSettingsUI: function(){
        throw new Error(this.declaredClass
            + " does not support a storage settings user-interface");
    }
};



/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/storage/air.sql.js)SIZE(11835)TIME(1265328064)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



// summary: 
//		Storage provider that uses features in the Adobe AIR runtime to achieve
//		permanent storage

apf.storage.modules['air.sql'] = {
    database_file: "apf.db",

    initialized: false,
    _db: null,
	
    init: function(){
        this.File          = window.runtime.flash.filesystem.File;
        this.SQLConnection = window.runtime.flash.data.SQLConnection;
        this.SQLStatement  = window.runtime.flash.data.SQLStatement;
        
        this.table_name = "__APF_" + (apf.config.name
            ? apf.config.name.toUpperCase()
            : "STORAGE");

        // need to initialize our storage database
        try {
            this._db = new this.SQLConnection();
            this._db.open(this.File.applicationStorageDirectory.resolvePath(this.database_file));
			
            this._sql("CREATE TABLE IF NOT EXISTS " + this.table_name
                + "(namespace TEXT, key TEXT, value TEXT)");
            this._sql("CREATE UNIQUE INDEX IF NOT EXISTS namespace_key_index ON "
                + this.table_name + " (namespace, key)");
			
            this.initialized = true;
        }
        catch(e) {
            apf.console.warn(e.message);
            return false;
        }
    },
	
    _sql: function(query, params){
        var stmt = new this.SQLStatement();
        stmt.sqlConnection = this._db;
        stmt.text          = query;
        if (params)
            apf.extend(stmt.parameters, params);

        stmt.execute();
        return stmt.getResult();
    },
	
    isAvailable: function(){
        return apf.isAIR;
    },
	
    put: function(key, value, namespace){
        
        if (this.isValidKey(key) == false)
            throw new Error(apf.formatErrorString(0, null,
                "Setting name/value pair",
                "Invalid key given: " + key));
        
        
        if (!namespace)
            namespace = this.namespace;

        
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null,
                "Setting name/value pair",
                "Invalid namespace given: " + namespace));
        
		
        // try to store the value
        try {
            this._sql("DELETE FROM " + this.table_name
                + " WHERE namespace = :namespace AND key = :key",
            {
                ":namespace": namespace,
                ":key"      : key
            });
            this._sql("INSERT INTO " + this.table_name
                + " VALUES (:namespace, :key, :value)",
            {
                ":namespace": namespace,
                ":key"      : key,
                ":value"    : value
            });
        }
        catch(e) {
            
            throw new Error(apf.formatErrorString(0, null,
                "Setting name/value pair",
                "Error writing file: " + e.message));
            
			
            return false;
        }
		
        return true;
    },
	
    get: function(key, namespace){
        
        if (this.isValidKey(key) == false)
            throw new Error(apf.formatErrorString(0, null,
                "Getting name/value pair",
                "Invalid key given: " + key));
        
		
        if (!namespace)
            namespace = this.namespace;
		
        
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null,
                "Getting name/value pair",
                "Invalid namespace given: " + namespace));
        
		
        var results = this._sql("SELECT * FROM " + this.table_name
            + " WHERE namespace = :namespace AND key = :key",
        {
            ":namespace": namespace,
            ":key"      : key
        });
		
        if (results.data && results.data.length)
            return results.data[0].value;
		
        return null;
    },
	
    getNamespaces: function(){
        var results = [ this.namespace ];
        var rs = this._sql("SELECT namespace FROM " + this.table_name + " DESC GROUP BY namespace");
        if (rs.data) {
            for (var i = 0; i < rs.data.length; i++) {
                if (rs.data[i].namespace != this.namespace)
                    results.push(rs.data[i].namespace);
            }
        }
        return results;
    },

    getKeys: function(namespace){
        if(!namespace)
            namespace = this.namespace;

        
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null,
                "Clearing storage",
                "Invalid namespace given: " + namespace));
        
		
        var results = [];
        var rs = this._sql("SELECT key FROM " + this.table_name
            + " WHERE namespace = :namespace", {
            ":namespace": namespace
        });
        if (rs.data) {
            for (var i = 0; i < rs.data.length; i++)
                results.push(rs.data[i].key);
        }
        return results;
    },
	
    clear: function(namespace){
        if (!namespace)
            namespace = this.namespace;
	    
        
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null,
                "Clearing storage",
                "Invalid namespace given: " + namespace));
        
        
        this._sql("DELETE FROM " + this.table_name
            + " WHERE namespace = :namespace", {
            ":namespace":namespace
        });
    },
	
    remove: function(key, namespace){
        if (!namespace)
            namespace = this.namespace;

        
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null,
                "Removing key",
                "Invalid namespace given: " + namespace));
        
        
        this._sql("DELETE FROM " + this.table_name
            + " WHERE namespace = :namespace AND key = :key",
        {
            ":namespace": namespace,
            ":key"      : key
        });
    },
	
    putMultiple: function(keys, values, namespace) {
        
        if (this.isValidKeyArray(keys) === false
            || ! values instanceof Array
            || keys.length != values.length){
            throw new Error(apf.formatErrorString(0, null,
                "Setting multiple name/value pairs",
                "Invalid arguments: keys = [" + keys + "], values = [" + values + "]"));
        }
        
		
        if (!namespace)
            namespace = this.namespace;

        
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null,
                "Setting multiple name/value pairs",
                "Invalid namespace given: " + namespace));
        

        // try to store the value
        try {
            this._db.begin();
            for (var i = 0; i < keys.length; i++) {
                this._sql("DELETE FROM " + this.table_name
                    + " WHERE namespace = :namespace AND key = :key",
                {
                    ":namespace": namespace,
                    ":key"      : key[i]
                });
                this._sql("INSERT INTO " + this.table_name
                    + " VALUES (:namespace, :key, :value)",
                {
                    ":namespace": namespace,
                    ":key"      : key[i],
                    ":value"    : value
                });
            }
            this._db.commit();
        }
        catch(e) {
            
            throw new Error(apf.formatErrorString(0, null,
                "Writing multiple name/value pair",
                "Error writing file: " + e.message));
            
            return false;
        }
		
        return true;
    },

    getMultiple: function(keys, namespace){
        
        if (this.isValidKeyArray(keys) === false)
            throw new Error(apf.formatErrorString(0, null,
                "Getting name/value pair",
                "Invalid key array given: " + keys));
        
		
        if (!namespace)
            namespace = this.namespace;

        
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null,
                "Getting multiple name/value pairs",
                "Invalid namespace given: " + namespace));
        

        var results = [];
        for (var i = 0; i < keys.length; i++) {
            var result = this._sql("SELECT * FROM " + this.table_name
                + " WHERE namespace = :namespace AND key = :key",
            {
                ":namespace": namespace,
                ":key"      : keys[i]
            });
            results[i] = result.data && result.data.length 
                ? result.data[0].value
                : null;
        }
		
        return results;
    },
	
    removeMultiple: function(keys, namespace){
        
        if (this.isValidKeyArray(keys) === false)
            throw new Error(apf.formatErrorString(0, null,
                "Removing name/value pair",
                "Invalid key array given: " + keys));
        
		
        if (!namespace)
            namespace = this.namespace;

        
        if (this.isValidKey(namespace) == false)
            throw new Error(apf.formatErrorString(0, null,
                "Removing multiple name/value pairs",
                "Invalid namespace given: " + namespace));
        
		
        this._db.begin();
        for (var i = 0; i < keys.length;i++) {
            this._sql("DELETE FROM " + this.table_name
                + " WHERE namespace = namespace = :namespace AND key = :key",
            {
                ":namespace": namespace,
                ":key"      : keys[i]
            });
        }
        this._db.commit();
    },
	
    isPermanent: function(){
        return true;
    },

    getMaximumSize: function(){
        return this.SIZE_NO_LIMIT;
    },

    hasSettingsUI: function(){
        return false;
    },
	
    showSettingsUI: function(){
        throw new Error(this.declaredClass + " does not support a storage settings user-interface");
    },
	
    hideSettingsUI: function(){
        throw new Error(this.declaredClass + " does not support a storage settings user-interface");
    }
};



/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/teleport/http.js)SIZE(37105)TIME(1270937593)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/**
 * This object does what is commonly known as Ajax, it <strong>A</strong>synchronously 
 * communicates using <strong>J</strong>avascript <strong>A</strong>nd in most 
 * cases it sends or receives <strong>X</strong>ml. It allows for easy http 
 * communication from within the browser. This object provides
 * {@link teleport.http.method.savecache caching} on top of
 * the browser's cache. This enables you to optimize your application, because
 * this can be set on a per call basis. 
 * Example:
 * Retrieving content over http synchronously:
 * <code>
 *  var http = new apf.http();
 *  var data = http.get("http://www.example.com/mydata.jsp", {async: false});
 *  alert(data);
 * </code>
 * Example:
 * Retrieving content over http asynchronously:
 * <code>
 *  var http = new apf.http();
 *  http.get("http://www.example.com/mydata.jsp", {
 *      callback: function(data, state, extra){
 *         if (state != apf.SUCCESS)
 *             return alert('an error has occurred');
 *
 *         alert(data);
 *      }
 *  });
 * </code>
 * Example:
 * Async http request with retry.
 * <code>
 *  var http = new apf.http();
 *  http.get("http://www.example.com/mydata.jsp", {
 *      callback: function(data, state, extra){
 *          if (state != apf.SUCCESS) {
 *              var oError = new Error(apf.formatErrorString(0, null,
 *                  "While loading data", "Could not load data\n" + extra.message));
 *
 *              if (extra.tpModule.retryTimeout(extra, state, null, oError) === true)
 *                  return true;
 *
 *              throw oError;
 *          }
 *
 *          alert(data);
 *      }
 *  });
 * </code>
 *
 * @event error Fires when a communication error occurs.
 *   bubbles: yes
 *   cancelable:  Prevents a communication error to be thrown.
 *   object:
 *     {Error}          error     the error object that is thrown when the event
 *                                callback doesn't return false.
 *     {Number}         state     the state of the call
 *       Possible values:
 *       apf.SUCCESS  the request was successfull
 *       apf.TIMEOUT  the request has timed out.
 *       apf.ERROR    an error has occurred while making the request.
 *       apf.OFFLINE  the request was made while the application was offline.
 *     {mixed}          userdata  data that the caller wanted to be available in
 *                                the callback of the http request.
 *     {XMLHttpRequest} http      the object that executed the actual http request.
 *     {String}         url       the url that was requested.
 *     {Http}           tpModule  the teleport module that is making the request.
 *     {Number}         id        the id of the request.
 *     {String}         message   the error message.
 *
 * @constructor
 * @define http
 * @addnode teleport
 * @default_private
 *
 * @author      Ruben Daniels (ruben AT ajax DOT org)
 * @version     %I%, %G%
 * @since       0.4
 */
apf.http = function(){
    this.queue     = [null];
    this.callbacks = {};
    this.cache     = {};

    /**
     * Sets the timeout of http requests in milliseconds. Default is 10000ms (10s).
     */
    this.timeout   = this.timeout || 10000; //default 10 seconds
    
    /**
     * Sets whether this element routes traffic through a server proxy.
     * Remarks:
     * This can also be set on a per call basis. See {@link teleport.http.method.get}.
     */
    this.autoroute = this.autoroute || false;
    
    /**
     * String specifying the url to the route script. 
     * Remarks:
     * The route script will receive the route information in 3 extra headers:
     *   X-Route-Request     - Containing the destination url.<br />
     *   X-Proxy-Request     - Containing the destination url.<br />
     *   X-Compress-Response - Set to 'gzip'.<br />
     */
    this["route-server"] = this["route-server"] || null;

    if (!this.$uniqueId)
        this.$uniqueId = apf.all.push(this) - 1;

    this.toString = this.toString || function(){
        return "[Ajax.org Teleport Component : (HTTP)]";
    };

    
    var namespace = apf.config.name + ".apf.http";

    /**
     * Saves the apf http cache to the available {@link core.storage storage engine}.
     */
    this.saveCache = function(){
        
        if (!apf.serialize)
            throw new Error(apf.formatErrorString(1079, this,
                "HTTP save cache",
                "Could not find JSON library."));
        

        
        apf.console.info("[HTTP] Loading HTTP Cache", "teleport");
        

        var strResult = apf.serialize(comm.cache);
        apf.storage.put("cache_" + this.name, strResult,
            apf.config.name + ".apf.http");
    };

    /**
     * Loads the apf http cache from the available {@link core.storage storage engine}.
     */
    this.loadCache = function(){
        var strResult = apf.storage.get("cache_" + this.name,
            apf.config.name + ".apf.http");

        
        apf.console.info("[HTTP] Loading HTTP Cache", "steleport");
        

        if (!strResult)
            return false;

        this.cache = apf.unserialize(strResult);

        return true;
    };

    /**
     * Removes the stored http cache from the available {@link core.storage storage engine}.
     */
    this.clearCache = function(){
        apf.storage.remove("cache_" + this.name,
            apf.config.name + ".apf.http");
    };
    

    /**
     * Makes an http request that receives xml
     * @param {String}   url       the url that is accessed.
     * @param {Object}   options   the options for the http request
     *   Properties:
     *   {Boolean} async          whether the request is sent asynchronously. Defaults to true.
     *   {mixed}   userdata       custom data that is available to the callback function.
     *   {String}  method         the request method (POST|GET|PUT|DELETE). Defaults to GET.
     *   {Boolean} nocache        whether browser caching is prevented.
     *   {String}  data           the data sent in the body of the message.
     *   {Boolean} autoroute      whether the request can fallback to a server proxy.
     *   {Boolean} caching        whether the request should use internal caching.
     *   {Boolean} ignoreOffline  whether to ignore offline catching.
     *   {Function} callback      the handler that gets called whenever the
     *                            request completes succesfully or with an error,
     *                            or when the request times out.
     */
    this.getXml = function(url, callback, options){
        if (!options) options = {};
        options.useXML = true;
        options.callback = callback;
        return this.get(url, options);
    };

    /**
     * Makes an http request.
     * @param {String}   url       the url that is accessed.
     * @param {Object}   options   the options for the http request
     *   Properties:
     *   {Boolean} async          whether the request is sent asynchronously. Defaults to true.
     *   {mixed}   userdata       custom data that is available to the callback function.
     *   {String}  method         the request method (POST|GET|PUT|DELETE). Defaults to GET.
     *   {Boolean} nocache        whether browser caching is prevented.
     *   {String}  data           the data sent in the body of the message.
     *   {Boolean} useXML         whether the result should be interpreted as xml.
     *   {Boolean} autoroute      whether the request can fallback to a server proxy.
     *   {Boolean} caching        whether the request should use internal caching.
     *   {Boolean} ignoreOffline  whether to ignore offline catching.
     *   {Function} callback      the handler that gets called whenever the
     *                            request completes succesfully or with an error,
     *                            or when the request times out.
     */
    this.get = this.$get = function(url, options){
        if (!options)
            options = {};

        var _self = this;
        var id    = options.id;
        

        var async = options.async = (options.async
            || typeof options.async == "undefined" || apf.isOpera || false);

        
        if (apf.isWebkit)
            url = apf.html_entity_decode(url);
        

        var data = options.data || "";

        if (apf.isNot(id)) {
            
            if (this.cache[url] && this.cache[url][data]) {
                var http = {
                    responseText : this.cache[url][data],
                    responseXML  : {},
                    status       : 200,
                    isCaching    : true
                }
            }
            else
            
                var http = apf.getHttpReq();

            id = this.queue.push({
                http     : http,
                url      : url,
                callback : options.callback,
                retries  : 0,
                options  : options
            }) - 1;

            
            if (http.isCaching) {
                if (async)
                    return $setTimeout("apf.lookup(" + this.$uniqueId
                        + ").receive(" + id + ");", 50);
                else
                    return this.receive(id);
            }
            
        }
        else {
            var http = this.queue[id].http;

            
            if (http.isCaching)
                http = apf.getHttpReq();
            else
            
                http.abort();
        }

        if (async) {
            
            {
                http.onreadystatechange = function(){
                    if (!_self.queue[id] || http.readyState != 4)
                        return;

                    _self.receive(id);
                }
            }
        }

        var autoroute = this.autoroute && apf.isOpera
            ? true //Bug in opera
            : (options.autoroute || this.shouldAutoroute),
            httpUrl = autoroute ? this["route-server"] : url;

        
        if (!options.hideLogMessage) {
            apf.console.teleport(this.queue[id].log = new apf.teleportLog({
                id      : id,
                tp      : this,
                type    : options.type,
                method  : this.method || options.method || "GET",
                url     : url,
                route   : autoroute ? httpUrl : "",
                data    : new String(data && data.xml ? data.xml : data),
                start   : new Date()
            }))
        }
        
        var headers = [];
        
        
        function setRequestHeader(name, value){
            
            headers.push(name + ": " + value);
            
            http.setRequestHeader(name, value);
        }

        var errorFound = false;
        try {
            if (options.nocache)
                httpUrl = apf.getNoCacheUrl(httpUrl);

            
            
            // experimental for Firefox Cross Domain problem
            // http://ubiquity-xforms.googlecode.com/svn/wiki/CrossDomainSubmissionDeployment.wiki
            
            
            try {
                netscape.security.PrivilegeManager.enablePrivilege("UniversalBrowserRead");
            }
            catch (e) {
            
            
                //Currently we don't support html5 cross domain access
                if (apf.hasHtml5XDomain
                  && httpUrl.match(/^http:\/\//)
                  && !new apf.url(httpUrl).isSameLocation()) {
                    throw new Error(apf.formatErrorString(0,
                        this, "Communication error", "Url: " + httpUrl
                            + "\nReason: Same origin policy in effect"));
                  }
            
            
            }
            
            
            //end experimental

            http.open(this.method || options.method || "GET", httpUrl, async);

            if (options.username) {
                setRequestHeader("Authorization", "Basic " 
                    + apf.crypto.Base64.encode(options.username + ":" + options.password))
            }

            //@todo OPERA ERROR's here... on retry [is this still applicable?]
            if (!apf.isWebkit)
                setRequestHeader("User-Agent", "Ajax.org Teleport 3.0"); //@deprecated
            setRequestHeader("X-Requested-With", "XMLHttpRequest");
            if (!options.headers || !options.headers["Content-type"])
                setRequestHeader("Content-type", this.contentType
                    || (this.useXML || options.useXML ? "text/xml" : "text/plain"));

            if (autoroute) {
                setRequestHeader("X-Route-Request", url);
                setRequestHeader("X-Proxy-Request", url);
                setRequestHeader("X-Compress-Response", "gzip");
            }
        }
        catch (e) {
            errorFound = e.message;
        }

        if (errorFound) {
            var useOtherXH = false;

            
            if (self.XMLHttpRequestUnSafe) {
                try {
                    http = new XMLHttpRequestUnSafe();
                    http.onreadystatechange = function(){
                        if (!_self.queue[id] || http.readyState != 4)
                            return;

                        _self.receive(id);
                    }
                    http.open(this.method || options.method || "GET", (options.nocache
                        ? apf.getNoCacheUrl(httpUrl)
                        : httpUrl), async);

                    setRequestHeader("X-Requested-With", "XMLHttpRequest");
                    if (!options.headers || !options.headers["Content-type"])
                        setRequestHeader("Content-type", this.contentType
                            || (this.useXML || options.useXML ? "text/xml" : "text/plain"));

                    this.queue[id].http = http;
                    options.async     = true; //force async
                    useOtherXH        = true;
                }
                catch (e) {}
            }
            

            // Retry request by routing it
            if (!useOtherXH && this.autoroute && !autoroute) {
                

                this.shouldAutoroute = true;

                options.autoroute = true;
                return this.get(url, options);
            }

            if (!useOtherXH) {
                //Routing didn't work either... Throwing error
                var noClear = options.callback ? options.callback(null, apf.ERROR, {
                    userdata: options.userdata,
                    http    : http,
                    url     : url,
                    tpModule: this,
                    id      : id,
                    message : "Permission denied accessing remote resource: "
                              + url + "\nMessage: " + errorFound
                }) : false;
                if (!noClear)
                    this.clearQueueItem(id);

                return;
            }
        }

        if (this.$headerHook)
            this.$headerHook(http);

        //Set request headers
        if (options.headers) {
            for (var name in options.headers)
                setRequestHeader(name, options.headers[name]);
        }
        
        
        if (!options.hideLogMessage)
            this.queue[id].log.request(headers);
        

        function handleError(){
            var msg = self.navigator.onLine
                ? "File or Resource not available " + url
                : "Browser is currently working offline";

            
            apf.console.warn(msg, "teleport");
            if (!options.hideLogMessage)
                _self.queue[id].log.response({
                    
                    end     : new Date(),
                    
                    message : msg,
                    http    : http
                });
            

            var state = self.navigator && navigator.onLine
                ? apf.ERROR
                : apf.TIMEOUT;

            // File not found
            var noClear = options.callback ? options.callback(null, state, {
                userdata : options.userdata,
                http     : http,
                url      : url,
                tpModule : _self,
                id       : id,
                message  : msg
            }) : false;
            if(!noClear) _self.clearQueueItem(id);
        }

        function send(isLocal){
            var hasError;

            if (apf.isIE && isLocal) { //When local IE calls onreadystate immediately
                var oldWinOnerror = window.onerror;
                window.onerror = function(){
                    if (arguments.caller.callee == send) {
                        window.onerror = oldWinOnerror;
                        //_self.receive(id);
                        //setTimeout(function(){handleError();});
                        return true;
                    }
                    else {
                        window.onerror = oldWinOnerror;
                        
                        if (oldWinOnerror)
                            return oldWinOnerror.apply(window, arguments);
                    }
                }
                http.send(data);
                window.onerror = oldWinOnerror;
            }
            else {
                try{
                    http.send(data);
                }
                catch(e){
                    hasError = true;
                }
            }

            if (hasError) {
                handleError();
                return;
            }
        }

        if (!async) {
            send.call(this);
            return this.receive(id);
        }
        else {
            if (apf.loadsLocalFilesSync && location.protocol == "file:"
              && url.indexOf("http://") == -1) {
                $setTimeout(function(){
                    send.call(_self, true);
                });
            }
            else
                send.call(_self);

            return id;
        }
    };
    
    
    /**
     * Method that all async objects should implement
     * @private
     */
    if (!this.exec) {
        this.exec = function(method, args, callback, options){
            if (!options)
                options = {};
            
            var url = args[0], query = "";
            if (!options.method)
                options.method = method.toUpperCase();
            if (!options.callback)
                options.callback = callback;
            
            this.contentType = "application/x-www-form-urlencoded";
            this.$get(
                apf.getAbsolutePath(apf.config.baseurl, url), 
                options.method == "GET" 
                    ? options 
                    : apf.extend({data : query}, options)
            );
        }
    }
    

    /**
     * @private
     */
    this.receive = function(id){
        if (!this.queue[id])
            return false;

        var qItem    = this.queue[id],
            http     = qItem.http,
            callback = qItem.callback;
        //if (apf.isGecko)
        //    var apf = self.apf || apf;     // needed here to fix a rare ReferenceError in FF

        

        if (self.navigator && navigator.onLine === false 
          && (location.protocol != "file:"
          || qItem.url.indexOf("http://") > -1))
            return false;

        // Test if HTTP object is ready
        if (qItem.async) {
            try {
                if (http.status) {}
            }
            catch (e) {
                var _self = this;
                return $setTimeout(function(){
                    _self.receive(id)
                }, 10);
            }
        }
        
        
        if (!qItem.options.hideLogMessage) {
            apf.console.info("[HTTP] Receiving [" + id + "]"
                + (http.isCaching
                    ? "[<span style='color:orange'>cached</span>]"
                    : "")
                + " from " + qItem.url,
                "teleport",
                http.responseText);
        }
        

        //Gonna check for validity of the http response
        var errorMessage = [],
            extra = {
                
                end      : new Date(),
                
                tpModule : this,
                http     : http,
                url      : qItem.url,
                callback : callback,
                id       : id,
                retries  : qItem.retries || 0,
                userdata : qItem.options.userdata
            };

        // Check HTTP Status
        // The message didn't receive the server. We consider this a timeout (i.e. 12027)
        if (http.status > 600)
            return this.$timeout(id);

        extra.data = http.responseText; //Can this error?

        if (http.status >= 400 && http.status < 600 || http.status < 10 && http.status != 0) {
            

            errorMessage.push("HTTP error [" + id + "]:" + http.status + "\n"
                + http.responseText);
        }

        // Check for XML Errors
        if (qItem.options.useXML || this.useXML) {
            /* Note (Mike, Oct 14th 2008): for WebDAV, I had to copy the lines below,
                                           it required custom responseXML handling/
                                           parsing.
                                           If you alter this code, please correct
                                           webdav.js appropriately.
            */
            if ((http.responseText || "").replace(/^[\s\n\r]+|[\s\n\r]+$/g, "") == "")
                errorMessage.push("Received an empty XML document (0 bytes)");
            else {
                try {
                    var xmlDoc = (http.responseXML && http.responseXML.documentElement)
                        ? apf.xmlParseError(http.responseXML)
                        : apf.getXmlDom(http.responseText);

                    if (!apf.supportNamespaces)
                        xmlDoc.setProperty("SelectionLanguage", "XPath");

                    extra.data = xmlDoc.documentElement;
                }
                catch(e){
                    errorMessage.push("Received invalid XML\n\n" + e.message);
                }
            }
        }
        
        //Process errors if there are any
        if (errorMessage.length) {
            extra.message = errorMessage.join("\n");

            
            if (qItem.log)
                qItem.log.response(extra);
            

            // Send callback error state
            if (!callback || !callback(extra.data, apf.ERROR, extra))
                this.clearQueueItem(id);

            return;
        }

        
        if (qItem.options.caching) {
            if (!this.cache[qItem.url])
                this.cache[qItem.url] = {};

            this.cache[qItem.url][qItem.options.data] = http.responseText;
        }
        

        
        if (qItem.log)
            qItem.log.response(extra);
        

        //Http call was successfull Success
        if (!callback || !callback(extra.data, apf.SUCCESS, extra))
            this.clearQueueItem(id);

        return extra.data;
    };

    this.$timeout = function(id){
        if (!this.queue[id])
            return false;

        var qItem = this.queue[id],
            http  = qItem.http;

        

        // Test if HTTP object is ready
        try {
            if (http.status) {}
        }
        catch (e) {
            var _self = this;
            return $setTimeout(function(){
                _self.$timeout(id)
            }, 10);
        }

        var callback = qItem.callback;

        http.abort();

        
        apf.console.info("HTTP Timeout [" + id + "]", "teleport");
        

        var extra;
        var noClear = callback ? callback(null, apf.TIMEOUT, extra = {
            
            end     : new Date(),
            
            userdata: qItem.options.userdata,
            http    : http,
            url     : qItem.url,
            tpModule: this,
            id      : id,
            message : "HTTP Call timed out",
            retries : qItem.retries || 0
        }) : false;
        
        
        if (qItem.log)
            qItem.log.response(extra);
        
        
        if (!noClear)
            this.clearQueueItem(id);
    };

    /**
     * Checks if the request has times out. If so it's retried
     * three times before an exception is thrown. Request retrying is a very
     * good way to create robust Ajax applications. In many cases, even with
     * good connections requests time out.
     * @param {Object}  extra      the information object given as a third
     *                             argument of the http request callback.
     * @param {Number}  state      the return code of the http request.
     *   Possible values:
     *   apf.SUCCESS  the request was successfull
     *   apf.TIMEOUT  the request has timed out.
     *   apf.ERROR    an error has occurred while making the request.
     *   apf.OFFLINE  the request was made while the application was offline.
     * @param {AmlNode} [amlNode]    the element receiving the error event.
     * @param {Error}   [oError]     the error to be thrown when the request is
     *                               not retried.
     * @param {Number}  [maxRetries] the number of retries that are done before
     *                               the request times out. Default is 3.
     */
    this.retryTimeout = function(extra, state, amlNode, oError, maxRetries){
        if (state == apf.TIMEOUT
          && extra.retries < (maxRetries || apf.maxHttpRetries))
            return extra.tpModule.retry(extra.id);

        oError = oError || new Error(apf.formatErrorString(0,
            this, "Communication " + (state == apf.TIMEOUT
                ? "timeout"
                : "error"), "Url: " + extra.url + "\nInfo: " + extra.message));

        if ((amlNode || apf).dispatchEvent("error", apf.extend({
            error   : oError,
            state   : state,
            bubbles : true
        }, extra)) === false)
            return true;
    };

    /**
     * Removes the item from the queue. This is usually done automatically.
     * However when the callback returns true the queue isn't cleared, for instance
     * when a request is retried. The id of the call
     * is found on the 'extra' object. The third argument of the callback.
     * Example:
     * <code>
     *  http.clearQueueItem(extra.id);
     * </code>
     * @param {Number} id the id of the call that should be removed from the queue.
     */
    this.clearQueueItem = function(id){
        if (!this.queue[id])
            return false;

        

        if (apf.releaseHTTP)
            apf.releaseHTTP(this.queue[id].http);

        this.queue[id] = null;
        delete this.queue[id];

        return true;
    };

    /**
     * Retries a call based on it's id. The id of the call is found on the
     * 'extra' object. The third argument of the callback.
     * Example:
     * <code>
     *  function callback(data, state, extra){
     *      if (state == apf.TIMEOUT && extra.retries < apf.maxHttpRetries)
     *          return extra.tpModule.retry(extra.id);
     *
     *      //Do stuff here
     *  }
     * </code>
     * @param {Number} id the id of the call that should be retried.
     */
    this.retry = function(id){
        if (!this.queue[id])
            return false;

        var qItem = this.queue[id];

        

        
        apf.console.info("[HTTP] Retrying request [" + id + "]", "teleport");
        

        qItem.retries++;
        qItem.options.id = id;
        this.get(qItem.url, qItem.options);

        return true;
    };

    /**
     * see {@link teleport.http.method.clearqueueitem}
     */
    this.cancel = function(id){
        if (id === null)
            id = this.queue.length - 1;

        if (!this.queue[id])
            return false;

        //this.queue[id][0].abort();
        this.clearQueueItem(id);
    };

    if (!this.$loadAml && !this.instantiate && !this.call) {
        /**
         * @private
         */
        this.$loadAml = function(x){
            var receive = this["receive"];

            for (var i = 0, l = this.childNodes.length; i < l; i++) {
                if (this.childNodes[i].nodeType != 1)
                    continue;

                var url      = this.childNodes[i].getAttribute("url"),
                    callback = self[this.childNodes[i].getAttribute("receive") || receive],
                    options  = {
                        useXML  : this.childNodes[i].getAttribute("type") == "XML",
                        async   : !apf.isFalse(this.childNodes[i].getAttribute("async"))
                    };

                this[this.childNodes[i].getAttribute("name")] = function(data, userdata){
                    options.userdata = userdata;
                    options.data     = data;
                    return this.get(url, options);
                }
            }
        };

        /**
         * @private
         */
        this.instantiate = function(x){
            var url     = x.getAttribute("src"),
                options = {
                    async   : x.getAttribute("async") != "false",
                    nocache : true
                };

            this.getURL = function(data, userdata){
                options.data     = data;
                options.userdata = userdata;
                options.callback = this.callbacks.getURL;
                return this.get(url, options);
            }

            var name = "http" + Math.round(Math.random() * 100000);
            apf.setReference(name, this);

            return name + ".getURL()";
        };

        /**
         * @private
         */
        this.call = function(method, args){
            this[method].call(this, args);
        };
    }
};


apf.teleportLog = function(extra){
    var xml, request = extra.method + " " + extra.url + " HTTP/1.1\n\n" + extra.data;
    
    this.setXml = function(pNode){
        if (!xml) {
            var doc = pNode.ownerDocument;
            xml = doc.createElement(extra.tp.localName || extra.type || "http");
            xml.appendChild(doc.createElement("request")).appendChild(doc.createTextNode(request || "-"));
            xml.appendChild(doc.createElement("response")).appendChild(doc.createTextNode(response || "-"));
        }
        
        apf.xmldb.appendChild(pNode, xml);
    }
    
    this.request = function(headers){
        request = request.replace(/\n\n/, "\n" + headers.join("\n") + "\n\n");

        if (xml)
            apf.setQueryValue(xml, "request/text()", request);
        
        this.request = function(){}
    }
    
    var response = "";
    this.response = function(extra){
        var headers = extra.http.getAllResponseHeaders() ;
        response = "HTTP/1.1 " + extra.http.status + " " + extra.http.statusText + "\n"
            + (headers ? headers : "\n")
            + extra.http.responseText;
        
        if (xml)
            apf.setQueryValue(xml, "response/text()", response);
    }
}




apf.Init.run("http");


/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/teleport/iframe.js)SIZE(5748)TIME(1265038748)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*
 * This object create a compatibility layer for environments where the
 * native XMLHttpRequest object isn't available. It fall backs on an iframe for
 * it's communication
 */
apf.USEIFRAME = false;
/**
 * @private
 */
function runTpIframe(){
    function XMLHttpRequest(){
        this.$uniqueId = apf.all.push(this);
        var _self     = this;
        
        if (apf.USEIFRAME) {
            this.iframe = document.body.appendChild(document.createElement("iframe"));
            //this.iframe.style.display = "none";
            this.iframe.style.width  = "400px";
            this.iframe.style.height = "300px";
            this.iframe.style.position = "absolute";
            this.iframe.style.left = "0";
            this.iframe.style.top = "0";
            this.iframe.style.zIndex = 1000000000;
            document.body.style.display = "block";
        }
        else {
            var xml = document.body.appendChild(document.createElement("xml"));
            this.xmlDocument = xml.XMLDocument;
            this.xmlDocument.setProperty("SelectionLanguage", "XPath");
            document.body.removeChild(xml);
        }
        
        this.readyState   = 0;
        this.status       = null;
        this.responseText = null;
        this.responseXML  = null;
    
        this.setRequestHeader = function(){
            //Not supported
        }
        
        this.send = function(){
            this.done = false;
            if (apf.USEIFRAME) 
                this.iframe.src = this.url;
            else 
                this.xmlDocument.load(this.url);
        }
        
        this.open = function(protocol, url, async){
            this.method = protocol;
            this.url      = url;
            this.async    = async;
            
            if (apf.USEIFRAME) {
                if (!async) 
                    throw new Error(apf.formatErrorString(1081, null, "Iframe callback", "Compatibility mode prevents possibility of non-async calls"));
                this.iframe.onload = stateChangeHandlerIframe;
                //onreadystatechange
                //onerror
            }
            else {
                this.xmlDocument.async = async;
                this.xmlDocument.onreadystatechange = stateChangeHandler;
            }
        }
        
        this.abort = function(){
            if (apf.USEIFRAME) {
                this.iframe.onreadystatechange = null;
                this.iframe.src = "about:blank";
                _self.done = false;
                _self.readyState = "";
            }
            else 
                this.xmlDocument.abort();
        }
        
        var me = this;
        function stateChangeHandler(){
            me.receive();
        }
        
        this.receive = function(){
            this.readyState = this.xmlDocument.readyState;
            
            if (this.readyState == 4) {
                this.status       = 200;
                this.responseText = this.xmlDocument.responseText || this.xmlDocument.xml;
                this.responseXML  = this.xmlDocument;
           }
            
            if (this.onreadystatechange) 
                this.onreadystatechange();
        }
        
        function stateChangeHandlerIframe(){
            if (_self.done) // || _self.readyState != "complete") 
                return;
            _self.done = true;
            _self.receiveIframe();
        }
        
        this.receiveIframe = function(){
            var strXml = this.iframe.contentWindow.document.body.innerText;
            strXml     = strXml.replace(/^- /gm, "");
            
            try {
                this.responseXML = apf.getXmlDom(strXml);
                this.responseXML.setProperty("SelectionLanguage", "XPath");
                this.responseXML.loadXML(strXml);
            }
            catch (e) {
                this.responseXML = null;
            }
            this.responseText = this.responseXML ? this.responseXML.xml : strXml;
            this.status       = 200;
            this.readyState   = 4;
            
            if (this.onreadystatechange) 
                this.onreadystatechange();
        }
    }
    
    function getDOMParser(message, no_error){
        var xml = document.body.appendChild(document.createElement("xml"));
        var xmlParser = xml.XMLDocument;
        document.body.removeChild(xml);
        
        xmlParser.setProperty("SelectionLanguage", "XPath");
        if (message) 
            xmlParser.loadXML(message);
        if (!no_error) 
            apf.xmlParseError(xmlParser);
        
        return xmlParser;
    }
}



/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/draw/vml.js)SIZE(20284)TIME(1270594867)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/draw/canvas.js)SIZE(21818)TIME(1257329186)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


/*FILEHEAD(/var/lib/platform/source/trunk/core/lib/draw/chartdraw.js)SIZE(47182)TIME(1257329186)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */
 


/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/domparser.js)SIZE(16380)TIME(1271196961)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


/**
 * The parser of the Ajax.org Markup Language. Besides aml this parser takes care
 * of distributing parsing tasks to other parsers like the native html parser and
 * the xsd parser.
 * @parser
 * @private
 *
 * @define include element that loads another aml files.
 * Example:
 * <code>
 *   <a:include src="bindings.aml" />
 * </code>
 * @attribute {String} src the location of the aml file to include in this application.
 * @addnode global, anyaml
 */
apf.DOMParser = function(){};

apf.DOMParser.prototype = new (function(){
    this.caseInsensitive    = true;
    this.preserveWhiteSpace = true; //@todo apf3.0 whitespace issue
    
    this.$shouldWait = 0;

    // privates
    var RE     = [
            /\<\!(DOCTYPE|doctype)[^>]*>/,
            /&nbsp;/g,
            /<\s*\/?\s*(?:\w+:\s*)[\w-]*[\s>\/]/g
        ],
        XPATH  = "//@*[not(contains(local-name(), '.')) and not(translate(local-name(), 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 'abcdefghijklmnopqrstuvwxyz') = local-name())]";
    
    this.parseFromString = function(xmlStr, mimeType, options){
        var xmlNode;
        if (this.caseInsensitive) {
            //replace(/&\w+;/, ""). replace this by something else
            //.replace(RE[1], " ")
            var str = xmlStr.replace(RE[0], "")
              .replace(RE[2], //.replace(/^[\r\n\s]*/, "")
                function(m){ return m.toLowerCase(); });

            /* @todo apf3.0 integrate this
            x.ownerDocument.setProperty("SelectionNamespaces",
                                    "xmlns:a='" + apf.ns.aml + "'");
            */
        
            if (!this.supportNamespaces)
                str = str.replace(/xmlns\=\"[^"]*\"/g, "");
        
            
        
            var xmlNode = apf.getXmlDom(str);
            if (apf.xmlParseError) apf.xmlParseError(xmlNode);
            xmlNode = xmlNode.documentElement;
            
        }
        else {
            xmlNode = apf.getXmlDom(xmlStr, null, this.preserveWhiteSpace || apf.debug).documentElement;
        }

        return this.parseFromXml(xmlNode, options);
    };
    
    //@todo prevent leakage by not recording .$aml
    this.parseFromXml = function(xmlNode, options){
        var doc, docFrag, amlNode, beforeNode;
        if (!options) 
            options = {};
        
        if (!options.delayedRender && !options.include) {
            //Create a new document
            if (options.doc) {
                doc     = options.doc;
                docFrag = options.docFrag || doc.createDocumentFragment();
            }
            else {
                doc            = new apf.AmlDocument();
                doc.$aml       = xmlNode;
                doc.$domParser = this;
            }
            
            
            //Check for children in Aml node
            /*if (!xmlNode.childNodes.length) {
                apf.console.warn("DOMParser got markup without any children");
                return (docFrag || doc);
            }*/
            
            
            //Let's start building our tree
            amlNode = this.$createNode(doc, xmlNode.nodeType, xmlNode); //Root node
            (docFrag || doc).appendChild(amlNode);
            if (options.htmlNode)
                amlNode.$int = options.htmlNode;
        }
        else {
            amlNode    = options.amlNode;
            doc        = options.doc;
            
            if (options.include) {
                var n = amlNode.childNodes;
                var p = n.indexOf(options.beforeNode);
                var rest = n.splice(p, n.length - p);
            }
        }

        //Set parse context
        this.$parseContext = [amlNode, options];

        //First pass - Node creation
        var nodes, nodelist = {}, prios = [], _self = this;
        (function recur(amlNode, nodes){
            var cL, newNode, node, nNodes,
                cNodes = amlNode.childNodes,
                i      = 0,
                l      = nodes.length;
            for (; i < l; i++) {
                //Create child
                newNode = _self.$createNode(doc, (node = nodes[i]).nodeType, node);
                if (!newNode) continue; //for preserveWhitespace support

                cNodes[cL = cNodes.length] = newNode; //Add to children
                
                //Set tree refs
                newNode.parentNode = amlNode;
                if (cL > 0)
                    (newNode.previousSibling = cNodes[cL - 1]).nextSibling = newNode;

                //Create children
                if (!newNode.render && newNode.canHaveChildren && (nNodes = node.childNodes).length)
                    recur(newNode, nNodes);
                
                //newNode.$aml = node; //@todo should be deprecated...
                
                //Store high prio nodes for prio insertion
                if (newNode.$parsePrio) {
                    if (newNode.$parsePrio == "001") {
                        newNode.dispatchEvent("DOMNodeInsertedIntoDocument"); //{relatedParent : nodes[j].parentNode}
                        continue;
                    }
                        
                    (nodelist[newNode.$parsePrio] || (prios.push(newNode.$parsePrio) 
                      && (nodelist[newNode.$parsePrio] = []))).push(newNode); //for second pass
                }
            }

            amlNode.firstChild = cNodes[0];
            amlNode.lastChild  = cNodes[cL];
        })(amlNode, xmlNode.childNodes);
        
        if (options.include && rest.length) {
            var index = n.length - 1;
            n.push.apply(n, rest);
            var last = n[index];
            var next = n[index + 1];
            (next.previousSibling = last).nextSibling = next;
            amlNode.lastChild = n[n.length - 1];
        }

        if (options.delay) {
            amlNode.$parseOptions = {
                prios: prios,
                nodelist: nodelist
            };
            return (docFrag || doc);
        }
        
        //Second pass - Document Insert signalling
        prios.sort();
        var i, j, l, l2;
        for (i = 0, l = prios.length; i < l; i++) {
            nodes = nodelist[prios[i]];
            for (j = 0, l2 = nodes.length; j < l2; j++) {
                nodes[j].dispatchEvent("DOMNodeInsertedIntoDocument"); //{relatedParent : nodes[j].parentNode}
            }
        }

        if (this.$shouldWait)
            return (docFrag || doc);

        if (options.timeout) {
            $setTimeout(function(){
                _self.$continueParsing(amlNode, options);
            });
        }
        else {
            this.$continueParsing(amlNode, options);
        }

        return (docFrag || doc);
    };
    
    this.$callCount = 0;
    this.$continueParsing = function(amlNode, options){
        if (this.$shouldWait && --this.$shouldWait != 0)
            return;

        if (!options)
            options = {};
            
        this.$callCount++;

        if (amlNode.$parseOptions) {
            var prios    = amlNode.$parseOptions.prios,
                nodelist = amlNode.$parseOptions.nodelist,
                i, j, l, l2, node;
            delete amlNode.$parseOptions;
            
            //Second pass - Document Insert signalling
            prios.sort();
            for (i = 0, l = prios.length; i < l; i++) {
                nodes = nodelist[prios[i]];
                for (j = 0, l2 = nodes.length; j < l2; j++) {
                    if (!(node = nodes[j]).parentNode || node.$amlLoaded) //@todo generalize this using compareDocumentPosition
                        continue;
                    nodes[j].dispatchEvent("DOMNodeInsertedIntoDocument"); //{relatedParent : nodes[j].parentNode}
                }
            }
        }
        
        //instead of $amlLoaded use something more generic see compareDocumentPosition
        if (!options.ignoreSelf && !amlNode.$amlLoaded)
            amlNode.dispatchEvent("DOMNodeInsertedIntoDocument"); //{relatedParent : nodes[j].parentNode}

        //Recursively signal non prio nodes
        (function _recur(nodes){
            var node, nNodes;
            for (var i = 0, l = nodes.length; i < l; i++) {
                if (!(node = nodes[i]).$parsePrio && !node.$amlLoaded) {
                    node.dispatchEvent("DOMNodeInsertedIntoDocument"); //{relatedParent : nodes[j].parentNode}
                }
                
                //Create children
                if (!node.render && (nNodes = node.childNodes).length)
                    _recur(nNodes);
            }
        })(amlNode.childNodes);
        
        if (!--this.$callCount && !options.delay)
            apf.queue.empty();
        
        if (options.callback)
            options.callback.call(amlNode.ownerDocument);

        delete this.$parseContext;
    };
    
    this.$createNode = function(doc, nodeType, xmlNode, namespaceURI, nodeName, nodeValue){
        var o;
        switch (nodeType) {
            case 1:
                var id, prefix;
                if (xmlNode) {
                    if ((namespaceURI = xmlNode.namespaceURI || apf.ns.xhtml) 
                      && !(prefix = doc.$prefixes[namespaceURI])) {
                        doc.$prefixes[prefix = xmlNode.prefix || xmlNode.scopeName || ""] = namespaceURI;
                        doc.$namespaceURIs[namespaceURI] = prefix;
                        
                        if (!doc.namespaceURI && !prefix) {
                            doc.namespaceURI = namespaceURI;
                            doc.prefix       = prefix;
                        }
                    }
                    nodeName = xmlNode.baseName || xmlNode.localName || xmlNode.tagName.split(":").pop();
                }
                else {
                    prefix = doc.$prefixes[namespaceURI] || "";
                }
                
                
                if (!namespaceURI) {
                    throw new Error("Missing namespace definition."); //@todo apf3.0 make proper error
                }
                if (!apf.namespaces[namespaceURI]) {
                    if (this.allowAnyElement)
                        namespaceURI = apf.ns.xhtml;
                    else 
                        throw new Error("Missing namespace handler for '" + namespaceURI + "'"); //@todo apf3.0 make proper error
                }
                
                
                var els = apf.namespaces[namespaceURI].elements;

                
                if (!(els[nodeName] || els["@default"])) {
                    throw new Error("Missing element constructor: " + nodeName); //@todo apf3.0 make proper error
                }
                
                
                o = new (els[nodeName] || els["@default"])(null, nodeName);
                
                o.prefix       = prefix || "";
                o.namespaceURI = namespaceURI;
                o.tagName      = prefix ? prefix + ":" + nodeName : nodeName;
        
                if (xmlNode) {
                    if (id = xmlNode.getAttribute("id"))
                        o.$propHandlers["id"].call(o, o.id = id);

                    //attributes
                    var attr = xmlNode.attributes, n;
                    for (var a, i = 0, l = attr.length; i < l; i++) {
                        o.attributes.push(new apf.AmlAttr(o, 
                            (n = (a = attr[i]).nodeName), a.nodeValue));
                        
                        if (n == "render")
                            o.render = true;
                        
                    }
                }
                
                break;
            case 2:
                o = new apf.AmlAttr();
                o.name  = o.nodeName = nodeName;
                if (nodeValue || (nodeValue = xmlNode && xmlNode.nodeValue))
                    o.value = o.nodeValue = nodeValue;

                if (xmlNode) {
                    if (xmlNode.namespaceURI && !(o.prefix = doc.$namespaceURIs[o.namespaceURI = xmlNode.namespaceURI]))
                        doc.$prefixes[o.prefix = xmlNode.prefix || xmlNode.scopeName] = o.namespaceURI;
                }
                else {
                    o.prefix = doc.$prefixes[namespaceURI];
                }
                
                break;
            case 3:
                if (xmlNode) 
                    nodeValue = xmlNode && xmlNode.nodeValue;
                if (!this.preserveWhitespace && !(nodeValue || "").trim())
                    return;

                o = new apf.AmlText();
                o.nodeValue = nodeValue || xmlNode && xmlNode.nodeValue;
                break;
            case 7:
                var target = nodeName || xmlNode && xmlNode.nodeName;
                
                if(!apf.aml.processingInstructions[target])
                    throw new Error(apf.formatErrorString(0, null,
                        "The processing instruction does not exist", "Could not find the processing instruction with target: " + target));
                
                o = new apf.aml.processingInstructions[target]();

                o.target = o.nodeName  = target;
                o.data   = o.nodeValue = nodeValue || xmlNode && xmlNode.nodeValue;
                break;
            case 4:
                o = new apf.AmlCDATASection();
                o.nodeValue = nodeValue || xmlNode && xmlNode.nodeValue;
                break;
            case 5: //unsupported
                o = new apf.AmlNode();
                o.nodeType = nodeType;
                break;
            case 6: //unsupported
                o = new apf.AmlNode();
                o.nodeType = nodeType;
                break;
            case 8:
                o = new apf.AmlComment();
                o.nodeValue = nodeValue || xmlNode && xmlNode.nodeValue;
                break;
            case 9:
                o = new apf.AmlDocument();
                o.$domParser = this;
                break;
            case 10: //unsupported
                o = new apf.AmlNode();
                o.nodeType = nodeType;
                break;
            case 11:
                o = new apf.AmlDocumentFragment();
                break;
        }
        
        o.$aml          = xmlNode;
        o.ownerDocument = doc;
        
        return o;
    };
})();

/**
 *
 * @author      Ruben Daniels (ruben AT ajax DOT org)
 * @version     %I%, %G%
 * @since       0.8
 */
apf.AmlNamespace = function(){
    this.elements = {};
    this.processingInstructions = {};
};

apf.AmlNamespace.prototype = {
    setElement : function(tagName, fConstr){
        return this.elements[tagName] = fConstr;
    },
    
    setProcessingInstruction : function(target, fConstr){
        this.processingInstructions[target] = fConstr;
    }
};




/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/aml.js)SIZE(1478)TIME(1257329185)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


/**
 * The parser of the Ajax.org Markup Language. Besides aml this parser takes care
 * of distributing parsing tasks to other parsers like the native html parser and
 * the xsd parser.
 * @parser
 * @private
 *
 * @define include element that loads another aml files.
 * Example:
 * <code>
 *   <a:include src="bindings.aml" />
 * </code>
 * @attribute {String} src the location of the aml file to include in this application.
 * @addnode global, anyaml
 */
apf.aml = new apf.AmlNamespace();
apf.setNamespace("http://ajax.org/2005/aml", apf.aml);


/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/aml/node.js)SIZE(21382)TIME(1270838604)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */

apf.__AMLNODE__ = 1 << 14;



/**
 * All elements inheriting from this {@link term.baseclass baseclass} have Document Object Model (DOM) support. The DOM
 * is the primary method for accessing and manipulating an xml document. This
 * includes html documents and aml documents. Every element in the ajax.org
 * markup language can be manipulated using the W3C DOM. This means
 * that every element and attribute you can set in the xml format, can be
 * changed, set, removed reparented, etc runtime. This offers a great deal of
 * flexibility. Well known methods
 * from this specification are .appendChild .removeChild .setAttribute and
 * insertBefore to name a few. Ajax.org Platform aims to implement DOM1
 * completely and parts of DOM2. Which should be extended in the future to fully
 * implement DOM Level 2. For more information see {@link http://www.w3.org/DOM/} 
 * or {@link http://www.w3schools.com/dom/default.asp}.
 * Example:
 * Ajax.org Markup Language
 * <code>
 *  <a:window id="winExample" title="Example" visible="true">
 *      <a:button id="tstButton" />
 *  </a:window>
 * </code>
 * Document Object Model in javascript
 * <code>
 *  //The following line is only there for completeness sake. In fact apf
 *  //automatically adds a reference in javascript called winExample based
 *  //on the id it has.
 *  var winExample = apf.document.getElementById("winExample");
 *  winExample.setAttribute("title", "Example");
 *  winExample.setAttribute("icon", "icoFolder.gif");
 *  winExample.setAttribute("left", "100");
 *
 *  var lblNew = apf.document.createElement("label");
 *  winExample.appendChild(lblNew);
 *  lblNew.setAttribute("caption", "Example");
 *
 *  tstButton.setAttribute("caption", "Click me");
 * </code>
 * That would be the same as having the following aml:
 * <code>
 *  <a:window id="winExample"
 *    title   = "Example"
 *    icon    = "icoFolder.gif"
 *    left    = "100"
 *    visible = "true">
 *      <a:button id="tstButton" caption="Click me"/>
 *      <a:label caption="Example" />
 *  </a:window>
 * </code>
 * Remarks:
 * Because the W3C DOM is native to all modern browsers the internet is full
 * of tutorials and documentation for this API. If you need more information
 * it's a good idea to search for tutorials online.
 *
 * @event DOMNodeInserted
 * @event DOMNodeInsertedIntoDocument
 * @event DOMNodeRemoved
 * @event DOMNodeRemovedFromDocument
 *
 * @constructor
 * @baseclass
 *
 * @author      Ruben Daniels (ruben AT ajax DOT org)
 * @version     %I%, %G%
 * @since       0.5
 */
apf.AmlNode = function(){
    this.$init(function(){
        /**
         * Nodelist containing all the child nodes of this element.
         */
        this.childNodes = []; //@todo AmlNodeList
    });
};

(function() {

    
    
    /**
     * Number specifying the type of node within the document.
     */
    this.$regbase = this.$regbase | apf.__AMLNODE__;
    
    /**
     * Constant for a dom element node.
     * @type {Number}
     */
    this.NODE_ELEMENT                = 1;
    /**
     * Constant for a dom attribute node.
     * @type {Number}
     */
    this.NODE_ATTRIBUTE              = 2;
    /**
     * Constant for a dom text node.
     * @type {Number}
     */
    this.NODE_TEXT                   = 3;
    /**
     * Constant for a dom cdata section node.
     * @type {Number}
     */
    this.NODE_CDATA_SECTION          = 4;
    /**
     * Constant for a dom entity reference node.
     * @type {Number}
     */
    this.NODE_ENTITY_REFERENCE       = 5;
    /**
     * Constant for a dom entity node.
     * @type {Number}
     */
    this.NODE_ENTITY                 = 6;
    /**
     * Constant for a dom processing instruction node.
     * @type {Number}
     */
    this.NODE_PROCESSING_INSTRUCTION = 7;
    /**
     * Constant for a dom comment node.
     * @type {Number}
     */
    this.NODE_COMMENT                = 8;
    /**
     * Constant for a dom document node.
     * @type {Number}
     */
    this.NODE_DOCUMENT               = 9;
    /**
     * Constant for a dom document type node.
     * @type {Number}
     */
    this.NODE_DOCUMENT_TYPE          = 10;
    /**
     * Constant for a dom document fragment node.
     * @type {Number}
     */
    this.NODE_DOCUMENT_FRAGMENT      = 11;
    /**
     * Constant for a dom notation node.
     * @type {Number}
     */
    this.NODE_NOTATION               = 12;
    
    

    /**
     * The document node of this application
     */
    this.ownerDocument = null;

    /**
     * Returns the value of the current node. 
     */
    this.nodeValue = "";
    
    /**
     * The namespace URI of the node, or null if it is unspecified (read-only). 
     * When the node is a document, it returns the XML namespace for the current 
     * document.
     */
    this.namespaceURI = "";
    
    /**
     * @todo
     */
    //this.baseURI = alsdjlasdj
    
    /**
     * @todo
     */
    //this.prefix = asdkljahqsdkh
        
    /**
     * Appends an element to the end of the list of children of this element.
     * If the element was already a child of another element it is removed from
     * that parent before adding it this element.
     *
     * @param  {AmlNode}  amlNode  the element to insert as child of this element.
     * @return  {AmlNode}  the appended node
     * @method
     */
    this.appendChild =

    /**
     * Inserts an element before another element in the list of children of this
     * element. * If the element was already a child of another element it is
     * removed from that parent before adding it this element.
     *
     * @param  {AmlNode}  amlNode     the element to insert as child of this element.
     * @param  {AmlNode}  beforeNode  the element which determines the insertion position of the element.
     * @return  {AmlNode}  the inserted node
     */
    this.insertBefore = function(amlNode, beforeNode, noHtmlDomEdit){
        
        if (!amlNode || !amlNode.hasFeature || !amlNode.hasFeature(apf.__AMLNODE__)){
            throw new Error(apf.formatErrorString(1072, this,
                "Insertbefore DOM operation",
                "Invalid argument passed. Expecting an AmlElement."));
        }
        
        
        if (this.nodeType == this.NODE_DOCUMENT) {
            if (this.childNodes.length) {
                throw new Error(apf.formatErrorString(0, this,
                    "Insertbefore DOM operation",
                    "Only one top level element is allowed in an AML document."));
            }
            else this.documentElement = amlNode; //@todo apf3.0 removal
        }

        if (amlNode.nodeType == this.NODE_DOCUMENT_FRAGMENT) {
            var nodes = amlNode.childNodes.slice(0);
            for (var i = 0, l = nodes.length; i < l; i++) {
                this.insertBefore(nodes[i], beforeNode);
            }
            return amlNode;
        }
        
        var isMoveWithinParent = amlNode.parentNode == this,
            oldParentHtmlNode  = amlNode.$pHtmlNode,
            oldParent          = amlNode.parentNode,
            index              = -1,
            _self              = this;
        
        if (beforeNode) {
            index = this.childNodes.indexOf(beforeNode);
            if (index < 0) {
                
                if (beforeNode == this)
                    throw new Error(apf.formatErrorString(1072, this,
                        "Insertbefore DOM operation",
                        "Before node is the same node as inserted node"));
                else 
                    throw new Error(apf.formatErrorString(1072, this,
                        "Insertbefore DOM operation",
                        "Before node is not a child of the parent node specified"));
                

                return false;
            }
        }

        if (!amlNode.ownerDocument)
            amlNode.ownerDocument = this.ownerDocument || apf.ownerDocument;

        if (amlNode.parentNode)
            amlNode.removeNode(isMoveWithinParent, noHtmlDomEdit);
        amlNode.parentNode = this;

        if (beforeNode)
            index = this.childNodes.indexOf(beforeNode);

        if (beforeNode) {
            amlNode.nextSibling = beforeNode;
            amlNode.previousSibling = beforeNode.previousSibling;
            beforeNode.previousSibling = amlNode;
            if (amlNode.previousSibling)
                amlNode.previousSibling.nextSibling = amlNode;
        }

        if (index >= 0) {
            this.childNodes = this.childNodes.slice(0, index).concat(amlNode,
                this.childNodes.slice(index));
        }
        else {
            index = this.childNodes.push(amlNode) - 1;

            amlNode.nextSibling = null;
            if (index > 0) {
                amlNode.previousSibling = this.childNodes[index - 1];
                amlNode.previousSibling.nextSibling = amlNode;
            }
            else {
                amlNode.previousSibling = null;
            }
        }

        this.firstChild = this.childNodes[0];
        this.lastChild  = this.childNodes[this.childNodes.length - 1];

        //@todo fix event struture, fix tree events
        function triggerUpdate(){
            amlNode.$pHtmlNode = _self.canHaveChildren ? _self.$int : document.body;

            //Signal node and all it's ancestors
            amlNode.dispatchEvent("DOMNodeInserted", {
                $beforeNode         : beforeNode,
                relatedNode         : _self,
                $isMoveWithinParent : isMoveWithinParent,
                $oldParentHtmlNode  : oldParentHtmlNode,
                $oldParent          : oldParent,
                bubbles             : true
            });

            //@todo this is a hack, a good solution should be found
            var iframelist;
            var containsIframe = (amlNode.$ext && amlNode.$ext.nodeType == 1 
              && (iframelist = amlNode.$ext.getElementsByTagName("iframe")).length > 0
              && apf.findHost(iframelist[0].parentNode) == amlNode);

            //!apf.isGecko && 
            if (!noHtmlDomEdit && amlNode.$ext) {// && !containsIframe
                //!isMoveWithinParent || 
                if (!amlNode.$altExt || amlNode.$altExt.parentNode == amlNode.$pHtmlNode) {
                    amlNode.$pHtmlNode.insertBefore(isMoveWithinParent && amlNode.$altExt || amlNode.$ext,
                        beforeNode && (beforeNode.$altExt || beforeNode.$ext) || null);
                }
            }
        }

        var doc = this.nodeType == this.NODE_DOCUMENT ? this : this.ownerDocument;
        if (!doc || doc.$domParser.$shouldWait)
            return amlNode;

        if (this.nodeType == this.NODE_DOCUMENT_FRAGMENT)
            return; //We don't update the tree if this is a doc fragment

        //@todo review this...
        //this.nodeType == 1 && 
        if (!amlNode.$amlLoaded) {
            //amlNode.$reappendToParent = triggerUpdate;
            (this.ownerDocument || this).$domParser.$continueParsing(amlNode, {delay: true});
            //return amlNode; //@todo apf3.0 so we do call DOMNodeInserted here
        }

        triggerUpdate();
        return amlNode;
    };

    /**
     * Removes this element from the document hierarchy. Call-chaining is
     * supported.
     *
     */
    this.removeNode = function(doOnlyAdmin, noHtmlDomEdit){
        
        if (doOnlyAdmin && typeof doOnlyAdmin != "boolean") {
            throw new Error(apf.formatErrorString(0, this,
                "Removing node from parent",
                "Invalid DOM Call. removeNode() does not take any arguments."));
        }
        

        if (!this.parentNode || !this.parentNode.childNodes)
            return this;

        
        if (!this.parentNode.childNodes.contains(this)) {
            /*throw new Error(apf.formatErrorString(0, this,
                "Removing node from parent",
                "Passed node is not a child of this node.", this.$aml));*/
            return false;
        }
        

        //If we're not loaded yet, just remove us from the aml to be parsed
        if (this.$amlLoaded && !apf.isDestroying) {
            //this.parentNode.$aml.removeChild(this.$aml);

            this.dispatchEvent("DOMNodeRemoved", {
                relatedNode  : this.parentNode,
                bubbles      : true,
                $doOnlyAdmin : doOnlyAdmin
            });
            
            if (!noHtmlDomEdit && !doOnlyAdmin && this.$ext && this.$ext.parentNode)
                this.$ext.parentNode.removeChild(this.$ext);
        }
        
        this.parentNode.childNodes.remove(this);

        if (this.parentNode.firstChild == this)
            this.parentNode.firstChild = this.nextSibling;
        if (this.parentNode.lastChild == this)
            this.parentNode.lastChild = this.previousSibling;

        if (this.nextSibling)
            this.nextSibling.previousSibling = this.previousSibling;
        if (this.previousSibling)
            this.previousSibling.nextSibling = this.nextSibling;

        this.$pHtmlNode      =
        this.parentNode      =
        this.previousSibling =
        this.nextSibling     = null;

        return this;
    };

    /**
     * Removes a child from the node list of this element. Call-chaining is
     * supported.
     */
    this.removeChild = function(childNode) {
        
        if (!childNode || !childNode.hasFeature || !childNode.hasFeature(apf.__AMLNODE__)) {
            throw new Error(apf.formatErrorString(0, this,
                "Removing a child node",
                "Invalid Argument. removeChild() requires one argument of type AMLElement."));
        }
        

        childNode.removeNode();
        return this;
    };
    
    //@todo
    this.replaceChild = function(){};

    /**
     * Clones this element, creating an exact copy of it but does not insert
     * it in the document hierarchy.
     * @param {Boolean} deep whether the element's are cloned recursively.
     * @return {AmlNode} the cloned element.
     */
    this.cloneNode = function(deep){
        if (deep && this.nodeType == 1) {
            return this.ownerDocument.$domParser.parseFromXml(this, {
                doc   : this.ownerDocument,
                delay : true
            }).childNodes[0];
        }
        else {
            return this.ownerDocument.$domParser.$createNode(
                this.ownerDocument, this.nodeType, this);
        }
    };
    
    //@todo
    this.canDispatch = function(namespaceURI, type){};
    
    //@todo
    this.compareDocumentPosition = function(otherNode){
        /*
            DOCUMENT_POSITION_DISCONNECTED = 0x01;
            DOCUMENT_POSITION_PRECEDING = 0x02;
            DOCUMENT_POSITION_FOLLOWING = 0x04;
            DOCUMENT_POSITION_CONTAINS = 0x08;
            DOCUMENT_POSITION_CONTAINED_BY = 0x10;
        */
    };
    
    this.hasAttributes = function(){
        return this.attributes && this.attributes.length;
    };
    
    this.hasChildNodes = function(){
        return this.childNodes && this.childNodes.length;
    };
    
    this.isDefaultNamespace = function(namespaceURI){
        if (node.nodeType == 1) {
            if (!this.prefix)
                return this.namespaceURI == namespaceURI;
            
            //@todo Loop through attributes here
        }
        
        var node = this.parentNode || this.ownerElement;
        return node && node.isDefaultNamespace(namespaceURI);
    };
    
    this.lookupNamespaceURI = function(prefix){
        if (node.nodeType == 1) {
            if (this.namespaceURI && prefix == this.prefix)
                return this.namespaceURI ;
                
            //@todo Loop through attributes here
        }
        
        var node = this.parentNode || this.ownerElement;
        return node && node.lookupNamespaceURI(prefix);
    };
    
    this.lookupPrefix = function(namespaceURI){
        if (this.nodeType == 1) {
            if (namespaceURI == this.namespaceURI && this.prefix)
                return this.prefix;
            
            //@todo Loop through attributes here
        }
        
        var node = this.parentNode || this.ownerElement;
        return node && node.lookupPrefix(namespaceURI);    
    };
    
    this.normalize = function(){};
    
    /**** Xpath support ****/

    /**
     * Queries the aml dom using the W3C xPath query language and returns a node
     * list. This is not an official API call but can be useful in certain cases.
     * see {@link core.documentimplementation.method.evaluate evaluate on the apf.document}
     * @param {String}  sExpr          the xpath expression to query the aml DOM tree with.
     * @param {AmlNode} [contextNode]  the element that serves as the starting point of the search. Defaults to this element.
     * @returns {NodeList} list of found nodes.
     */
    this.selectNodes = function(sExpr, contextNode){
        if (!apf) return;
        
        if (!apf.XPath)
            apf.runXpath();
        return apf.XPath.selectNodes(sExpr,
            contextNode || (this.nodeType == 9 ? this.documentElement : this));
    };

    /**
     * Queries the aml dom using the W3C xPath query language and returns a single
     * node. This is not an official API call but can be useful in certain cases.
     * see {@link core.documentimplementation.method.evaluate evaluate on the apf.document}
     * @param {String}  sExpr          the xpath expression to query the aml DOM tree with.
     * @param {AmlNode} [contextNode]  the element that serves as the starting point of the search. Defaults to this element.
     * @returns {AmlNode} the first node that matches the query.
     */
    this.selectSingleNode  = function(sExpr, contextNode){
        if (!apf) return;
        
        if (!apf.XPath)
            apf.runXpath();
        return apf.XPath.selectNodes(sExpr,
            contextNode || (this.nodeType == 9 ? this.documentElement : this))[0];
    };
    
    /*this.addEventListener("DOMNodeInsertedIntoDocument", function(e){
        
    }, true);*/
}).call(apf.AmlNode.prototype = new apf.Class());



/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/aml/element.js)SIZE(19085)TIME(1270838604)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


apf.AmlElement = function(struct, tagName){
    var $init = this.$init;
    this.$init = function(tagName, nodeFunc, struct){
        this.$supportedProperties = this.$supportedProperties.slice();
        
        var prop, p, q;
        p = this.$propHandlers;
        q = this.$propHandlers = {};
        for (prop in p)
            q[prop] = p[prop];
        
        p = this.$booleanProperties;
        q = this.$booleanProperties = {};
        for (prop in p)
            q[prop] = p[prop];
        
        $init.call(this, tagName, nodeFunc, struct);
    };
    
    this.$init(function(tagName, nodeFunc, struct){
        this.$events            = {};
        this.$inheritProperties = {};
        
        /**
         * Nodelist containing all attributes. This is implemented according to the
         * W3C specification.
         * Example:
         * <code>
         *  for (var i = 0; i < obj.attributes.length; i++) {
         *      alert(obj.attributes.item(i));
         *  }
         * </code>
         * @see baseclass.amldom.method.getAttribute
         * @see baseclass.amldom.method.setAttribute
         */
        this.attributes = new apf.AmlNamedNodeMap(this); //@todo apf3.0 move to init?
        
        /**
         * The purpose of this element
         * Possible values:
         * apf.NODE_VISIBLE     this element has a gui representation
         * apf.NODE_HIDDEN      this element does not display a gui
         */
        this.nodeFunc = nodeFunc;
        
        /**
         * The local name of this element
         */
        this.localName = tagName; //@todo
        
        //Parse struct to create attributes and child nodes
        if (struct) {
            var nodes, prop, i, l;
            if (struct.childNodes) {
                nodes = struct.childNodes;
                delete struct.childNodes; //why delete?
            }
            
            //Attributes
            for (prop in struct){ 
                if (prop == "htmlNode") continue;
                
                this.attributes.push(new apf.AmlAttr(this, prop, struct[prop]));
            }
            
            if (!this.ownerDocument) {
                this.ownerDocument = apf.document;
                this.prefix       = "";
                this.namespaceURI = null;
                this.tagName      = tagName;
            }
            
            if (nodes) {
                this.childNodes = nodes;

                for (i = 0, l = nodes.length; i < l; i++) {
                    nodes[i].nextSibling = nodes[i + 1] || null;
                    nodes[i].previousSibling = nodes[i - 1] || null;
                    nodes[i].parentNode = this;
                }
                this.firstChild = nodes[0] || null;
                this.lastChild  = nodes[nodes.length - 1] || null;
            }

            //Temp hack
            this.$aml = apf.$emptyNode || (apf.$emptyNode = apf.getXml("<empty />"));
        }
    });
    
    if (tagName) //of typeof is not function and not true
        $init.call(this, tagName, apf.NODE_HIDDEN, struct);
};

(function(){
    /**
     * Number specifying the type of node within the document.
     */
    this.nodeType = this.NODE_ELEMENT;
    this.canHaveChildren = true;
    
    this.$propHandlers = {
        /**
         * @attribute {String} id the identifier of this element. When set this
         * identifier is the name of the variable in javascript to access this
         * element directly. This identifier is also the way to get a reference to
         * this element using apf.document.getElementById.
         * Example:
         * <code>
         *  <a:bar id="barExample" />
         *  <a:script>
         *      alert(barExample);
         *  </a:script>
         * </code>
         */
        "id": function(value){
            
            if (value == "apf") {
                throw new Error(apf.formatErrorString(0, this, 
                    "Setting Name of Element",
                    "Cannot set name of element to 'apf'"));
            }
            
            
            if (this.name == value)
                return;
    
            if (self[this.name] == this)
                self[this.name] = null
    
            if (!self[value] || !self[value].hasFeature) {
                try {
                    self[value] = this;
                }
                catch(ex) {
                    
                    var error = true;
                    
                }
            }
            
            if (error && value in self) {
                apf.console.warn("trying to set a value in the global scope with "
                                + "a reserved name '" + value + "'.\nNothing wrong "
                                + "with that, except that you will not be able to "
                                + "reference\nthe object from the global scope in JS.")
            }
            
            
            //@todo dispatch event for new name creation.
            //@todo old name disposal
            apf.nameserver.register(this.localName, value, this)
            
            this.name = value;
        }
    };
    
    this.$booleanProperties   = {};
    this.$inheritProperties   = {};
    this.$supportedProperties = [];
    
    /**
     * Returns a list of elements with the given tag name.
     * The subtree below the specified element is searched, excluding the
     * element itself.
     *
     * @method
     * @param  {String}  tagName  the tag name to look for. The special string "*" represents any tag name.
     * @return  {NodeList}  containing any node matching the search string
     */
    this.getElementsByTagName = function(tagName, norecur){
        tagName = tagName.toLowerCase();
        var node, i, l,
            nodes  = this.childNodes,
            result = [];
        for (i = 0, l = nodes.length; i < l; i++) {
            if ((node = nodes[i]).nodeType != 1)
                continue;
            
            if (node.tagName == tagName || tagName == "*")
                result.push(node);

            if (!norecur && node.nodeType == 1)
                result = result.concat(node.getElementsByTagName(tagName));
        }
        
        return result;
    };
    
    this.getElementsByTagNameNS = function(namespaceURI, localName, norecur){
        localName = localName.toLowerCase();
        var node, i, l,
            nodes  = this.childNodes,
            result = [];
        for (i = 0, l = nodes.length; i < l; i++) {
            if ((node = nodes[i]).nodeType != 1)
                continue;

            if (node.namespaceURI == namespaceURI && (node.localName == localName || localName == "*"))
                result.push(node);

            if (!norecur && node.nodeType == 1)
                result = result.concat(node.getElementsByTagNameNS(namespaceURI, localName));
        }
        
        return result;
    };

    /**
     * Sets an attribute on this element. Call-chaining is supported.
     * @param {String} name the name of the attribute to which the value is set
     * @param {String} value the new value of the attribute.
     */
    this.setAttribute = function(name, value, noTrigger) {
        name = name.toLowerCase();
        
        var a = this.attributes.getNamedItem(name);
        if (!a) {
            this.attributes.push(a = new apf.AmlAttr(this, name, value));
        
            if (!this.$amlLoaded)
                return;
            
            if (noTrigger)
                a.$setValue(value);
            else {
                //@todo apf3.0 domattr
                a.dispatchEvent("DOMNodeInsertedIntoDocument", {
                    relatedNode : this
                });
                
                //@todo apf3.0 domattr
                a.dispatchEvent("DOMNodeInserted", {
                    relatedNode : this,
                    bubbles     : true
                });
            }

            return;
        }

        var oldValue = a.nodeValue;
        a.$setValue(value);
        
        if (noTrigger || !this.$amlLoaded)
            return;
        
        //@todo apf3.0 domattr
        a.$triggerUpdate(null, oldValue);
    };
    
    //@todo apf3.0 domattr
    this.setAttributeNode = function(attrNode){
        this.attributes.setNamedItem(attrNode);
    };
    
    this.setAttributeNS = function(namespaceURI, name, value){
        return this.setAttribute(name, value);
    };
    
    //@todo apf3.0 domattr
    this.hasAttribute = function(name){
        return this.getAttributeNode(name) ? true : false;
    };
    
    //@todo
    this.hasAttributeNS = function(namespaceURI, name){
        return this.hasAttribute(name);
    };
    
    /**
     * Removes an attribute from this element. Call-chaining is supported.
     * @param {String} name the name of the attribute to remove.
     */
    //@todo apf3.0 domattr
    this.removeAttribute = function(name){
        this.attributes.removeNamedItem(name);
        return this;
    };
    
    //@todo apf3.0 domattr
    this.removeAttributeNS = function(namespaceURI, name){
        return this.removeAttribute(name);
    };
    
    //@todo apf3.0 domattr
    this.removeAttributeNode = function(attrNode){
        this.attributes.removeNamedItem(attrNode.name); //@todo this should probably be slightly different.
    };

    /**
     * Retrieves the value of an attribute of this element
     * @param  {String}  name       the name of the attribute for which to return the value.
     * @param  {Boolean} [inherited]
     * @return {String} the value of the attribute or null if none was found with the name specified.
     * @method
     */
    this.getAttribute = function(name, inherited){
        var item = this.attributes.getNamedItem(name);
        return item ? (inherited 
            ? item.inheritedValue || item.nodeValue 
            : item.nodeValue) : null;
    };
    
    /**
     * Retrieves the attribute node for a given name
     * @param {String} name the name of the attribute to find.
     * @return {AmlNode} the attribute node or null if none was found with the name specified.
     */
    this.getAttributeNode = function(name){
        return this.attributes.getNamedItem(name);
    };

    this.getBoundingClientRect = function(){
        return new apf.AmlTextRectangle(this);
    };
    
    //@todo
    this.querySelector = function(){
        // here we should use: http://code.google.com/p/css2xpath/source/browse/trunk/src/css2xpath.js
    };
    
    //@todo
    this.querySelectorAll = function(){
        // here we should use: http://code.google.com/p/css2xpath/source/browse/trunk/src/css2xpath.js
    };
    
    //@todo
    this.scrollIntoView = function(){
        
    };
    
    /**
     * Replaces the child aml elements with new aml.
     * @param {mixed}       amlDefNode  the aml to be loaded. This can be a string or a parsed piece of xml.
     * @param {HTMLElement} oInt        the html parent of the created aml elements.
     */
    this.replaceMarkup = function(amlDefNode, options) {
        
        apf.console.info("Remove all children from element");
        

        if (!options)
            options = {};

        if (!options.$intAML)
            options.$intAML = this.$aml;
        if (!options.$int)
            options.$int = this.$int;
        options.clear = true;
        
        //Remove All the childNodes
        for (var i = this.childNodes.length - 1; i >= 0; i--) {
            var oItem = this.childNodes[i];
            /*var nodes = oItem.childNodes;
            for (var k = 0; k < nodes.length; k++)
                if (nodes[k].destroy)
                    nodes[k].destroy(true);

            if (oItem.$aml && oItem.$aml.parentNode)
                oItem.$aml.parentNode.removeChild(oItem.$aml);*/

            if (oItem.destroy)
                oItem.destroy(true);

            if (oItem.$ext != this.$int)
                apf.destroyHtmlNode(oItem.$ext);
        }
        
        this.childNodes.length = 0;
        this.$int.innerHTML = "<div class='loading'>loading...</div>";

        //Do an insertMarkup
        this.insertMarkup(amlDefNode, options);
    };

    /**
     * Inserts new aml into this element.
     * @param {mixed}       amlDefNode  the aml to be loaded. This can be a string or a parsed piece of xml.
     * @param {HTMLElement} oInt        the html parent of the created aml elements.
     */
    this.insertMarkup = function(amlDefNode, options){
        
        apf.console.info("Loading sub markup from external source");
        

        

        var include = new apf.XiInclude();
        include.setAttribute("href", amlDefNode);
        if (options && options.clear)
            include.setAttribute("clear", true);
        include.options  = options;
        include.callback = options && options.callback;
        this.appendChild(include);
    };
    
    //@todo prefix only needs on top element
    this.serialize = function(shallow){
        if (shallow || !this.firstChild) {
            return "<" 
                + (this.prefix 
                  ? this.prefix + ":" + this.localName + " xmlns:" 
                    + this.prefix + "=\"" + this.namespaceURI + "\""
                  : this.localName) + (this.attributes.length ? " " : "")
                + this.attributes.join(" ")
                + "/>";
        }
        else {
            var str = ["<" 
                + (this.prefix 
                  ? this.prefix + ":" + this.localName + " xmlns:" 
                    + this.prefix + "=\"" + this.namespaceURI + "\""
                  : this.localName) + (this.attributes.length ? " " : "")
                + this.attributes.join(" ")
                + ">"];
            
            for (var i = this.firstChild; i; i = i.nextSibling)
                str.push(i.serialize());
            
            return str.join("") + "</" + (this.prefix ? this.prefix 
                + ":" + this.localName : this.localName) + ">";
        }
    };
    
    this.$setInheritedAttribute = function(prop){
        var value, node = this;
        
        value = node.getAttribute(prop);
        if (!value) {
            node = node.parentNode;
            
            //Second argument fetches special inheritance value, if any
            while (node && node.nodeType == 1 && !(value = node.getAttribute(prop, true))) {
                node = node.parentNode;
            }
        }
        
        if (!value && apf.config && prop)
            value = apf.config[prop];
    
        if (value) {
            
            //Remove any bounds if relevant
            this.$clearDynamicProperty(prop);
    
            if (typeof value == "string" 
              && (value.indexOf("{") > -1 || value.indexOf("[") > -1)) {
                this.$setDynamicProperty(prop, value);
                this.$inheritProperties[prop] = 2;
            }
            else 
            
                this.setProperty(prop, value, false, false, 2);
        }
        
        return value;
    };
    
    this.$handlePropSet = function(prop, value, force){
        if (value && this.$booleanProperties[prop])
            value = apf.isTrue(value);

        
        if (typeof this[prop] == "function") {
            throw new Error("Could not set property/attribute '" + prop
                + "' which has the same name as a method on this object: '"
                + this.toString() + "'");
        }
        

        this[prop] = value;

        var handler;
        return (handler = this.$propHandlers && this.$propHandlers[prop]
          || this.nodeFunc == apf.NODE_VISIBLE && apf.GuiElement && apf.GuiElement.propHandlers[prop] || null)
          && handler.call(this, value, prop, force);
    };
    
    //var aci = apf.config.$inheritProperties; << UNUSED
    this.addEventListener("DOMNodeInsertedIntoDocument", function(e){
        var a, i, l, attr = this.attributes;

        
        
        

        //Set all attributes
        for (i = 0, l = attr.length; i < l; i++) {
            attr[i].dispatchEvent("DOMNodeInsertedIntoDocument");
        }

        this.$amlLoaded = true;
    }, true);
}).call(apf.AmlElement.prototype = new apf.AmlNode());



/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/aml/characterdata.js)SIZE(2018)TIME(1270838604)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


//@todo apf3.0 The functions seem to not set nodeValue...
apf.AmlCharacterData = function(){
    this.data = "";
    this.length = 0;
    
    this.$init(true);
    
    this.appendData = function(sValue){
        this.dispatchEvent("DOMCharacterDataModified", {
            value : sValue
        });
    };
    
    this.deleteData = function(nOffset, nCount){
        this.dispatchEvent("DOMCharacterDataModified", {
            offset: nOffset,
            count : nCount
        });
    };
    
    this.insertData = function(nOffset, nCount){
        this.dispatchEvent("DOMCharacterDataModified", {
            offset: nOffset,
            count : nCount
        });
    };
    
    this.replaceData = function(nOffset, nCount, sValue){
        this.dispatchEvent("DOMCharacterDataModified", {
            offset: nOffset,
            count : nCount,
            value : sValue
        });
    };
    
    this.substringData = function(nOffset, nCount){};
}
apf.AmlCharacterData.prototype = new apf.AmlNode();


/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/aml/text.js)SIZE(4137)TIME(1270838604)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


apf.AmlText = function(isPrototype){
    this.$init(isPrototype);
};

(function(){
    this.nodeType = this.NODE_TEXT;
    this.nodeName = "#text";
    
    this.serialize = function(){
        return apf.xmlentities(this.nodeValue).replace(/</g, "&lt;").replace(/>/g, "&gt;");
    };
    
    
    
    //@todo think about using this.replaceData();
    this.$setValue = function(value){
        //if (!this.$amlLoaded)
            //return;
        
        this.dispatchEvent("DOMCharacterDataModified", {
            bubbles   : true,
            prevValue : this.nodeValue,
            newValue  : this.nodeValue = value
        });
        
        if (this.$amlLoaded && this.$ext)
            this.$ext.nodeValue = value;
    }

    this.addEventListener("DOMNodeInsertedIntoDocument", function(e){
        var pHtmlNode;
        if (!(pHtmlNode = this.parentNode.$int) || this.parentNode.hasFeature(apf.__CHILDVALUE__)) 
            return;

        this.$amlLoaded = true;
        
        var nodeValue = this.nodeValue;

        //@todo optimize for inside elements?
        if (apf.config.liveText && !this.parentNode.hasFeature(apf.__CHILDVALUE__) 
          && (nodeValue.indexOf("{") > -1 || nodeValue.indexOf("[") > -1)) {
            
            //Convert to live markup pi
            this.$supportedProperties = [];
            this.$propHandlers        = {};
            this.$booleanProperties   = {};
            this.$inheritProperties   = {};
            
            this.$propHandlers["calcdata"] = apf.LiveMarkupPi.prototype.$propHandlers["calcdata"];
            
            this.$setInheritedAttribute = apf.AmlElement.prototype.$setInheritedAttribute;
            
            this.implement(apf.StandardBinding);
            
            
            pHtmlNode.appendChild(this.$ext = document.createElement("span"));
            this.$setDynamicProperty("calcdata", this.nodeValue);
            
            return;
        }

        if (apf.hasTextNodeWhiteSpaceBug) {
            var nodeValue = nodeValue.replace(/[\t\n\r ]+/g, " ");

            if (nodeValue && nodeValue != " ")
                this.$ext = pHtmlNode.appendChild(
                  pHtmlNode.ownerDocument.createTextNode(nodeValue));
        }
        else
            this.$ext = pHtmlNode.appendChild(
              pHtmlNode.ownerDocument.createTextNode(nodeValue));
    }, true);
}).call(apf.AmlText.prototype = new apf.AmlCharacterData());



/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/aml/textrectangle.js)SIZE(1662)TIME(1259091141)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


apf.AmlTextRectangle = function(host){
    var _self = this;
    function handler(){
        var pos = _self.getAbsolutePosition(_self.$ext);
        _self.setProperty("left", pos[0]);
        _self.setProperty("top", pos[1]);
        _self.setProperty("right", document.documentElement.offsetWidth - pos[0]);
        _self.setProperty("bottom", document.documentElement.offsetWidth - pos[1]);
    }
    
    host.addEventListener("prop.width", handler);
    host.addEventListener("prop.height", handler);
    host.addEventListener("prop.left", handler);
    host.addEventListener("prop.top", handler);

    handler.call(host);
};
apf.AmlTextRectangle.prototype = new apf.Class();


/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/aml/processinginstruction.js)SIZE(3337)TIME(1270838604)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


apf.AmlProcessingInstruction = function(isPrototype){
    this.$init(isPrototype);
    
    //@todo apf3.0 possibly move this to an init function
    this.$supportedProperties = [];
    this.$propHandlers        = {};
    this.$booleanProperties   = {};
    this.$inheritProperties   = {};
};

(function(){
    this.nodeType = this.NODE_PROCESSING_INSTRUCTION;
    
    /**
     * @todo docs
     */
    this.data   = null;
    
    /**
     * @todo docs
     */
    this.target = null;
    
    this.serialize = function(){
        return "<?" + this.target + "\n" + apf.xmlentities(this.nodeValue) + "\n?>";
    };
    
    this.reload = function(){
        this.$handlePropSet("data", this.data);
    }
    
    //1 = force no bind rule, 2 = force bind rule
    this.$attrExcludePropBind = apf.extend({
        calcdata : 0 //Start in code mode
    }, this.$attrExcludePropBind);
    
    this.getAttribute = function(){};
    this.$setInheritedAttribute = apf.AmlElement.prototype.$setInheritedAttribute;
    
    this.$setValue = function(value){
        this.setProperty("data", value);
    }
    
    this.$handlePropSet = function(prop, value, force){
        this[prop] = value;
        
        if (prop == "data") {
            this.$clearDynamicProperty("calcdata");
            this.$setDynamicProperty("calcdata", value);
        }
        else if (prop == "target") {
            //not implemented
        }
        else if (this.$propHandlers[prop]) {
            this.$propHandlers[prop].call(this, value, prop);
        }
    };

    this.addEventListener("DOMNodeInsertedIntoDocument", function(e){
        var pHtmlNode;
        if (this.parentNode.$bindingRule || !(pHtmlNode = this.parentNode.$int)) 
            return;

        pHtmlNode.appendChild(this.$ext = document.createElement("span"));
        this.$ext.host = this;

        this.$setDynamicProperty("calcdata", this.data);
        
        
        if (this.target.match(/\-debug$/)) {
            apf.console.info(this.$lastFParsed.toString());
        }
        
    }, true);
    
    this.addEventListener("DOMNodeRemovedFromDocument", function(e){
        this.$clearDynamicProperty("calcdata");
    });
}).call(apf.AmlProcessingInstruction.prototype = new apf.AmlNode());


/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/aml/document.js)SIZE(9094)TIME(1270838604)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * The aml document, this is the root of the DOM Tree and has a nodeType with 
 * value 9 (apf.NODE_DOCUMENT). 
 *
 * @constructor
 * @inherits apf.AmlNode
 * @inherits apf.Class
 * @default_private 
 * @see baseclass.amldom
 *
 * @author      Ruben Daniels (ruben AT ajax DOT org)
 * @version     %I%, %G%
 * @since       0.8
 */
apf.AmlDocument = function(){
    this.$prefixes      = {};
    this.$namespaceURIs = {};
    this.domConfig      = new apf.AmlConfiguration();
    
    this.$init();
};

(function() {
    /**
     * The type of node within the document.
     *   Possible values:
     */
    this.nodeType   = this.NODE_DOCUMENT;
    this.nodeFunc   = apf.NODE_HIDDEN;
    this.nodeName   = "#document";
    
    this.$amlLoaded = true;
    
    this.activeElement   = null; //@todo alias of window.foccussed;
    this.doctype         = null;
    this.domConfig       = null;
    this.implementation  = null;
    this.characterSet    = apf.characterSet;
    
    /**
     * The root element node of the aml application. This is an element with
     * the tagName 'application'. This is similar to the 'html' element
     */
    this.documentElement = null;
    
    /**
     * Gets a aml element based on it's id.
     * @param {String} id the id of the aml element to return.
     * @return {AMLElement} the aml element with the id specified.
     */
    this.getElementById = function(id){
        return self[id];
    };
    
    this.getElementsByTagName = function(tagName){
        var docEl, res = (docEl = this.documentElement)
            .getElementsByTagName(tagName);

        if (tagName == "*" || docEl.tagName == tagName)
            res.unshift(docEl);
        return res;
    };
    
    this.getElementsByTagNameNS = function(nameSpaceURI, tagName){
        var docEl,
            res = (docEl = this.documentElement)
                .getElementsByTagNameNS(nameSpaceURI, tagName);

        if (tagName == "*" || docEl.tagName == tagName && docEl.namespaceURI == nameSpaceURI)
            res.unshift(docEl);
        return res;
    };

    /**
     * Creates a new aml element.
     * @param {mixed} tagName information about the new node to create.
     *   Possible values:
     *   {String}     the tagName of the new element to create
     *   {String}     the aml definition for a single or multiple elements.
     *   {XMLElement} the aml definition for a single or multiple elements.
     * @return {AMLElement} the created aml element.
     */
    this.createElement = function(qualifiedName){
        return this.$domParser.$createNode(this, this.NODE_ELEMENT, null,
            this.namespaceURI, qualifiedName);
    };
        
    this.createElementNS = function(namespaceURI, qualifiedName){
        return this.$domParser.$createNode(this, this.NODE_ELEMENT, null,
            namespaceURI, qualifiedName);
    };
    
    this.importNode = function(node, deep){
        if (deep && node.nodeType == 1) {
            return this.$domParser.parseFromXml(node, {
                doc   : this,
                delay : true
            }).childNodes[0];
        }
        else {
            return this.$domParser.$createNode(this, node.nodeType, node);
        }
    };
    
    //@todo
    this.createAttribute = function(nodeName){
        return this.$domParser.$createNode(this, this.NODE_ATTRIBUTE, null,
            this.nameSpaceURI, nodeName);
    };
    
    //@todo
    this.createAttributeNS = function(nameSpaceURI, nodeName){
        return this.$domParser.$createNode(this, this.NODE_ATTRIBUTE, null,
            nameSpaceURI, nodeName);
    };
    
    this.createEvent = function(){
        return new apf.AmlEvent();
    };
    
    this.createComment = function(nodeValue){
        return this.$domParser.$createNode(this, this.NODE_COMMENT, null, null,
            null, nodeValue);
    };
    
    this.createProcessingInstruction = function(nodeValue){
        return this.$domParser.$createNode(this, this.NODE_PROCESSING_INSTRUCTION,
            null, null, null, nodeValue);
    };
    
    this.createCDATASection = function(nodeValue){
        return this.$domParser.$createNode(this, this.NODE_CDATA_SECTION, null,
            null, null, nodeValue);
    };
    
    this.createTextNode = function(nodeValue){
        return this.$domParser.$createNode(this, this.NODE_TEXT, null, null,
            null, nodeValue);
    };
    
    this.createDocumentFragment = function(){
        return this.$domParser.$createNode(this, this.NODE_DOCUMENT_FRAGMENT);
    };

    this.querySelector = function(){};
    
    this.querySelectorAll = function(){};

    
    /**
     * See W3C evaluate
     */
    this.evaluate = function(sExpr, contextNode, nsResolver, type, x){
        var result = apf.XPath.selectNodes(sExpr,
            contextNode || this.documentElement);

        /**
         * @private
         */
        return {
            snapshotLength : result.length,
            snapshotItem   : function(i){
                return result[i];
            }
        }
    };

    /**
     * See W3C createNSResolver
     */
    this.createNSResolver = function(contextNode){
        return {};
    };
    

    this.hasFocus = function(){
        
    }

    
}).call(apf.AmlDocument.prototype = new apf.AmlNode());



/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/aml/comment.js)SIZE(1509)TIME(1259091141)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


apf.AmlComment = function(isPrototype){
    this.nodeType = this.NODE_COMMENT;
    this.nodeName = "#comment";
    
    this.$init(isPrototype);
};

(function(){
    this.serialize = function(){
        return "<!--" + this.nodeValue + "-->";
    };
    
    this.$setValue = function(value){
        this.dispatchEvent("DOMCharacterDataModified", {
            bubbles   : true,
            newValue  : value,
            prevValue : this.nodeValue
        });
    }
}).call(apf.AmlComment.prototype = new apf.AmlCharacterData());


/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/aml/namednodemap.js)SIZE(3217)TIME(1270838604)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


//@todo apf3.0
apf.AmlNamedNodeMap = function(host){
    this.$host = host;
};

(function(){
    this.getNamedItem    = function(name){
        for (var i = 0; i < this.length; i++) {
            if (this[i].name == name)
                return this[i];
        }
        return false;
    };
    
    this.setNamedItem    = function(node){
        var name = node.name;
        for (var item, i = this.length - 1; i >= 0; i--) {
            if (this[i].name == name) {
                this[i].ownerElement = null;
                this.splice(i, 1);
                break;
            }
        }
        
        this.push(node);
        
        node.ownerElement = this.$host;
        node.ownerDocument = this.$host.ownerDocument;
        node.$triggerUpdate();
    };
    
    //@todo apf3.0 domattr
    this.removeNamedItem = function(name){
        //Should deconstruct dynamic properties
        
        for (var item, i = this.length - 1; i >= 0; i--) {
            if (this[i].name == name) {
                item = this[i];
                this.splice(i, 1);
                break;
            }
        }
        if (!item) return false;
        
        item.ownerElement.setProperty(name, "");
        item.ownerElement = null;
        
        return item;
    };
    
    this.item            = function(i){
        return this[i];
    };

    //if (apf.isIE < 8) { //Only supported by IE8 and above
        this.length = 0;
        
        this.splice = function(pos, length){
            for (var i = pos, l = this.length - length; i < l; i++) {
                this[i] = this[i + 1];
            }
            delete this[i];
            this.length -= length;
        }
        
        this.push = function(o) {
            this[this.length++] = o;
            return this.length;
        }
    //}
    
    this.join = function(glue){
        var x = [];
        for (var e, a, i = 0, l = this.length; i < l; i++) {
            if ((e = (a = this[i]).ownerElement) && !e.$inheritProperties[a.nodeName])
                x.push(this[i]);
        }
        return x.join(glue);
    }
}).call(apf.AmlNamedNodeMap.prototype = {}); //apf.isIE < 8 ? {} : []


/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/aml/event.js)SIZE(2086)TIME(1265666735)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


/**
 * Implementation of W3C event object. An instance of this class is passed as
 * the first argument of any event handler. Per event it will contain different
 * properties giving context based information about the event.
 * @constructor
 * @default_private
 */
apf.AmlEvent = function(name, data){
    this.name = name;
    
    var prop;
    for (prop in data)
        this[prop] = data[prop];
};

apf.AmlEvent.prototype = {
    
    bubbles : false,
    cancelBubble : false,
    

    /**
     * Cancels the event if it is cancelable, without stopping further 
     * propagation of the event. 
     */
    preventDefault : function(){
        this.returnValue = false;
    },

    
    /**
     * Prevents further propagation of the current event. 
     */
    stopPropagation : function(){
        this.cancelBubble = true;
    },
    

    stop : function() {
        this.returnValue = false;
        
        this.cancelBubble = true;
        
    }
};


/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/aml/attr.js)SIZE(4834)TIME(1270838604)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


apf.AmlAttr = function(ownerElement, name, value){
    this.$init();
    
    if (ownerElement) {
        this.ownerElement  = ownerElement;
        this.ownerDocument = ownerElement.ownerDocument;
    }
    
    this.nodeName  = this.name  = name;
    this.nodeValue = this.value = value;
};

(function(){
    this.nodeType  = this.NODE_ATTRIBUTE;
    
    this.MODIFICATION = 1;
    this.ADDITION     = 2;
    this.REMOVAL      = 3;
    
    this.serialize = 
    this.toString  = function(){
        return this.name + "=\"" + apf.xmlentities(String(this.value))
            .replace(/</g, "&lt;").replace(/>/g, "&gt;") + "\"";
    };
    
    
    
    this.$setValue = function(value){
        this.nodeValue = this.value = value;
        this.specified = true;

        //@todo apf3.0 domattr
        this.ownerElement.dispatchEvent("DOMAttrModified", {
            relatedNode : this,
            attrChange  : this.MODIFICATION,
            attrName    : this.name,
            newValue    : value,
            prevValue   : this.$lastValue || "",
            bubbles     : true
        });
        
        this.$lastValue = value;
    };
    
    this.$triggerUpdate = function(e, oldValue){
        var name  = this.name,
            value = this.value || this.nodeValue,
            host  = this.ownerElement;

        if (name == "id" && !this.specified && host.id) {
            this.specified = true;
            return;
        }

        if (name.substr(0, 2) == "on") {
            if (host.$events[name])
                host.removeEventListener(name.replace(/^on/, ""), host.$events[name]);
            if (value)
                host.addEventListener(name, (host.$events[name] = 
                  (typeof value == "string"
                    ? 
                      apf.lm.compile(value, {event: true, parsecode: true})
                      
                    : value)));
            return;
        }
        
        else {
            if (this.specified)
                host.$clearDynamicProperty(name);
            
            if (typeof value == "string" && (host.$attrExcludePropBind[name] || 
              (value.indexOf("{") > -1 || value.indexOf("[") > -1))) {
                host.$setDynamicProperty(name, value);
                
                return;//@todo apf3.0 test this for disabled
            }
        }
        
        
        host.setProperty(name, value); //@todo apf3.0 is this a lot slower?
        //host.$handlePropSet(name, value);

        if (this.specified) {
            //@todo apf3.0 domattr - slow?
            host.dispatchEvent("DOMAttrModified", { //@todo this is not good, node might not be specified at init
                relatedNode : this,
                attrChange  : this.MODIFICATION,
                attrName    : name,
                newValue    : value,
                prevValue   : this.$lastValue || "",
                bubbles     : true
            });
        }
        else this.specified = true;
            
        this.$lastValue = value;
    };
    
    //@todo apf3.0 domattr
    this.addEventListener("DOMNodeInsertedIntoDocument", this.$triggerUpdate);
}).call(apf.AmlAttr.prototype = new apf.AmlNode());


/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/aml/cdatasection.js)SIZE(1300)TIME(1259091141)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


apf.AmlCDATASection = function(isPrototype){
    this.nodeType = this.NODE_CDATA_SECTION;
    this.nodeName = "#cdata-section";
    
    this.$init(isPrototype);
};

apf.AmlCDATASection.prototype = new apf.AmlText(true);
apf.AmlCDATASection.prototype.serialize = function(){
    return "<![CDATA[" + this.nodeValue + "]]>";
};


/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/aml/selection.js)SIZE(8619)TIME(1270838604)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/aml/configuration.js)SIZE(1384)TIME(1259091141)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


apf.AmlConfiguration = function(isPrototype){
    this.parameterNames = [];

    this.$init(isPrototype);
};

(function(){
    this.setParameter = this.setProperty;
    
    this.getParameter = this.getProperty;
    
    this.canSetParameter = function(name, value){ //@todo for value
        return this.parameterNames.indexOf(name) > -1;
    };
}).call(apf.AmlConfiguration.prototype = new apf.Class());


/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/aml/documentfragment.js)SIZE(1286)TIME(1259091141)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


apf.AmlDocumentFragment = function(isPrototype){
    this.$init(isPrototype);
};

apf.AmlDocumentFragment.prototype = new apf.AmlNode();
apf.AmlDocumentFragment.prototype.nodeName = "#document-fragment";
apf.AmlDocumentFragment.prototype.nodeType = 
    apf.AmlDocumentFragment.prototype.NODE_DOCUMENT_FRAGMENT;


/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/aml/range.js)SIZE(15247)TIME(1270838604)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/xhtml.js)SIZE(1530)TIME(1269561667)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * Object creating the XHTML namespace for the aml parser.
 *
 * @constructor
 * @parser
 *
 * @author      Ruben Daniels (ruben AT ajax DOT org)
 * @version     %I%, %G%
 * @since       0.8
 */
apf.xhtml = new apf.AmlNamespace();
apf.setNamespace("http://www.w3.org/1999/xhtml", apf.xhtml);


/*
if (apf.getTextNode(x)) {
    var data = {
        amlNode  : x,
        htmlNode : o
    }

    
}

*/

/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/xhtml/element.js)SIZE(2954)TIME(1270838604)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



apf.XhtmlElement = function(struct, tagName){
    this.$init(tagName || true, apf.NODE_VISIBLE, struct);
    
    this.$xoe                = this.addEventListener;
    this.addEventListener    = this.$xae;
    this.removeEventListener = this.$xre;
    
    var _self = this;
    this.$de = function(e){
        _self.dispatchEvent(e.type, e);
    }
};

(function(){
    this.$xae = function(type, fn){
        this.$xoe.apply(this, arguments);
        
        if (this.$ext)
            apf.addListener(this.$ext, type, this.$de);
    };
    
    this.$xre = function(type, fn) {
        apf.AmlElement.prototype.removeEventListener.apply(this, arguments);
        
        if (this.$ext)
            apf.removeListener(this.$ext, type, this.$de);
    }
    
    this.$handlePropSet = function(name, value, force){
        if (this.$booleanProperties[name])
            value = apf.isTrue(value);

        this[name] = value;
        
        var handler = this.$propHandlers && this.$propHandlers[name]
          || apf.GuiElement.propHandlers[name];
        
        if (handler)
            handler.call(this, value, null, name);
        else if (this.$int) {
            this.$int.setAttribute(apf.isIE && name == "class" 
                ? "className" : name, value);
        }
    };
    
    this.addEventListener("DOMNodeInsertedIntoDocument", function(e){
        var pHtmlNode;
        if (!(pHtmlNode = this.parentNode.$int)) 
            return;

        if (this.$aml) {
            this.$ext = 
            this.$int = apf.insertHtmlNode(this.$aml.serialize
                ? this.$aml 
                : this.$aml.cloneNode(false), pHtmlNode);
        }
        else {
            this.$ext = this.$int = 
              pHtmlNode.appendChild(document.createElement(this.localName));
        }
    }, true);
}).call(apf.XhtmlElement.prototype = new apf.AmlElement());

apf.xhtml.setElement("@default", apf.XhtmlElement);


/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/xhtml/option.js)SIZE(1537)TIME(1259091141)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



apf.XhtmlOptionElement = function(struct, tagName){
    this.$init(tagName || "option", apf.NODE_VISIBLE, struct);
};

(function(){
    this.addEventListener("DOMNodeInsertedIntoDocument", function(e){
        this.$ext = 
        this.$int = this.parentNode.$int.appendChild(
          this.parentNode.$int.ownerDocument.createElement("option"));

        if (this.value)
            this.$int.setAttribute("value", this.value);
    }, true);
}).call(apf.XhtmlOptionElement.prototype = new apf.AmlElement());

apf.xhtml.setElement("option", apf.XhtmlOptionElement);


/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/xhtml/input.js)SIZE(2187)TIME(1268784066)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


apf.XhtmlInputElement = function(struct, tagName){
    this.$init(tagName || "input", apf.NODE_VISIBLE, struct);
};

(function(){
    this.$xae = apf.XhtmlElement.prototype.$xae;
    this.$xre = apf.XhtmlElement.prototype.$xre;
    this.$handlePropSet = function(name, value, force){
        if (name == "type")
            return;

        return apf.XhtmlElement.prototype.$handlePropSet.call(this, name, value, force);
    };

    this.addEventListener("DOMNodeInsertedIntoDocument", function(e){
        var pHtmlNode;
        if (!(pHtmlNode = this.parentNode.$int))
            return;

        if (this.$aml) {
            this.$ext =
            this.$int = apf.insertHtmlNode(this.$aml.serialize
                ? this.$aml
                : this.$aml.cloneNode(false), pHtmlNode);
        }
        else {
            this.$ext = this.$int = document.createElement(this.localName);
            if (this.getAttribute("type"))
                this.$int.setAttribute("type", this.getAttribute("type"));
            pHtmlNode.appendChild(this.$int);
        }
    }, true);
}).call(apf.XhtmlInputElement.prototype = new apf.AmlElement());

apf.xhtml.setElement("input", apf.XhtmlInputElement);


/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/xhtml/html.js)SIZE(2473)TIME(1269561666)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * @todo description
 *
 * @author      Ruben Daniels (ruben AT ajax DOT org)
 * @version     %I%, %G%
 * @since       0.4
 */
apf.XhtmlHtmlElement = function(struct, tagName){
    this.$init(tagName || "html", apf.NODE_VISIBLE, struct);
    
    this.$int        = document.body;
    this.$tabList    = []; //Prevents documentElement from being focussed
    this.$focussable = apf.KEYBOARD;
    this.focussable  = true;
    this.visible     = true;
    this.$isWindowContainer = true;
    this.focus = function(){ this.dispatchEvent("focus"); };
    this.blur  = function(){ this.dispatchEvent("blur"); };
    
    
    apf.window.$addFocus(this);
    
    
    this.addEventListener("DOMNodeInsertedIntoDocument", function(e){
        var i, l, n, a, c,
            attr = this.attributes, doc = this.ownerDocument;
        for (i = 0, l = attr.length; i < l; i++) {
            n = (a = attr[i]).nodeName.split(":");
            if (n[0] == "xmlns") {
                if (c = n[1]) {
                    doc.$prefixes[c] = a.nodeValue;
                    doc.$namespaceURIs[a.nodeValue] = c;
                }
                else {
                    doc.namespaceURI = a.nodeValue;
                }
            }
        }
        
        if (!doc.namespaceURI)
            doc.namespaceURI = apf.ns.xhtml;
    });
};
apf.XhtmlHtmlElement.prototype = new apf.XhtmlElement();

apf.xhtml.setElement("html", apf.XhtmlHtmlElement);



/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/xhtml/skipchildren.js)SIZE(2342)TIME(1259091141)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


apf.XhtmlSkipChildrenElement = function(struct, tagName){
    this.$init(tagName, apf.NODE_VISIBLE, struct);
};

(function(){
    this.canHaveChildren = false;
    
    this.$redraw = function(){
        var _self = this;
        apf.queue.add("redraw" + this.$uniqueId, function(){
            var pHtmlNode  = _self.$ext.parentNode;
            var beforeNode = _self.$ext.nextSibling;
            pHtmlNode.removeChild(_self.$ext);
            
            _self.$ext = apf.insertHtmlNode(null, pHtmlNode, beforeNode, _self.$aml 
                ? (_self.$aml.serialize ? _self.$aml.serialize() : _self.$aml.xml)
                : _self.serialize());
        });
    }
    
    this.addEventListener("DOMNodeInsertedIntoDocument", function(e){
        var pHtmlNode;
        if (!(pHtmlNode = this.parentNode.$int)) 
            return;

        this.$ext = apf.insertHtmlNode(null, pHtmlNode, null, this.$aml 
            ? (this.$aml.serialize ? this.$aml.serialize() : this.$aml.xml)
            : this.serialize());
    }, true);
}).call(apf.XhtmlSkipChildrenElement.prototype = new apf.AmlElement());

apf.xhtml.setElement("object", apf.XhtmlSkipChildrenElement);
apf.xhtml.setElement("embed", apf.XhtmlSkipChildrenElement);
apf.xhtml.setElement("table", apf.XhtmlSkipChildrenElement);

apf.xhtml.setElement("pre", apf.XhtmlSkipChildrenElement);


/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/xhtml/body.js)SIZE(1443)TIME(1259091141)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


apf.XhtmlBodyElement = function(struct, tagName){
    this.$init(tagName || "body", apf.NODE_VISIBLE, struct);
};

(function(){
    this.addEventListener("DOMNodeInsertedIntoDocument", function(e){
        if (!this.ownerDocument.body)
            this.ownerDocument.body = this;
        
        this.$ext = 
        this.$int = document.body;
    }, true);
}).call(apf.XhtmlBodyElement.prototype = new apf.AmlElement());

apf.xhtml.setElement("body", apf.XhtmlBodyElement);


/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/xhtml/ignore.js)SIZE(1360)TIME(1264352083)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


apf.XhtmlIgnoreElement = function(struct, tagName){
    this.$init(tagName, apf.NODE_VISIBLE, struct);
};

apf.XhtmlIgnoreElement.prototype = new apf.AmlElement();

apf.xhtml.setElement("script",   apf.XhtmlIgnoreElement);
apf.xhtml.setElement("noscript", apf.XhtmlIgnoreElement);
apf.xhtml.setElement("head",     apf.XhtmlIgnoreElement);
apf.xhtml.setElement("meta",     apf.XhtmlIgnoreElement);


/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/xsd.js)SIZE(12771)TIME(1269561667)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/xsd/element.js)SIZE(1869)TIME(1259091142)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/xsd/maxinclusive.js)SIZE(1568)TIME(1259091142)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/xsd/enumeration.js)SIZE(1844)TIME(1259091142)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/xsd/maxscale.js)SIZE(1436)TIME(1259091142)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/xsd/length.js)SIZE(1527)TIME(1259091142)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/xsd/list.js)SIZE(1215)TIME(1259091142)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/xsd/pattern.js)SIZE(1537)TIME(1259091142)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/xsd/totaldigits.js)SIZE(1564)TIME(1259091142)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/xsd/maxlength.js)SIZE(1597)TIME(1259091142)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/xsd/union.js)SIZE(2331)TIME(1259091142)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/xsd/minscale.js)SIZE(1436)TIME(1259091142)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/xsd/restriction.js)SIZE(1644)TIME(1259091142)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/xsd/simpletype.js)SIZE(2201)TIME(1259091142)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/xsd/minlength.js)SIZE(1610)TIME(1259091142)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/xsd/schema.js)SIZE(1124)TIME(1259091142)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/xsd/mininclusive.js)SIZE(1567)TIME(1259091142)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/xsd/minexclusive.js)SIZE(1556)TIME(1259091142)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/xsd/fractiondigits.js)SIZE(1620)TIME(1259091142)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/xsd/maxexclusive.js)SIZE(1553)TIME(1259091142)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/xforms.js)SIZE(4191)TIME(1269561667)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */





//XForms





/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/xinclude.js)SIZE(1325)TIME(1269561667)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * Object creating the XML Include namespace for the aml parser.
 *
 * @constructor
 * @parser
 *
 * @allownode simpleType, complexType
 *
 * @author      Ruben Daniels (ruben AT ajax DOT org)
 * @version     %I%, %G%
 * @since       0.8
 */
apf.xinclude = new apf.AmlNamespace();
apf.setNamespace("http://www.w3.org/2001/XInclude", apf.xinclude);



/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/html5.js)SIZE(3232)TIME(1269561667)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */





/* #-ifdef __WITH_HTML5
if (tagName == "input") {
    objName = apf.HTML5INPUT[objName = x.getAttribute("type")]
        || objName || "textbox";
}
//#-endif*/


/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/xslt/xslt.js)SIZE(13722)TIME(1265038748)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/xinclude/include.js)SIZE(6154)TIME(1271196961)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


/**
 * Defines a list of acceptable values
 */
apf.XiInclude = function(struct, tagName){
    this.$init(tagName || "include", apf.NODE_HIDDEN, struct);
};

apf.xinclude.setElement("include", apf.XiInclude);
apf.aml.setElement("include", apf.XiInclude);

//@todo test defer="true" situation
(function(){
    this.$parsePrio = "002";

    //1 = force no bind rule, 2 = force bind rule
    /*this.$attrExcludePropBind = apf.extend({
        href : 1,
        src  : 1
    }, this.$attrExcludePropBind);*/

    this.$propHandlers["href"] = 
    this.$propHandlers["src"]  = function(value){
        if (typeof value != "string")
            return finish.call(this, value);

        this.$path = value.charAt(0) == "{" //@todo this shouldn't happen anymore
          ? value
          : apf.getAbsolutePath(apf.hostPath, value);
        
        var domParser = this.ownerDocument.$domParser;
        if (!this.defer) {
            domParser.$shouldWait++;
            this.$parseContext = domParser.$parseContext || [this.parentNode];
        }
        
        //var basePath = apf.hostPath;//only for recursion: apf.getDirname(xmlNode.getAttribute("filename")) || 
        loadIncludeFile.call(this, this.$path);
    };
    
    function done(xmlNode) {
        if (this.callback) {
            this.callback({
                xmlNode : xmlNode,
                amlNode : this.parentNode
            })
        }
        
        this.parentNode.removeChild(this);
    }
    
    function finish(xmlNode){
        var domParser = this.ownerDocument.$domParser;

        if (this.clear)
            this.parentNode.$int.innerHTML = "";
        
        if (xmlNode) {
            domParser.parseFromXml(xmlNode, {
                doc        : this.ownerDocument,
                amlNode    : this.parentNode,
                beforeNode : this,
                include    : true
            });
            
            if (!this.defer) {
                var o     = (this.$parseContext[1] || (this.$parseContext[1] = {})),
                    cb    = o.callback,
                    _self = this;

                o.callback = function(){
                    done.call(_self, xmlNode);
                    if (cb)
                        cb.call(_self.ownerDocument);
                };
                domParser.$continueParsing.apply(domParser, this.$parseContext);
            }
            else
                done.call(this, xmlNode);
        }
        else {
            if (!this.defer)
                domParser.$continueParsing.apply(domParser, this.$parseContext);
            
            done.call(this, xmlNode);
        }
    }
    
    function loadIncludeFile(path){
        
        apf.console.info("Loading include file: " + path);
        

        var _self = this;
        apf.getData(path, apf.extend(this.options || {}, {
            
            type : "markup",
            
            callback : function(xmlString, state, extra){
                if (state != apf.SUCCESS) {
                    var oError = new Error(apf.formatErrorString(1007,
                        _self, "Loading Includes", "Could not load Include file '"
                        + (path || _self.src)
                        + "'\nReason: " + extra.message));

                    if (extra.tpModule.retryTimeout(extra, state, null, oError) === true)
                        return true;

                    apf.console.error(oError.message);

                    finish.call(_self, null);

                    //throw oError;
                    return;
                }

                //@todo apf3.0 please make one way of doing this
                xmlString = xmlString.replace(/\<\!DOCTYPE[^>]*>/, "")
                    .replace(/^[\r\n\s]*/, ""); //.replace(/&nbsp;/g, " ")
                if (!apf.supportNamespaces)
                    xmlString = xmlString.replace(/xmlns\=\"[^"]*\"/g, "");
                
                if (xmlString.indexOf("<a:application") == -1)
                    xmlString = "<a:application xmlns:a='" + apf.ns.aml +"'>"
                      + xmlString + "</a:application>";

                var xmlNode = apf.getXml(xmlString, null, true);//apf.getAmlDocFromString(xmlString);
            
                if (!xmlNode) {
                    throw new Error(apf.formatErrorString(0, null,
                        "Loading include",
                        "Could not parse include file. Maybe the file does not exist?", xmlNode));
                }
                xmlNode.setAttribute("filename", extra.url);

                
                apf.console.info("Loading of " + xmlNode[apf.TAGNAME].toLowerCase() + " include done from file: " + extra.url);
                
            
                finish.call(_self, xmlNode); //@todo add recursive includes support here
            },
            async         : true,
            ignoreOffline : true
        }));
    }
}).call(apf.XiInclude.prototype = new apf.AmlElement());


/*FILEHEAD(/var/lib/platform/source/trunk/core/markup/xinclude/fallback.js)SIZE(1322)TIME(1264690337)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/anchoring.js)SIZE(18824)TIME(1271196962)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */

apf.__ANCHORING__ = 1 << 13;



/**
 * All elements inheriting from this {@link term.baseclass baseclass} have anchoring features. Each side of the
 * element can be attached at a certain distance to it's parent's rectangle.
 * When the parent is resized the anchored side of the element stays
 * at the specified distance at all times. If both sides are anchored the
 * element size is changed to make sure the specified distance is maintained.
 * Example:
 * This example shows a bar that has 10% as a margin around it and contains a
 * frame that is displayed using different calculations and settings.
 * <code>
 *  <a:bar width="80%" height="80%" top="10%" left="10%">
 *      <a:frame 
 *        caption = "Example" 
 *        left    = "50%+10"
 *        top     = "100"
 *        right   = "10%"
 *        bottom  = "Math.round(0.232*100)" />
 *  </a:bar>
 * </code>
 * Remarks:
 * This is one of three positioning methods.
 * See {@link baseclass.alignment}
 * See {@link element.grid}
 *
 * @constructor
 * @baseclass
 * @author      Ruben Daniels (ruben AT ajax DOT org)
 * @version     %I%, %G%
 * @since       0.3
 */
apf.Anchoring = function(){
    this.$regbase = this.$regbase | apf.__ANCHORING__;
    this.$anchors = [];

    var VERTICAL   = 1;
    var HORIZONTAL = 2;

    this.$updateQueue = 0;
    this.$inited      =
    this.$parsed      =
    this.$anchoringEnabled = false;
    this.$hordiff     = 
    this.$verdiff     = 0;
    this.$rule_v      =
    this.$rule_h      =
    this.$rule_header = "";

    var l = apf.layout;
    
    this.$supportedProperties.push("anchors");
    
    var propHandlers = {
        "right" : function(value, prop){
            if (!this.$anchoringEnabled && !this.$setLayout("anchoring"))
                return;
            
            if (!value && value !== 0)
                this.$ext.style[prop] = "";

            //@note Removed apf.isParsing here to activate general queuing
            if (!this.$updateQueue)
                l.queue(this.$pHtmlNode, this);
            this.$updateQueue = this.$updateQueue | HORIZONTAL;
        },

        "bottom" : function(value, prop){
            if (!this.$anchoringEnabled && !this.$setLayout("anchoring"))
                return;

            if (!value && value !== 0)
                this.$ext.style[prop] = "";

            //@note Removed apf.isParsing here to activate general queuing            
            if (!this.$updateQueue)
                l.queue(this.$pHtmlNode, this);
            this.$updateQueue = this.$updateQueue | VERTICAL;
        }
    };
    propHandlers.left = propHandlers.width = propHandlers.right;
    propHandlers.top = propHandlers.height = propHandlers.bottom;
    
    this.$propHandlers["anchors"] = function(value){
        this.$anchors = value ? value.splitSafe("(?:, *| )") : [];

        if (!this.$anchoringEnabled && !this.$setLayout("anchoring"))
            return;

        if (!this.$updateQueue && apf.loaded)
            l.queue(this.$pHtmlNode, this);
        this.$updateQueue = this.$updateQueue | HORIZONTAL | VERTICAL;
    };

    /**
     * Turns anchoring off.
     *
     */
    this.$disableAnchoring = function(activate){
        //!this.$parsed || 
        if (!this.$inited || !this.$anchoringEnabled || !this.$pHtmlNode)
            return;

        l.removeRule(this.$pHtmlNode, this.$uniqueId + "_anchors");
        if (l.queue)
            l.queue(this.$pHtmlNode);

        for (var prop in propHandlers) {
            delete this.$propHandlers[prop];
        }

        this.removeEventListener("DOMNodeRemoved", remove); 
        this.removeEventListener("DOMNodeInserted", reparent); 

        if (this.right)
            this.$ext.style.left = apf.getHtmlLeft(this.$ext);

        if (this.bottom)
            this.$ext.style.top = apf.getHtmlTop(this.$ext);

        this.removeEventListener("prop.visible", visibleHandler);

        this.$inited   = false;
        this.$anchoringEnabled = false; //isn't this redundant?
    };

    /**
     * Enables anchoring based on attributes set in the AML of this element
     *
     * @attribute {Number, String} [left]   a way to determine the amount of pixels from the left border of this element to the left edge of it's parent's border. This attribute can also contain percentages, arithmetic and even full expressions.
     * Example:
     * <a:bar left="(20% + 10) * SOME_JS_VAR" />
     * @attribute {Number, String} [right]  a way to determine the amount of pixels from the right border of this element to the right edge of it's parent's border.This attribute can also contain percentages, arithmetic and even full expressions.
     * Example:
     * <a:bar right="(20% + 10) * SOME_JS_VAR" />
     * @attribute {Number, String} [width]  a way to determine the amount of pixels from the left border to the right border of this element.This attribute can also contain percentages, arithmetic and even full expressions.
     * Example:
     * <a:bar width="(20% + 10) * SOME_JS_VAR" />
     * @attribute {Number, String} [top]    a way to determine the amount of pixels from the top border of this element to the top edge of it's parent's border.This attribute can also contain percentages, arithmetic and even full expressions.
     * Example:
     * <a:bar top="(20% + 10) * SOME_JS_VAR" />
     * @attribute {Number, String} [bottom] a way to determine the amount of pixels from the bottom border of this element to the bottom edge of it's parent's border.This attribute can also contain percentages, arithmetic and even full expressions.
     * Example:
     * <a:bar bottom="(20% + 10) * SOME_JS_VAR" />
     * @attribute {Number, String} [height] a way to determine the amount of pixels from the top border to the bottom border of this element.This attribute can also contain percentages, arithmetic and even full expressions.
     * Example:
     * <a:bar height="(20% + 10) * SOME_JS_VAR" />
     */
    this.$enableAnchoring = function(){
        if (this.$inited) //@todo add code to reenable anchoring rules (when showing)
            return;

        /**** Properties and Attributes ****/
        apf.extend(this.$propHandlers, propHandlers);

        /**** Event handlers ****/
        this.addEventListener("DOMNodeRemoved", remove); 
        this.addEventListener("DOMNodeInserted", reparent); 
        this.addEventListener("prop.visible", visibleHandler);

        this.$updateQueue = 0 
            | ((this.left || this.width || this.right || this.anchors) && HORIZONTAL) 
            | ((this.top || this.height || this.bottom || this.anchors) && VERTICAL) ;

        if (this.$updateQueue)
            l.queue(this.$pHtmlNode, this);

        this.$inited   = true;
        this.$anchoringEnabled = true;
    };
    
    function visibleHandler(e){
        if (!(this.$rule_header || this.$rule_v || this.$rule_h))
            return;

        if (e.value) {
            if (this.$rule_v || this.$rule_h) {
                var rules = this.$rule_header + "\n" + this.$rule_v + "\n" + this.$rule_h;
                l.setRules(this.$pHtmlNode, this.$uniqueId + "_anchors", rules);
                //this.$ext.style.display = "none";
                l.queue(this.$pHtmlNode, this);
            }
            l.processQueue();
        }
        else {
            l.removeRule(this.$pHtmlNode, this.$uniqueId + "_anchors");
            l.queue(this.$pHtmlNode)
        }
    }
    
    function remove(e){
        if (e && (e.$doOnlyAdmin || e.currentTarget != this))
            return;

        if (l.queue && this.$pHtmlNode) {
            l.removeRule(this.$pHtmlNode, this.$uniqueId + "_anchors");
            l.queue(this.$pHtmlNode)
        }
    }

    function reparent(e){
        if (!this.$amlLoaded || e.currentTarget != this)
            return;

        if (!e.$isMoveWithinParent && this.$parsed) //@todo hmm weird state check
            this.$moveAnchoringRules(e.$oldParentHtmlNode);
        //else if (e.relatedNode == this) //@todo test this
            //e.currentTarget.$setLayout("anchoring");
    }

    this.$moveAnchoringRules = function(oldParent, updateNow){
        var rules = oldParent && l.removeRule(oldParent, this.$uniqueId + "_anchors");
        if (rules)
            l.queue(oldParent);

        if (!this.$rule_v && !this.$rule_h)
            return;

        this.$rule_header = getRuleHeader.call(this);
        rules = this.$rule_header + "\n" + this.$rule_v + "\n" + this.$rule_h;

        //@todo sometimes the content is not displayed anymore (when reparenting by xinclude)
        //this.$ext.style.display = "none";

        l.setRules(this.$pHtmlNode, this.$uniqueId + "_anchors", rules);
        l.queue(this.$pHtmlNode, this);
    };

    this.$hasAnchorRules = function(){
        return this.$rule_v || this.$rule_h ? true : false;
    };

    function getRuleHeader(){
        return "try{\
            var oHtml = " + (apf.hasHtmlIdsInJs
                ? this.$ext.getAttribute("id")
                : "document.getElementById('"
                    + this.$ext.getAttribute("id") + "')") + ";\
            \
            var pWidth = " + (this.$pHtmlNode == this.$pHtmlDoc.body
                ? "apf.getWindowWidth()" //@todo only needed for debug?
                : "apf.getHtmlInnerWidth(oHtml.parentNode)") + ";\
            \
            var pHeight = " + (this.$pHtmlNode == this.$pHtmlDoc.body
                ? "apf.getWindowHeight()" //@todo only needed for debug?
                : "apf.getHtmlInnerHeight(oHtml.parentNode)") + ";\
            }catch(e){\
            }";
    }

    /**
     * @macro
     */
    function setPercentage(expr, value){
        return String(expr).replace(apf.percentageMatch, "((" + value + " * $1)/100)");
    }

     

    this.$updateLayout = function(){
        //@todo review if this can be improved
        
        if (!this.$ext.offsetHeight && !this.$ext.offsetWidth) {
            var _self      = this;
            var propChange = function (name, old, value){
                if (_self.$updateQueue && apf.isTrue(value) && (_self.$ext.offsetWidth || _self.$ext.offsetHeight)) {
                    _self.$updateLayout();
                    apf.layout.activateRules(_self.$ext.parentNode);
                    
                    var p = _self;
                    while (p) {
                        p.unwatch("visible", propChange);
                        p = p.parentNode;
                    }
                    
                    _self.$isWaitingOnDisplay = false;
                }
            }

            this.$isWaitingOnDisplay = true;
            this.watch("visible", propChange);
            
            var p = this.parentNode;
            while(p) {
                p.watch("visible", propChange);
                p = p.parentNode;
            }
            
            return;
        }
        

        if (!this.$parsed) {
            if (!this.$ext.getAttribute("id"))
                apf.setUniqueHtmlId(this.$ext);

            this.$rule_header = getRuleHeader.call(this);
            this.$parsed      = true;
        }

        if (!this.$updateQueue) {
            if (this.visible)
                this.$ext.style.display = "";
            return;
        }

        if (this.draggable == "relative") {
            if ("absolute|fixed|relative".indexOf(apf.getStyle(this.$ext, "position")) == -1) //@todo apf3.1 the IDE doesn't like this
                this.$ext.style.position = "absolute";
        }
        else if (this.left || this.left ===  0 || this.top || this.top === 0 
          || this.right || this.right === 0 || this.bottom || this.bottom === 0 
          || this.$anchors.length) {
            if ("absolute|fixed".indexOf(apf.getStyle(this.$ext, "position")) == -1)
                this.$ext.style.position = "absolute";
        }

        var rules;
        if (this.$updateQueue & HORIZONTAL) {
            rules = [];
            
            this.$hordiff = apf.getWidthDiff(this.$ext);

            var left  = this.$anchors[3] || this.left,
                right = this.$anchors[1] || this.right,
                width = this.width, hasLeft = left || left === 0,
                hasRight = right || right === 0, 
                hasWidth = width || width === 0;

            if (right && typeof right == "string")
                right = setPercentage(right, "pWidth");

            if (hasLeft) {
                if (parseInt(left) != left) {
                    left = setPercentage(left,  "pWidth");
                    rules.push("oHtml.style.left = (" + left + ") + 'px'");
                }
                else
                    this.$ext.style.left = left + "px";
            }
            if (!hasLeft && hasRight) {
                if (parseInt(right) != right) {
                    right = setPercentage(right, "pWidth");
                    rules.push("oHtml.style.right = (" + right + ") + 'px'");
                }
                else
                    this.$ext.style.right = right + "px";
            }
            if (hasWidth) {
                if (parseInt(width) != width) {
                    width = setPercentage(width, "pWidth");
                    rules.push("oHtml.style.width = Math.max(" 
                        + (this.minwidth - this.$hordiff)
                        + ", Math.min(" + (this.maxwidth - this.$hordiff) + ", "
                        + width + " - " + this.$hordiff + ")) + 'px'");
                }
                else {
                    this.$ext.style.width = ((width > this.minwidth
                        ? (width < this.maxwidth
                            ? width
                            : this.maxwidth)
                        : this.minwidth) - this.$hordiff) + "px";
                }
            }

            if (hasLeft && hasRight) { //right != null && left != null) {
                rules.push("oHtml.style.width = (pWidth - (" + right
                    + ") - (" + left + ") - " + this.$hordiff + ") + 'px'");
            }

            this.$rule_h = (rules.length
                ? "try{" + rules.join(";}catch(e){};try{") + ";}catch(e){};"
                : "");
        }

        if (this.$updateQueue & VERTICAL) {
            rules = [];

            this.$verdiff = apf.getHeightDiff(this.$ext);

            var top    = this.$anchors[0] || this.top,
                bottom = this.$anchors[2] || this.bottom,
                height = this.height, hasTop = top || top === 0,
                hasBottom = bottom || bottom === 0, 
                hasHeight = height || height === 0;

            if (bottom && typeof bottom == "string")
                bottom = setPercentage(bottom, "pHeight");

            if (hasTop) {
                if (parseInt(top) != top) {
                    top = setPercentage(top, "pHeight");
                    rules.push("oHtml.style.top = (" + top + ") + 'px'");
                }
                else
                    this.$ext.style.top = top + "px";
            }
            if (!hasTop && hasBottom) {
                if (parseInt(bottom) != bottom) {
                    rules.push("oHtml.style.bottom = (" + bottom + ") + 'px'");
                }
                else
                    this.$ext.style.bottom = bottom + "px";
            }
            if (hasHeight) {
                if (parseInt(height) != height) {
                    height = setPercentage(height, "pHeight");
                    rules.push("oHtml.style.height = Math.max(" 
                        + (this.minheight - this.$verdiff)
                        + ", Math.min(" + (this.maxheight - this.$verdiff) + ", "
                        + height + " - " + this.$verdiff + ")) + 'px'");
                }
                else {
                    this.$ext.style.height = ((height > this.minheight
                        ? (height < this.maxheight
                            ? height
                            : this.maxheight)
                        : this.minheight) - this.$verdiff) + "px";
                }
            }

            if (hasTop && hasBottom) { //bottom != null && top != null) {
                rules.push("oHtml.style.height = (pHeight - (" + bottom +
                    ") - (" + top + ") - " + this.$verdiff + ") + 'px'");
            }

            this.$rule_v = (rules.length
                ? "try{" + rules.join(";}catch(e){};try{") + ";}catch(e){};"
                : "");
        }

        if (this.$rule_v || this.$rule_h) {
            l.setRules(this.$pHtmlNode, this.$uniqueId + "_anchors",
                this.$rule_header + "\n" + this.$rule_v + "\n" + this.$rule_h, true);
        }
        else {
            l.removeRule(this.$pHtmlNode, this.$uniqueId + "_anchors");
        }

        this.$updateQueue = 0;
    };

    this.addEventListener("DOMNodeInsertedIntoDocument", function(e){
        //if (this.$updateQueue)
            //this.$updateLayout();
    });

    this.addEventListener("DOMNodeRemovedFromDocument", function(e){
        this.$disableAnchoring();
    });
};




/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/alignment.js)SIZE(14756)TIME(1270838606)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */

apf.__ALIGNMENT__ = 1 << 12;



/**
 * All elements inheriting from this {@link term.baseclass baseclass} have alignment features. 
 * An element can be aligned to any side of its parent's rectangle. Multiple elements can
 * be aligned to the same side; these are then stacked. Layouts created using
 * alignment, with or without vbox/hbox elements can be stored in xml format.
 * These can then be loaded and saved for later use. Using this technique it's
 * possible to offer a layout manager to your users from within your application.
 * This layout manager could then allow the user to choose between several
 * layouts and save new ones.
 * Example:
 * An Outlook-like layout in AML
 * <code>
 *  <a:toolbar   align = "top-1"          height = "40" />
 *  <a:tree      align = "left-splitter"  width  = "20%" />
 *  <a:datagrid  align = "right-splitter" height = "50%" />
 *  <a:text      align = "right" />
 *  <a:statusbar align = "bottom-2"       height = "20" />
 * </code>
 * Remarks:
 * This is one of three positioning methods.
 * See {@link element.grid}
 * See {@link baseclass.anchoring}
 *
 * @attribute {Boolean} dock whether this element can function as a dockable section of the layout.
 * @attrinfo  layout/align  dropdown
 * @default   false
 * @attribute {Boolean} dockable whether this element can be dragged to dock somewhere else
 * @attrinfo  layout/align  dropdown
 * @default   false

 * @attribute  {String} align       the edge of the parent to which this
 *                                  element aligns. Possible values are
 *                                  a combination of: "left", "middle",
 *                                  "right", "top", "bottom" and "slider"
 *                                  and optionally a size.
 * Example:
 * <code>
 *  <a:tree align="left-splitter-3" width="200" height="200">
 *      <a:item caption="root" icon="icoUsers.gif">
 *          <a:item icon="icoUsers.gif" caption="test">
 *              <a:item icon="icoUsers.gif" caption="test" />
 *              <a:item icon="icoUsers.gif" caption="test" />
 *              <a:item icon="icoUsers.gif" caption="test" />
 *          </a:item>
 *      </a:item>
 *  </a:tree>
 * </code>
 * @attrinfo  layout  textbox
 * @attribute  {String} lean        the position of element when it is ambiguous.
 *   Possible values:
 *   left   the element leans towards the left
 *   right  the element leans towards the right
 *   top    the element leans towards the top
 *   bottom the element leans towards the bottom
 * @attrinfo  layout/align  dropdown
 * @default   left
 * @attribute  {Number} edge        the size of the edge of the space between
 *                                  this and the neighbouring element to the
 *                                  right or top. If the value of this attribute
 *                                  is smaller than that of the splitter,
 *                                  the edge will be the size of the splitter.
 * @attrinfo  layout/align  slider
 * @default   4
 * @attribute  {Number} weight      the factor (between 0 and 1) this element
 *                                  takes when no width is specified. The factor
 *                                  is calculated by doing (weight/totalweight)
 *                                  * space available in parent. Based on
 *                                  the parent being a vbox or hbox this
 *                                  attribute calculates either the element's
 *                                  width or height.
 * @attrinfo  layout/align  slider
 * @default   1
 * @attribute  {Number} splitter    the size of splitter that is placed between
 *                                  this and the neighbouring element to the
 *                                  right or top. When not specified, the
 *                                  splitter is not displayed.
 * @attrinfo  layout/align  slider
 * @default   0
 * @attribute  {Number} minwidth    the minimum horizontal size of this element.
 * @attrinfo  layout  slider
 * @default   0
 * @attribute  {Number} minheight   the minimum vertical size of this element.
 * @attrinfo  layout  slider
 * @default   0

 * @constructor
 * @baseclass
 * @author      Ruben Daniels (ruben AT ajax DOT org)
 * @version     %I%, %G%
 * @since       0.4
 *
 * @default_private
 */
apf.Alignment = function(){
    this.$regbase = this.$regbase | apf.__ALIGNMENT__;

    var l = apf.layout;

    if (typeof this.dock == "undefined")
        this.dock = false;
    if (typeof this.dockable == "undefined")
        this.dockable = false;
    this.$booleanProperties["dock"] = true;
    this.$booleanProperties["dockable"] = true;
    this.$supportedProperties.push("dock", "dockable", "align", "lean", "edge",
        "weight", "splitter", "minwidth", "minheight");

    /**** DOM Hooks ****/

    /**
     * Turns the alignment features off.
     * @param  {Boolean} [purge] whether alignment is recalculated right after setting the property.
     */
    //var lastPosition, amlNode = this;
    this.$disableAlignment = function(purge){
        if (!this.aData || !this.$alignmentEnabled) 
            return;

        for (var prop in propHandlers)
            delete this.$propHandlers[prop];
        
        this.removeEventListener("DOMNodeRemoved", remove); 
        this.removeEventListener("DOMNodeInserted", reparent); 
        
        this.removeEventListener("prop.visible", visibleHandler);

        remove.call(this);
        
        this.$alignmentEnabled = false;
    };

    /**
     * Turns the alignment features on.
     *
     */
    this.$enableAlignment = function(purge){
        this.$alignmentEnabled = true;

        var buildParent = "vbox|hbox".indexOf(this.parentNode.tagName) == -1
            && !this.parentNode.pData;

        apf.extend(this.$propHandlers, propHandlers);

        this.addEventListener("DOMNodeRemoved", remove); 
        this.addEventListener("DOMNodeInserted", reparent); 
        this.addEventListener("prop.visible", visibleHandler);

        var layout = l.get(this.$pHtmlNode, buildParent
            ? apf.getBox(this.parentNode.margin || this.$pHtmlNode.getAttribute("margin") || "")
            : null);

        if (buildParent) {
            this.parentNode.pData = l.parseXml(
                this.parentNode || apf.getXml("<vbox />"),
                layout, "vbox", true);

            layout.root = this.parentNode.pData;
        }

        if (!this.aData)
            this.aData = l.parseXml(this, layout, this, true); //not recur?

        
        if (this.align) {
            l.addAlignNode(this, layout.root);

            if (this.aData.hidden || this.visible === false)
                this.aData.prehide(true);

            //@note Removed apf.isParsing here to activate general queuing
            this.$purgeAlignment();
        }
        else
        
        {
            var pData = this.parentNode.aData || this.parentNode.pData;
            this.aData.stackId = pData.children.push(this.aData) - 1;
            this.aData.parent  = pData;
        }
    };
    
    function visibleHandler(e){
        if (!this.aData) return;

        if (!this.aData.hidden == e.value) //useless changing to same state
            return;

        if (e.value) {
            if (this.aData.preshow() !== false)
                this.$ext.style.display = "none";
            this.$purgeAlignment();
        }
        else {
            this.$ext.style.display = "block";
            this.aData.prehide();
            this.$purgeAlignment();
        }
        
        apf.layout.processQueue(); //@todo apf3.0 might not be the best but fixes trunk/test/toc.html
    };

    /**
     * Calculates the rules for this element and activates them.
     * @private
     */
    this.$purgeAlignment = function(){
        var layout = l.get(this.$pHtmlNode);
        
        //@todo review if this can be improved
        
        if (this.$ext && this.$ext.style.display == "block" 
          && !this.$ext.offsetHeight && !this.$ext.offsetWidth) {
            var _self      = this;
            var propChange = function (name, old, value){
                if (_self.$ext.offsetWidth || _self.$ext.offsetHeight) {
                    l.queue(_self.$pHtmlNode, null, layout.root);
                    //apf.layout.activateRules(_self.$ext.parentNode);
                    
                    var p = _self;
                    while (p) {
                        p.unwatch("visible", propChange);
                        p = p.parentNode;
                    }
                    
                    _self.$isWaitingOnDisplay = false;
                }
            }

            this.$isWaitingOnDisplay = true;
            this.watch("visible", propChange);
            
            var p = this.parentNode;
            while(p) {
                p.watch("visible", propChange);
                p = p.parentNode;
            }
            
            return;
        }
        
        
        l.queue(this.$pHtmlNode, null, layout.root);
    };

    function remove(e){
        if (e && (e.$doOnlyAdmin || e.currentTarget != this))
            return;

        if (this.aData) {
            this.aData.remove();
            this.$purgeAlignment();

            if (this.parentNode.pData && !this.parentNode.pData.children.length) {
                l.removeAll(this.parentNode.pData);
                this.parentNode.pData = null;
            }

            if (this.$ext)
                this.$ext.style.display = "none";
        }
    }

    //@todo support inserbefore for align templates
    function reparent(e){ //@todo domnodeinserted should be called before intodoc then use $amlLoaded to check
        if (!this.$amlLoaded || e.currentTarget != this)
            return;

        if (!e.$isMoveWithinParent && this.aData 
          && this.aData.pHtml != this.$pHtmlNode) {
            this.aData.pHtml = this.$pHtmlNode;
            //this.aData = null;
            this.$enableAlignment();
        }
    }

    //@todo problem with determining when aData.parent | also with weight and minwidth
    //@todo move the prophandlers to inside the constructor
    
    var propHandlers = {
        
        "align" : function(value){
            if (value) {
                /*this.aData.remove();
                this.aData.template   = value;
                this.splitter         = undefined;
                this.aData.edgeMargin = this.edge || 0;
                this.$enableAlignment();*/
                this.$setLayout("alignment");
            }
            else {
                this.$setLayout("anchoring");
                this.$ext.style.display = "block";
            }
        },
        

        "lean" : function(value){
            this.aData.isBottom = (value || "").indexOf("bottom") > -1;
            this.aData.isRight = (value || "").indexOf("right") > -1;
            this.$purgeAlignment();
        },

        "edge" : function(value){
            this.aData.edgeMargin = Math.max(this.aData.splitter || 0, value != "splitter" ? value : 0);
            this.aData.splitter   = value == "splitter" ? 5 : false;
            this.$purgeAlignment();
        },

        "weight" : function(value){
            this.aData.weight = parseFloat(value);
            this.$purgeAlignment();
        },

        "splitter" : function(value){
            this.aData.splitter = value ? 5 : false;
            this.aData.edgeMargin = Math.max(this.aData.splitter || 0, this.edge || 0);

            if (!value && this.align && this.align.indexOf("-splitter"))
                this.align = this.aData.template = this.align.replace("-splitter", "");

            this.$purgeAlignment();
        },

        "width" : function(value){
            //resetting this property because else we can't reset, when we have
            //a fast JIT we'll do setProperty in onresize
            this.width = null;
            this.aData.fwidth = value || false;

            if (this.aData.fwidth && this.aData.fwidth.indexOf("/") > -1) {
                this.aData.fwidth = eval(this.aData.fwidth);
                if (this.aData.fwidth <= 1)
                    this.aData.fwidth = (this.aData.fwidth * 100) + "%";
            }

            this.$purgeAlignment();
        },

        "height" : function(value){
            //resetting this property because else we can't reset, when we have a
            //fast JIT we'll do setProperty in onresize
            this.height = null;
            this.aData.fheight = String(value) || false;

            if (this.aData.fheight && this.aData.fheight.indexOf("/") > -1) {
                this.aData.fheight = eval(this.aData.fheight);
                if (this.aData.fheight <= 1)
                    this.aData.fheight = (this.aData.fheight * 100) + "%";
            }

            this.$purgeAlignment();
        },

        "minwidth" : function(value){
            this.aData.minwidth = value;
            this.$purgeAlignment();
        },

        "minheight" : function(value){
            this.aData.minheight = value;
            this.$purgeAlignment();
        }
    };

    this.addEventListener("DOMNodeRemovedFromDocument", function(e){
        this.$disableAlignment();
        this.aData = null;
    });
};




/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/contenteditable2.js)SIZE(6789)TIME(1270838606)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */
apf.__CONTENTEDITABLE__  = 1 << 24;




/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/guielement.js)SIZE(31701)TIME(1270838606)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */

apf.__GUIELEMENT__ = 1 << 15;
apf.__VALIDATION__ = 1 << 6;



/**
 * All elements inheriting from this {@link term.baseclass baseclass} are a aml component.
 *
 * @constructor
 * @baseclass
 * @author      Ruben Daniels (ruben AT ajax DOT org)
 * @version     %I%, %G%
 * @since       0.4
 *
 * @inherits apf.Alignment
 * @inherits apf.Anchoring
 * @inherits apf.Docking
 * @inherits apf.DelayedRender
 * @inherits apf.DragDrop
 * @inherits apf.Focussable
 * @inherits apf.Interactive
 * @inherits apf.Transaction
 * @inherits apf.Validation
 *
 * @attribute {String} span     the number of columns this element spans. Only used inside a table element.
 * @attribute {String} margin   
 * @todo attribute align
 *
 * @attribute {mixed} left the left position of this element. Depending
 * on the choosen layout method the unit can be pixels, a percentage or an
 * expression.
 *
 * @attribute {mixed} top the top position of this element. Depending
 * on the choosen layout method the unit can be pixels, a percentage or an
 * expression.
 *
 * @attribute {mixed} right the right position of this element. Depending
 * on the choosen layout method the unit can be pixels, a percentage or an
 * expression.
 *
 * @attribute {mixed} bottom the bottom position of this element. Depending
 * on the choosen layout method the unit can be pixels, a percentage or an
 * expression.
 *
 * @attribute {mixed} width the different between the left edge and the
 * right edge of this element. Depending on the choosen layout method the
 * unit can be pixels, a percentage or an expression.
 * Remarks:
 * When used as a child of a grid element the width can also be set as '*'. 
 * This will fill the rest space.
 *
 * @attribute {mixed} height the different between the top edge and the
 * bottom edge of this element. Depending on the choosen layout method the
 * unit can be pixels, a percentage or an expression.
 * Remarks:
 * When used as a child of a grid element the height can also be set as '*'. 
 * This will fill the rest space.
 *
 * @event resize Fires when the element changes width or height. This event
 * currently only fires when anchoring (left, top, width, height, right, bottom), 
 * alignment (align, vbox, hbox) or the table layout is used.
 * 
 * @event contextmenu Fires when the user requests a context menu. Either
 * using the keyboard or mouse.
 *   bubbles: yes
 *   cancelable:  Prevents the default contextmenu from appearing.
 *   object:
 *   {Number} x         the x coordinate where the contextmenu is requested on.
 *   {Number} y         the y coordinate where the contextmenu is requested on.
 *   {Event}  htmlEvent the html event object that triggered this event from being called.
 * @event focus       Fires when this element receives focus.
 * @event blur        Fires when this element loses focus.
 * @event keydown     Fires when this element has focus and the user presses a key on the keyboard.
 *   cancelable: Prevents the default key action.
 *   bubbles:
 *   object:
 *   {Boolean} ctrlKey   whether the ctrl key was pressed.
 *   {Boolean} shiftKey  whether the shift key was pressed.
 *   {Boolean} altKey    whether the alt key was pressed.
 *   {Number}  keyCode   which key was pressed. This is an ascii number.
 *   {Event}   htmlEvent the html event object that triggered this event from being called.
 */
apf.GuiElement = function(){
    this.$init(true);
};

(function(){
    this.$regbase    = this.$regbase | apf.__GUIELEMENT__;
    
    this.$focussable = apf.KEYBOARD_MOUSE; // Each GUINODE can get the focus by default
    this.visible     = true; //default value;
    
    
    this.$booleanProperties["disable-keyboard"] = true;
    
    this.$booleanProperties["visible"]          = true;
    this.$booleanProperties["focussable"]       = true;
    
    
    this.$supportedProperties.push("draggable", "resizable");
    
    this.$supportedProperties.push(
        "focussable", "zindex", "disabled", "tabindex",
        "disable-keyboard", "contextmenu", "visible", "autosize", 
        "loadaml", "actiontracker", "alias",
        "width", "left", "top", "height", "tooltip"
    );

    this.$setLayout = function(type){
        if (!this.$drawn || !this.$pHtmlNode)
            return false;

        if (this.parentNode) {
            
            if (this.parentNode.localName == "table") {
                this.parentNode.register(this);
                this.$disableCurrentLayout = null;
                return type == "table";
            }
            

            
            else if ("vbox|hbox".indexOf(this.parentNode.localName) > -1) {
                this.parentNode.register(this);
                this.$disableCurrentLayout = null;
                return type == this.parentNode.localName;
            }
            
            
            
            else if (this.align) {
                if (!this.$alignmentEnabled) {
                    if (this.$disableCurrentLayout)
                        this.$disableCurrentLayout();
                    this.$enableAlignment();
                    this.$disableCurrentLayout = this.$disableAlignment;
                }
                return type == "alignment";
            }
            
        }
        
        
        if (!this.$anchoringEnabled) {
            if (this.$disableCurrentLayout)
                this.$disableCurrentLayout();
            this.$enableAnchoring();
            this.$disableCurrentLayout = this.$disableAnchoring;
        }
        return type == "anchoring";
        
    }
    
    this.addEventListener("DOMNodeInserted", function(e){
        if (e.currentTarget == this 
          && "vbox|hbox|table".indexOf(this.parentNode.localName) == -1) {
            this.$setLayout();
        }
    }); 

    this.implement(
        
        apf.Anchoring
        
        
        ,apf.Alignment
        
        
    );
    
    /**** Convenience functions for gui nodes ****/

    

    /**** Geometry ****/

    /**
     * Sets the different between the left edge and the right edge of this
     * element. Depending on the choosen layout method the unit can be
     * pixels, a percentage or an expression.
     * Call-chaining is supported.
     * @param {Number} value the new width of this element.
     */
    this.setWidth = function(value){
        this.setProperty("width", value, false, true);
        return this;
    };

    /**
     * Sets the different between the top edge and the bottom edge of this
     * element. Depending on the choosen layout method the unit can be
     * pixels, a percentage or an expression.
     * Call-chaining is supported.
     * @param {Number} value the new height of this element.
     */
    this.setHeight = function(value){
        this.setProperty("height", value, false, true);
        return this;
    };

    /**
     * Sets the left position of this element. Depending on the choosen
     * layout method the unit can be pixels, a percentage or an expression.
     * Call-chaining is supported.
     * @param {Number} value the new left position of this element.
     */
    this.setLeft   = function(value){
        this.setProperty("left", value, false, true);
        return this;
    };

    /**
     * Sets the top position of this element. Depending on the choosen
     * layout method the unit can be pixels, a percentage or an expression.
     * Call-chaining is supported.
     * @param {Number} value the new top position of this element.
     */
    this.setTop    = function(value){
        this.setProperty("top", value, false, true);
        return this;
    };

    if (!this.show) {
        /**
         * Makes the elements visible. Call-chaining is supported.
         */
        this.show = function(){
            this.setProperty("visible", true, false, true);
            return this;
        };
    }

    if (!this.hide) {
        /**
         * Makes the elements invisible. Call-chaining is supported.
         */
        this.hide = function(){
            this.setProperty("visible", false, false, true);
            return this;
        };
    }

    /**
     * Retrieves the calculated width in pixels for this element
     */
    this.getWidth  = function(){
        return (this.$ext || {}).offsetWidth;
    };

    /**
     * Retrieves the calculated height in pixels for this element
     */
    this.getHeight = function(){
        return (this.$ext || {}).offsetHeight;
    };

    /**
     * Retrieves the calculated left position in pixels for this element
     * relative to the offsetParent.
     */
    this.getLeft   = function(){
        return (this.$ext || {}).offsetLeft;
    };

    /**
     * Retrieves the calculated top position in pixels for this element
     * relative to the offsetParent.
     */
    this.getTop    = function(){
        return (this.$ext || {}).offsetTop;
    };

    /**** Disabling ****/

    /**
     * Activates the functions of this element. Call-chaining is supported.
     */
    this.enable  = function(){
        this.setProperty("disabled", false, false, true);
        return this;
    };

    /**
     * Deactivates the functions of this element.
     * Call-chaining is supported.
     */
    this.disable = function(){
        this.setProperty("disabled", true, false, true);
        return this;
    };

    /**** z-Index ****/

    /**
     * Moves this element to the lowest z ordered level.
     * Call-chaining is supported.
     */
    this.sendToBack = function(){
        this.setProperty("zindex", 0, false, true);
        return this;
    };

    /**
     * Moves this element to the highest z ordered level.
     * Call-chaining is supported.
     */
    this.bringToFront  = function(){
        this.setProperty("zindex", apf.all.length + 1, false, true);
        return this;
    };

    /**
     * Moves this element one z order level deeper.
     * Call-chaining is supported.
     */
    this.sendBackwards = function(){
        this.setProperty("zindex", this.zindex - 1, false, true);
        return this;
    };

    /**
     * Moves this element one z order level higher.
     * Call-chaining is supported.
     */
    this.bringForward  = function(){
        this.setProperty("zindex", this.zindex + 1, false, true);
        return this;
    };

    
    
    this.hasFocus = function(){}

    this.addEventListener("DOMNodeInsertedIntoDocument", function(e){
        var x = this.$aml;

        // will $pHtmlNode be deprecated soon?
        // check used to be:
        //if (!this.$pHtmlNode && this.parentNode)
        if (this.parentNode) {
            if (this.localName == "item" 
              && this.parentNode.hasFeature(apf.__MULTISELECT__)) //special case for item nodes, using multiselect rendering
                this.$pHtmlNode = this.parentNode.$container;
            else
                this.$pHtmlNode = this.parentNode.$int; //@todo apf3.0 change this in the mutation events
        }

        if (!this.$pHtmlNode) //@todo apf3.0 retry on DOMNodeInserted
            return;
        
        this.$pHtmlDoc  = this.$pHtmlNode.ownerDocument || document;

        if (this.$initSkin)
            this.$initSkin(x);

        if (this.$draw)
            this.$draw();

        if (e.id)
            this.$ext.setAttribute("id", e.id);

        if (typeof this.visible == "undefined")
            this.visible = true;

        
        if (apf.debug && this.$ext && this.$ext.nodeType)
            this.$ext.setAttribute("uniqueId", this.$uniqueId);
        

        
        if (this.$focussable && typeof this.focussable == "undefined")
            apf.GuiElement.propHandlers.focussable.call(this);
        
        
        this.$drawn = true;
    }, true);
    
    this.addEventListener("DOMNodeInsertedIntoDocument", function(e){
        if (!this.$pHtmlNode) //@todo apf3.0 retry on DOMInsert or whatever its called
            return;
        
        this.$setLayout();

        if (this.$loadAml)
            this.$loadAml(this.$aml); //@todo replace by event
    });
    
    
    var f;
    this.addEventListener("$event.resize", f = function(c){
        apf.layout.setRules(this.$ext, "resize", "var o = apf.all[" + this.$uniqueId + "];\
            if (o) o.dispatchEvent('resize');", true);

        apf.layout.queue(this.$ext);
        this.removeEventListener("$event.resize", f);
    });
    

    
    this.addEventListener("contextmenu", function(e){
        
        
        if (!this.contextmenus) return;
        
        if (this.hasFeature(apf.__DATABINDING__)) {
            var contextmenu;
            var xmlNode = this.hasFeature(apf.__MULTISELECT__)
                ? this.selected
                : this.xmlRoot;

            var i, l, m, isRef, sel, menuId, cm, result;
            for (i = 0, l = this.contextmenus.length; i < l; i++) {
                isRef  = (typeof (cm = this.contextmenus[i]) == "string");
                result = null;
                if (!isRef && cm.match && xmlNode) {//@todo apf3.0 cache this statement
                    result = (cm.cmatch || (cm.cmatch = apf.lm.compile(cm.match, {
                        xpathmode  : 3,
                        injectself : true
                    })))(xmlNode)
                }

                if (isRef || xmlNode && result || !cm.match) { //!xmlNode && 
                    menuId = isRef
                        ? cm
                        : cm.menu

                    if (!self[menuId]) {
                        
                        throw new Error(apf.formatErrorString(0, this,
                            "Showing contextmenu",
                            "Could not find contextmenu by name: '" + menuId + "'"),
                            this.$aml);
                        
                        
                        return;
                    }

                    self[menuId].display(e.x, e.y, null, this, xmlNode);

                    e.returnValue  = false;//htmlEvent.
                    e.cancelBubble = true;
                    break;
                }
            }

            //IE6 compatiblity
            /*
            @todo please test that disabling this is OK
            if (!apf.config.disableRightClick) {
                document.oncontextmenu = function(){
                    document.oncontextmenu = null;
                    e.cancelBubble = true;
                    return false;
                }
            }*/
        }
        else {
            menuId = typeof this.contextmenus[0] == "string"
                ? this.contextmenus[0]
                : this.contextmenus[0].getAttribute("menu")

            if (!self[menuId]) {
                
                throw new Error(apf.formatErrorString(0, this,
                    "Showing contextmenu",
                    "Could not find contextmenu by name: '" + menuId + "'",
                    this.$aml));
                
                
                return;
            }

            self[menuId].display(e.x, e.y, null, this);

            e.returnValue = false;//htmlEvent.
            e.cancelBubble = true;
        }
    });
    
}).call(apf.GuiElement.prototype = new apf.AmlElement());

/**
 * @for apf.amlNode
 * @private
 */
apf.GuiElement.propHandlers = {
    
    /**
     * @attribute {Boolean} focussable whether this element can receive the focus.
     * The focussed element receives keyboard event.s
     */
    "focussable": function(value){
        this.focussable = typeof value == "undefined" || value;

        if (!this.hasFeature(apf.__FOCUSSABLE__)) //@todo should this be on the prototype
            this.implement(apf.Focussable);

        if (this.focussable) {
            apf.window.$addFocus(this, this.tabindex);
        }
        else {
            apf.window.$removeFocus(this);
        }
    },
    

    /**
     * @attribute {Number} zindex the z ordered layer in which this element is
     * drawn.
     */
    "zindex": function(value){
        this.$ext.style.zIndex = value;
    },

    /**
     * @attribute {Boolean} visible whether this element is shown.
     */
    "visible": function(value){
        if (apf.isFalse(value) || typeof value == "undefined") {
            this.$ext.style.display = "none";
            
            if (apf.document.activeElement == this || this.canHaveChildren
              && apf.isChildOf(this, apf.document.activeElement, false)) {
                if (apf.config.allowBlur && this.hasFeature(apf.__FOCUSSABLE__))
                    this.blur();
                else
                    apf.window.moveNext();
            }
            
            this.visible = false;
        }
        else { //if (apf.isTrue(value)) default
            this.$ext.style.display = "block"; //Some form of inheritance detection
            
            if (apf.layout && this.$int) //apf.hasSingleRszEvent)
                apf.layout.forceResize(this.$int);//this.$int
            
            this.visible = true;
        }
    },

    /**
     * @attribute {Boolean} disabled whether this element's functions are active.
     * For elements that can contain other apf.NODE_VISIBLE elements this
     * attribute applies to all it's children.
     */
    "disabled": function(value){
        if (!this.$drawn) {
            var _self     = this;
            this.disabled = false;

            apf.queue.add("disable" + this.$uniqueId, function(e){
                _self.disabled = value;
                apf.GuiElement.propHandlers.disabled.call(_self, value);
            });
            return;
        }

        //For child containers we only disable its children
        if (this.canHaveChildren) {
            //@todo Fix focus here first.. else it will jump whilst looping
            if (value != -1)
                value = this.disabled = apf.isTrue(value);

            var nodes = this.childNodes;
            for (var node, i = 0, l = nodes.length; i < l; i++) {
                node = nodes[i];
                if (node.nodeFunc == apf.NODE_VISIBLE) {
                    if (value && node.disabled != -1)
                        node.$disabled = node.disabled || false;
                    node.setProperty("disabled", value ? -1 : false);
                }
            }

            //this.disabled = undefined;
            if (this.$isWindowContainer)
                return;
        }

        if (value == -1 || value == false) {
            //value = true;
        }
        else if (typeof this.$disabled == "boolean") {
            if (value === null) {
                value = this.$disabled;
                this.$disabled = null;
            }
            else {
                this.$disabled = value || false;
                return;
            }
        }

        if (apf.isTrue(value) || value == -1) {
            this.disabled = false;
            if (apf.document.activeElement == this) {
                apf.window.moveNext(true); //@todo should not include window
                if (apf.document.activeElement == this)
                    this.$blur();
            }

            if (this.hasFeature(apf.__PRESENTATION__))
                this.$setStyleClass(this.$ext, this.$baseCSSname + "Disabled");

            if (this.$disable)
                this.$disable();

            

            this.disabled = value;
        }
        else {
            if (this.hasFeature(apf.__DATABINDING__) && apf.config.autoDisable
              && !(!this.$bindings || this.xmlRoot))
                return false;

            this.disabled = false;

            if (apf.document.activeElement == this)
                this.$focus();

            if (this.hasFeature(apf.__PRESENTATION__))
                this.$setStyleClass(this.$ext, null, [this.$baseCSSname + "Disabled"]);

            if (this.$enable)
                this.$enable();

            
        }
    },

    /**
     * @attribute {Boolean} enables whether this element's functions are active.
     * For elements that can contain other apf.NODE_VISIBLE elements this
     * attribute applies to all it's children.
     */
    "enabled" : function(value){
       this.setProperty("disabled", !value);
    },

    /**
     * @attribute {Boolean} disable-keyboard whether this element receives
     * keyboard input. This allows you to disable keyboard independently from
     * focus handling.
     */
    "disable-keyboard": function(value){
        this.disableKeyboard = apf.isTrue(value);
    },
    
    /**
     * @attribute {String}  tooltip  the text displayed when a user hovers with 
     * the mouse over the element.
     */
    "tooltip" : function(value){
        this.$ext.setAttribute("title", value);
    },
    
    
    "align" : function(value){
        if (value)
            this.$setLayout("alignment");
    },
    

    
    /**
     * @attribute {String} contextmenu the name of the menu element that will
     * be shown when the user right clicks or uses the context menu keyboard
     * shortcut.
     * Example:
     * <code>
     *  <a:menu id="mnuExample">
     *      <a:item>test</a:item>
     *      <a:item>test2</a:item>
     *  </a:menu>
     *   
     *  <a:list 
     *    contextmenu = "mnuExample" 
     *    width       = "200" 
     *    height      = "150" />
     *  <a:bar 
     *    contextmenu = "mnuExample" 
     *    width       = "200" 
     *    height      = "150" />
     * </code>
     */
    "contextmenu": function(value){
        this.contextmenus = [value];
    },
    

    
    /**
     * @attribute {String} actiontracker the name of the actiontracker that
     * is used for this element and it's children. If the actiontracker doesn't
     * exist yet it is created.
     * Example:
     * In this example the list uses a different actiontracker than the two
     * textboxes which determine their actiontracker based on the one that
     * is defined on the bar.
     * <code>
     *  <a:list actiontracker="newAT" />
     *
     *  <a:bar actiontracker="someAT">
     *      <a:textbox />
     *      <a:textbox />
     *  </a:bar>
     * </code>
     */
    "actiontracker": function(value){
        if (!value) {
            this.$at = null;
        }
        else if (value.tagName == "actiontracker") {
            this.$at = value;
        }
        else {
            this.$at = typeof value == "string" && self[value]
              ? apf.nameserver.get("actiontracker", value) || self[value].getActionTracker()
              : apf.setReference(value,
                  apf.nameserver.register("actiontracker",
                      value, new apf.actiontracker()));

            if (!this.$at.name)
                this.$at.name = value;
        }
    },
    
    
    //Load subAML
    /**
     * @attribute {String} aml the {@link term.datainstruction data instruction} 
     * that loads new aml as children of this element.
     */
    "aml": function(value){
        //Clear??
        this.insertMarkup(value);
    }

    /**
     * @attribute {String} sets this aml element to be editable
     * that loads new aml as children of this element.
     */
    
    
   
    
};




/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/presentation.js)SIZE(20362)TIME(1270838606)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */

apf.__PRESENTATION__ = 1 << 9;


/**
 * All elements inheriting from this {@link term.baseclass baseclass} have skinning features. A skin is a description
 * of how the element is rendered. In the web browser this is done using html
 * elements and css.
 * Remarks:
 * The skin is set using the skin attribute. The skin of each element can be
 * changed at run time. Other than just changing the look of an element, a skin
 * change can help the user to perceive information in a different way. For 
 * example a list element has a default skin, but can also use the thumbnail 
 * skin to display thumbnails of the {@link term.datanode data nodes}.
 *
 * A skin for an element is always build up out of a standard set of parts.
 * <code>
 *   <a:textbox name="textbox">
 *      <a:alias>
 *          ...
 *      </a:alias>
 *      <a:style><![CDATA[
 *          ...
 *      ]]></a:style>
 *  
 *      <a:presentation>
 *          <a:main>
 *              ...
 *          </a:main>
 *          ...
 *      </a:presentation>
 *   </a:textbox>
 * </code>
 * The alias contains a name that contains alternative names for the skin. The
 * style tags contain the css. The main tag contains the html elements that are
 * created when the component is created. Any other skin items are used to render
 * other elements of the widget. In this reference guide you will find these
 * skin items described on the pages of each widget.
 *
 * @constructor
 * @baseclass
 * @author      Ruben Daniels (ruben AT ajax DOT org)
 * @version     %I%, %G%
 * @since       0.5
 */
apf.Presentation = function(){
    this.$init(true);
};

(function(){
    this.$regbase = this.$regbase | apf.__PRESENTATION__;
    
    /**** Properties and Attributes ****/

    this.$supportedProperties.push("skin");
    
    /**
     * @attribute {string} skinset the skinset for
     * this element. If none is specified the skinset attribute
     * of <a:appsettings /> is used. When not defined the default skinset
     * is accessed.
     * Example:
     * <code>
     *  <a:list skinset="perspex" />
     * </code>
     */
    this.$propHandlers["skinset"] =

    /**
     * @attribute {string} skin the name of the skin in the skinset that defines 
     * how this element is rendered. When a skin is changed the full state of the
     * element is kept including it's selection, all the
     * aml attributes, loaded data, focus and disabled state.
     * Example:
     * <code>
     *  <a:list id="lstExample" skin="thumbnails" />
     * </code>
     * Example:
     * <code>
     *  lstExample.setAttribute("skin", "list");
     * </code>
     */
    

    /**
     * @attribute {String} style the css style applied to the this element. This can be a string containing one or more css rules.
     */
    this.$propHandlers["style"] = function(value){
        if (!this.styleAttrIsObj && this.$amlLoaded)
            this.$ext.setAttribute("style", value);
    }

    var oldClass;
    /**
     * @attribute {String} class the name of the css style class applied to the this element.
     */
    this.$propHandlers["class"] = function(value){
        this.$setStyleClass(this.$ext, value, [oldClass || ""])
    }

    

    /**** Private methods ****/

    this.$setStyleClass = apf.setStyleClass;

    function setLeechedSkin(e){
        if (!this.$amlLoaded || e && (e.$isMoveWithinParent 
          || e.currentTarget != this))
            return;

        this.$setInheritedAttribute(this, "skinset");

        if (this.attributes.getNamedItem("skin"))
            return;

        //e.relatedNode
        var skinName, pNode = this.parentNode, skinNode;
        if ((skinName = this.$canLeechSkin.dataType 
          == apf.STRING ? this.$canLeechSkin : this.localName)
          && pNode.$originalNodes 
          && (skinNode = pNode.$originalNodes[skinName])
          && skinNode.getAttribute("inherit")) {
            var link = skinNode.getAttribute("link");
            this.$isLeechingSkin = true;
            if (link) {
                this.$forceSkinChange(link);
            }
            else {
                var skin = pNode.skinName.split(":");
                this.$forceSkinChange(skin[1], skin[0]);
            }
        }
        else if (this.$isLeechingSkin) {
            delete this.kin;
            this.$forceSkinChange();
        }
    }

    //Skin Inheritance
    //@todo Probably requires some cleanup
    this.$initSkin = function(x){
        if (this.$canLeechSkin) {
            this.addEventListener("DOMNodeInserted", setLeechedSkin);
        }
        
        if (!this.skin)
            this.skin = this.getAttribute("skin");
        
        var skinName, pNode = this.parentNode, skinNode;
        if (this.$canLeechSkin && !this.skin 
          && (skinName = this.$canLeechSkin.dataType == apf.STRING 
            ? this.$canLeechSkin 
            : this.localName)
          && pNode.$originalNodes 
          && (skinNode = pNode.$originalNodes[skinName])
          && skinNode.getAttribute("inherit")) {
            var link = skinNode.getAttribute("link");
            this.$isLeechingSkin = true;
            if (link) {
                this.skin = link;
                this.$loadSkin();
            }
            else {
                this.$loadSkin(pNode.skinName);
            }
        }
        else {
            if (!this.skinset)
                this.skinset = this.getAttribute("skinset");
            
            this.$loadSkin(null, this.$canLeechSkin);
        }
    }

    /**
     * Initializes the skin for this element when none has been set up.
     *
     * @param  {String}  skinName  required  Identifier for the new skin (for example: 'default:List' or 'win').
     * @param  {Boolean} [noError]
     */
    this.$loadSkin = function(skinName, noError){
        //this.skinName || //where should this go and why?
        this.baseSkin = skinName || (this.skinset 
            || this.$setInheritedAttribute("skinset")) 
            + ":" + (this.skin || this.localName);

        clearTimeout(this.$skinTimer);

        if (this.skinName) {
            this.$blur();
            this.$baseCSSname = null;
        }

        this.skinName = this.baseSkin; //Why??
        //this.skinset  = this.skinName.split(":")[0];

        this.$pNodes = {}; //reset the this.$pNodes collection
        this.$originalNodes = apf.skins.getTemplate(this.skinName, true);

        if (!this.$originalNodes) {
            var skin = this.skin;
            if (skin) {
                var skinset = this.skinName.split(":")[0];
                this.baseName = this.skinName = "default:" + skin;
                this.$originalNodes = apf.skins.getTemplate(this.skinName);
                
                if (!this.$originalNodes && skinset != "default") {
                    this.baseName = this.skinName = skinset + ":" + this.localName;
                    this.$originalNodes = apf.skins.getTemplate(this.skinName, true);
                }
            }
            
            if (!this.$originalNodes) {
                this.baseName = this.skinName = "default:" + this.localName;
                this.$originalNodes = apf.skins.getTemplate(this.skinName);
            }

            if (!this.$originalNodes) {
                if (noError) {
                    return (this.baseName = this.skinName = 
                        this.originalNode = null);
                }
                
                throw new Error(apf.formatErrorString(1077, this,
                    "Presentation",
                    "Could not load skin: " + this.baseSkin));
            }
            
            //this.skinset = this.skinName.split(":")[0];
        }

        if (this.$originalNodes)
            apf.skins.setSkinPaths(this.skinName, this);
    };

    this.$getNewContext = function(type, amlNode){
        
        if (type != type.toLowerCase()) {
            throw new Error("Invalid layout node name ('" + type + "'). lowercase required");
        }

        if (!this.$originalNodes[type]) {
            throw new Error(apf.formatErrorString(0, this,
                "Getting new skin item",
                "Missing node in skin description '" + type + "'"));
        }
        

        this.$pNodes[type] = this.$originalNodes[type].cloneNode(true);
    };

    this.$hasLayoutNode = function(type){
        
        if (type != type.toLowerCase()) {
            throw new Error("Invalid layout node name ('" + type + "'). lowercase required");
        }
        

        return this.$originalNodes[type] ? true : false;
    };

    this.$getLayoutNode = function(type, section, htmlNode){
        
        if (type != type.toLowerCase()) {
            throw new Error("Invalid layout node name ('" + type + "'). lowercase required");
        }
        if (!this.$pNodes) {
            throw new Error("Skin not loaded for :" + this.serialize(true));
        }
        

        var node = this.$pNodes[type] || this.$originalNodes[type];
        if (!node) {
            
            if (!this.$dcache)
                this.$dcache = {}

            if (!this.$dcache[type + "." + this.skinName]) {
                this.$dcache[type + "." + this.skinName] = true;
                apf.console.info("Could not find node '" + type
                                 + "' in '" + this.skinName + "'", "skin");
            }
            
            return false;
        }

        if (!section)
            return apf.getFirstElement(node);

        var textNode = node.selectSingleNode("@" + section);
        if (!textNode)
            return null;

        return (htmlNode
            ? apf.queryNode(textNode.nodeValue, htmlNode)
            : apf.getFirstElement(node).selectSingleNode(textNode.nodeValue));
    };

    this.$getOption = function(type, section){
        type = type.toLowerCase(); //HACK: lowercasing should be solved in the comps.

        //var node = this.$pNodes[type];
        var node = this.$pNodes[type] || this.$originalNodes[type];
        if (!section || !node)
            return node;//apf.getFirstElement(node);
        var option = node.selectSingleNode("@" + section);

        return option ? option.nodeValue : "";
    };

    this.$getExternal = function(tag, pNode, func, aml){
        if (!pNode)
            pNode = this.$pHtmlNode;
        if (!tag)
            tag = "main";
        //if (!aml)
            //aml = this.$aml;

        tag = tag.toLowerCase(); //HACK: make components case-insensitive

        this.$getNewContext(tag);
        var oExt = this.$getLayoutNode(tag);
        
        var node;
        if (node = (aml || this).getAttributeNode("style"))
            oExt.setAttribute("style", node.nodeValue);

        if (node = (aml || this).getAttributeNode("class"))
            this.$setStyleClass(oExt, (oldClass = node.nodeValue));

        if (func)
            func.call(this, oExt);

        oExt = apf.insertHtmlNode(oExt, pNode);
        oExt.host = this;
        if (node = (aml || this).getAttributeNode("bgimage"))
            oExt.style.backgroundImage = "url(" + apf.getAbsolutePath(
                this.mediaPath, node.nodeValue) + ")";

        if (!this.$baseCSSname)
            this.$baseCSSname = oExt.className.trim().split(" ")[0];

        //@todo what about setting this dynamic in an attribute???
        //@todo is another place for this more efficient?
        //@todo apf3.0 set this also for skin change
        this.minwidth   = apf.getCoord(parseInt(this.$getOption("main", "minwidth")), 5);
        this.minheight  = apf.getCoord(parseInt(this.$getOption("main", "minheight")), 5);
        this.maxwidth   = apf.getCoord(parseInt(this.$getOption("main", "maxwidth")), 10000);
        this.maxheight  = apf.getCoord(parseInt(this.$getOption("main", "maxheight")), 10000);

        

        return oExt;
    };

    /**** Focus ****/
    this.$focus = function(){
        if (!this.$ext)
            return;

        this.$setStyleClass(this.oFocus || this.$ext, this.$baseCSSname + "Focus");
    };

    this.$blur = function(){
        
        if (this.renaming)
            this.stopRename(null, true);
        

        if (!this.$ext)
            return;

        this.$setStyleClass(this.oFocus || this.$ext, "", [this.$baseCSSname + "Focus"]);
    };

    this.$fixScrollBug = function(){
        if (this.$int != this.$ext)
            this.oFocus = this.$int;
        else {
            this.oFocus =
            this.$int   =
                this.$ext.appendChild(document.createElement("div"));

            this.$int.style.height = "100%";
            this.$int.className = "focusbug"
        }
    };

    /**** Caching ****/
    /*
    this.$setClearMessage    = function(msg){};
    this.$updateClearMessage = function(){}
    this.$removeClearMessage = function(){};*/
}).call(apf.Presentation.prototype = new apf.GuiElement());

apf.config.$inheritProperties["skinset"] = 1;




/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/validation.js)SIZE(27480)TIME(1269561670)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */

apf.__VALIDATION__ = 1 << 6;



//if checkequal then notnull = true
apf.validator = {
    macro : {
        

        //var temp
        "pattern"     : "value.match(",
        "pattern_"    : ")",
        "custom"      : "(",
        "custom_"     : ")",
        "min"         : "parseInt(value) >= ",
        "max"         : "parseInt(value) <= ",
        "maxlength"   : "value.toString().length <= ",
        "minlength"   : "value.toString().length >= ",
        "notnull"     : "value.toString().length > 0",
        "checkequal"  : "!(temp = ",
        "checkequal_" : ").isValid() || temp.getValue() == value"
    },
    
    compile : function(options){
        var m = this.macro, s = ["var temp, valid = true; \
            if (!validityState) \
                validityState = new apf.validator.validityState(); "];

        if (options.required) {
            s.push("if (checkRequired && (!value || value.toString().trim().length == 0)) {\
                validityState.$reset();\
                validityState.valueMissing = true;\
                valid = false;\
            }")
        }
        
        s.push("validityState.$reset();\
            if (value) {");
        
        for (prop in options) {
            if (!m[prop]) continue;
            s.push("if (!(", m[prop], options[prop], m[prop + "_"] || "", ")){\
                validityState.$set('", prop, "');\
                valid = false;\
            }");
        }

        s.push("};validityState.valid = valid; return validityState;");
        return new Function('value', 'checkRequired', 'validityState', s.join(""));
    }
}

/**
 * Object containing information about the validation state. It contains
 * properties that specify whether a certain validation was passed.
 * Remarks:
 * This is part of {@link http://www.whatwg.org/specs/web-apps/current-work/multipage/forms.html#validitystatethe HTML 5 specification}.
 */
apf.validator.validityState = function(){
    this.valueMissing    = false,
    this.typeMismatch    = false,
    this.patternMismatch = false,
    this.tooLong         = false,
    this.rangeUnderflow  = false,
    this.rangeOverflow   = false,
    this.stepMismatch    = false,
    this.customError     = false,
    this.valid           = true,

    this.$reset = function(){
        for (var prop in this) {
            if (prop.substr(0,1) == "$") 
                continue;
            this[prop] = false;
        }
        this.valid = true;
    },

    this.$set = function(type) {
        switch (type) {
            case "min"         : this.rangeUnderflow  = true; break;
            case "max"         : this.rangeOverflow   = true; break;
            case "minlength"   : this.tooShort        = true; break;
            case "maxlength"   : this.tooLong         = true; break;
            case "pattern"     : this.patternMismatch = true; break;
            case "datatype"    : this.typeMismatch    = true; break;
            case "notnull"     : this.typeMismatch    = true; break;
            case "checkequal"  : this.typeMismatch    = true; break;
        }
    }
};

/**
 * All elements inheriting from this {@link term.baseclass baseclass} have validation support.
 * Example:
 * <code>
 *  <a:bar validgroup="vgExample">
 *      <a:label>Number</a:label>
 *      <a:textbox required="true" min="3" max="10" 
 *        invalidmsg="Invalid Entry;Please enter a number between 3 and 10" />
 *      <a:label>Name</a:label>
 *      <a:textbox required="true" minlength="3" 
 *        invalidmsg="Invalid Entry;Please enter your name" />
 *      <a:label>Message</a:label>
 *      <a:textarea required="true" 
 *        invalidmsg="Invalid Message;Please enter a message!" />
 *
 *      <a:button onclick="if(vgExample.isValid()) alert('valid!')">
 *          Validate
 *      </a:button>
 *  </a:bar>
 * </code>
 *
 * @event invalid    Fires when this component goes into an invalid state.
 *
 * @constructor
 * @baseclass
 * @author      Ruben Daniels (ruben AT ajax DOT org)
 * @version     %I%, %G%
 * @since       0.5
 */
apf.Validation = function(){
    this.$regbase = this.$regbase | apf.__VALIDATION__;

    /**
     * Checks if this element's value is valid.
     *
     * @param  {Boolean} [checkRequired] whether this check also adheres to the 'required' ruled.
     * @return  {Boolean} specifying whether the value is valid
     * @see  baseclass.validationgroup
     * @see  element.submitform
     */
    this.isValid = function(checkRequired){
        if (!this.$vOptions)
            return true;
        
        (this.$vOptions.isValid || (this.$vOptions.isValid
          = apf.validator.compile(this.$vOptions))).call(this,
            typeof this.getValue == "function" ? this.getValue(null, true) : null, 
            checkRequired, this.validityState || 
            (this.validityState = new apf.validator.validityState()));
        
        var valid = this.validityState.valid;
        
        
        
        if (!valid)
            this.dispatchEvent("invalid", this.validityState);
            
        return valid;
    };

    /**
     * @private
     */
    this.setCustomValidity = function(message){
        //do stuff
    }

    /**
     * @private
     * @todo This method should also scroll the element into view
     */
    this.showMe = function(){
        var p = this.parentNode;
        while (p) {
            if (p.show)
                p.show();
            p = p.parentNode;
        }
    };

    /**
     * Puts this element in the error state, optionally showing the
     * error box if this element's is invalid.
     *
     * @param  {Boolean} [ignoreReq]  whether this element required check is turned on.
     * @param  {Boolean} [nosetError] whether the error box is displayed if this component does not validate.
     * @param  {Boolean} [force]      whether this element in the error state and don't check if the element's value is invalid.
     * @return  {Boolean}  boolean specifying whether the value is valid
     * @see  object.validationgroup
     * @see  element.submitform
     * @method
     */
    
    
    /**
     * Puts this element in the error state, optionally showing the
     * error box if this element is invalid.
     *
     * @param  {Boolean} [ignoreReq]  whether this element required check is turned on.
     * @param  {Boolean} [nosetError] whether the error box is displayed if this component does not validate.
     * @param  {Boolean} [force]      whether this element in the error state and don't check if the element's value is invalid.
     * @return  {Boolean}  boolean specifying whether the value is valid
     * @see  object.validationgroup
     * @see  element.submitform
     * @method
     */
    this.validate = function(ignoreReq, nosetError, force){
        //if (!this.$validgroup) return this.isValid();

        if (force || !this.isValid(!ignoreReq) && !nosetError) {
            this.setError();
            return false;
        }
        else {
            this.clearError();
            return true;
        }
    };

    /**
     *    @private
     */
    this.setError = function(value){
        if (!this.$validgroup)
            this.$propHandlers["validgroup"].call(this, "vg" + this.parentNode.$uniqueId);

        var errBox = this.$validgroup.getErrorBox(this);

        if (!this.$validgroup.allowMultipleErrors)
            this.$validgroup.hideAllErrors();

        errBox.setMessage(this.invalidmsg);
        
        apf.setStyleClass(this.$ext, this.$baseCSSname + "Error");
        this.showMe(); //@todo scroll refHtml into view

        errBox.display(this);
        
        
        
        if (apf.document.activeElement && apf.document.activeElement != this)
            this.focus(null, {mouse:true}); //arguable...
    };

    /**
     *    @private
     */
    this.clearError = function(value){
        if (this.$setStyleClass)
            this.$setStyleClass(this.$ext, "", [this.$baseCSSname + "Error"]);

        if (this.$validgroup) {
            var errBox = this.$validgroup.getErrorBox(null, true);
            if (!errBox || errBox.host != this)
                return;

            errBox.hide();
        }
    };

    this.addEventListener("DOMNodeRemovedFromDocument", function(e){
        if (this.$validgroup)
            this.$validgroup.unregister(this);
    });

    /**
     *
     * @attribute  {Boolean}  required     whether a valid value for this element is required.
     * @attribute  {RegExp}   pattern      the pattern tested against the value of this element to determine it's validity.
     * @attribute  {String}   datatype     the datatype that the value of this element should adhere to. This can be any 
     * of a set of predefined types, or a simple type created by an XML Schema definition.
     *   Possible values:
     *   {String} xsd:dateTime
     *   {String} xsd:time
     *   {String} xsd:date
     *   {String} xsd:gYearMonth
     *   {String} xsd:gYear
     *   {String} xsd:gMonthDay
     *   {String} xsd:gDay
     *   {String} xsd:gMonth
     *   {String} xsd:string
     *   {String} xsd:boolean
     *   {String} xsd:base64Binary
     *   {String} xsd:hexBinary
     *   {String} xsd:float
     *   {String} xsd:decimal
     *   {String} xsd:double
     *   {String} xsd:anyURI
     *   {String} xsd:integer
     *   {String} xsd:nonPositiveInteger
     *   {String} xsd:negativeInteger
     *   {String} xsd:long
     *   {String} xsd:int
     *   {String} xsd:short
     *   {String} xsd:byte
     *   {String} xsd:nonNegativeInteger
     *   {String} xsd:unsignedLong
     *   {String} xsd:unsignedInt
     *   {String} xsd:unsignedShort
     *   {String} xsd:unsignedByte
     *   {String} xsd:positiveInteger
     *   {String} apf:url
     *   {String} apf:website
     *   {String} apf:email
     *   {String} apf:creditcard
     *   {String} apf:expdate
     *   {String} apf:wechars
     *   {String} apf:phonenumber
     *   {String} apf:faxnumber
     *   {String} apf:mobile
     * @attribute  {Integer}  min          the minimal value for which the value of this element is valid.
     * @attribute  {Integer}  max          the maximum value for which the value of this element is valid.
     * @attribute  {Integer}  minlength    the minimal length allowed for the value of this element.
     * @attribute  {Integer}  maxlength    the maximum length allowed for the value of this element.
     * @attribute  {Boolean}  notnull      whether the value is filled. Same as {@link baseclass.validation.attribute.required} but this rule is checked realtime when the element looses the focus, instead of at specific request (for instance when leaving a form page).
     * @attribute  {String}   checkequal   the id of the element to check if it has the same value as this element.
     * @attribute  {String}   invalidmsg   the message displayed when this element has an invalid value. Use a ; character to seperate the title from the message.
     * @attribute  {String}   validgroup   the identifier for a group of items to be validated at the same time. This identifier can be new. It is inherited from a AML node upwards.
     * @attribute  {String}   validtest    the instruction on how to test for success. This attribute is generally used to check the value on the server.
     * Example:
     * This example shows how to check the username on the server. In this case
     * comm.loginCheck is an async rpc function that checks the availability of the
     * username. If it exists it will return 0, otherwise 1. The value variable
     * contains the current value of the element (in this case the textbox). It
     * can be used as a convenience variable.
     * <pre class="code">
     *  <a:label>Username</a:label>
     *  <a:textbox
     *    validtest  = "{comm.loginCheck(value) == 1}"
     *    pattern    = "/^[a-zA-Z0-9_\-. ]{3,20}$/"
     *    invalidmsg = "Invalid username;Please enter a valid username." />
     * </pre>
     */
    this.addEventListener("DOMNodeInsertedIntoDocument", function(e){
        //this.addEventListener(this.hasFeature(apf.__MULTISELECT__) ? "onafterselect" : "onafterchange", onafterchange);
        /* Temp disabled, because I don't understand it (RLD)
        this.addEventListener("beforechange", function(){
            if (this.xmlRoot && apf.getBoundValue(this) === this.getValue())
                return false;
        });*/
        
        // validgroup
        if (!this.validgroup)
            this.$setInheritedAttribute("validgroup");
    });
    
    //1 = force no bind rule, 2 = force bind rule
    this.$attrExcludePropBind = apf.extend({
        pattern : 1,
        validtest : 3
    }, this.$attrExcludePropBind);

    this.$booleanProperties["required"] = true;
    this.$supportedProperties.push("validgroup", "required", "datatype",
        "pattern", "min", "max", "maxlength", "minlength", "validtest",
        "notnull", "checkequal", "invalidmsg", "requiredmsg");

    this.$fValidate = function(){
        if (this.contenteditable)
            return;
        
        if (!this.$validgroup)
            this.validate(true);
        else {
             var errBox = this.$validgroup.getErrorBox(this);
             if (!errBox.visible || errBox.host != this)
                this.validate(true);
        }
    };
    this.addEventListener("blur", this.$fValidate);
    
    this.$propHandlers["validgroup"] = function(value){
        if (value) {
            var vgroup;
            if (typeof value != "string") {
                this.$validgroup = value.name;
                vgroup = value;
            }
            else {
                vgroup = apf.nameserver.get("validgroup", value);
            }

            this.$validgroup = vgroup || new apf.ValidationGroup(value);
            this.$validgroup.register(this);
            /*
                @todo What about children, when created after start
                See button login action
            */
        }
        else {
            this.$validgroup.unregister(this);
            this.$validgroup = null;
        }
    };
    
    this.$propHandlers["pattern"]    = function(value, prop){
        if (value.substr(0, 1) != "/")
            value = "/" + value + "/";

        (this.$vOptions || (this.$vOptions = {}))[prop] = value;
        delete this.$vOptions.isValid;
    };
    
    
    this.$propHandlers["required"]   = 
    this.$propHandlers["custom"]     = 
    this.$propHandlers["min"]        = 
    this.$propHandlers["max"]        = 
    this.$propHandlers["maxlength"]  = 
    this.$propHandlers["minlength"]  = 
    this.$propHandlers["notnull"]    = 
    this.$propHandlers["checkequal"] = function(value, prop){
        (this.$vOptions || (this.$vOptions = {}))[prop] = value;
        delete this.$vOptions.isValid;
    };
    
    //@todo rewrite this for apf3.0
    this.$propHandlers["validtest"] = function(value){
        var _self = this, rvCache = {};
        /**
         * Removes the validation cache created by the validtest rule.
         */
        this.removeValidationCache = function(){
            rvCache = {};
        }
        
        this.$checkRemoteValidation = function(){
            var value = this.getValue();
            if(typeof rvCache[value] == "boolean") return rvCache[value];
            if(rvCache[value] == -1) return true;
            rvCache[value] = -1;

            apf.getData(this.validtest, {
               xmlNode : this.xmlRoot,
               value   : this.getValue(),
               callback : function(data, state, extra){
                  if (state != apf.SUCCESS) {
                      if (state == apf.TIMEOUT && extra.retries < apf.maxHttpRetries)
                          return extra.tpModule.retry(extra.id);
                      else {
                          var commError = new Error(apf.formatErrorString(0, _self, 
                            "Validating entry at remote source", 
                            "Communication error: \n\n" + extra.message));

                          if (_self.dispatchEvent("error", apf.extend({
                            error : commError, 
                            state : status
                          }, extra)) !== false)
                              throw commError;
                          return;
                      }
                  }

                  rvCache[value] = apf.isTrue(data);//instr[1] ? data == instr[1] : apf.isTrue(data);
                  
                  if(!rvCache[value]){
                    if (!_self.hasFocus())
                        _self.setError();
                  }
                  else _self.clearError();
              }
            });
            
            return true;
        };
        
        (this.$vOptions || (this.$vOptions = {})).custom = "apf.lookup(" + this.$uniqueId + ").$checkRemoteValidation()";
        delete this.$vOptions.isValid;
    };
};


apf.GuiElement.propHandlers["required"]   = 
apf.GuiElement.propHandlers["pattern"]    = 
apf.GuiElement.propHandlers["min"]        = 
apf.GuiElement.propHandlers["max"]        = 
apf.GuiElement.propHandlers["maxlength"]  = 
apf.GuiElement.propHandlers["minlength"]  = 
apf.GuiElement.propHandlers["notnull"]    = 
apf.GuiElement.propHandlers["checkequal"] = 
apf.GuiElement.propHandlers["validtest"]  = function(value, prop){
    this.implement(apf.Validation);
    this.$propHandlers[prop].call(this, value, prop);
}

/**
 * Object allowing for a set of AML elements to be validated, an element that 
 * is not valid shows the errorbox.
 * Example:
 * <code>
 *  <a:bar validgroup="vgForm">
 *      <a:label>Phone number</a:label>
 *      <a:textbox id="txtPhone"
 *        required   = "true"
 *        pattern    = "(\d{3}) \d{4} \d{4}"
 *        invalidmsg = "Incorrect phone number entered" />
 *
 *      <a:label>Password</a:label>
 *      <a:textbox
 *        required   = "true"
 *        mask       = "password"
 *        minlength  = "4"
 *        invalidmsg = "Please enter a password of at least four characters" />
 *  </a:bar>
 * </code>
 *
 * To check if the element has valid information entered, leaving the textbox
 * (focussing another element) will trigger a check. Programmatically a check
 * can be done using the following code:
 * <code>
 *  txtPhone.validate();
 *
 *  //Or use the html5 syntax
 *  txtPhone.checkValidity();
 * </code>
 *
 * To check for the entire group of elements use the validation group. For only
 * the first non-valid element the errorbox is shown. That element also receives
 * focus.
 * <code>
 *  vgForm.validate();
 * </code>
 *
 * @event validation Fires when the validation group isn't validated.
 *
 * @inherits apf.Class
 * @constructor
 * @default_private
 *
 * @author      Ruben Daniels (ruben AT ajax DOT org)
 * @version     %I%, %G%
 * @since       0.9
 */
apf.ValidationGroup = function(name){
    this.$init();
    
    this.childNodes = [];
    
    if (name)
        apf.setReference(name, this);
    
    this.name = name || "validgroup" + this.$uniqueId;
    apf.nameserver.register("validgroup", this.name, this);
};

(function(){
    /**
     * When set to true, only visible elements are validated. Default is false.
     * @type Boolean
     */
    this.validateVisibleOnly = false;
    
    /**
     * When set to true, validation doesn't stop at the first invalid element. Default is false.
     * @type Boolean
     */
    this.allowMultipleErrors = false;

    /**
     * Adds a aml element to this validation group.
     */
    this.register   = function(o){ 
        if (o.hasFeature(apf.__VALIDATION__)) 
            this.childNodes.push(o);
    };
    
    /**
     * Removes a aml element from this validation group.
     */
    this.unregister = function(o){
        this.childNodes.remove(o); 
    };

    /**
     * Returns a string representation of this object.
     */
    this.toString = function(){
        return "[APF Validation Group]";
    };

    //Shared among all validationgroups
    var errbox;
    /**
     * Retrieves {@link element.errorbox} used for a specified element.
     *
     * @param  {AmlNode}  o  required  AmlNode specifying the element for which the Errorbox should be found. If none is found, an Errorbox is created. Use the {@link object.validationgroup.property.allowMultipleErrors} to influence when Errorboxes are created.
     * @param  {Boolean}  no_create    Boolean that specifies whether new Errorbox may be created when it doesn't exist already
     * @return  {Errorbox}  the found or created Errorbox;
     */
    this.getErrorBox = function(o, no_create){
        if (this.allowMultipleErrors || !errbox && !no_create) {
            errbox            = new apf.errorbox();
            errbox.$pHtmlNode = o.$ext.parentNode;
            errbox.skinset    = apf.getInheritedAttribute(o.parentNode, "skinset"); //@todo use skinset here. Has to be set in presentation
            errbox.dispatchEvent("DOMNodeInsertedIntoDocument");
        }
        return errbox;
    };

    /**
     * Hide all Errorboxes for the elements using this element as their validation group.
     *
     */
    this.hideAllErrors = function(){
        if (errbox && errbox.host)
            errbox.host.clearError();
    };

    function checkValidChildren(oParent, ignoreReq, nosetError){
        var found;
        //Per Element
        for (var v, i = 0; i < oParent.childNodes.length; i++) {
            var oEl = oParent.childNodes[i];

            if (!oEl)
                continue;
            if (!oEl.disabled
              && (!this.validateVisibleOnly && oEl.visible || !oEl.$ext || oEl.$ext.offsetHeight)
              && (oEl.hasFeature(apf.__VALIDATION__) && oEl.isValid && !oEl.isValid(!ignoreReq))) {
                //|| !ignoreReq && oEl.required && (!(v = oEl.getValue()) || new String(v).trim().length == 0)
                
                if (!nosetError) {
                    if (!found) {
                        oEl.validate(true, null, true);
                        found = true;
                        if (!this.allowMultipleErrors)
                            return true; //Added (again)
                    }
                    else if (oEl.errBox && oEl.errBox.host == oEl)
                        oEl.errBox.hide();
                }
                else if (!this.allowMultipleErrors)
                    return true;
            }
            if (oEl.canHaveChildren && oEl.childNodes.length) {
                found = checkValidChildren.call(this, oEl, ignoreReq, nosetError) || found;
                if (found && !this.allowMultipleErrors)
                    return true; //Added (again)
            }
        }
        return found;
    }

    /**
     * Checks if (part of) the set of element's registered to this element are
     * valid. When an element is found with an invalid value the error state can
     * be set for that element.
     *
     * @param  {Boolean}    [ignoreReq]  whether to adhere to the 'required' check.
     * @param  {Boolean}    [nosetError  whether to not set the error state of the element with an invalid value
     * @param  {AMLElement} [page]           the page for which the children will be checked. When not specified all elements of this validation group will be checked.
     * @return  {Boolean}  specifying whether the checked elements are valid.
     * @method isValid, validate, checkValidity
     */
    
    
    /**
     * Checks if (part of) the set of element's registered to this element are
     * valid. When an element is found with an invalid value the error state can
     * be set for that element.
     *
     * @param  {Boolean}    [ignoreReq]  whether to adhere to the 'required' check.
     * @param  {Boolean}    [nosetError  whether to not set the error state of the element with an invalid value
     * @param  {AMLElement} [page]           the page for which the children will be checked. When not specified all elements of this validation group will be checked.
     * @return  {Boolean}  specifying whether the checked elements are valid.
     * @method isValid, validate, checkValidity
     */
    this.validate =
    
    /**
     * Checks if (part of) the set of element's registered to this element are
     * valid. When an element is found with an invalid value the error state can
     * be set for that element.
     *
     * @param  {Boolean}    [ignoreReq]  whether to adhere to the 'required' check.
     * @param  {Boolean}    [nosetError  whether to not set the error state of the element with an invalid value
     * @param  {AMLElement} [page]           the page for which the children will be checked. When not specified all elements of this validation group will be checked.
     * @return  {Boolean}  specifying whether the checked elements are valid.
     * @method isValid, validate, checkValidity
     */
    this.isValid = function(ignoreReq, nosetError, page){
        var found = checkValidChildren.call(this, page || this, ignoreReq,
            nosetError);

        if (page) {
            
            try {
            
                if (page.validation && !eval(page.validation)) {
                    alert(page.invalidmsg);
                    found = true;
                }
            
            }
            catch(e) {
                throw new Error(apf.formatErrorString(0, this,
                    "Validating Page",
                    "Error in javascript validation string of page: '"
                    + page.validation + "'", page.$aml));
            }
            
        }

        //Global Rules
        //
        //if (!found)
            //found = this.dispatchEvent("validation");

        return !found;
    };
}).call(apf.ValidationGroup.prototype = new apf.Class());

apf.config.$inheritProperties["validgroup"] = 1;




/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/databinding.js)SIZE(54384)TIME(1270838606)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */

apf.__DATABINDING__ = 1 << 1;



/**
 * Baseclass adding data binding features to this element. Databinding takes
 * care of automatically going from data to representation and establishing a
 * permanent link between the two. In this way data that is changed will
 * change the representation as well. Furthermore, actions that are executed on
 * the representation will change the underlying data.
 * Example:
 * <code>
 *  <a:list>
 *      <a:model>
 *          <data>
 *              <item icon="ajax_org.gif">Item 1</item>
 *              <item icon="ajax_org.gif">Item 2</item>
 *          </data>
 *      </a:model>
 *      <a:bindings>
 *          <a:icon match="[@icon]" />
 *          <a:caption match="[text()]" />
 *          <a:each match="[item]" />
 *      </a:bindings>
 *  </a:list>
 * </code>
 *
 * @event error             Fires when a communication error has occured while
 *                          making a request for this element.
 *   cancelable: Prevents the error from being thrown.
 *   bubbles:
 *   object:
 *   {Error}          error     the error object that is thrown when the event
 *                              callback doesn't return false.
 *   {Number}         state     the state of the call
 *     cancellable: Prevents the error from being thrown.
 *     Possible values:
 *     apf.SUCCESS  the request was successfull
 *     apf.TIMEOUT  the request has timed out.
 *     apf.ERROR    an error has occurred while making the request.
 *     apf.OFFLINE  the request was made while the application was offline.
 *   {mixed}          userdata  data that the caller wanted to be available in
 *                              the callback of the http request.
 *   {XMLHttpRequest} http      the object that executed the actual http request.
 *   {String}         url       the url that was requested.
 *   {Http}           tpModule  the teleport module that is making the request.
 *   {Number}         id        the id of the request.
 *   {String}         message   the error message.
 * @event beforeretrieve    Fires before a request is made to retrieve data.
 *   cancelable: Prevents the data from being retrieved.
 * @event afterretrieve     Fires when the request to retrieve data returns both
 *                          on success and failure.
 * @event receive           Fires when data is successfully retrieved
 *   object:
 *   {String} data  the retrieved data
 *
 * @constructor
 * @baseclass
 * @author      Ruben Daniels (ruben AT ajax DOT org)
 * @version     %I%, %G%
 * @since       0.4
 * @default_private
 */
apf.DataBinding = function(){
    this.$init(true);
    
    this.$loadqueue = 
    this.$dbTimer   = null;
    this.$regbase   = this.$regbase | apf.__DATABINDING__;
    this.$mainBind  = "value";
    
    this.$bindings     = 
    this.$cbindings    = 
    this.$attrBindings = false;

    //1 = force no bind rule, 2 = force bind rule
    this.$attrExcludePropBind = apf.extend({
        model     : 1,
        each      : 1
        //eachvalue : 1 //disabled because of line 1743 valueRule = in multiselect.js
    }, this.$attrExcludePropBind);

    /**** Public Methods ****/

    /**
     * Sets a value of an XMLNode based on an xpath statement executed on the data of this model.
     *
     * @param  {String}  xpath  the xpath used to select a XMLNode.
     * @param  {String}  value  the value to set.
     * @return  {XMLNode}  the changed XMLNode
     */
    this.setQueryValue = function(xpath, value, type){
        var node = apf.createNodeFromXpath(this[type || 'xmlRoot'], xpath);
        if (!node)
            return null;

        apf.setNodeValue(node, value, true);
        //apf.xmldb.setTextNode(node, value);
        return node;
    };

    /**
     * Queries the bound data for a string value
     *
     * @param {String} xpath  the xpath statement which queries on the data this element is bound on.
     * @param {String} type   the node that is used as the context node for the query.
     * Possible values:
     * selected     the selected data anode of this element.
     * xmlRoot      the root data node that this element is bound on.
     * indicator    the data node that is highlighted for keyboard navigation.
     * @return {String} value of the selected XML Node
     * @todo
     *  lstRev.query('revision/text()', 'selected');
     *  lstRev.query('revision/text()', 'xmlRoot');
     *  lstRev.query('revision/text()', 'indicator');
     */
    this.queryValue = function(xpath, type){
        return apf.queryValue(this[type || 'xmlRoot'], xpath );
    };
	/**
     * Queries the bound data for an array of string values
     *
     * @param {String} xpath the xpath statement which queries on the data this element is bound on.
     * @param {String} type   the node that is used as the context node for the query.
     * Possible values:
     * selected     the selected data anode of this element.
     * xmlRoot      the root data node that this element is bound on.
     * indicator    the data node that is highlighted for keyboard navigation.
     * @return {String} value of the selected XML Node
     */
    this.queryValues = function(xpath, type){
        return apf.queryValues(this[type || 'xmlRoot'], xpath );
    };
	
    /**
     * Executes an xpath statement on the data of this model
     *
     * @param  {String}   xpath    the xpath used to select the XMLNode(s).
     * @param {String} type   the node that is used as the context node for the query.
     * Possible values:
     * selected     the selected data anode of this element.
     * xmlRoot      the root data node that this element is bound on.
     * indicator    the data node that is highlighted for keyboard navigation.
     * @return  {variant}  XMLNode or NodeList with the result of the selection
     */
    this.queryNode = function(xpath, type){
        var n = this[type||'xmlRoot'];
		return n ? n.selectSingleNode(xpath) : null;
    };

    /**
     * Executes an xpath statement on the data of this model
     *
     * @param  {String}   xpath    the xpath used to select the XMLNode(s).
     * @param {String} type   the node that is used as the context node for the query.
     * Possible values:
     * selected     the selected data anode of this element.
     * xmlRoot      the root data node that this element is bound on.
     * indicator    the data node that is highlighted for keyboard navigation.
     * @return  {variant}  XMLNode or NodeList with the result of the selection
     */
    this.queryNodes = function(xpath, type){
        var n = this[type||'xmlRoot'];
		return n ? n.selectNodes(xpath) : [];
    };
	
    this.$checkLoadQueue = function(){
        // Load from queued load request
        if (this.$loadqueue) {
            this.xmlRoot = null;
            var q = this.load(this.$loadqueue[0], {cacheId: this.$loadqueue[1]});
            if (!q || q.dataType != apf.ARRAY || q != this.$loadqueue)
                this.$loadqueue = null;
        }
    };
    
    //setProp
    this.$execProperty = function(prop, xmlNode){
        var attr = this.$attrBindings[prop];
        
        
        
        
            if (attr.cvalue.asyncs) { //if async
                var _self = this;
                return attr.cvalue.call(this, xmlNode, function(value){
                    _self.setProperty(prop, value, true);
                    
                    
                
                }); 
            }
            else {
                var value = attr.cvalue.call(this, xmlNode);
            }
        
        
        this.setProperty(prop, value, true);
        
        
    };
    
    //@todo apf3.0 contentEditable support
    this.$applyBindRule = function(name, xmlNode, defaultValue, callback){
        var handler = this.$attrBindings[name] 
          && this.$attrBindings[name].cvalue || this.$cbindings[name];

        return handler ? handler.call(this, xmlNode, callback) : defaultValue || "";
    };
    
    this.$hasBindRule = function(name){
        return this.$attrBindings[name] || this.$bindings 
          && this.$bindings[name];
    };
    
    this.$getBindRule = function(name, xmlNode){
        return this.$attrBindings[name] || this.$bindings 
          && this.$bindings.getRule(name, xmlNode);
    };
    
    var ruleIsMatch = {"drag":1,"drop":1,"dragcopy":1}
    this.$getDataNode = function(name, xmlNode, createNode, ruleList, multiple){
        var node, rule = this.$attrBindings[name];
        if (rule) { //@todo apf3.0 find out why drag and drop rules are already compiled here
            if (rule.cvalue.type != 3) //@todo warn here?
                return false;
            
            var func = rule.cvalue2 || rule.compile("value", {
                xpathmode  : multiple ? 4 : 3,
                parsecode  : 1,
                injectself : ruleIsMatch[name]
            });
            if (func && (node = func(xmlNode, createNode))) {
                if (ruleList)
                    ruleList.push(rule);

                return node;
            }
            
            return false;
        }
        
        return this.$bindings 
           && this.$bindings.getDataNode(name, xmlNode, createNode, ruleList, multiple);
    };
    
    /**
     * Sets the model of the specified element
     *
     * @param  {Model}  The model this element is going to connect to.
     * 
     */
    
    this.setModel = function(model){
        this.setAttribute("model", model, false, true);
    };
    
    
    /**
     * Gets the model to which this element is connected.
     * This is the model which acts as a datasource for this element.
     *
     * @param {Boolean} doRecur whether the model should be searched recursively up the data tree.
     * @returns  {Model}  The model this element is connected to.
     * @see  element.smartbinding
     */
    this.getModel = function(doRecur){
        if (doRecur && !this.$model)
            return this.dataParent ? this.dataParent.parent.getModel(true) : null;

        return this.$model;
    };
    
    /**
     * Reloads the data in this element.
     *
     */
    this.reload = this.reload || function(){
        this.load(this.xmlRoot, {cacheId: this.cacheId, force: true});
    };
    
    /**
     * Loads data in to this element using binding rules to transform the
     * data in to a presentation.
     * Example:
     * <code>
     *  <a:list id="lstExample">
     *      <a:bindings>
     *          <a:caption match="[text()]" />
     *          <a:icon match="[@icon]" />
     *          <a:each match="[image]" />
     *      </a:bindings>
     *  </a:list>
     *  
     *  <a:script><!--
     *      apf.onload = function() {
     *      lstExample.load('<images>\
     *          <image icon="icoTest.gif">image 1</image>\
     *          <image icon="icoTest.gif">image 2</image>\
     *          <image icon="icoTest.gif">image 3</image>\
     *          </images>');
     *      }
     *  --></a:script>
     * </code>
     *
     * @param {mixed}  [xmlNode]
     *   Possible Values:
     *   {XMLElement}  an xml element loaded in to this element.
     *   {String}      an xml string which is loaded in this element.
     *   {String}      an instruction to load data from a remote source.
     *   {Null}        null clears this element from it's data {@link baseclass.cache.method.clear}.
     * @param {Object} [options]
     *   Properties:
     *   {XMLElement} [xmlNode]    the {@link term.datanode data node} that provides
     *                             context to the data instruction.
     *   {Function}   [callback]   the code executed when the data request returns.
     *   {mixed}      []           Custom properties available in the data instruction.
     *   {String}     [cacheId]    the xml element to which the binding rules are applied.
     *   {Boolean}    [force]      whether cache is checked before loading the data.
     *   {Boolean}    [noClearMsg] wether a message is set when clear is called.
     *
     * @event beforeload  Fires before loading data in this element.
     *   cancelable: Prevents the data from being loaded.
     *   object:
     *   {XMLElement} xmlNode the node that is loaded as the root {@link term.datanode data node}.
     * @event afterload   Fires after loading data in this element.
     *   object:
     *   {XMLElement} xmlNode the node that is loaded as the root {@link term.datanode data node}.
     * @see  element.smartbinding
     * @see  baseclass.cache.method.clear
     */
    this.load = function(xmlNode, options){
        if (options) {
            var cacheId      = options.cacheId,
                forceNoCache = options.force,
                noClearMsg   = options.noClearMsg;
        }

        if (cacheId && cacheId == this.cacheId && !forceNoCache)
            return;

        
        if (apf.popup.isShowing(this.$uniqueId))
            apf.popup.forceHide(); //This should be put in a more general position
        

        // Convert first argument to an xmlNode we can use;
        if (xmlNode) {
            if (typeof xmlNode == "string") {
                if (xmlNode.charAt(0) == "<")
                    xmlNode = apf.getXmlDom(xmlNode).documentElement;
                else {
                    return apf.model.prototype.$loadFrom.call(this, xmlNode, options);
                }
            }
            else if (xmlNode.nodeType == 9) {
                xmlNode = xmlNode.documentElement;
            }
            else if (xmlNode.nodeType == 3 || xmlNode.nodeType == 4) {
                xmlNode = xmlNode.parentNode;
            }
            else if (xmlNode.nodeType == 2) {
                xmlNode = xmlNode.ownerElement 
                    || xmlNode.parentNode 
                    || xmlNode.selectSingleNode("..");
            }
        }

        // If control hasn't loaded databinding yet, queue the call
        if (this.$preventDataLoad || !this.$canLoadData 
          && ((!this.$bindings && !this.$canLoadDataAttr) || !this.$amlLoaded) 
          && (!this.hasFeature(apf.__MULTISELECT__) || !(this.each || this.$template)) 
          || this.$canLoadData && !this.$canLoadData()) {
            this.xmlRoot = xmlNode;
            
            
            if (this.$amlLoaded && !this.$attrBindings) {
                apf.console.warn("Could not load data yet in " + (this.localName
                  ? this.localName + "[" + (this.name || "") + "]"
                  : this.nodeName) + ". The loaded data is queued "
                      + "until smartbinding rules are loaded or set manually.");
            }
            

            return this.$loadqueue = [xmlNode, cacheId];
        }

        // If no xmlNode is given we clear the control, disable it and return
        if (this.dataParent && this.dataParent.xpath)
            this.dataParent.parent.signalXmlUpdate[this.$uniqueId] = !xmlNode;

        if (!xmlNode && (!cacheId || !this.$isCached || !this.$isCached(cacheId))) {
            
            apf.console.warn("No xml root node was given to load in "
                + this.localName + "[" + (this.name || '') + "]. Clearing any "
                + "loaded xml in this component");
            

            this.clear(noClearMsg);

            
            if (apf.config.autoDisable && this.$createModel === false)
                this.setProperty("disabled", true);

            //@todo apf3.0 remove , true in clear above
            //this.setProperty("selected", null);
            
            return;
        }

        var disabled = this.disabled;
        this.disabled = false;

        //Run onload event
        if (this.dispatchEvent("beforeload", {xmlNode : xmlNode}) === false)
            return false;

        
        apf.console.info("Loading XML data in "
          + (this.localName 
            ? this.localName + "[" + (this.name || '') + "]"
            : this.nodeName));
        

        // If reloading current document, and caching is disabled, exit
        if (this.caching && !forceNoCache && xmlNode && xmlNode == this.xmlRoot)
            return;

        this.clear(true, true);

        this.cacheId = cacheId;

        if (this.dispatchEvent("$load", {
          forceNoCache : forceNoCache, 
          xmlNode  : xmlNode
        }) === false) {
            delete this.cacheId;
            return;
        }
        
        //Set usefull vars
        this.documentId = apf.xmldb.getXmlDocId(xmlNode);
        this.xmlRoot    = xmlNode;
        
        
        this.setProperty("root", this.xmlRoot);
        

        

        // Draw Content
        this.$load(xmlNode);
        
        

        // Check if subtree should be loaded
        this.$loadSubData(xmlNode);

        if (this.$createModel === false) {
            this.disabled = true;
            this.setProperty("disabled", false);
        }
        else
            this.disabled = disabled;

        // Run onafteronload event
        this.dispatchEvent('afterload', {xmlNode : xmlNode});
    };
    
    /**
     * @binding load Determines how new data is loaded data is loaded into this
     * element. Usually this is only the root node containing no children.
     * Example:
     * This example shows a load rule in a text element. It gets its data from
     * a list. When a selection is made on the list the data is loaded into the
     * text element.
     * <code>
     *  <a:list id="lstExample" width="200" height="200">
     *      <a:bindings>
     *          <a:caption match="[text()]" />
     *          <a:value match="[text()]" />
     *          <a:each match="[message]" />
     *      </a:bindings>
     *      <a:model>
     *          <messages>
     *              <message id="1">message 1</message>
     *              <message id="2">message 2</message>
     *          </messages>
     *      </a:model>
     *  </a:list>
     * 
     *  <a:text model="{lstExample.selected}" width="200" height="150">
     *      <a:bindings>
     *          <a:load get="http://localhost/getMessage.php?id=[@id]" />
     *          <a:contents match="[message/text()]" />
     *      </a:bindings>
     *  </a:text>
     * </code>
     * @attribute {string} get the {@link term.datainstruction data instruction}
     *                     that is used to load data into the xmlRoot of this component.
     */
    this.$loadSubData = function(xmlRootNode){
        if (this.$hasLoadStatus(xmlRootNode)) return;

        //var loadNode = this.$applyBindRule("load", xmlRootNode);
        var loadNode, rule = this.$getBindRule("load", xmlRootNode);
        if (rule && (!rule[1] || rule[1](xmlRootNode))) {
            
            
            this.$setLoadStatus(xmlRootNode, "loading");

            if (this.$setClearMessage)
                this.$setClearMessage(this["loading-message"], "loading");

            //||apf.xmldb.findModel(xmlRootNode)
            var mdl = this.getModel(true);
            
            if (!mdl)
                throw new Error("Could not find model");
            

            var amlNode = this;
            if (mdl.$insertFrom(rule.getAttribute("get"), {
              xmlNode     : loadNode,  //@todo apf3.0
              insertPoint : xmlRootNode, //this.xmlRoot,
              amlNode     : this,
              callback    : function(){
                    
                    amlNode.setProperty(amlNode.hasFeature(apf.__MULTISELECT__) 
                        ? "selected" 
                        : "root", xmlRootNode);
                    
                }
              }) === false
            ) {
                this.clear(true);
                
                if (apf.config.autoDisable)
                    this.setProperty("disabled", true);

                //amlNode.setProperty("selected", null); //@todo is this not already done in clear?
                
            }
        }
    };
    
    /**
     * Unloads data from this element and resets state displaying an empty message.
     * Empty message is set on the {@link baseclass.guielement.property.msg}.
     *
     * @param {Boolean} [nomsg]   whether to display the empty message.
     * @param {Boolean} [doEvent] whether to sent select events.
     * @see baseclass.databinding.method.load
     * @private
     */
    //@todo this function is call way too much for a single load of a tree
    //@todo should clear listener
    this.clear = function(nomsg, doEvent, fakeClear){
        if (!this.$container)
            return;//@todo apf3.0

        if (this.clearSelection)
            this.clearSelection(true);//!doEvent);//@todo move this to the $clear event in multiselect.js

        var lastHeight = this.$container.offsetHeight;

        if (this.dispatchEvent("$clear") !== false)
            this.$container.innerHTML = ""; //@todo apf3.0

        if (typeof nomsg == "string") {
            var msgType = nomsg;
            nomsg = false;
            
            //@todo apf3.0 please use attr. inheritance
            if (!this[msgType + "-message"]) {
                this.$setInheritedAttribute(msgType + "-message");
            }
        }
        this.$lastClearType = msgType || null;

        if (!nomsg && this.$setClearMessage) {
            this.$setClearMessage(msgType 
              ? this[msgType + "-message"] 
              : this["empty-message"], msgType || "empty", lastHeight);

            //this.setProperty("selected", null); //@todo apf3.0 get the children to show loading... as well (and for each selected, null
            //c[i].o.clear(msgType, doEvent);
        }
        else if(this.$removeClearMessage)
            this.$removeClearMessage();

        if (!fakeClear)
            this.documentId = this.xmlRoot = this.cacheId = null;

        
        if (!nomsg) {
            if (this.hasFeature(apf.__MULTISELECT__)) //@todo this is all wrong
                this.setProperty("length", 0);
            //else 
                //this.setProperty("value", ""); //@todo redo apf3.0
        }
        
    };
    
    this.clearMessage = function(msg){
        this.customMsg = msg;
        this.clear("custom");
    };

    /**
     * @private
     */
    this.$setLoadStatus = function(xmlNode, state, remove){
        //remove old status if any
        var ostatus = xmlNode.getAttribute("a_loaded");
        ostatus = ostatus
            ? ostatus.replace(new RegExp("\\|\\w+\\:" + this.$uniqueId + "\\|", "g"), "")
            : "";

        if (!remove)
            ostatus += "|" + state + ":" + this.$uniqueId + "|";

        xmlNode.setAttribute("a_loaded", ostatus);
    };

    /**
     * @private
     */
    this.$removeLoadStatus = function(xmlNode){
        this.$setLoadStatus(xmlNode, null, true);
    };

    /**
     * @private
     */
    this.$hasLoadStatus = function(xmlNode, state){
        var ostatus = xmlNode.getAttribute("a_loaded");
        if (!ostatus) return false;

        return (ostatus.indexOf((state || "") + ":" + this.$uniqueId + "|") != -1)
    };

    /**
     * @event beforeinsert Fires before data is inserted.
     *   cancelable: Prevents the data from being inserted.
     *   object:
     *   {XMLElement} xmlParentNode the parent in which the new data is inserted
     * @event afterinsert Fires after data is inserted.
     */

    /**
     * @private
     */
    this.insert = function(xmlNode, options){
        if (typeof xmlNode == "string") {
            if (xmlNode.charAt(0) == "<") {
                xmlNode = apf.getXmlDom(xmlNode).documentElement;
            }
            else {
                if (!options.insertPoint)
                    options.insertPoint = this.xmlRoot;
                return apf.model.prototype.$insertFrom.call(this, xmlNode, options);
            }
        }
        
        var insertPoint = options.insertPoint || this.xmlRoot;

        if (this.dispatchEvent("beforeinsert", {
          xmlParentNode : insertPoint
        }) === false)
            return false;

        //Integrate XMLTree with parentNode
        if (typeof options.copyAttributes == "undefined")
            options.copyAttributes = true;
            
        var newNode = apf.mergeXml(xmlNode, insertPoint, options);

        //Call __XMLUpdate on all listeners
        apf.xmldb.applyChanges("insert", insertPoint);

        //Select or propagate new data
        if (this.selectable && this.autoselect) {
            if (this.xmlNode == newNode)
                this.$selectDefault(this.xmlNode);
        }
        
        else if (this.xmlNode == newNode) {
            this.setProperty("root", this.xmlNode);
        }
        

        if (this.$hasLoadStatus(insertPoint, "loading"))
            this.$setLoadStatus(insertPoint, "loaded");

        this.dispatchEvent("afterinsert");

        //Check Connections
        //this one shouldn't be called because they are listeners anyway...(else they will load twice)
        //if(this.selected) this.setConnections(this.selected, "select");
    };
    
    /**
     * @attribute {Boolean} render-root whether the xml element loaded into this
     * element is rendered as well. Default is false.
     * Example:
     * This example shows a tree which also renders the root element.
     * <code>
     *  <a:tree render-root="true">
     *      <a:model>
     *          <root name="My Computer">
     *              <drive name="C">
     *                  <folder name="/Program Files" />
     *                  <folder name="/Desktop" />
     *              </drive>
     *          </root>
     *      </a:model>
     *      <a:bindings>
     *          <a:caption match="[@name]"></a:caption>
     *          <a:each match="[root|drive|folder]"></a:each>
     *      </a:bindings>
     *  </a:tree>
     * </code>
     */
    this.$booleanProperties["render-root"] = true;
    this.$supportedProperties.push("empty-message", "loading-message",
        "offline-message", "render-root", "smartbinding",
        "bindings", "actions");

    /**
     * @attribute {Boolean} render-root wether the root node of the data loaded
     * into this element is rendered as well. 
     * @see element.tree
     */
    this.$propHandlers["render-root"] = function(value){
        this.renderRoot = value;
    };
    
    /**
     * @attribute {String} empty-message the message displayed by this element
     * when it contains no data. This property is inherited from parent nodes.
     * When none is found it is looked for on the appsettings element. Otherwise
     * it defaults to the string "No items".
     */
    this.$propHandlers["empty-message"] = function(value){
        this["empty-message"] = value;

        if (this.$updateClearMessage) 
            this.$updateClearMessage(this["empty-message"], "empty");
    };

    /**
     * @attribute {String} loading-message  the message displayed by this
     * element when it's loading. This property is inherited from parent nodes.
     * When none is found it is looked for on the appsettings element. Otherwise
     * it defaults to the string "Loading...".
     * Example:
     * This example uses property binding to update the loading message. The
     * position of the progressbar should be updated by the script taking care
     * of loading the data.
     * <code>
     *  <a:list loading-message="{'Loading ' + Math.round(progress1.value*100) + '%'}" />
     *  <a:progressbar id="progress1" />
     * </code>
     * Remarks:
     * Usually a static loading message is displayed for only 100 milliseconds
     * or so, whilst loading the data from the server. This is done for instance
     * when the load binding rule is used. In the code example below a list
     * binds on the selection of a tree displaying folders. When the selection
     * changes, the list loads new data by extending the model. During the load
     * of this new data the loading message is displayed.
     * <code>
     *  <a:list model="[trFolders::element]">
     *      <a:bindings>
     *          ...
     *          <a:load get="{comm.getFiles([@path])}" />
     *      </bindings>
     *  </a:list>
     * </code>
     */
    this.$propHandlers["loading-message"] = function(value){
        this["loading-message"] = value;

        if (this.$updateClearMessage)
            this.$updateClearMessage(this["loading-message"], "loading");
    };

    /**
     * @attribute {String} offline-message  the message displayed by this
     * element when it can't load data because the application is offline.
     * This property is inherited from parent nodes. When none is found it is
     * looked for on the appsettings element. Otherwise it defaults to the
     * string "You are currently offline...".
     */
    this.$propHandlers["offline-message"] = function(value){
        this["offline-message"] = value;

        if (this.$updateClearMessage)
            this.$updateClearMessage(this["offline-message"], "offline");
    };

    /**
     * @attribute {String} smartbinding  the name of the SmartBinding for this
     * element. A smartbinding is a collection of rules which define how data
     * is transformed into representation, how actions on the representation are
     * propagated to the data and it's original source, how drag&drop actions
     * change the data and where the data is loaded from. Each of these are
     * optionally defined in the smartbinding set and can exist independently
     * of the smartbinding object.
     * Example:
     * This example shows a fully specified smartbinding. Usually only parts
     * are used. This example shows a tree with files and folders.
     * <code>
     *  <a:tree smartbinding="sbExample" />
     * 
     *  <a:smartbinding id="sbExample">
     *      <a:bindings>
     *          <a:caption  match  = "[@caption|@filename]"/>
     *          <a:icon     match  = "[file]"
     *                      value  = "icoFile.gif" />
     *          <a:icon     value  = "icoFolder.gif" />
     *          <a:each     match  = "[file|folder|drive]" />
     *          <a:drag     match  = "[folder|file]" />
     *          <a:drop     match  = "[folder]" 
     *                      target = "[root]"
     *                      action = "tree-append" />
     *          <a:drop     match  = "[folder]" 
     *                      target = "[folder]"
     *                      action = "insert-before" />
     *          <a:drop     match  = "[file]"   
     *                      target = "[folder|root]" 
     *                      action = "tree-append" />
     *          <a:drop     match  = "[file]"   
     *                      target = "[file]"
     *                      action = "insert-before" />
     *      </a:bindings>
     *      <a:actions>
     *          <a:remove set = "remove.php?path=[@path]" />
     *          <a:rename set = "move.php?from=oldValue&amp;to=[@path]" />
     *      </a:actions>
     *      <a:model src="xml/filesystem.xml" />
     *  </a:smartbinding>
     * </code>
     * Remarks:
     * The smartbinding parts can also be assigned to an element by adding them
     * directly as a child in aml.
     * <code>
     *  <a:tree>
     *      <a:bindings>
     *          ...
     *      </bindings>
     *      <a:model />
     *  </a:tree>
     * </code>
     *
     * See:
     * There are several ways to be less verbose in assigning certain rules.
     * <ul>
     *  <li>{@link baseclass.multiselectbinding.binding.each}</li>
     *  <li>{@link baseclass.dragdrop.attribute.drag}</li>
     *  <li>{@link element.bindings}</li>
     *  <li>{@link element.actions}</li>
     *  <li>{@link element.dragdrop}</li>
     * </ul>
     */
    this.$propHandlers["smartbinding"] = 
    
    /**
     * @attribute {String} actions the id of the actions element which
     * provides the action rules for this element. Action rules are used to
     * send changes on the bound data to a server.
     * Example:
     * <code>
     *  <a:tree 
     *    id             = "tree" 
     *    height         = "200" 
     *    width          = "250" 
     *    actions       = "actExample"
     *    model          = "xml/filesystem.xml"
     *    actiontracker  = "atExample"
     *    startcollapsed = "false" 
     *    onerror        = "alert('Sorry this action is not permitted');return false">
     *      <a:each match="[folder|drive]">
     *          <a:caption match="[@caption|@filename]" />
     *          <a:icon value="Famfolder.gif" />
     *      </a:each>
     *  </a:tree>
     *  
     *  <a:actions id="actExample">
     *      <a:rename match = "[file]"   
     *               set    = "rename_folder.php?id=[@fid]" />
     *      <a:rename match = "[folder]" 
     *               set    = "rename_file.php?id=[@fid]" />
     *  </a:actions>
     *  
     *  <a:button 
     *    caption = "Rename"
     *    right   = "10" 
     *    top     = "10"
     *    onclick = "tree.startRename()" />
     *  <a:button onclick="tree.getActionTracker().undo();">Undo</a:button>
     * </code>
     */
    this.$propHandlers["actions"] = 

    /**
     * @attribute {String} bindings the id of the bindings element which
     * provides the binding rules for this element.
     * Example:
     * This example shows a set of binding rules that transform data into the
     * representation of a list. In this case it displays the names of
     * several email accounts, with after each account name the number of unread
     * mails in that account. It uses JSLT to transform the caption.
     * <code>
     *  <a:model id="mdlExample">
     *      <data>
     *          <account icon="application.png">Account 1
     *              <mail read="false" />
     *              <mail read="false" />
     *              <mail read="true" />
     *          </account>
     *          <account icon="application.png">Account 2</account>
     *      </data>
     *  </a:model>
     *  <a:list bindings="bndExample" model="mdlExample" />
     * 
     *   <a:bindings id="bndExample">
     *      <a:caption>[text()] (#[mail[@read != 'true']])</a:caption>
     *      <a:icon match="[@icon]" />
     *      <a:each match="[account]" sort="[text()]" />
     *  </a:bindings>
     * </code>
     * Remarks:
     * Bindings can also be assigned directly by putting the bindings tag as a
     * child of this element.
     *
     * If the rule only contains a select attribute, it can be written in a
     * short way by adding an attribute with the name of the rule to the
     * element itself:
     * <code>
     *  <a:list 
     *    caption = "[text()] (#[mail[@read != 'true']])"
     *    icon    = "[@icon]"
     *    each    = "[account]"
     *    sort    = "[text()]" />
     * </code>
     */
    this.$propHandlers["bindings"] = function(value, prop){
        var local = "$" + prop;
        if (this[local])
            this[local].unregister(this);
        
        if (!value)
            return;

        
        if (!apf.nameserver.get(prop, value))
            throw new Error(apf.formatErrorString(1064, this,
                "Setting " + prop,
                "Could not find " + prop + " by name '" + value + "'"));
        

        apf.nameserver.get(prop, value).register(this);
        
        if (prop != "actions")
            this.$checkLoadQueue();
    };

    
    var eachBinds = {"caption":1, "icon":1, "select":1, "css":1, "sort":1,
                     "drop":2, "drag":2, "dragcopy":2, "eachvalue":1}; //Similar to apf.Class
    
    this.$addAttrBind = function(prop, fParsed, expression) {
        //Detect if it uses an external model
        if (fParsed.models) {
            
            if (this.hasFeature(apf.__MULTISELECT__)) {
                
                if (eachBinds[prop]) {
                    throw new Error("Cannot use external model inside " + prop + " rule"); //@todo apf3.0 convert to apf error
                }
                
            }
            
        }

        //Set listener for all models
        var i, xpath, modelId, model,
            paths = fParsed.xpaths,
            list  = {};
        for (i = 0; i < paths.length; i+=2) {
            if (!list[(modelId = paths[i])])
                list[modelId] = 1;
            else list[modelId]++
        }
        
        if (!this.$propsUsingMainModel)
            this.$propsUsingMainModel = {};

        var rule = (this.$attrBindings || (this.$attrBindings = {}))[prop] = {
            cvalue  : fParsed,
            value   : expression,
            compile : apf.BindingRule.prototype.$compile,
            models  : []
        };

        delete this.$propsUsingMainModel[prop];
        for (xpath, i = 0; i < paths.length; i+=2) {
            modelId = paths[i];
            if (list[modelId] == -1)
                continue;

            xpath = paths[i + 1];

            if (modelId == "#" || xpath == "#") {
                var m = (rule.cvalue3 || (rule.cvalue3 = apf.lm.compile(rule.value, {
                    xpathmode: 5
                })))(this.xmlRoot);
                
                //@todo apf3 this needs to be fixed in live markup
                if (typeof m != "string") {
                    model = m.model && m.model.$isModel && m.model;
                    if (model)
                        xpath = m.xpath;
                    else if (m.model) {
                        model = apf.xmldb.findModel(m.model);
                        xpath = apf.xmlToXpath(m.model, model.data) + (m.xpath ? "/" + m.xpath : ""); //@todo make this better
                    }
                    else {
                        //wait until model becomes available
                        this.addEventListener("prop." + prop, function(e){
                            var m = (rule.cvalue3 || (rule.cvalue3 = apf.lm.compile(rule.value, {
                                xpathmode: 5
                            })))(this.xmlRoot);
                            
                            if (m.model) {
                                this.removeEventListener("prop." + prop, arguments.callee);
                                var _self = this;
                                setTimeout(function(){
                                    _self.$clearDynamicProperty(prop);
                                    _self.$setDynamicProperty(prop, expression);
                                }, 10);
                            }
                        });
                        continue;
                    }
                }
                else model = null;
            }
            else model = null;

            if (!model) {
                if (modelId) {
                    //@todo apf3.0 how is this cleaned up???
                    //Add change listener to the data of the model
                    model = apf.nameserver.get("model", modelId) //is model creation useful here?
                        || apf.setReference(modelId, apf.nameserver.register("model", modelId, new apf.model()));
                }
                else {
                    if (!this.$model && !this.$initingModel)
                        initModel.call(this);
    
                    model = this.$model;

                    if (!this.hasFeature(apf.__MULTISELECT__) 
                      && eachBinds[prop] != 2 || !eachBinds[prop]) //@experimental - should not set this because model will load these attributes
                        this.$propsUsingMainModel[prop] = {
                            xpath    : xpath,
                            optimize : list[modelId] == 1
                        };
                }
            }
            
            //@todo warn here if no model??
            if (model && (!this.hasFeature(apf.__MULTISELECT__) 
              && eachBinds[prop] != 2 || !eachBinds[prop])) {
                //Create the attribute binding
                model.$bindXmlProperty(this, prop, xpath, list[modelId] == 1, expression.indexOf("*[") > -1);
                rule.models.push(model);
            }
            
            list[modelId] = -1;
        }
        
        rule.xpath = xpath;

        this.$canLoadDataAttr = eachBinds[prop] == 1; //@todo apf3.0 remove
        this.$checkLoadQueue();
    }
    
    this.$removeAttrBind = function(prop){
        //@todo apf3.0
        //$model.$unbindXmlProperty
        var rule = this.$attrBindings[prop]
        if (!rule)
            return;
        
        delete this.$attrBindings[prop];
        
        var models = rule.models;
        for (var i = 0; i < models.length; i++) {
            models[i].$unbindXmlProperty(this, prop);
        }
    };
    
    this.$initingModel;
    function initModel(){
        this.$initingModel = true;
        this.$setInheritedAttribute("model");
    }
    
    this.addEventListener("DOMNodeInsertedIntoDocument", function(e){
        //Set empty message if there is no data
        if (!this.model && this.$setClearMessage && !this.value)
            this.$setClearMessage(this["empty-message"], "empty");
        
        /*var hasInitSb = apf.AmlParser.sbInit[this.$uniqueId] ? true : false;
        if ((!hasInitSb || !hasModel) && this.$setClearMessage
          && (!this.$loadqueue && !this.xmlRoot && (this.hasFeature(apf.__MULTISELECT__)
          || this.ref || hasInitSb)))*/

        this.$amlLoaded = true; //@todo this can probably be removed
        this.$checkLoadQueue();
    });
    
    

    /**
     * @attribute {String} model the name of the model to load data from or a
     * datainstruction to load data.
     * Example:
     * <code>
     *  <a:model id="mdlExample" src="filesystem.xml" />
     *   <a:tree 
     *     height         = "200" 
     *     width          = "250" 
     *     model          = "mdlExample">
     *       <a:each match="[folder|drive]">
     *           <a:caption match="[@caption]" />
     *           <a:icon value="Famfolder.gif" />
     *       </a:each>
     *   </a:tree>
     * </code>
     * Example:
     * <code>
     *  <a:tree 
     *    height         = "200" 
     *    width          = "250" 
     *    model          = "filesystem.xml">
     *      <a:each match="[folder|drive]">
     *          <a:caption match="[@caption]" />
     *          <a:icon value="Famfolder.gif" />
     *      </a:each>
     *  </a:tree>
     * </code>
     * Example:
     * <code>
     *  <a:tree 
     *     id             = "tree"
     *     height         = "200" 
     *     width          = "250" 
     *     model          = "filesystem.xml">
     *       <a:each match="[folder|drive]">
     *           <a:caption match="[@caption]" />
     *           <a:icon value="Famfolder.gif" />
     *       </a:each>
     *   </a:tree>
     *   <a:text 
     *     model  = "{tree.selected}" 
     *     value  = "[@caption]" 
     *     width  = "250" 
     *     height = "100" />
     * </code>
     * Remarks:
     * This attribute is inherited from a parent when not set. You can use this
     * to tell sets of elements to use the same model.
     * <code>
     *  <a:bar model="mdlForm">
     *      <a:label>Name</a:label>
     *      <a:textbox value="[name]" />
     * 
     *      <a:label>Happiness</a:label>
     *      <a:slider value="[happiness]" min="0" max="10" />
     *  </a:bar>
     * 
     *  <a:model id="mdlForm">
     *      <data />
     *  </a:model>
     * </code>
     * When no model is specified the default model is choosen. The default
     * model is the first model that is found without a name, or if all models
     * have a name, the first model found.
     * Example:
     * This example shows a dropdown from which the user can select a country.
     * The list of countries is loaded from a model. Usually this would be loaded
     * from a seperate url, but for clarity it's inlined. When the user selects
     * a country in the dropdown the value of the item is stored in the second
     * model (mdlForm) at the position specified by the ref attribute. In this
     * case this is the country element.
     * <code>
     *  <a:label>Name</a:label>
     *  <a:textbox value="[name]" model="mdlForm" />
     * 
     *  <a:label>Country</a:label>
     *  <a:dropdown
     *    value   = "[mdlForm::country]"
     *    each    = "[mdlCountries::country]"
     *    caption = "[text()]">
     *  </a:dropdown>
     * 
     *  <a:model id="mdlCountries">
     *      <countries>
     *          <country value="USA">USA</country>
     *          <country value="GB">Great Brittain</country>
     *          <country value="NL">The Netherlands</country>
     *      </countries>
     *  </a:model>
     * 
     *  <a:model id="mdlForm">
     *      <data>
     *          <name />
     *          <country />
     *      </data>
     *  </a:model>
     * </code>
     * @see baseclass.databinding.attribute.model
     */
    this.$propHandlers["model"] = function(value){
        //Unset model
        if (!value && !this.$modelParsed) {
            if (this.$model) {
                this.clear();
                this.$model.unregister(this);
                this.$model = null;
                this.lastModelId = "";
            }
            else if (this.dataParent)
                this.dataParent.parent = null; //Should be autodisconnected by property binding

            return;
        }
        
        this.$initingModel = true;

        var fParsed;
        //Special case for property binding
        if ((fParsed = this.$modelParsed) && fParsed.type != 2) {
            var found, pb = fParsed.props;
            
            if (this.dataParent)
                this.dataParent = null; //Should be autodisconnected by property binding

            //Try to figure out who is the dataParent
            for (var prop in pb){
                

                this.dataParent = {
                    parent : self[prop.split(".")[0]],
                    xpath  : null,
                    model  : this.$modelParsed.instruction
                };
        
                found = true;
                break; // We currently only support one data parent
            }
            
            if (found) {
                //@todo this statement doesnt make sense
                /*//Maybe a compound model is found
                if (!this.dataParent && (pb = fParsed.xpaths && fParsed.xpaths[0])) {
                    this.dataParent = {
                        parent : self[pb.split(".")[0]],
                        xpath  : fParsed.xpaths[1],
                        model  : this.$modelParsed.instruction
                    };
                }*/
                
                if (this.dataParent && !this.dataParent.signalXmlUpdate)
                    this.dataParent.signalXmlUpdate = {};
            }
            
            this.$modelParsed = null;
        }

        //Analyze the data
        var model;
        if (typeof value == "object") {
            if (value.dataType == apf.ARRAY) { //Optimization used for templating
                model = apf.nameserver.get("model", value[0]);
                model.register(this, value[1]);
                return;
            }
            else if (value.$isModel) { // A model node is passed
                //Convert model object to value;
                model = value;
                value = this.model = model.name;
                if (!value)
                    model.setProperty("id", value = this.model = "model" + model.$uniqueId);
                
                //@todo why not set directly here?
            }
            else if (this.dataParent) { //Data came through data parent
                this.model = this.dataParent.model; //reset this property

                model = apf.xmldb.findModel(value);
                var xpath = apf.xmlToXpath(value, model.data, true) || ".";
                
                
                if (model.queryNode(xpath) != value)
                    throw new Error("xml data node is not attached to model");
                
                
                model.register(this, xpath);
                return;
            }
            else {
                //@todo Error ??
            }
        }

        //Optimize xmlroot position and set model async (unset the old one)
        //@todo apf3.0 this could be optimized by using apf.queue and only when not all info is there...
        clearTimeout(this.$dbTimer);
        if (!this.$amlLoaded && this.nodeType == 1) {
            var _self = this;
            this.$dbTimer = $setTimeout(function(){
                if (!_self.$amlDestroyed)
                    apf.setModel(value, _self);
            });
        }
        else
            apf.setModel(value, this);
    };

    
};

    apf.DataBinding.prototype = new apf.Presentation();


apf.config.$inheritProperties["model"]           = 1;
apf.config.$inheritProperties["empty-message"]   = 1;
apf.config.$inheritProperties["loading-message"] = 1;
apf.config.$inheritProperties["offline-message"] = 1;
apf.config.$inheritProperties["noloading"]       = 1;

apf.Init.run("databinding");




/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/databinding/multiselect.js)SIZE(44062)TIME(1271234270)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


/**
 * All elements inheriting from this {@link term.baseclass baseclass} can bind to data 
 * which contains multiple nodes.
 *
 * @allowchild  item, choices
 * @define  choices     Container for item nodes which receive presentation. 
 * This element is part of the XForms specification. It is not necesary for 
 * the Ajax.org Markup Language.
 * Example:
 * <code>
 *  <a:list>
 *      <a:choices>
 *          <a:item>red</a:item>
 *          <a:item>blue</a:item>
 *          <a:item>green</a:item>
 *      </a:choices>
 *  </a:list>
 * </code>
 * @allowchild  item
 *
 * @constructor
 * @baseclass
 * @default_private
 */
apf.MultiselectBinding = function(){
    if (!this.setQueryValue)
        this.implement(apf.DataBinding);

    this.$init(function(){
        this.$selectTimer = {};
    });
};

(function(){
    this.length = 0;
    
    //1 = force no bind rule, 2 = force bind rule
    this.$attrExcludePropBind = apf.extend({
        caption   : 2,
        icon      : 2,
        eachvalue : 2,
        select    : 2,
        css       : 2,
        sort      : 2,
        drag      : 2,
        drop      : 2,
        dragcopy  : 2,
        selected  : 2,
        //caret     : 2,
        each      : 1,
        "selection"             : 3, //only databound when has an xpath
        "selection-unique"      : 3, //only databound when has an xpath
        "selection-constructor" : 3 //only databound when has an xpath
    }, this.$attrExcludePropBind);

     
    /**
     * Change the sorting order of this element
     *
     * @param {Object}  options  the new sort options. These are applied incrementally.
     *                           Any property not set is maintained unless the clear
     *                           parameter is set to true.
     *   Properties:
     *   {String}   order        see {@link baseclass.multiselectbinding.binding.each.attribute.order}
     *   {String}   [xpath]      see {@link baseclass.multiselectbinding.binding.each.attribute.sort}
     *   {String}   [type]       see {@link baseclass.multiselectbinding.binding.each.attribute.data-type}
     *   {String}   [method]     see {@link baseclass.multiselectbinding.binding.each.attribute.sort-method}
     *   {Function} [getNodes]   Function that retrieves a list of nodes.
     *   {String}   [dateFormat] see {@link baseclass.multiselectbinding.binding.each.attribute.date-format}
     *   {Function} [getValue]   Function that determines the string content based
     *                           on an xml node as it's first argument.
     * @param {Boolean} clear    removes the current sort options.
     * @param {Boolean} noReload whether to reload the data of this component.
     * @see   baseclass.multiselectbinding.binding.each
     */
    this.resort = function(options, clear, noReload){
        if (!this.$sort)
            this.$sort = new apf.Sort();
 
        this.$sort.set(options, clear);
        
        if (this.clearAllCache)
            this.clearAllCache();

        if (noReload)
            return;

        

        var _self = this;
        (function sortNodes(xmlNode, htmlParent) {
            var sNodes = _self.$sort.apply(
                apf.getArrayFromNodelist(xmlNode.selectNodes(_self.each)));

            for (var i = 0; i < sNodes.length; i++) {
                if (_self.$isTreeArch || _self.$withContainer){
                    var htmlNode = apf.xmldb.findHtmlNode(sNodes[i], _self);

                    
                    if (!_self.$findContainer){
                        throw new Error(apf.formatErrorString(_self,
                            "Sorting Nodes",
                            "This component does not \
                             implement _self.$findContainer"));
                    }
                    

                    var container = _self.$findContainer(htmlNode);

                    htmlParent.appendChild(htmlNode);
                    if (!apf.isChildOf(htmlNode, container, true))
                        htmlParent.appendChild(container);

                    sortNodes(sNodes[i], container);
                }
                else
                    htmlParent.appendChild(apf.xmldb.findHtmlNode(sNodes[i], _self));
            }
        })(this.xmlRoot, this.$container);

        return options;
    };

    /**
     * Change sorting from ascending to descending and vice versa.
     */
    this.toggleSortOrder = function(){
        return this.resort({"ascending" : !this.$sort.get().ascending}).ascending;
    };

    /**
     * Retrieves the current sort options
     *
     * @returns {Object}  the current sort options.
     *   Properties:
     *   {String}   order      see {@link baseclass.multiselectbinding.binding.each.attribute.order}
     *   {String}   xpath      see {@link baseclass.multiselectbinding.binding.each.attribute.sort}
     *   {String}   type       see {@link baseclass.multiselectbinding.binding.each.attribute.data-type}
     *   {String}   method     see {@link baseclass.multiselectbinding.binding.each.attribute.sort-method}
     *   {Function} getNodes   Function that retrieves a list of nodes.
     *   {String}   dateFormat see {@link baseclass.multiselectbinding.binding.each.attribute.date-format}
     *   {Function} getValue   Function that determines the string content based on
     *                         an xml node as it's first argument.
     * @see    baseclass.multiselectbinding.binding.each
     */
    this.getSortSettings = function(){
        return this.$sort.get();
    };
    

    /**
     * Retrieves a nodelist containing the {@link term.datanode data nodes} which
     * are rendered by this element (see each nodes, see
     * {@link baseclass.multiselectbinding.binding.each}).
     *
     * @param {XMLElement} [xmlNode] the parent element on which the each query is applied.
     */
    this.getTraverseNodes = function(xmlNode){
        
        if (!this.each) {
            throw new Error("Could not render bound data. Missing 'each' rule for " 
                + this.localName + (this.id && "[" + this.id + "]" || "")); //@todo apf3.0 make into proper apf error
        }
        
        
        
        if (this.$sort) {
            var nodes = apf.getArrayFromNodelist((xmlNode || this.xmlRoot).selectNodes(this.each));
            return this.$sort.apply(nodes);
        }
        

        return (xmlNode || this.xmlRoot).selectNodes(this.each);
    };

    /**
     * Retrieves the first {@link term.datanode data node} which gets representation
     * in this element
     * (see each nodes, see {@link baseclass.multiselectbinding.binding.each}).
     *
     * @param {XMLElement} [xmlNode] the parent element on which the each query is executed.
     * @return {XMLElement}
     */
    this.getFirstTraverseNode = function(xmlNode){
        
        if (this.$sort) {
            var nodes = (xmlNode || this.xmlRoot).selectNodes(this.each);
            return this.$sort.apply(nodes)[0];
        }
        

        return (xmlNode || this.xmlRoot).selectSingleNode(this.each);
    };

    /**
     * Retrieves the last {@link term.datanode data node} which gets representation
     * in this element
     * (see each nodes, see {@link baseclass.multiselectbinding.binding.each}).
     *
     * @param {XMLElement} [xmlNode] the parent element on which the each query is executed.
     * @return {XMLElement} the last {@link term.datanode data node}
     * @see    baseclass.multiselectbinding.binding.each
     */
    this.getLastTraverseNode = function(xmlNode){
        var nodes = this.getTraverseNodes(xmlNode || this.xmlRoot);
        return nodes[nodes.length-1];
    };

    /**
     * Determines whether an {@link term.datanode data node} is a each node (see
     * {@link baseclass.multiselectbinding.binding.each})
     *
     * @param {XMLElement} [xmlNode] the parent element on which the each query is executed.
     * @return  {Boolean}  whether the xml element is a each node.
     * @see  baseclass.multiselectbinding.binding.each
     */
    this.isTraverseNode = function(xmlNode){
        /*
            Added optimization, only when an object has a tree architecture is it
            important to go up to the each parent of the xmlNode, else the node
            should always be based on the xmlroot of this component
        */
        //this.$isTreeArch
        var nodes = this.getTraverseNodes(
          this.getTraverseParent(xmlNode) || this.xmlRoot);
        for (var i = 0; i < nodes.length; i++)
            if (nodes[i] == xmlNode)
                return true;
        return false;
    };

    /**
     * Retrieves the next each node (see {@link baseclass.multiselectbinding.binding.each})
     * to be selected
     * from a given each node. The method can do this in either direction and
     * also return the Nth node for this algorithm.
     *
     * @param {XMLElement}  xmlNode  the starting point for determining the next selection.
     * @param {Boolean}     [up]     the direction of the selection. Default is false.
     * @param {Integer}     [count]  the distance in number of nodes. Default is 1.
     * @return  {XMLElement} the {@link term.datanode data node} to be selected next.
     * @see  baseclass.multiselectbinding.binding.each
     */
    this.getNextTraverseSelected = function(xmlNode, up, count){
        if (!xmlNode)
            xmlNode = this.selected;
        if (!count)
            count = 1;

        var i = 0;
        var nodes = this.getTraverseNodes(this.getTraverseParent(xmlNode) || this.xmlRoot);
        while (nodes[i] && nodes[i] != xmlNode)
            i++;

        var node = (up == null)
            ? nodes[i + count] || nodes[i - count]
            : (up ? nodes[i + count] : nodes[i - count]);

        //arguments[2]
        return node || count && (i < count || (i + 1) > Math.floor(nodes.length / count) * count)
            ? node
            : (up ? nodes[nodes.length-1] : nodes[0]);
    };

    /**
     * Retrieves the next each node (see {@link baseclass.multiselectbinding.binding.each}).
     * The method can do this in either direction and also return the Nth next node.
     *
     * @param {XMLElement}  xmlNode     the starting point for determining the next node.
     * @param {Boolean}     [up]        the direction. Default is false.
     * @param {Integer}     [count]     the distance in number of nodes. Default is 1.
     * @return  {XMLElement} the next each node
     * @see  baseclass.multiselectbinding.binding.each
     */
    this.getNextTraverse = function(xmlNode, up, count){
        if (!count)
            count = 1;
        if (!xmlNode)
            xmlNode = this.selected;

        var i = 0;
        var nodes = this.getTraverseNodes(this.getTraverseParent(xmlNode) || this.xmlRoot);
        while (nodes[i] && nodes[i] != xmlNode)
            i++;

        return nodes[i + (up ? -1 * count : count)];
    };

    /**
     * Retrieves the parent each node (see {@link baseclass.multiselectbinding.binding.each}).
     * In some cases the each rules has a complex form like 'children/item'. In
     * those cases the generated tree has a different structure from that of the xml
     * data. For these situations the xmlNode.parentNode property won't return
     * the each parent, this method will give you the right parent.
     *
     * @param {XMLElement} xmlNode the node for which the parent element will be determined.
     * @return  {XMLElement} the parent node or null if none was found.
     * @see  baseclass.multiselectbinding.binding.each
     */
    this.getTraverseParent = function(xmlNode){
        if (!xmlNode.parentNode || xmlNode == this.xmlRoot) 
            return false;

        //@todo this can be removed when we have a new xpath implementation
        if (xmlNode.$regbase)
            return xmlNode.parentNode;

        var x, id = xmlNode.getAttribute(apf.xmldb.xmlIdTag);
        if (!id) {
            //return false;
            xmlNode.setAttribute(apf.xmldb.xmlIdTag, "temp");
            id = "temp";
        }

        /*
        do {
            xmlNode = xmlNode.parentNode;
            if (xmlNode == this.xmlRoot)
                return false;
            if (this.isTraverseNode(xmlNode))
                return xmlNode;
        } while (xmlNode.parentNode);
        */

        //This is not 100% correct, but good enough for now

        x = xmlNode.selectSingleNode("ancestor::node()[(("
            + this.each + ")/@" + apf.xmldb.xmlIdTag + ")='"
            + id + "']");

        if (id == "temp")
            xmlNode.removeAttribute(apf.xmldb.xmlIdTag);
        return x;
    };
    
    /**
     * Finds HTML presentation node in cache by ID
     *
     * @param  {String} id  the id of the HTMLElement which is looked up.
     * @return {HTMLElement} the HTMLElement found. When no element is found, null is returned.
     */
    if (!this.$findHtmlNode) { //overwritten by apf.Cache
        this.$findHtmlNode = function(id){
            return this.$pHtmlDoc.getElementById(id);
        };
    }
    
    this.$setClearMessage = function(msg, className, lastHeight){
        if (!this.$empty) {
            if (!this.$hasLayoutNode("empty"))
                return;
            
            this.$getNewContext("empty");

            var xmlEmpty = this.$getLayoutNode("empty");
            if (!xmlEmpty) return;

            this.$empty = apf.insertHtmlNode(xmlEmpty, this.$container);
        }
        else {
            this.$container.appendChild(this.$empty);
        }

        var empty = this.$getLayoutNode("empty", "caption", this.$empty);

        if (empty)
            apf.setNodeValue(empty, msg || "");

        this.$empty.setAttribute("id", "empty" + this.$uniqueId);
        apf.setStyleClass(this.$empty, className, ["loading", "empty", "offline"]);
        
        //@todo apf3.0 cleanup?
        var extH = apf.getStyle(this.$ext, "height");
        this.$empty.style.height = (lastHeight && (!extH || extH == "auto") && className != "empty")
            ? (Math.max(10, (lastHeight
               - apf.getHeightDiff(this.$empty)
               - apf.getHeightDiff(this.$ext))) + "px")
            : "";
    };

    this.$updateClearMessage = function(msg, className) {
        if (!this.$empty || this.$empty.parentNode != this.$container
          || this.$empty.className.indexOf(className) == -1)
            return;

        var empty = this.$getLayoutNode("empty", "caption", this.$empty);
        if (empty)
            apf.setNodeValue(empty, msg || "");
    }

    this.$removeClearMessage = function(){
        if (!this.$empty)
            this.$empty = document.getElementById("empty" + this.$uniqueId);
        if (this.$empty && this.$empty.parentNode)
            this.$empty.parentNode.removeChild(this.$empty);
    };
    
    /**
     * Set listeners, calls HTML creation methods and
     * initializes select and focus states of object.
     */
    this.$load = function(XMLRoot){
        //Add listener to XMLRoot Node
        apf.xmldb.addNodeListener(XMLRoot, this);

        var length = this.getTraverseNodes(XMLRoot).length;
        if (!this.renderRoot && !length)
            return this.clear(null, null, true); //@todo apf3.0 this should clear and set a listener

        //Traverse through XMLTree
        var nodes = this.$addNodes(XMLRoot, null, null, this.renderRoot);

        //Build HTML
        this.$fill(nodes);

        //Select First Child
        if (this.selectable) {
            
            //@todo apf3.0 optimize to not set selection when .selection or .selected is set on initial load
            if (this.autoselect) {
                if (!this.selected) {
                    if (this.renderRoot)
                        this.select(XMLRoot, null, null, null, true);
                    else if (nodes.length)
                        this.$selectDefault(XMLRoot);
                    //else @todo apf3.0 this one doesnt seem needed
                        //this.clearSelection();
                }
            }
            else {
                this.clearSelection(true);
                var xmlNode = this.renderRoot
                    ? this.xmlRoot
                    : this.getFirstTraverseNode(); //should this be moved to the clearSelection function?
                if (xmlNode)
                    this.setCaret(xmlNode);
                
                if (this.selected)
                    this.setProperty("selected", null);
                if (this.choosen)
                    this.setProperty("choosen", null);
                
            }
        }

        if (this.focussable)
            apf.document.activeElement == this ? this.$focus() : this.$blur();

        
        if (length != this.length)
            this.setProperty("length", length);
        
    };

    var actionFeature = {
        "insert"      : 127,//1111111
        "add"         : 123,//1111011
        "remove"      : 46, //0101110
        "redo-remove" : 79, //1001111
        "synchronize" : 127,//1111111
        "move-away"   : 105,//1101001
        "move"        : 77  //1001101
    };

    /**
     * Loops through parents of changed node to find the first
     * connected node. Based on the action it will change, remove
     * or update the representation of the data.
     *
     * @event xmlupdate Fires when xml of this element is updated.
     *   object:
     *   {String}     action   the action that was executed on the xml.
     *      Possible values:
     *      text        a text node is set.
     *      update      an xml node is updated.
     *      insert      xml nodes are inserted.
     *      add         an xml node is added.
     *      remove      an xml node is removed (parent still set).
     *      redo-remove an xml node is removed (parent not set).
     *      synchronize unknown update.
     *      move-away   an xml node is moved (parent not set).
     *      move        an xml node is moved (parent still set).
     *   {XMLElement} xmlNode  the node that is subject to the update.
     *   {Mixed}      result   the result.
     *   {UndoObj}    UndoObj  the undo information.
     */
    this.$xmlUpdate = function(action, xmlNode, listenNode, UndoObj, lastParent){
        if (!this.xmlRoot)
            return; //@todo think about purging cache when xmlroot is removed

        var result, length, pNode, htmlNode,
            startNode = xmlNode;
        if (!listenNode)
            listenNode = this.xmlRoot;

        if (action == "redo-remove") {
            lastParent.appendChild(xmlNode); //ahum, i'm not proud of this one
            var eachNode = this.isTraverseNode(xmlNode);
            lastParent.removeChild(xmlNode);
            
            if (!eachNode)
                xmlNode = lastParent;
        }

        //Get First ParentNode connected
        do {
            if (action == "add" && this.isTraverseNode(xmlNode)
              && startNode == xmlNode)
                break; //@todo Might want to comment this out for adding nodes under a eachd node

            if (xmlNode.getAttribute(apf.xmldb.xmlIdTag)) {
                htmlNode = this.$findHtmlNode(
                    xmlNode.getAttribute(apf.xmldb.xmlIdTag)
                    + "|" + this.$uniqueId);

                if (htmlNode
                  && (startNode != xmlNode || xmlNode == this.xmlRoot)
                  && actionFeature[action] & 1)
                    action = "update";

                if (xmlNode == listenNode && !this.renderRoot) {
                    if (xmlNode == this.xmlRoot && action != "insert") {
                        //@todo apf3.0 - fix this for binding on properties
                        this.dispatchEvent("xmlupdate", {
                            action : action,
                            xmlNode: xmlNode,
                            UndoObj: UndoObj
                        });
                        return;
                    }
                    break;
                }

                if (htmlNode && actionFeature[action] & 2
                  && !this.isTraverseNode(xmlNode))
                    action = "remove"; //@todo why not break here?

                if (!htmlNode && actionFeature[action] & 4
                  && this.isTraverseNode(xmlNode)){
                    action = "add";
                    break;
                }

                if (htmlNode  || action == "move")
                    break;
            }
            else if (actionFeature[action] & 8 && this.isTraverseNode(xmlNode)){
                action = "add";
                break;
            }

            if (xmlNode == listenNode) break;
            xmlNode = xmlNode.parentNode;
        }
        while (xmlNode && xmlNode.nodeType != 9);

        

        

        //if(xmlNode == listenNode && !action.match(/add|synchronize|insert/))
        //    return; //deleting nodes in parentData of object

        var foundNode = xmlNode;
        if (xmlNode && xmlNode.nodeType == 9)
            xmlNode = startNode;

        if (action == "replacechild"
          && (UndoObj ? UndoObj.args[0] == this.xmlRoot : !this.xmlRoot.parentNode)) {
            return this.load(UndoObj ? UndoObj.args[1] : listenNode); //Highly doubtfull this is exactly right...
        }

        //Action Tracker Support - && xmlNode correct here??? - UndoObj.xmlNode works but fishy....
        if (UndoObj && xmlNode && !UndoObj.xmlNode)
            UndoObj.xmlNode = xmlNode;

        //Check Move -- if value node isn't the node that was moved then only perform a normal update
        if (action == "move" && foundNode == startNode) {
            //if(!htmlNode) alert(xmlNode.getAttribute("id")+"|"+this.$uniqueId);
            var isInThis  = apf.isChildOf(this.xmlRoot, xmlNode.parentNode, true);
            var wasInThis = apf.isChildOf(this.xmlRoot, UndoObj.extra.parent, true);

            //Move if both previous and current position is within this object
            if (isInThis && wasInThis)
                this.$moveNode(xmlNode, htmlNode);
            else if (isInThis) //Add if only current position is within this object
                action = "add";
            else if (wasInThis) //Remove if only previous position is within this object
                action = "remove";
        }
        else if (action == "move-away") {
            var goesToThis = apf.isChildOf(this.xmlRoot, UndoObj.extra.parent, true);
            if (!goesToThis)
                action = "remove";
        }

        //Remove loading message
        if (this.$removeClearMessage && this.$setClearMessage) {
            if (this.getFirstTraverseNode())
                this.$removeClearMessage();
            else
                this.$setClearMessage(this["empty-message"], "empty")
        }

        //Check Insert
        if (action == "insert" && (this.$isTreeArch || xmlNode == this.xmlRoot)) {
            if (!xmlNode)
                return;
            
            if (this.$hasLoadStatus(xmlNode) && this.$removeLoading)
                this.$removeLoading(htmlNode);

            if (this.$container.firstChild && !apf.xmldb.getNode(this.$container.firstChild)) {
                //Appearantly the content was cleared
                this.$container.innerHTML = "";

                if (!this.renderRoot) {
                    length = this.getTraverseNodes().length;
                    if (!length)
                        this.clear();
                }
            }

            result = this.$addNodes(xmlNode, (this.$getParentNode
                ? this.$getParentNode(htmlNode)
                : htmlNode), true, false);//this.$isTreeArch??

            this.$fill(result);

            
            if (this.selectable && !this.xmlRoot.selectSingleNode(this.each))
                apf.console.warn("No traversable nodes were found for "
                                 + this.name + " [" + this.localName + "]\n\
                                  Traverse Rule : " + this.$getBindRule("each")[4].getAttribute("match"));
            

            if (this.selectable && (length === 0 || !this.xmlRoot.selectSingleNode(this.each)))
                return;
        }
        else if (action == "add") {// || !htmlNode (Check Add)
            var parentHTMLNode;
            pNode = this.getTraverseParent(xmlNode);
            
            if (pNode == this.xmlRoot)
                parentHTMLNode = this.$container;
            
            if (!parentHTMLNode && this.$isTreeArch) {
                parentHTMLNode = this.$findHtmlNode(
                    pNode.getAttribute(apf.xmldb.xmlIdTag) + "|" + this.$uniqueId); 
            }
            
            //This should be moved into a function (used in setCache as well)
            
            if (!parentHTMLNode && this.getCacheItem)
                parentHTMLNode = this.getCacheItem(pNode.getAttribute(apf.xmldb.xmlIdTag)
                    || (pNode.getAttribute(apf.xmldb.xmlDocTag)
                         ? "doc" + pNode.getAttribute(apf.xmldb.xmlDocTag)
                         : false));
            

            //Only update if node is in current representation or in cache
            if (parentHTMLNode || this.$isTreeArch 
              && apf.isChildOf(this.xmlRoot, xmlNode)) {
                parentHTMLNode = (this.$findContainer && parentHTMLNode
                    ? this.$findContainer(parentHTMLNode)
                    : parentHTMLNode) || this.$container; //@todo I think this is wrong for non rendered sub tree nodes that get changed

                result = this.$addNodes(xmlNode, parentHTMLNode, true, true,
                    apf.xmldb.getHtmlNode(this.getNextTraverse(xmlNode), this));

                if (parentHTMLNode)
                    this.$fill(result);
            }
        }
        else if (action == "remove") { //Check Remove
            //&& (!xmlNode || foundNode == xmlNode && xmlNode.parentNode
            if (!xmlNode || startNode != xmlNode) //@todo unsure if I can remove above commented out statement
                return;
            
            //Remove HTML Node
            if (htmlNode)
                this.$deInitNode(xmlNode, htmlNode);
            else if (xmlNode == this.xmlRoot) {
                return this.load({
                    noClearMsg: !this.dataParent || !this.dataParent.autoselect
                });
            }
        }
        else if (htmlNode) {
            this.$updateNode(xmlNode, htmlNode);

            //Transaction 'niceties'
            if (action == "replacechild" && this.hasFeature(apf.__MULTISELECT__)
              && this.selected && xmlNode.getAttribute(apf.xmldb.xmlIdTag)
              == this.selected.getAttribute(apf.xmldb.xmlIdTag)) {
                this.selected = xmlNode;
            }

            //if(action == "synchronize" && this.autoselect) this.reselect();
        }
        else if (action == "redo-remove") { //Check Remove of the data (some ancestor) that this component is bound on
            var testNode = this.xmlRoot;
            while (testNode && testNode.nodeType != 9)
                testNode = testNode.parentNode;

            if (!testNode) {
                //Set Component in listening state until data becomes available again.
                var model = this.getModel(true);

                
                if (!model)
                    throw new Error(apf.formatErrorString(0, this,
                        "Setting change notifier on component",
                        "Component without a model is listening for changes",
                        this.$aml));
                

                return model.$waitForXml(this);
            }
        }
        
        

        //For tree based nodes, update all the nodes up
        pNode = xmlNode ? xmlNode.parentNode : lastParent;
        if (this.$isTreeArch && !this.$preventRecursiveUpdate 
          && pNode && pNode.nodeType == 1) {
            do {
                htmlNode = this.$findHtmlNode(pNode.getAttribute(
                    apf.xmldb.xmlIdTag) + "|" + this.$uniqueId);

                if (htmlNode)
                    this.$updateNode(pNode, htmlNode);
            }
            while ((pNode = this.getTraverseParent(pNode)) && pNode.nodeType == 1);
        }

        //Make sure the selection doesn't become corrupted
        if (actionFeature[action] & 32 && this.selectable
          && startNode == xmlNode
          && (action != "insert" || xmlNode == this.xmlRoot)) {

            clearTimeout(this.$selectTimer.timer);
            // Determine next selection
            if (action == "remove" && apf.isChildOf(xmlNode, this.selected, true)
              || xmlNode == this.$selectTimer.nextNode)
                this.$selectTimer.nextNode = this.getDefaultNext(xmlNode, this.$isTreeArch);

            //@todo Fix this by putting it after xmlUpdate when its using a timer
            var _self = this;
            this.$selectTimer.timer = $setTimeout(function(){
                _self.$checkSelection(_self.$selectTimer.nextNode);
                _self.$selectTimer.nextNode = null;
            });
        }

        
        //Set dynamic properties that relate to the changed content
        if (actionFeature[action] & 64) {
            if (!length)
                length = this.xmlRoot.selectNodes(this.each).length;
            if (length != this.length)
                this.setProperty("length", length);
        }
        

        //Let's signal components that are waiting for xml to appear (@todo what about clearing the signalXmlUpdate)
        if (this.signalXmlUpdate && actionFeature[action] & 16) {
            var uniqueId;
            for (uniqueId in this.signalXmlUpdate) {
                if (parseInt(uniqueId) != uniqueId) continue; //safari_old stuff

                var o = apf.lookup(uniqueId);
                if (!this.selected) continue;

                xmlNode = this.selected.selectSingleNode(o.dataParent.xpath);
                if (!xmlNode) continue;

                o.load(xmlNode);
            }
        }

        this.dispatchEvent("xmlupdate", {
            action : action,
            xmlNode: xmlNode,
            result : result,
            UndoObj: UndoObj
        });
    };

    /**
     * Loop through NodeList of selected Traverse Nodes
     * and check if it has representation. If it doesn't
     * representation is created via $add().
     */
    this.$addNodes = function(xmlNode, parent, checkChildren, isChild, insertBefore, depth){
        
        if (!this.each) {
            throw new Error(apf.formatErrorString(1060, this,
                "adding Nodes for load",
                "No each SmartBinding rule was specified. This rule is \
                 required for a " + this.localName + " component.", this.$aml));
        }
        

        var htmlNode, lastNode;
        isChild          = (isChild && (this.renderRoot && xmlNode == this.xmlRoot
            || this.isTraverseNode(xmlNode)));
        var nodes        = isChild ? [xmlNode] : this.getTraverseNodes(xmlNode);
        /*var loadChildren = nodes.length && this.$bindings["insert"]
            ? this.$applyBindRule("insert", xmlNode)
            : false; << UNUSED */

        
        var cId, cItem;
        if (this.$isTreeArch && this.caching 
          && (cItem = this.cache[(cId = xmlNode.getAttribute(apf.xmldb.xmlIdTag))])) {
            if (this.$subTreeCacheContext || this.$needsDepth) {
                //@todo
                //We destroy the current items, because currently we 
                //don't support multiple treecachecontexts
                //and because datagrid needs to redraw depth
                this.clearCacheItem(cId);
            }
            else {
                this.$subTreeCacheContext = {
                    oHtml      : cItem,
                    container  : parent,
                    parentNode : null,
                    beforeNode : null
                };

                var htmlNode;
                while (cItem.childNodes.length)
                    parent.appendChild(htmlNode = cItem.childNodes[0]);
                
                return nodes;
            }
        }
        

        for (var i = 0; i < nodes.length; i++) {
            if (nodes[i].nodeType != 1) {
                
                continue;
            }

            if (checkChildren) {
                htmlNode = this.$findHtmlNode(nodes[i]
                    .getAttribute(apf.xmldb.xmlIdTag) + "|" + this.$uniqueId);
            }

            if (!htmlNode) {
                //Retrieve DataBind ID
                var Lid = apf.xmldb.nodeConnect(this.documentId, nodes[i], null, this);

                //Add Children
                var beforeNode = isChild
                        ? insertBefore
                        : (lastNode ? lastNode.nextSibling : null),//(parent || this.$container).firstChild);
                    parentNode = this.$add(nodes[i], Lid, isChild ? xmlNode.parentNode : xmlNode,
                        beforeNode ? parent || this.$container : parent, beforeNode,
                        (!beforeNode && i == nodes.length - 1), depth);//Should use getTraverParent

                //Exit if component tells us its done with rendering
                if (parentNode === false) {
                    //Tag all needed xmlNodes for future reference
                    // @todo apf3.0 code below looks harmful... hence commented out (Mike)
                    /*for (var j = i; j < nodes.length; j++)
                        apf.xmldb.nodeConnect(this.documentId, nodes[j],
                            null, this);*/
                    break;
                }

                //Parse Children Recursively -> optimize: don't check children that can't exist
                //if(this.$isTreeArch) this.$addNodes(nodes[i], parentNode, checkChildren);
            }

            if (checkChildren)
                lastNode = htmlNode;// ? htmlNode.parentNode.parentNode : null;
        }

        return nodes;
    };

    this.$handleBindingRule = function(value, prop){
        if (!value)
            this[prop] = null;

        //@todo apf3.0 fix parsing
        if (prop == "each") {
            if (value.indexOf("::") > -1) {
                value = value.replace(/^\[|\]$/g, "").split("::"); //@todo could be optimized
                this.setProperty("model", value[0]);
                this.each = value[1];
            }
            else
                this.each = value.replace(/^\[|\]$/g, ""); 
        }

        //@todo apf3.0 find a better heuristic (portal demo)
        if (this.xmlRoot && !this.$bindRuleTimer && this.$amlLoaded) {
            var _self = this;
            apf.queue.add("reload" + this.$uniqueId, function(){
                
                apf.console.log("Reloading multiselect based on \
                                 attribute bind change: " + _self.serialize(true));
                
                _self.reload();
            });
        }
    };
    
    this.$select = function(o){
        
        if (this.renaming)
            this.stopRename(null, true);
        

        if (!o || !o.style)
            return;
        return this.$setStyleClass(o, "selected");
    };

    this.$deselect = function(o){
        
        if (this.renaming) {
            this.stopRename(null, true);

            if (this.ctrlselect)
                return false;
        }
        

        if (!o)
            return;
        return this.$setStyleClass(o, "", ["selected", "indicate"]);
    };

    this.$indicate = function(o){
        
        if (this.renaming)
            this.stopRename(null, true);
        

        if (!o)
            return;
        return this.$setStyleClass(o, "indicate");
    };

    this.$deindicate = function(o){
        
        if (this.renaming)
            this.stopRename(null, true);
        

        if (!o)
            return;
        return this.$setStyleClass(o, "", ["indicate"]);
    };

    
    /**
     * @attribute {String} each the xpath statement that determines which
     * {@link term.datanode data nodes} are rendered by this element (also known
     * as {@link term.eachnode each nodes}. See
     * {@link baseclass.multiselectbinding.binding.each} for more information.
     * Example:
     * <code>
     *  <a:label>Country</a:label>
     *  <a:dropdown
     *      model     = "mdlCountries"
     *      each      = "[country]"
     *      eachvalue = "[@value]"
     *      caption   = "[text()]">
     *  </a:dropdown>
     *
     *  <a:model id="mdlCountries">
     *      <countries>
     *          <country value="USA">USA</country>
     *          <country value="GB">Great Brittain</country>
     *          <country value="NL">The Netherlands</country>
     *          ...
     *      </countries>
     *  </a:model>
     * </code>
     * @see  baseclass.multiselectbinding.binding.each
     */
    this.$propHandlers["each"] =

    /**
     * @attribute {String} caption the xpath statement that determines from
     * which xml node the caption is retrieved.
     * Example:
     * <code>
     *  <a:list caption="[text()]" each="[item]" />
     * </code>
     */
    this.$propHandlers["caption"]  =
    
    /**
     * @attribute {String} valuerule the xpath statement that determines from
     * which xml node the value is retrieved.
     * Example:
     * <code>
     *  <a:list value="[@value]" each="[item]" />
     * </code>
     * @see  baseclass.multiselect.binding.value
     */
    this.$propHandlers["eachvalue"]  =

    /**
     * @attribute {String} icon the xpath statement that determines from
     * which xml node the icon url is retrieved.
     * Example:
     * <code>
     *  <a:list icon="[@icon]" each="[item]" />
     * </code>
     */
    this.$propHandlers["icon"]     =

    /**
     * @attribute {String} tooltip the xpath statement that determines from
     * which xml node the tooltip text is retrieved.
     * Example:
     * <code>
     *  <a:list tooltip="[text()]" each="[item]" />
     * </code>
     */
    this.$propHandlers["tooltip"]  = this.$handleBindingRule;

    
    /**
     * @attribute {String} sort the xpath statement that selects the sortable value.
     * Example:
     * <code>
     *  <a:list sort="[@name]" each="[person]" />
     * </code>
     * @see  element.each.attribute.sort
     */
    this.$propHandlers["sort"] = function(value){
        if (value) {
            this.$sort = new apf.Sort()
            this.$sort.set({
                getValue : apf.lm.compile(value)
            });
        }
        else {
            this.$sort = null;
        }
    }
    

    /**
     * @attribute {String} select the xpath statement that determines whether
     * this node is selectable.
     * Example:
     * <code>
     *  <a:list match="{[@disabled] != 1}" each="[item]" />
     * </code>
     * @see  baseclass.multiselect.binding.select
     */
    //this.$propHandlers["select"]   = 
    
}).call(apf.MultiselectBinding.prototype = new apf.DataBinding());


/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/databinding/standard.js)SIZE(6499)TIME(1263859264)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * @constructor
 * @private
 * @baseclass
 */
apf.StandardBinding = function(){
    this.$init(true);
    
    
    if (apf.Validation)
        this.implement(apf.Validation);
    
    
    if (!this.setQueryValue)
        this.implement(apf.DataBinding);

    if (!this.defaultValue) //@todo please use this in a sentence
        this.defaultValue = "";

    /**
     * Load XML into this element
     * @private
     */
    this.$load = function(xmlNode){
        //Add listener to XMLRoot Node
        apf.xmldb.addNodeListener(xmlNode, this);
        //Set Properties

        
        var b, lrule, rule, bRules, bRule, value;
        if (b = this.$bindings) {
	        for (rule in b) {
	            lrule = rule.toLowerCase();
	            if (this.$supportedProperties.indexOf(lrule) > -1) {
	                bRule = (bRules = b[lrule]).length == 1 
                      ? bRules[0] 
                      : this.$getBindRule(lrule, xmlNode);

                    value = bRule.value || bRule.match;

	                
                    //Remove any bounds if relevant
                    this.$clearDynamicProperty(lrule);
            
                    if (value.indexOf("{") > -1 || value.indexOf("[") > -1)
                        this.$setDynamicProperty(lrule, value);
                    else 
                    
                    if (this.setProperty)
                        this.setProperty(lrule, value, true);
	            }
	        }
	    }
        

        //Think should be set in the event by the Validation Class
        if (this.errBox && this.isValid && this.isValid())
            this.clearError();
    };

    /**
     * Set xml based properties of this element
     * @private
     */
    this.$xmlUpdate = function(action, xmlNode, listenNode, UndoObj){
        //Clear this component if some ancestor has been detached
        if (action == "redo-remove") {
            var retreatToListenMode = false, model = this.getModel(true);
            if (model) {
                var xpath = model.getXpathByAmlNode(this);
                if (xpath) {
                    xmlNode = model.data.selectSingleNode(xpath);
                    if (xmlNode != this.xmlRoot)
                        retreatToListenMode = true;
                }
            }
            
            if (retreatToListenMode || this.xmlRoot == xmlNode) {
                
                //RLD: Disabled because sometimes indeed components do not 
                //have a model when their xmlRoot is removed.
                if (!model) {
                    throw new Error(apf.formatErrorString(0, this, 
                        "Setting change notifier on component", 
                        "Component without a model is listening for changes", 
                        this.$aml));
                }
                

                //Set Component in listening state untill data becomes available again.
                return model.$waitForXml(this);
            }
        }

        //Action Tracker Support
        if (UndoObj && !UndoObj.xmlNode)
            UndoObj.xmlNode = this.xmlRoot;

        //Set Properties

        
        var b, lrule, rule, bRules, bRule, value;
        if (b = this.$bindings) {
	        for (rule in b) {
	            lrule = rule.toLowerCase();
	            if (this.$supportedProperties.indexOf(lrule) > -1) {
                    bRule = (bRules = b[lrule]).length == 1 
                      ? bRules[0] 
                      : this.$getBindRule(lrule, xmlNode);

                    value = bRule.value || bRule.match;

	                
                    //Remove any bounds if relevant
                    this.$clearDynamicProperty(lrule);
            
                    if (value.indexOf("{") > -1 || value.indexOf("[") > -1)
                        this.$setDynamicProperty(lrule, value);
                    else 
                    
                    if (this.setProperty)
                        this.setProperty(lrule, value);
	            }
	        }
	    }
        

        //@todo Think should be set in the event by the Validation Class
        if (this.errBox && this.isValid && this.isValid())
            this.clearError();
        
        this.dispatchEvent("xmlupdate", {
            action : action,
            xmlNode: xmlNode,
            UndoObj: UndoObj
        });
    };

    /**
     * Clears the data loaded into this element resetting it's value.
     */
    //@todo apf3.0 this is wrong
    this.addEventListener("$clear", function(nomsg, do_event){
        if (this.$propHandlers && this.$propHandlers["value"]) {
            this.value = -99999; //force resetting
            this.$propHandlers["value"].call(this, "");
        }
    });
};
apf.StandardBinding.prototype = new apf.DataBinding();

apf.Init.run("standardbinding");


/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/multiselect.js)SIZE(72530)TIME(1270838606)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */

apf.__MULTISELECT__ = 1 << 8;



/**
 * @term eachnode A each node is a {@link term.datanode data node} that is in the set selected by the 
 * {@link baseclass.multiselectbinding.binding.each each binding rule}.
 * These {@link term.datanode data nodes} get representation within the visual element. For instance
 * each item in a list is connected to such a each node. A each node
 * can be selected, removed, added, dragged, dropped and so on. 
 * Example:
 * In this example the person nodes that have the show attribute set to 1 are the 
 * each nodes of the list. This list will display three items.
 * <code>
 *  <a:list>
 *      <a:bindings>
 *          <a:caption match="[@name]" />
 *          <a:each match="[person[@show='1']]" />
 *      </a:bindings>
 *      <a:model>
 *          <data>
 *              <person name="test 5"/>
 *              <person show="1" name="test 3"/>
 *              <person name="test 4"/>
 *              <person show="1" name="test 2"/>
 *              <person show="1" name="test 1"/>
 *          </data>
 *      </a:model>
 *  </a:list>
 * </code>
 * Remarks:
 * A somewhat advanced topic is understanding how an element can use the 
 * each {@link term.binding binding rule}. For the tree this binding rules
 * can be used to create a virtual tree mapping of the xml.
 */

/**
 * @term caret When selecting nodes in a list using the keyboard, the caret is 
 * the indication of the position within that list. The item that the caret is
 * on might or might not be selected. This feature is especially useful when 
 * holding the control key or using the shift key to multi select items.
 */

/**
 * All elements inheriting from this {@link term.baseclass baseclass} have selection features. This includes handling
 * for multiselect and several keyboard based selection interaction. It also
 * takes care of {@link term.caret caret} handling when multiselect is enabled. Furthermore features 
 * for dealing with multinode component are included like adding and removing 
 * {@link term.datanode data nodes}.
 *
 * @constructor
 * @baseclass
 * @author      Ruben Daniels (ruben AT ajax DOT org)
 * @version     %I%, %G%
 * @since       0.5
 *
 * @inherits apf.MultiselectBinding
 *
 * @binding select Determines whether the {@link term.eachnode each node} can be selected.
 * Example:
 * In this example the tree contains nodes that have a disabled flag set. 
 * These nodes cannot be selected
 * <code>
 *  <a:list width="200">
 *      <a:bindings>
 *          <a:selectable match="[self::node()[not(@disabled) or @disabled != 'true']]" />
 *          <a:each match="[person]"></a:each>
 *          <a:caption match="[@name]"></a:caption>
 *      </a:bindings>
 *      <a:model>
 *          <data>
 *              <person disabled="false" name="test 5"/>
 *              <person disabled="true" name="test 3"/>
 *              <person name="test 4"/>
 *              <person disabled="true" name="test 2"/>
 *              <person disabled="true" name="test 1"/>
 *          </data>
 *      </a:model>
 *  </a:list>
 * </code>
 * @binding value  Determines the way the value for the element is retrieved
 * from the selected node. The value property contains this value.
 * Example:
 * <code>
 *  <a:dropdown onafterchange="alert(this.value)">
 *      <a:bindings>
 *          <a:caption match="[text()]" />
 *          <a:value match="[@value]" />
 *          <a:each match="[item]" />
 *      </a:bindings>
 *      <a:model>
 *          <items>
 *              <item value="#FF0000">red</item>
 *              <item value="#00FF00">green</item>
 *              <item value="#0000FF">blue</item>
 *          </items>
 *      </a:model>
 *  </a:dropdown>
 * </code>
 */
apf.MultiSelect = function(){
    this.$init(function(){
        this.$valueList       = [];
        this.$selectedList    = [];
    });
};

//@todo investigate if selectedList can be deprecated
(function() {
    this.$regbase    = this.$regbase|apf.__MULTISELECT__;

    /**** Properties ****/

    /**
     * the last selected item of this element.
     * @type {XMLElement} 
     */
    this.sellength    = 0;
    this.selected     = null;
    this.$selected    = null;
    
    /**
     * the xml element that has the {@link term.caret caret}.
     * @type {XMLElement} 
     */
    this.caret    = null;
    this.$caret   = null;
    
    /**
     * whether to use a {@link term.caret caret} in the interaction of this element.
     * @type {Boolean} 
     */
    this.useindicator = true;

    

    /**
     * Removes an {@link term.datanode data node} from the data of this element.
     * Example:
     * A simple list showing products. This list is used in all following examples.
     * <code>
     *  <a:list id="myList">
     *      <a:bindings>
     *          <a:caption match="[@name]" />
     *          <a:value match="[@id]" />
     *          <a:icon>[@type].png</a:icon>
     *          <a:each match="[product]" />
     *      </a:bindings>
     *      <a:model>
     *          <products>
     *              <product name="Soundblaster" type="audio"    id="product10" length="12" />
     *              <product name="Teapot"       type="3d"       id="product13" />
     *              <product name="Coprocessor"  type="chips"    id="product15" />
     *              <product name="Keyboard"     type="input"    id="product17" />
     *              <product name="Diskdrive"    type="storage"  id="product20" />
     *          </products>
     *      </a:model>
     *  </a:list>
     * </code>
     * Example:
     * This example selects a product by it's value and then removes the
     * selection.
     * <code>
     *  <a:script><!--
     *      apf.onload = function() {
     *          myList.setValue("product20");
     *          myList.remove();
     *      }
     *  --></a:script>
     * </code>
     * Example:
     * This example gets a product by it's value and then removes it.
     * <code>
     *  <a:script>
     *      var xmlNode = myList.findXmlNodeByValue("product20");
     *      myList.remove(xmlNode);
     *  </a:script>
     * </code>
     * Example:
     * This example retrieves all nodes from a list. All items with a length
     * greater than 10 are singled out and removed.
     * <code>
     *  <a:script><![CDATA[
     *      apf.onload = function() {
     *          var list = myList.getTraverseNodes();
     * 
     *          var removeList = [];
     *          for (var i = 0; i < list.length; i++) {
     *              if (list[i].getAttribute("length") > 10)
     *                  removeList.push(list[i]);
     *          }
     *          myList.remove(removeList);
     *      }
     *   ]]></a:script>
     * </code>
     * Remarks:
     * Another way to trigger this method is by using the action attribute on a
     * button.
     * <code>
     *  <a:button action="remove" target="myList">Remove item</a:button>
     * </code>
     * Using the action methodology you can let the original data source
     * (usually the server) know that the user removed an item.
     * <code>
     *     <a:list>
     *         <a:bindings />
     *         <a:remove set="remove_product.php?id=[@id]" />
     *     </a:list>
     * </code>
     * For undo this action should be extended and the server should maintain a
     * copy of the deleted item.
     * <code>
     *  <a:list actiontracker="atList">
     *      <a:bindings />
     *      <a:remove set  = "remove_product.php?id=[@id]"
     *                undo = "undo_remove_product.php?id=[@id]" />
     *  </a:list>
     *  <a:button 
     *    action = "remove" 
     *    target = "myList">Remove item</a:button>
     *   <a:button 
     *     caption  = "Undo"
     *     disabled = "{!atList.undolength}" 
     *     onclick  = "atList.undo()" />
     * </code>
     * @action
     * @param  {mixed} [nodeList]  the {@link term.datanode data node}(s) to be removed. If none are specified, the current selection is removed.
     *   Possible values:
     *   {NodeList}   the {@link term.datanode data nodes} to be removed.
     *   {XMLElement} the {@link term.datanode data node} to be removed.
     * @return  {Boolean}  specifies if the removal succeeded
     */
    this.remove = function(nodeList){
        //Use the current selection if no xmlNode is defined
        if (!nodeList)
            nodeList = this.$valueList;

        //If we're an xml node let's convert
        if (nodeList.nodeType)
            nodeList = [nodeList];

        //If there is no selection we'll exit, nothing to do
        if (!nodeList || !nodeList.length)
            return;

        
        //We're not removing the XMLRoot, that would be suicide ;)
        if (nodeList.contains(this.xmlRoot)) {
            throw new Error(apf.formatErrorString(0,
                "Removing nodes",
                "You are trying to delete the xml root of this \
                 element. This is not allowed."));
        }
        

        var changes = [];
        for (var i = 0; i < nodeList.length; i++) {
            changes.push({
                action : "removeNode",
                args   : [nodeList[i]]
            });
        }

        if (this.$actions["removegroup"])
            return this.$executeAction("multicall", changes, "removegroup", nodeList[0]);
        else {
            return this.$executeAction("multicall", changes, "remove", 
              nodeList[0], null, null, nodeList.length > 1 ? nodeList : null);
        }
    };
    
    /**
     * Adds an {@link term.datanode data node} to the data of this element.
     * Example:
     * A simple list showing products. This list is used in all following examples.
     * <code>
     *  <a:list id="myList">
     *      <a:bindings>
     *          <a:caption match="[@name]" />
     *          <a:value match="[@id]" />
     *          <a:icon>[@type].png</a:icon>
     *          <a:each match="[product]" />
     *      </a:bindings>
     *      <a:model>
     *          <products>
     *              <product name="Soundblaster" type="audio"    id="product10" />
     *              <product name="Teapot"       type="3d"       id="product13" />
     *              <product name="Coprocessor"  type="chips"    id="product15" />
     *              <product name="Keyboard"     type="input"    id="product17" />
     *              <product name="Diskdrive"    type="storage"  id="product20" />
     *          </products>
     *      </a:model>
     *  </a:list>
     * </code>
     * Example:
     * This example adds a product to this element.
     * selection.
     * <code>
     *  <a:script><![CDATA[
     *      apf.onload = function() {
     *          myList.add('<product name="USB drive" type="storage" />');
     *      }
     *  ]]></a:script>
     * </code>
     * Example:
     * This example copy's the selected product, changes it's name and then
     * adds it. After selecting the new node the user is offered a rename input
     * box.
     * <code>
     *  <a:script><![CDATA[
     *      apf.onload = function() {
     *          var xmlNode = apf.xmldb.copy(myList.selected);
     *          xmlNode.setAttribute("name", "New product");
     *          myList.add(xmlNode);
     *          myList.select(xmlNode);
     *          myList.startRename();
     *      }
     *  ]]></a:script>
     * </code>
     * Remarks:
     * Another way to trigger this method is by using the action attribute on a
     * button.
     * <code>
     *  <a:list>
     *      <a:bindings />
     *      <a:model />
     *      <a:actions>
     *          <a:add>
     *              <product name="New item" />
     *          </a:add>
     *      </a:actions>
     *  </a:list>
     *  <a:button action="add" target="myList">Add new product</a:button>
     * </code>
     * Using the action methodology you can let the original data source
     * (usually the server) know that the user added an item.
     * <code>
     *  <a:add get="{comm.addProduct()}" />
     * </code>
     * For undo this action should be extended as follows.
     * <code>
     *  <a:list id="myList" actiontracker="atList">
     *      <a:bindings />
     *      <a:model />
     *      <a:actions>
     *          <a:add set  = "add_product.php?xml=%[.]"
     *              undo = "remove_product.php?id=[@id]">
     *              <product name="New product" id="productId" />
     *          </a:add>
     *      </a:actions>
     *  </a:list>
     *  <a:button 
     *    action = "add" 
     *    target = "myList">Add new product</a:button>
     *  <a:button
     *     caption  = "Undo"
     *     disabled = "{!atList.undolength}" 
     *     onclick  = "atList.undo()" />
     * </code>
     * In some cases the server needs to create the new product before it's
     * added. This is done as follows.
     * <code>
     *  <a:add get="{comm.createNewProduct()}" />
     * </code>
     * Alternatively the template for the addition can be provided as a child of
     * the action rule.
     * <code>
     *  <a:add set="add_product.php?xml=%[.]">
     *      <product name="USB drive" type="storage" />
     *  </a:add>
     * </code>
     * @action
     * @param  {XMLElement} [xmlNode]    the {@link term.datanode data node} which is added. If none is specified the action will use the action rule to try to retrieve a new node to add.
     * @param  {XMLElement} [pNode]      the parent node of the added {@link term.datanode data node}.
     * @param  {XMLElement} [beforeNode] the position where the xml element should be inserted.
     * @return  {XMLElement} the added {@link term.datanode data node} or false on failure.
     */
    this.add = function(xmlNode, pNode, beforeNode, userCallback){
        var rule;

        if (this.$actions) {
            if (xmlNode && xmlNode.nodeType)
                rule = this.$actions.getRule("add", xmlNode);
            else if (typeof xmlNode == "string") {
                if (xmlNode.trim().charAt(0) == "<") {
                    xmlNode = apf.getXml(xmlNode);
                    rule = this.$actions.getRule("add", xmlNode);
                }
                else {
                    var rules = this.$actions["add"];
                    for (var i = 0, l = rules.length; i < l; i++) {
                        if (rules[i].getAttribute("type") == xmlNode) {
                            xmlNode = null;
                            rule = rules[i];
                            break;
                        }
                    }
                }
            }

            if (!rule) 
                rule = (this.$actions["add"] || {})[0];
        }
        else
            rule = null;
            
        
        
        var refNode  = this.$isTreeArch ? this.selected || this.xmlRoot : this.xmlRoot,
            amlNode  = this,
        callback = function(addXmlNode, state, extra){
            if (state != apf.SUCCESS) {
                var oError;

                oError = new Error(apf.formatErrorString(1032, amlNode,
                    "Loading xml data",
                    "Could not add data for control " + amlNode.name
                    + "[" + amlNode.tagName + "] \nUrl: " + extra.url
                    + "\nInfo: " + extra.message + "\n\n" + xmlNode));

                if (extra.tpModule.retryTimeout(extra, state, amlNode, oError) === true)
                    return true;

                throw oError;
            }

            /*if (apf.supportNamespaces && node.namespaceURI == apf.ns.xhtml) {
                node = apf.getXml(node.xml.replace(/xmlns\=\"[^"]*\"/g, ""));
                //@todo import here for webkit?
            }*/

            if (typeof addXmlNode != "object")
                addXmlNode = apf.getXmlDom(addXmlNode).documentElement;
            if (addXmlNode.getAttribute(apf.xmldb.xmlIdTag))
                addXmlNode.setAttribute(apf.xmldb.xmlIdTag, "");

            var actionNode = amlNode.$actions &&
              amlNode.$actions.getRule("add", amlNode.$isTreeArch
                ? amlNode.selected
                : amlNode.xmlRoot);
            if (!pNode) {
                if (actionNode && actionNode.parent) {
                    pNode = (actionNode.cparent 
                      || actionNode.compile("parent", {
                        xpathmode  : 2, 
                        injectself : true
                      }))(amlNode.$isTreeArch
                          ? amlNode.selected || amlNode.xmlRoot
                          : amlNode.xmlRoot);
                }
                else {
                    pNode = amlNode.$isTreeArch
                      ? amlNode.selected || amlNode.xmlRoot
                      : amlNode.xmlRoot
                }
            }

            if (!pNode)
                pNode = amlNode.xmlRoot;

            //Safari issue not auto importing nodes:
            if (apf.isWebkit && pNode.ownerDocument != addXmlNode.ownerDocument)
                addXmlNode = pNode.ownerDocument.importNode(addXmlNode, true); 

            
            if (!pNode) {
                throw new Error(apf.formatErrorString(0, amlNode,
                    "Executing add action",
                    "Missing parent node. You can only add nodes to a list if it\
                     has data loaded. Unable to perform action."));
            }
            

            if (amlNode.$executeAction("appendChild",
              [pNode, addXmlNode, beforeNode], "add", addXmlNode) !== false
              && amlNode.autoselect)
                amlNode.select(addXmlNode);

            if (userCallback)
                userCallback.call(amlNode, addXmlNode);

            return addXmlNode;
        };

        if (xmlNode)
            return callback(xmlNode, apf.SUCCESS);
        else {
            if (rule.get)
                return apf.getData(rule.get, {xmlNode: refNode, callback: callback})
            else {
                
                throw new Error(apf.formatErrorString(0, this,
                    "Executing add action",
                    "Missing add action defined in action rules. Unable to \
                     perform action."));
                
            }
        }

        return addXmlNode;
    };

    if (!this.setValue) {
        /**
         * Sets the value of this element.The value
         * corresponds to an item in the list of loaded {@link term.datanode data nodes}. This
         * element will receive the selection. If no {@link term.datanode data node} is found, the
         * selection is cleared.
         *
         * @param  {String}  value  the new value for this element.
         * @param  {Boolean} disable_event
         * @see baseclass.multiselect.method.getValue
         */
        this.setValue = function(value, disable_event){
            // @todo apf3.0 what does noEvent do? in this scope it's useless and
            // doesn't improve codeflow with a global lookup and assignment
            noEvent = disable_event;
            this.setProperty("value", value, false, true);
            noEvent = false;
        };
    }

    /**
     * Retrieves an {@link term.datanode data node} that has a value that corresponds to the
     * string that is searched on.
     * @param {String} value the value to match.
     */
    this.findXmlNodeByValue = function(value){
        var nodes   = this.getTraverseNodes(),
            bindSet = this.$attrBindings["eachvalue"]
                && "eachvalue" || this.$bindings["value"]
                && "value" || this.$hasBindRule("caption") && "caption";
        
        if (!bindSet)
            return false;
            
        for (var i = 0; i < nodes.length; i++) {
            if (this.$applyBindRule(bindSet, nodes[i]) == value)
                return nodes[i];
        }
    };

    if (!this.getValue) {
        /**
         * Retrieves the value of this element. This is the value of the
         * first selected {@link term.datanode data node}.
         * @see #setValue
         */
        this.getValue = function(xmlNode, noError){
            return this.value;
            /*
            if (!this.bindingRules && !this.caption) 
                return false;

            
            if (!this.caption && !this.bindingRules[this.$mainBind] && !this.bindingRules["caption"]) {
                if (noError)
                    return false;
                
                throw new Error(apf.formatErrorString(1074, this,
                    "Retrieving the value of this component.",
                    "No value rule has been defined. There is no way \
                     to determine the value of the selected item."));
            }
            

            return this.$applyBindRule(this.$mainBind, xmlNode || this.selected, null, true)
                || this.$applyBindRule("caption", xmlNode || this.selected, null, true);
            */
        };
    }

    /**
     * Select the current selection again.
     *
     * @todo Add support for multiselect
     */
    this.reselect = function(){
        if (this.selected) this.select(this.selected, null, this.ctrlselect,
            null, true);//no support for multiselect currently.
    };

    /**
     * Selects a single, or set of {@link term.eachnode each nodes}.
     * The selection can be visually represented in this element.
     *
     * @param {mixed}   xmlNode      the identifier to determine the selection.
     *   Possible values:
     *   {XMLElement}  the {@link term.datanode data node} to be used in the selection as a start/end point or to toggle the selection on the node.
     *   {HTMLElement} the html element node used as visual representation of {@link term.datanode data node}. Used to determine the {@link term.datanode data node} for selection.
     *   {String}      the value of the {@link term.datanode data node} to be select.
     * @param {Boolean} [ctrlKey]    whether the Ctrl key was pressed
     * @param {Boolean} [shiftKey]   whether the Shift key was pressed
     * @param {Boolean} [fakeselect] whether only visually a selection is made
     * @param {Boolean} [force]      whether reselect is forced.
     * @param {Boolean} [noEvent]    whether to not call any events
     * @return  {Boolean}  whether the selection could be made
     *
     * @event  beforeselect  Fires before a {@link baseclass.multiselect.method.select selection} is made
     *   object:
     *   {XMLElement}  selected the {@link term.datanode data node} that will be selected.
     *   {Array}       selection an array of {@link term.datanode data node} that will be selected.
     *   {HTMLElement} htmlNode the html element that visually represents the {@link term.datanode data node}.
     * @event  afterselect  Fires after a {@link baseclass.multiselect.method.select selection} is made
     *   object:
     *   {XMLElement}  selected  the {@link term.datanode data node} that was selected.
     *   {Array}       selection an array of {@link term.datanode data node} that are selected.
     *   {HTMLElement} htmlNode the html element that visually represents the {@link term.datanode data node}.
     */
    this.select  = function(xmlNode, ctrlKey, shiftKey, fakeselect, force, noEvent, userAction){
        if (!this.selectable || userAction && this.disabled || this.editable) 
            return;
        
        if (fakeselect == -1) {
	      	fakeselect = false;
	      	userAction = true;
        }

        if (this.$skipSelect) {
            this.$skipSelect = false;
            return;
        }

        if (this.ctrlselect && !shiftKey)
            ctrlKey = true;

        if (!this.multiselect)
            ctrlKey = shiftKey = false;
        
        // Selection buffering (for async compatibility)
        if (!this.xmlRoot) {
            if (!this.$buffered) {
                var f;
                this.addEventListener("afterload", f = function(){
                    this.select.apply(this, this.$buffered);
                    this.removeEventListener("afterload", f);
                    delete this.$buffered;
                });
            }

            this.$buffered = Array.prototype.slice.call(arguments);
            return;
        }

        var htmlNode;

        /**** Type Detection ****/
        if (!xmlNode) {
            
            throw new Error(apf.formatErrorString(1075, this,
                "Making a selection",
                "No selection was specified"))
            

            return false;
        }

        if (typeof xmlNode != "object") {
            var str = xmlNode; xmlNode = null;
            if (typeof xmlNode == "string")
                xmlNode = apf.xmldb.getNodeById(str);

            //Select based on the value of the xml node
            if (!xmlNode) {
                xmlNode = this.findXmlNodeByValue(str);
                if (!xmlNode) {
                    this.clearSelection(noEvent);
                    return;
                }
            }
        }
        
        if (!xmlNode.style) {
            htmlNode = this.$findHtmlNode(xmlNode.getAttribute(
                    apf.xmldb.xmlIdTag) + "|" + this.$uniqueId);
        }
        else {
            var id = (htmlNode = xmlNode).getAttribute(apf.xmldb.htmlIdTag);
            while (!id && htmlNode.parentNode)
                id = (htmlNode = htmlNode.parentNode).getAttribute(
                    apf.xmldb.htmlIdTag);

            xmlNode = apf.xmldb.getNodeById(id);//, this.xmlRoot);
        }
        
        if (!shiftKey && !ctrlKey && !force && !this.reselectable 
          && this.$valueList.length <= 1 && this.$valueList.indexOf(xmlNode) > -1)
            return;

        if (this.dispatchEvent('beforeselect', {
            selected    : xmlNode,
            htmlNode    : htmlNode,
            ctrlKey     : ctrlKey,
            shiftKey    : shiftKey,
            force       : force,
            captureOnly : noEvent
        }) === false)
              return false;

        /**** Selection ****/

        var lastIndicator = this.caret;
        this.caret        = xmlNode;

        //Multiselect with SHIFT Key.
        if (shiftKey) {
            var range = this.$calcSelectRange(
              this.$valueList[0] || lastIndicator, xmlNode);

            if (this.$caret)
                this.$deindicate(this.$caret);

            this.selectList(range);

            this.$selected  =
            this.$caret     = this.$indicate(htmlNode);
        }
        else if (ctrlKey) { //Multiselect with CTRL Key.
            //Node will be unselected
            if (this.$valueList.contains(xmlNode)) {
                if (this.selected == xmlNode) {
                    this.$deselect(this.$findHtmlNode(this.selected.getAttribute(
                        apf.xmldb.xmlIdTag) + "|" + this.$uniqueId));
                    
                    this.$deindicate(this.$caret);

                    if (this.$valueList.length && !fakeselect) {
                        //this.$selected = this.$selectedList[0];
                        this.selected = this.$valueList[0];
                    }
                }
                else
                    this.$deselect(htmlNode, xmlNode);

                if (!fakeselect) {
                    this.$selectedList.remove(htmlNode);
                    this.$valueList.remove(xmlNode);
                }

                if (htmlNode != this.$caret)
                    this.$deindicate(this.$caret);

                this.$selected  =
                this.$caret     = this.$indicate(htmlNode);
            }
            // Node will be selected
            else {
                if (this.$caret)
                    this.$deindicate(this.$caret);
                this.$caret = this.$indicate(htmlNode, xmlNode);

                this.$selected   = this.$select(htmlNode, xmlNode);
                this.selected    = xmlNode;

                if (!fakeselect) {
                    this.$selectedList.push(htmlNode);
                    this.$valueList.push(xmlNode);
                }
            }
        }
        else if (fakeselect && htmlNode && this.$selectedList.contains(htmlNode)) {//Return if selected Node is htmlNode during a fake select
            return;
        }
        else { //Normal Selection
            //htmlNode && this.$selected == htmlNode && this.$valueList.length <= 1 && this.$selectedList.contains(htmlNode)
            if (this.$selected)
                this.$deselect(this.$selected);
            if (this.$caret)
                this.$deindicate(this.$caret);
            if (this.selected)
                this.clearSelection(true);

            this.$caret = this.$indicate(htmlNode, xmlNode);
            this.$selected  = this.$select(htmlNode, xmlNode);
            this.selected   = xmlNode;

            this.$selectedList.push(htmlNode);
            this.$valueList.push(xmlNode);
        }

        if (this.delayedselect && (typeof ctrlKey == "boolean")){
            var _self = this;
            $setTimeout(function(){
                _self.dispatchEvent("afterselect", {
                    selection   : _self.$valueList,
                    selected    : xmlNode,
                    caret       : _self.caret,
                    captureOnly : noEvent
                });
            }, 10);
        }
        else {
            this.dispatchEvent("afterselect", {
                selection   : this.$valueList,
                selected    : xmlNode,
                caret       : this.caret,
                captureOnly : noEvent
            });
        }

        return true;
    };

    /**
     * Choose a selected item. This is done by double clicking on the item or
     * pressing the Enter key.
     *
     * @param {mixed}   xmlNode      the identifier to determine the selection.
     *   Possible values:
     *   {XMLElement}  the {@link term.datanode data node} to be choosen.
     *   {HTMLElement} the html element node used as visual representation of {@link term.datanode data node}. Used to determine the {@link term.datanode data node}.
     *   {String}      the value of the {@link term.datanode data node} to be choosen.
     * @event  beforechoose  Fires before a choice is made.
     *   object:
     *   {XMLElement} xmlNode   the {@link term.datanode data node} that was choosen.
     * @event  afterchoose   Fires after a choice is made.
     *   object:
     *   {XMLElement} xmlNode   the {@link term.datanode data node} that was choosen.
     */
    this.choose = function(xmlNode, userAction){
        if (!this.selectable || userAction && this.disabled) return;

        if (this.dispatchEvent("beforechoose", {xmlNode : xmlNode}) === false)
            return false;

        if (xmlNode && !xmlNode.style)
            this.select(xmlNode);

        
        if (this.hasFeature(apf.__DATABINDING__)
          && this.dispatchEvent("afterchoose", {xmlNode : this.selected}) !== false)
            this.setProperty("chosen", this.selected);
        
    };

    /**
     * Removes the selection of one or more selected nodes.
     *
     * @param {Boolean} [singleNode] whether to only deselect the indicated node
     * @param {Boolean} [noEvent]    whether to not call any events
     */
    this.clearSelection = function(noEvent, userAction){
        if (!this.selectable || userAction && this.disabled || !this.$valueList.length)
            return;

        if (!noEvent) {
            if (this.dispatchEvent("beforeselect", {
                selection : [],
                selected  : null,
                caret     : this.caret
            }) === false)
                return false;
        }
        
        //Deselect html nodes
        var htmlNode;
        for (var i = this.$valueList.length - 1; i >= 0; i--) {
            htmlNode = this.$findHtmlNode(this.$valueList[i].getAttribute(
                    apf.xmldb.xmlIdTag) + "|" + this.$uniqueId);
            this.$deselect(htmlNode);
        }
        
        //Reset internal variables
        this.$selectedList.length = 0;
        this.$valueList.length    = 0;
        this.$selected            =
        this.selected             = null;

        //Redraw indicator
        if (this.caret) {
            htmlNode = this.$findHtmlNode(this.caret.getAttribute(
                    apf.xmldb.xmlIdTag) + "|" + this.$uniqueId);

            this.$caret = this.$indicate(htmlNode);
        }

        if (!noEvent) {
            this.dispatchEvent("afterselect", {
                selection : this.$valueList,
                selected  : null,
                caret     : this.caret
            });
        }
    };

    /**
     * Selects a set of items
     *
     * @param {Array} xmlNodeList the {@link term.datanode data nodes} that will be selected.
     */
    //@todo I think there are missing events here?
    this.selectList = function(xmlNodeList, noEvent, selected, userAction){
        if (!this.selectable || userAction && this.disabled) return;

        if (this.dispatchEvent("beforeselect", {
            selection   : xmlNodeList,
            selected    : selected || xmlNodeList[0],
            caret       : this.caret,
            captureOnly : noEvent
          }) === false)
            return false;

        this.clearSelection(true);

        for (var sel, i = 0; i < xmlNodeList.length; i++) {
            //@todo fix select state in unserialize after removing
            if (!xmlNodeList[i] || xmlNodeList[i].nodeType != 1) continue;
            var htmlNode,
                xmlNode = xmlNodeList[i];

            //Type Detection
            if (typeof xmlNode != "object")
                xmlNode = apf.xmldb.getNodeById(xmlNode);
            if (!xmlNode.style)
                htmlNode = this.$pHtmlDoc.getElementById(xmlNode.getAttribute(
                    apf.xmldb.xmlIdTag) + "|" + this.$uniqueId);
            else {
                htmlNode = xmlNode;
                xmlNode  = apf.xmldb.getNodeById(htmlNode.getAttribute(
                    apf.xmldb.htmlIdTag));
            }

            if (!xmlNode) {
                
                apf.console.warn("Component : " + this.name + " ["
                    + this.localName + "]\nMessage : xmlNode whilst selecting a "
                    + "list of xmlNodes could not be found. Ignoring.")
                
                continue;
            }

            //Select Node
            if (htmlNode) {
                if (!sel && selected == htmlNode)
                    sel = htmlNode;

                this.$select(htmlNode, xmlNode);
                this.$selectedList.push(htmlNode);
            }
            this.$valueList.push(xmlNode);
        }

        this.$selected = sel || this.$selectedList[0];
        this.selected  = selected || this.$valueList[0];

        this.dispatchEvent("afterselect", {
            selection   : this.$valueList,
            selected    : this.selected,
            caret       : this.caret,
            captureOnly : noEvent
        });
    };

    /**
     * Sets the {@link term.caret caret} on an item to indicate to the user that the keyboard
     * actions are done relevant to that item. Using the keyboard
     * a user can change the position of the indicator using the Ctrl and arrow
     * keys while not making a selection. When making a selection with the mouse
     * or keyboard the indicator is always set to the selected node. Unlike a
     * selection there can be only one indicator item.
     *
     * @param {mixed}   xmlNode      the identifier to determine the indicator.
     *   Possible values:
     *   {XMLElement}  the {@link term.datanode data node} to be set as indicator.
     *   {HTMLElement} the html element node used as visual representation of
     *                 {@link term.datanode data node}. Used to determine the {@link term.datanode data node}.
     *   {String}      the value of the {@link term.datanode data node} to be set as indicator.
     * @event indicate Fires when an item becomes the indicator.
     */
    this.setCaret = function(xmlNode){
        if (!xmlNode) {
            if (this.$caret)
                this.$deindicate(this.$caret);
            this.caret  =
            this.$caret = null;
            return;
        }

        /**** Type Detection ****/
        var htmlNode;
        if (typeof xmlNode != "object")
            xmlNode = apf.xmldb.getNodeById(xmlNode);
        if (!xmlNode.style) {
            htmlNode = this.$findHtmlNode(xmlNode.getAttribute(
                    apf.xmldb.xmlIdTag) + "|" + this.$uniqueId);
        }
        else {
            var id = (htmlNode = xmlNode).getAttribute(apf.xmldb.htmlIdTag);
            while (!id && htmlNode.parentNode)
                id = (htmlNode = htmlNode.parentNode).getAttribute(
                    apf.xmldb.htmlIdTag);

            xmlNode = apf.xmldb.getNodeById(id);
        }

        if (this.$caret) {
            //this.$deindicate(this.$findHtmlNode(this.caret.getAttribute(
                //apf.xmldb.xmlIdTag) + "|" + this.$uniqueId));
            this.$deindicate(this.$caret);
        }
        
        this.$caret = this.$indicate(htmlNode);
        this.setProperty("caret", this.caret = xmlNode);
    };

    /**
     * @private
     */
    this.$setTempSelected = function(xmlNode, ctrlKey, shiftKey, down){
        clearTimeout(this.timer);

        if (this.$bindings.selectable) {
            while (xmlNode && !this.$getDataNode("selectable", xmlNode)) {
                xmlNode = this.getNextTraverseSelected(xmlNode, !down);
            }
            if (!xmlNode) return;
        }

        if (!this.multiselect)
            ctrlKey = shiftKey = false;

        if (ctrlKey || this.ctrlselect) {
            if (this.$tempsel) {
                this.select(this.$tempsel);
                this.$tempsel = null;
            }

            this.setCaret(xmlNode);
        }
        else if (shiftKey){
            if (this.$tempsel) {
                this.$selectTemp();
                this.$deselect(this.$tempsel);
                this.$tempsel = null;
            }

            this.select(xmlNode, null, shiftKey);
        }
        else if (!this.bufferselect || this.$valueList.length > 1) {
            this.select(xmlNode);
        }
        else {
            var id = apf.xmldb.getID(xmlNode, this);

            this.$deselect(this.$tempsel || this.$selected);
            this.$deindicate(this.$tempsel || this.$caret);
            this.$tempsel = this.$indicate(document.getElementById(id));
            this.$select(this.$tempsel);

            var _self = this;
            this.timer = $setTimeout(function(){
                _self.$selectTemp();
            }, 400);
        }
    };

    /**
     * @private
     */
    this.$selectTemp = function(){
        if (!this.$tempsel)
            return;

        clearTimeout(this.timer);
        this.select(this.$tempsel);

        this.$tempsel = null;
        this.timer    = null;
    };

    /**
     * Selects all the {@link term.eachnode each nodes} of this element
     *
     */
    this.selectAll = function(userAction){
        if (!this.multiselect || !this.selectable
          || userAction && this.disabled || !this.xmlRoot)
            return;

        var nodes = this.$isTreeArch
            ? this.xmlRoot.selectNodes(".//" 
              + this.each.split("|").join("|.//"))
            : this.xmlRoot.selectNodes(this.each);
        
        this.selectList(nodes);
    };

    /**
     * Retrieves an array or a document fragment containing all the selected
     * {@link term.datanode data nodes} from this element.
     *
     * @param {Boolean} [xmldoc] whether the method should return a document fragment.
     * @return {mixed} the selection of this element.
     */
    this.getSelection = function(xmldoc){
        var i, r;
        if (xmldoc) {
            r = this.xmlRoot
                ? this.xmlRoot.ownerDocument.createDocumentFragment()
                : apf.getXmlDom().createDocumentFragment();
            for (i = 0; i < this.$valueList.length; i++)
                apf.xmldb.cleanNode(r.appendChild(
                    this.$valueList[i].cloneNode(true)));
        }
        else {
            for (r = [], i = 0; i < this.$valueList.length; i++)
                r.push(this.$valueList[i]);
        }

        return r;
    };
    
    this.$getSelection = function(htmlNodes){
        return htmlNodes ? this.$selectedList : this.$valueList;
    };

    /**
     * Selects the next {@link term.datanode data node} to be selected.
     *
     * @param  {XMLElement}  xmlNode  the context {@link term.datanode data node}.
     * @param  {Boolean}     isTree
     */
    this.defaultSelectNext = function(xmlNode, isTree){
        var next = this.getNextTraverseSelected(xmlNode);
        //if(!next && xmlNode == this.xmlRoot) return;

        //Why not use this.$isTreeArch ??
        if (next || !isTree)
            this.select(next ? next : this.getTraverseParent(xmlNode));
        else
            this.clearSelection(true);
    };

    /**
     * Selects the next {@link term.datanode data node} when available.
     */
    this.selectNext = function(){
        var xmlNode = this.getNextTraverse();
        if (xmlNode)
            this.select(xmlNode);
    };

    /**
     * Selects the previous {@link term.datanode data node} when available.
     */
    this.selectPrevious = function(){
        var xmlNode = this.getNextTraverse(null, -1);
        if (xmlNode)
            this.select(xmlNode);
    };

    /**
     * @private
     */
    this.getDefaultNext = function(xmlNode, isTree){  //@todo why is isTree an argument
        var next = this.getNextTraverseSelected(xmlNode);
        //if(!next && xmlNode == this.xmlRoot) return;

        return (next && next != xmlNode)
            ? next
            : (isTree
                ? this.getTraverseParent(xmlNode)
                : null); //this.getFirstTraverseNode()
    };

    /**
     * Determines whether a node is selected.
     *
     * @param  {XMLElement} xmlNode  The {@link term.datanode data node} to be checked.
     * @return  {Boolean} whether the element is selected.
     */
    this.isSelected = function(xmlNode){
        if (!xmlNode) return false;

        for (var i = 0; i < this.$valueList.length; i++) {
            if (this.$valueList[i] == xmlNode)
                return this.$valueList.length;
        }

        return false;
    };

    /**
     * This function checks whether the current selection is still correct.
     * Selection can become invalid when updates to the underlying data
     * happen. For instance when a selected node is removed.
     */
    this.$checkSelection = function(nextNode){
        if (this.$valueList.length > 1) {
            //Fix selection if needed
            for (var lst = [], i = 0, l = this.$valueList.length; i < l; i++) {
                if (apf.isChildOf(this.xmlRoot, this.$valueList[i]))
                    lst.push(this.$valueList[i]);
            }

            if (lst.length > 1) {
                this.selectList(lst);
                if(this.caret
                  && !apf.isChildOf(this.xmlRoot, this.caret)) {
                    this.setCaret(nextNode || this.selected);
                }
                return;
            }
            else if (lst.length) {
                //this.clearSelection(true); //@todo noEvents here??
                nextNode = lst[0];
            }
        }

        if (!nextNode) {
            if (this.selected
              && !apf.isChildOf(this.xmlRoot, this.selected)) {
                nextNode = this.getFirstTraverseNode();
            }
            else if(this.selected && this.caret
              && !apf.isChildOf(this.xmlRoot, this.caret)) {
                this.setCaret(this.selected);
            }
            else if (!this.selected){
                nextNode = this.xmlRoot
                    ? this.getFirstTraverseNode()
                    : null;
            }
            else {
                return; //Nothing to do
            }
        }

        if (nextNode) {
            if (this.autoselect) {
                this.select(nextNode);
            }
            else {
                if (!this.multiselect)
                    this.clearSelection();
                this.setCaret(nextNode);
            }
        }
        else
            this.clearSelection();

        //if(action == "synchronize" && this.autoselect) this.reselect();
    };

    /**
     * @attribute {Boolean} [multiselect]   whether the user may select multiple items. Default is true, false for dropdown. 
     * @attribute {Boolean} [autoselect]    whether a selection is made after data is loaded. Default is true, false for dropdown. When the string 'all' is set, all {@link term.datanode data nodes} are selected.
     * @attribute {Boolean} [selectable]    whether the {@link term.datanode data nodes} of this element can be selected. Default is true.
     * @attribute {Boolean} [ctrlselect]    whether when a selection is made as if the user is holding the Ctrl key. When set to true each mouse selection will add to the current selection. selecting an already selected element will deselect it.
     * @attribute {Boolean} [allowdeselect] whether the user can remove the selection of this element. When set to true it is possible for this element to have no selected {@link term.datanode data node}.
     * @attribute {Boolean} [reselectable]  whether selected nodes can be selected again and the selection events are called again. Default is false. When set to false a selected {@link term.datanode data node} cannot be selected again.
     * @attribute {String}  [default]       the value that this component has when no selection is made.
     * @attribute {String}  [eachvalue]     the {@link term.expression expression} that determines the value for each {@link term.datanode data nodes} in the dataset of the element.
     * Remarks:
     * 
     * Example:
     *
     * @see baseclass.multiselect.attribute.eachvalue
     */
    this.selectable = true;
    if (typeof this.ctrlselect == "undefined")
        this.ctrlselect = false;
    if (typeof this.multiselect == "undefined")
        this.multiselect = true;
    if (typeof this.autoselect == "undefined")
        this.autoselect = true;
    if (typeof this.delayedselect == "undefined")
        this.delayedselect = true;
    if (typeof this.allowdeselect == "undefined")
        this.allowdeselect = true;
    this.reselectable = false;

    this.$booleanProperties["selectable"]    = true;
    //this.$booleanProperties["ctrlselect"]    = true;
    this.$booleanProperties["multiselect"]   = true;
    this.$booleanProperties["autoselect"]    = true;
    this.$booleanProperties["delayedselect"] = true;
    this.$booleanProperties["allowdeselect"] = true;
    this.$booleanProperties["reselectable"]  = true;

    this.$supportedProperties.push("selectable", "ctrlselect", "multiselect",
        "autoselect", "delayedselect", "allowdeselect", "reselectable", 
        "selection", "selected", "default", "value", "caret");

    /**
     * @attribute {String} [value]   the value of the element that is selected.
     * Remarks:
     * 
     * Example:
     *
     * @see baseclass.multiselect.attribute.eachvalue
     */
    //@todo add check here
    this.$propHandlers["value"] = function(value){
        if (this.$lastValue == value) {
            delete this.$lastValue;
            return;
        }

        if (!this.$attrBindings["eachvalue"] && !this.$amlLoaded
          && this.getAttribute("eachvalue")) {
            var _self = this;
            return apf.queue.add("value" + this.$uniqueId, function(){
                _self.$propHandlers["value"].call(_self, value);
            });
        }
        
        
        var rule = this.$getBindRule("value", this.xmlRoot);
        if (rule) {
            /*var compiled = rule.cvalue || rule.cmatch;
            if (compiled.type != 3) {
                throw new Error(apf.formatErrorString(0,
                    "Setting value attribute",
                    "Value attribute does not have legal value."));
            }*/
            if (rule.models[0] == this.$model) {
                throw new Error(apf.formatErrorString(0, this,
                    "Setting value attribute",
                    "Value should not point to the same model where the items\
                     are loaded from. Please use value=\"[mdlName::xpath]\" to\
                     specify the value. Use selected=\"[xpath]\" to just select\
                     a node without making a databinding to it."));
            }
        }
        

        if (value || value === 0 || this["default"])
            this.select(String(value) || this["default"]);
        else
            this.clearSelection();
    }
    
    this.$propHandlers["default"] = function(value, prop){
        if (!this.value || !this.$amlLoaded && !(this.getAttribute("value") 
          || this.getAttribute("selected") || this.getAttribute("selection"))) {
            this.$propHandlers["value"].call(this, "");
        }
    }
    
    /**
     * @attribute {String} [value]   the value of the element that is selected.
     * Remarks:
     * 
     * Example:
     *
     * @see baseclass.multiselect.attribute.selected, baseclass.multiselect.attribute.selection
     */
    //@todo fill this in
    this.$propHandlers["caret"] = function(value, prop){
        if (value)
            this.setCaret(value);
    }
    
    
    
    //@todo optimize this thing. Also implement virtual dataset support.
    /**
     * @attribute {String} [selection]   the {@link term.expression expression} that determines the selection for this element. A reference to an xml nodelist can be passed as well.
     * Remarks:
     * 
     * Example:
     *
     * @see baseclass.multiselect.attribute.selected, baseclass.multiselect.attribute.selection
     */
    this.$propHandlers["selection"] = 
    
    /**
     * @attribute {String} [selected]   the {@link term.expression expression} that determines the selected node for this element. A reference to an xml element can be passed as well.
     * Remarks:
     * 
     * Example:
     *
     * @see baseclass.multiselect.attribute.selected, baseclass.multiselect.attribute.selection
     */
    this.$propHandlers["selected"] = function(value, prop) {
        if (!value) value = this[prop] = null;

        if (prop == "selected" && typeof value != "string" && value == this.selected) {
            this.selected = null;
            return;
        }
        
        
        if (prop == "selection" && (this.getAttribute("selection") || "*").substr(0, 1) != "*"){
            apf.console.warn("Selection attribute (" + this.getAttributeNode("selection") 
                + ") should select multiple nodes. Please prefix xpath query with a * (ex.: *[item]).");
        }
        

        if (this.$isSelecting) {
            this.selection = this.$valueList;
            return false;
        }

        var nodes, bindSet, getValue, i, j, c, d;
        //Update the selection
        if (prop == "selection") {
            if (typeof value == "object" && value == this.$valueList) {
                var pNode;
                //We're using an external model. Need to update bound nodeset
                if ((c = this.$attrBindings[prop]) && c.cvalue.models) { //added check, @todo whats up with above assumption?
                    this.$isSelecting = true; //Prevent reentrance (optimization)
    
                    bindSet = this.$attrBindings["eachvalue"] 
                        && "eachvalue" || this.$bindings["value"]
                        && "value" || this.$hasBindRule("caption") && "caption";
                    
                    if (!bindSet)
                        throw new Error("Missing bind rule set: eachvalue, value or caption");//@todo apf3.0 make this into a proper error
                    
                    //@todo this may be optimized by keeping a copy of the selection
                    var selNodes = this.$getDataNode(prop, this.xmlRoot);
                    nodes        = value;
                    getValue     = (d = this.$attrBindings["selection-unique"]) && d.cvalue;
                    
                    if (selNodes.length) {
                        pNode = selNodes[0].parentNode;
                    }
                    else {
                        var model, path;
                        if (c.cvalue.xpaths[0] == "#" || c.cvalue.xpaths[1] == "#") {
                            var m = (c.cvalue3 || (c.cvalue3 = apf.lm.compile(c.value, {
                                xpathmode: 5
                            })))(this.xmlRoot);
                            
                            model = m.model && m.model.$isModel && m.model;
                            if (model)
                                path = m.xpath;
                            else if (m.model) {
                                model = apf.xmldb.findModel(m.model);
                                path = apf.xmlToXpath(m.model, model.data) + (m.xpath ? "/" + m.xpath : ""); //@todo make this better
                            }
                            else {
                                //No selection - nothing to do
                            }
                        }
                        else {
                            model = apf.nameserver.get("model", c.cvalue.xpaths[0]);
                            path  = c.cvalue.xpaths[1];
                        }

                        if (!model || !model.data) {
                            this.$isSelecting = false;
                            return false;
                        }
                        
                        pNode = model.queryNode(path.replace(/\/[^\/]+$|^[^\/]*$/, "") || ".");

                        if (!pNode)
                            throw new Error("Missing parent node"); //@todo apf3.0 make this into a proper error
                    }
                    
                    //Nodes removed
                    remove_loop:
                    for (i = 0; i < selNodes.length; i++) {
                        //Value is either determined by special property or in the 
                        //same way as the value for the bound node.
                        value = getValue 
                          ? getValue(selNodes[i]) 
                          : this.$applyBindRule(bindSet, selNodes[i]);
    
                        //Compare the value with the traverse nodes
                        for (j = 0; j < nodes.length; j++) {
                            if (this.$applyBindRule(bindSet, nodes[j]) == value) //@todo this could be cached
                                continue remove_loop;
                        }
                        
                        //remove node
                        apf.xmldb.removeNode(selNodes[i]);
                    }
                    
                    //Nodes added
                    add_loop:
                    for (i = 0; i < nodes.length; i++) {
                        //Value is either determined by special property or in the 
                        //same way as the value for the bound node.
                        value = this.$applyBindRule(bindSet, nodes[i]);
    
                        //Compare the value with the traverse nodes
                        for (j = 0; j < selNodes.length; j++) {
                            if (getValue 
                              ? getValue(selNodes[j]) 
                              : this.$applyBindRule(bindSet, selNodes[j]) == value) //@todo this could be cached
                                continue add_loop;
                        }
                        
                        //add node
                        var node = this.$attrBindings["selection-constructor"] 
                          && this.$getDataNode("selection-constructor", nodes[i])
                          || apf.getCleanCopy(nodes[i]);
                        apf.xmldb.appendChild(pNode, node);
                    }
                    
                    //@todo above changes should be via the actiontracker
                    this.$isSelecting = false;
                }
                
                return;
            }
            this.selection = this.$valueList;
        }
        else {
            this.selected = null;
        }
        
        if (!this.xmlRoot) {
            if (!this.$buffered) {
                var f;
                this.addEventListener("afterload", f = function(){
                    this.removeEventListener("afterload", f);
                    this.$propHandlers["selected"].call(this, value, prop);
                    delete this.$buffered;
                });
                this.$buffered = true;
            }
            this[prop] = null;
            return false;
        }

        if (!value || typeof value != "object") {
            //this[prop] = null;

            if (this.$attrBindings[prop]) {
                //Execute the selection query
                nodes = this.$getDataNode(prop, this.xmlRoot);
                if (nodes)
                    this.setProperty("selection", nodes);
                
                //Current model, it's an init selection, we'll clear the bind
                /*if (typeof value == "string" 
                  && !this.$attrBindings[prop].cvalue.xpaths[0]) {
                    this.$removeAttrBind(prop);
                }*/
            }
            else if (!value) {
                this.clearSelection();
            }
            else {
                this.select(value);
            }

            return false; //Disable signalling the listeners to this property
        }
        else if (typeof value.length == "number") {
            nodes = value;
            if (!nodes.length) {
                this.selected = null;
                if (this.$valueList.length) { //dont clear selection when no selection exists (at prop init)
                    this.clearSelection();
                    return false; //Disable signalling the listeners to this property
                }
                else return;
            }
            
            //For when nodes are traverse nodes of this element
            if (this.isTraverseNode(nodes[0]) 
              && apf.isChildOf(this.xmlRoot, nodes[0])) {
                if (!this.multiselect) {
                    this.select(nodes[0]);
                }
                else {
                    //this[prop] = null; //??
                    this.selectList(nodes);
                }
                return false; //Disable signalling the listeners to this property
            }
            
            //if external model defined, loop through items and find mate by value
            if (this.$attrBindings[prop]) { //Can assume an external model is in place
                bindSet = this.$attrBindings["eachvalue"] 
                    && "eachvalue" || this.$bindings["value"]
                    && "value" || this.$hasBindRule("caption") && "caption";
                
                if (!bindSet)
                    throw new Error("Missing bind rule set: eachvalue, value or caption");//@todo apf3.0 make this into a proper error
                
                var tNodes = !this.each 
                    ? this.getTraverseNodes()
                    : this.xmlRoot.selectNodes("//" + this.each.split("|").join("|//"));
                
                getValue = (c = this.$attrBindings["selection-unique"]) && c.cvalue;
                var selList  = [];
                for (i = 0; i < nodes.length; i++) {
                    //Value is either determined by special property or in the 
                    //same way as the value for the bound node.
                    value = getValue 
                        ? getValue(nodes[i]) 
                        : this.$applyBindRule(bindSet, nodes[i]);

                    //Compare the value with the traverse nodes
                    for (j = 0; j < tNodes.length; j++) {
                        if (this.$applyBindRule(bindSet, tNodes[j]) == value) //@todo this could be cached
                            selList.push(tNodes[j]);
                    }
                }
                
                //this[prop] = null; //???
                this.selectList(selList, true); //@todo noEvent to distinguish between user actions and not user actions... need to rethink this
                return false;
            }
            
            throw new Error("Show me which case this is");
        }
        else if (this.$valueList.indexOf(value) == -1) {
            //this.selected = null;
            this.select(value);
        }
    };
    
    
    
    this.$propHandlers["allowdeselect"] = function(value){
        if (value) {
            var _self = this;
            this.$container.onmousedown = function(e){
                if (!e)
                    e = event;
                if (e.ctrlKey || e.shiftKey)
                    return;

                var srcElement = e.srcElement || e.target;
                if (_self.allowdeselect && (srcElement == this
                  || srcElement.getAttribute(apf.xmldb.htmlIdTag)))
                    _self.clearSelection(); //hacky
            }
        }
        else {
            this.$container.onmousedown = null;
        }
    };

    this.$propHandlers["ctrlselect"] = function(value){
        if (value != "enter")
            this.ctrlselect = apf.isTrue(value);
    }

    function fAutoselect(){
        this.selectAll();
    }
    
    this.$propHandlers["autoselect"] = function(value){
        if (value == "all" && this.multiselect)
            this.addEventListener("afterload", fAutoselect);
        else
            this.removeEventListener("afterload", fAutoselect);
    };

    this.$propHandlers["multiselect"] = function(value){
        if (!value && this.$valueList.length > 1)
            this.select(this.selected);

        //if (value)
            //this.bufferselect = false; //@todo doesn't return to original value
    };

    // Select Bind class
    
    this.addEventListener("beforeselect", function(e){
        if (this.$bindings.selectable && !this.$getDataNode("selectable", e.selected))
            return false;
    }, true);
    

    
    this.addEventListener("afterselect", function (e){
        
        var combinedvalue = null;

        
        //@todo refactor below
        /*if (this.caret == this.selected || e.list && e.list.length > 1 && hasConnections) {
            //Multiselect databinding handling... [experimental]
            if (e.list && e.list.length > 1 && this.$getConnections().length) { //@todo this no work no more apf3.0
                var oEl  = this.xmlRoot.ownerDocument.createElement(this.selected.tagName);
                var attr = {};

                //Fill basic nodes
                var nodes = e.list[0].attributes;
                for (var j = 0; j < nodes.length; j++)
                    attr[nodes[j].nodeName] = nodes[j].nodeValue;

                //Remove nodes
                for (var prop, i = 1; i < e.list.length; i++) {
                    for (prop in attr) {
                        if (typeof attr[prop] != "string") continue;

                        if (!e.list[i].getAttributeNode(prop))
                            attr[prop] = undefined;
                        else if(e.list[i].getAttribute(prop) != attr[prop])
                            attr[prop] = "";
                    }
                }

                //Set attributes
                for (prop in attr) {
                    if (typeof attr[prop] != "string") continue;
                    oEl.setAttribute(prop, attr[prop]);
                }

                //missing is childnodes... will implement later when needed...

                oEl.setAttribute(apf.xmldb.xmlIdTag, this.$uniqueId);
                apf.MultiSelectServer.register(oEl.getAttribute(apf.xmldb.xmlIdTag),
                    oEl, e.list, this);
                apf.xmldb.addNodeListener(oEl, apf.MultiSelectServer);

                combinedvalue = oEl;
            }
        }*/
        
        
        //Set caret property
        this.setProperty("caret", e.caret);
        
        //Set selection length
        if (this.sellength != e.selection.length)
            this.setProperty("sellength", e.selection.length);
        
        //Set selection property
        delete this.selection;
        this.setProperty("selection", e.selection);
        if (!e.selection.length) {
            //Set selected property
            this.setProperty("selected", e.selected);
            
            //Set value property
            if (this.value)
                this.setProperty("value", "");
        }
        else {
            //Set selected property
            this.$chained = true;
            if (!e.force && (!this.dataParent || !this.dataParent.parent.$chained)) {
                var _self = this;
                $setTimeout(function(){
                    
                    _self.setProperty("selected", combinedvalue || e.selected);
                    
                    delete _self.$chained;
                }, 10);
            }
            else {
                
                this.setProperty("selected", combinedvalue || e.selected);
                
                delete this.$chained;
            }
            
            //Set value property
            var valueRule = this.$attrBindings["eachvalue"] && "eachvalue" 
                || this.$bindings["value"] && "value" 
                || this.$hasBindRule("caption") && "caption";

            if (valueRule) {
                //@todo this will call the handler again - should be optimized

                this.$lastValue = this.$applyBindRule(valueRule, e.selected)
                //this.$attrBindings["value"] && 
                if (this.$lastValue != 
                  (valueRule != "value" && (this.xmlRoot
                  && this.$applyBindRule("value", this.xmlRoot, null, true)) 
                  || this.value)) {
                    if (valueRule == "eachvalue" || this.xmlRoot != this)
                        this.change(this.$lastValue);
                    else
                        this.setProperty("value", this.$lastValue);
                }
                /*else {
                    this.setProperty("value", this.$lastValue);
                }*/
                delete this.$lastValue;
            }
        }
        
        

        
    }, true);
    
    
    

}).call(apf.MultiSelect.prototype = new apf.MultiselectBinding());



//@todo refactor below
/**
 * @private
 */
/*
apf.MultiSelectServer = {
    objects : {},

    register : function(xmlId, xmlNode, selList, jNode){
        if (!this.$uniqueId)
            this.$uniqueId = apf.all.push(this) - 1;

        this.objects[xmlId] = {
            xml   : xmlNode,
            list  : selList,
            jNode : jNode
        };
    },

    $xmlUpdate : function(action, xmlNode, listenNode, UndoObj){
        if (action != "attribute") return;

        var data = this.objects[xmlNode.getAttribute(apf.xmldb.xmlIdTag)];
        if (!data) return;

        var nodes = xmlNode.attributes;

        for (var j = 0; j < data.list.length; j++) {
            //data[j].setAttribute(UndoObj.name, xmlNode.getAttribute(UndoObj.name));
            apf.xmldb.setAttribute(data.list[j], UndoObj.name,
                xmlNode.getAttribute(UndoObj.name));
        }

        //apf.xmldb.synchronize();
    }
};
*/




/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/contenteditable.js)SIZE(67930)TIME(1270937593)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */
apf.__CONTENTEDITABLE__  = 1 << 23;




/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/contenteditable/links.js)SIZE(7735)TIME(1268784066)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/contenteditable/subsup.js)SIZE(1970)TIME(1257329189)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/contenteditable/fontbase.js)SIZE(8589)TIME(1267142467)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/contenteditable/media.js)SIZE(1496)TIME(1257329189)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/contenteditable/list.js)SIZE(4676)TIME(1257329189)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/contenteditable/fontstyle.js)SIZE(25755)TIME(1270838605)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */





/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/contenteditable/hr.js)SIZE(1600)TIME(1257329189)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/contenteditable/tables.js)SIZE(27142)TIME(1267142467)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/contenteditable/help.js)SIZE(1492)TIME(1257329189)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/contenteditable/charmap.js)SIZE(6958)TIME(1265760065)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/contenteditable/blockquote.js)SIZE(1601)TIME(1257329189)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/contenteditable/clipboard.js)SIZE(13471)TIME(1267142467)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/contenteditable/datetime.js)SIZE(3620)TIME(1257329189)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/contenteditable/code.js)SIZE(11906)TIME(1265328064)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/contenteditable/color.js)SIZE(7251)TIME(1270937593)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/contenteditable/printing.js)SIZE(2112)TIME(1266969664)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/contenteditable/anchor.js)SIZE(4572)TIME(1265032028)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/contenteditable/scayt.js)SIZE(2008)TIME(1257329189)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/contenteditable/search.js)SIZE(10471)TIME(1265760065)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/contenteditable/emotions.js)SIZE(4329)TIME(1265760065)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/contenteditable/directions.js)SIZE(1614)TIME(1257329189)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/contenteditable/image.js)SIZE(5047)TIME(1265032028)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/contenteditable/visualaid.js)SIZE(1743)TIME(1257329189)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/childvalue.js)SIZE(3191)TIME(1270838606)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */

apf.__CHILDVALUE__ = 1 << 27;


apf.ChildValue = function(){
    if (!this.$childProperty)
        this.$childProperty = "value";
    
    this.$regbase = this.$regbase | apf.__CHILDVALUE__;
    
    var f;
    this.addEventListener("DOMCharacterDataModified", f = function(e){
        if (e.currentTarget == this)
            return;
        
        var hasNoProp = typeof this[this.$childProperty] == "undefined";
        if (!hasNoProp)
            return;
        
        //Get value from xml (could also serialize children, but that is slower
        var m = this.serialize().match(/^[\s\S]*?>([\s\S]*)<[\s\S]*?$/),
            v = m && m[1] || "";

        
        if (v.indexOf("{") > -1 || v.indexOf("[") > -1) {
            this.$setDynamicProperty(this.$childProperty, v);
        }
        else
        
            this.setProperty(this.$childProperty, v);
    });
    
    //@todo Should be buffered
    this.addEventListener("DOMAttrModified", f);
    this.addEventListener("DOMNodeInserted", f);
    this.addEventListener("DOMNodeRemoved", f);
    
    this.addEventListener("DOMNodeInsertedIntoDocument", function(e){
        var hasNoProp = typeof this[this.$childProperty] == "undefined";
        if (hasNoProp 
          && !this.getElementsByTagNameNS(this.namespaceURI, "*", true).length 
          && (this.childNodes.length > 1 || this.firstChild 
          && (this.firstChild.nodeType == 1 
          || this.firstChild.nodeType != 7 
          && this.firstChild.nodeValue.trim().length))) {
            //Get value from xml (could also serialize children, but that is slower
            var m = (this.$aml && this.$aml.xml || this.serialize()).match(/^[\s\S]*?>([\s\S]*)<[\s\S]*?$/),
                v = m && m[1] || "";

            
            if (v.indexOf("{") > -1 || v.indexOf("[") > -1)
                this.$setDynamicProperty(this.$childProperty, v);
            else
            
                this.setProperty(this.$childProperty, v);
        }
        else if (hasNoProp)
            this.$propHandlers[this.$childProperty].call(this, "");
    });
};



/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/dataaction.js)SIZE(27286)TIME(1270838606)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */

apf.__DATAACTION__ = 1 << 25;


/**
 * Baseclass adding data action features to this element. 
 */
apf.DataAction = function(){
    this.$regbase = this.$regbase | apf.__DATAACTION__;

    /**** Public Methods ****/

    /**
     * Gets the ActionTracker this element communicates with.
     *
     * @return {ActionTracker}
     * @see  element.smartbinding
     */
    this.getActionTracker = function(ignoreMe){
        if (!apf.AmlNode)
            return apf.window.$at;

        var pNode = this, tracker = ignoreMe ? null : this.$at;
        if (!tracker && this.dataParent)
            tracker = this.dataParent.parent.$at; //@todo apf3.0 change this to be recursive??

        while (!tracker) {
            if (!pNode.parentNode) {
                var model;
                return (model = this.getModel && this.getModel(true)) && model.$at || apf.window.$at;
            }

            tracker = (pNode = pNode.parentNode).$at;
        }
        return tracker;
    };
 
    

    this.$actionsLog = {};
    this.$actions    = false;

    /**
     * @term locking {@link http://en.wikipedia.org/wiki/Lock_(computer_science) A lock} 
     * is a mechanism for enforcing limits on access to a resource in a 
     * multi-user environment. Locks are one way of enforcing concurrency 
     * control policies. Ajax.org Platform (apf) has support for locking in 
     * combination with {@link term.action action rules}. There are two 
     * types of locks; pessimistic and optimistic locks. Descriptions below are
     * from {@link http://en.wikipedia.org/wiki/Lock_(computer_science) wikipedia}. 
     *
     * Optimistic:
     * This allows multiple concurrent users access to the database whilst the 
     * system keeps a copy of the initial-read made by each user. When a user 
     * wants to update a record, the application determines whether another user 
     * has changed the record since it was last read. The application does this 
     * by comparing the initial-read held in memory to the database record to 
     * verify any changes made to the record. Any discrepancies between the 
     * initial-read and the database record violates concurrency rules and hence 
     * causes the system to disregard any update request. An error message is 
     * generated and the user is asked to start the update process again. 
     * It improves database performance by reducing the amount of locking 
     * required, thereby reducing the load on the database server. It works 
     * efficiently with tables that require limited updates since no users are 
     * locked out. However, some updates may fail. The downside is constant 
     * update failures due to high volumes of update requests from multiple 
     * concurrent users - it can be frustrating for users.
     *
     * For optimistic locking apf can run as if there would be no locking. 
     * Changed data is sent to the server and is either successfully saved or
     * not. When the action isn't changed and the server returns an error code
     * the {@link element.actiontracker actiontracker} <strong>automatically 
     * reverts the change</strong>. 
     *
     * Pessimistic:
     * This is whereby a user who reads a record with the intention of updating 
     * it, places an exclusive lock on the record to prevent other users from 
     * manipulating it. This means no one else can manipulate that record until 
     * the user releases the lock. The downside is that users can be locked out 
     * for a long time thereby causing frustration. 
     * 
     * For pessimistic locking add the locking attribute to the {@link term.action action rules}
     * that need it. The following example shows a lock request for a rename
     * action on a file browser tree.
     * <code>
     *  <a:rename set="..." lock="{comm.lockFile([@path], unlock)}" />
     * </code>
     * The unlock variable is true when the lock needs to be released. This is
     * done when the action was cancelled after getting a lock. For instance
     * when the user presses escape while renaming.
     *
     * MultiUser:
     * In multi user environments it can be handy
     * to be signalled of changes by others within the application. For more 
     * information on this please look at {@link element.remote}.
     *
     * Remarks:
     * During offline works pessimistic locks will always fail. If the application
     * does not use {@link element.remote remote smart bindings} the developer
     * should reload the part of the content for which the lock failed. See
     * {@link baseclass.databinding.event.lockfailed}.
     *
     * Note: APF understands the status codes specified in RFC4918 for the locking implementation
     *       {@link http://tools.ietf.org/html/rfc4918#section-9.10.6}
     */
     
    /**
     *  Start the specified action, does optional locking and can be offline aware
     *  - or for optimistic locking it will record the timestamp (a setting
     *    <a:appsettings locking="optimistic"/>)
     *  - During offline work, optimistic locks will be handled by taking the
     *    timestamp of going offline
     *  - This method is always optional! The server should not expect locking to exist.
     *
     * @event locksuccess   Fires when a lock request succeeds
     *   bubbles: yes
     *   object:
     *     {Number} state    the return code of the lock request
     * @event lockfailed    Fires when a lock request failes
     *   bubbles: yes
     *   object:
     *     {Number} state    the return code of the lock request
     * @event unlocksuccess Fires when an unlock request succeeds
     *   bubbles: yes
     *   object:
     *     {Number} state    the return code of the unlock request
     * @event unlockfailed  Fires when an unlock request fails
     *   bubbles: yes
     *   object:
     *     {Number} state    the return code of the unlock request
     */
    this.$startAction = function(name, xmlContext, fRollback){
        if (this.disabled || this.contenteditable && name != "edit")
            return false;

        var actionRule = this.$actions && this.$actions.getRule(name, xmlContext);
        if (!actionRule && apf.config.autoDisableActions && this.$actions) {
            
            if (!xmlContext) {
                apf.console.warn("Tried starting new action but no xml \
                    context was specified.");
            }
            else {
                apf.console.warn("Tried starting new action but no '" + name 
                    + "' action rule was found.");
            }
            
            
            return false;
        }

        var bHasOffline = typeof apf.offline != "undefined";
        

        if (this.dispatchEvent(name + "start", {
            xmlContext: xmlContext
        }) === false)
            return false;

        

        this.$actionsLog[name] = xmlContext;

        return true;
    };

    

    this.$stopAction = function(name, isCancelled, curLock){
        delete this.$actionsLog[name];

        
    };

    /**
     * Executes an action using action rules set in the {@link element.actions actions element}.
     *
     * @param {String}      atAction      the name of the action to be performed by the ActionTracker.
     *   Possible values:
     *   setTextNode        sets the first text node of an xml element. {@link core.xmldb.method.setTextNode}
     *   setAttribute       sets the attribute of an xml element. {@link core.xmldb.method.setAttribute}
     *   removeAttribute    removes an attribute from an xml element. {@link core.xmldb.method.removeAttribute}
     *   setAttributes      sets multiple attribute on an xml element. Arguments are [xmlNode, Array]
     *   replaceNode        replaces an xml child with another one. {@link core.xmldb.method.replaceNode}
     *   addChildNode       adds a new xml node to a parent node. {@link core.xmldb.method.addChildNode}
     *   appendChild        appends an xml node to a parent node. {@link core.xmldb.method.appendChild}
     *   moveNode           moves an xml node from one parent to another. {@link core.xmldb.method.moveNode}
     *   removeNode         removes a node from it's parent. {@link core.xmldb.method.removeNode}
     *   removeNodeList     removes multiple nodes from their parent. {@link core.xmldb.method.removeNodeList}
     *   setValueByXpath    sets the nodeValue of an xml node whiche is selected
     *                      by an xpath statement. Arguments are [xmlNode, xpath, value]
     *   multicall          calls multiple of these actions. Arguments is an array
     *                      of argument arrays for these actions each with a func
     *                      property which is the name of the action.
     * @param {Array}       args          the arguments to the function specified
     *                                    in <code>atAction</code>.
     * @param {String}      action        the name of the action rule defined in
     *                                    actions for this element.
     * @param {XMLElement}  xmlNode       the context for the action rules.
     * @param {Boolean}     [noevent]     whether or not to call events.
     * @param {XMLElement}  [contextNode] the context node for action processing
     *                                    (such as RPC calls). Usually the same
     *                                    as <code>xmlNode</code>
     * @return {Boolean} specifies success or failure
     * @see  element.smartbinding
     */
    this.$executeAction = function(atAction, args, action, xmlNode, noevent, contextNode, multiple){
        if (this.disabled || this.contenteditable && action != "edit") 
            return; //hack

        
        apf.console.info("Executing action '" + action + "' for " + (this.name || "")
                         + " [" + (this.localName || "") + "]");
        

        

        //Get Rules from Array
        var rule = this.$actions && this.$actions.getRule(action, xmlNode);
        if (!rule && this.$actions && apf.config.autoDisableActions 
          && "action|change".indexOf(action) == -1) {
            apf.console.warn("Could not execute action '" + action + "'. \
              No valid action rule was found and auto-disable-actions is enabled");
            
            return false;
        }
        
        
        
        var newMultiple;
        if (multiple) {
            newMultiple = [];
            for (var k = multiple.length - 1; k >= 0; k--) {
                newMultiple.unshift({
                    xmlActionNode : rule && rule[4],
                    amlNode       : this,
                    selNode       : multiple[k],
                    xmlNode       : multiple[k]
                })
            }
        }

        //@todo apf3.0 Shouldn't the contextNode be made by the match
        var ev = new apf.AmlEvent("before" + action.toLowerCase(), {
            action        : atAction,
            args          : args,
            xmlActionNode : rule,
            amlNode       : this,
            selNode       : contextNode,
            multiple      : newMultiple || false
            
        });

        //Call Event and cancel if it returns false
        if (!noevent) {
            //Allow the action and arguments to be changed by the event
            if (this.dispatchEvent(ev.name, null, ev) === false)
                return false;
            
            delete ev.currentTarget;
        }

        //Call ActionTracker and return ID of Action in Tracker
        var UndoObj = this.getActionTracker().execute(ev);
        ev.xmlNode = UndoObj.xmlNode;
        ev.undoObj = UndoObj;

        //Call After Event
        if (!noevent) { //@todo noevent is not implemented for before.. ???
            ev.name         = "after" + action.toLowerCase();
            ev.cancelBubble = false;
            delete ev.returnValue;
            delete ev.currentTarget;
            this.dispatchEvent(ev.name, null, ev);
        }

        return UndoObj;
    };

    /**
     * Executes an action based on the set name and the new value
     * @param {String}      atName   the name of the action rule defined in actions for this element.
     * @param {String}      setName  the name of the binding rule defined in bindings for this element.
     * @param {XMLElement}  xmlNode  the xml element to which the rules are applied
     * @param {String}      value    the new value of the node
     */
    this.$executeSingleValue = function(atName, setName, xmlNode, value, getArgList){
        var xpath, args, rule = this.$getBindRule(setName, xmlNode);
        
        //recompile bindrule to create nodes
        if (!rule) {
            
            if (this.$getBindRule(setName))
                throw new Error("There is no rule that matches the xml node for this operation.\
                                 Please make sure you are matching a node and using the value to \
                                 specify it's value <a:" + setName + " match='person' \
                                 value='[@name]' /> : " + xmlNode.xml); //@todo make apf Error
            else
            
                return false;
        }
        
        var compiled = rule.value ? rule.cvalue : rule.cmatch;
        if (!compiled) {
            if (rule.value)
                compiled = rule.compile("value");
            else
                return false;
        }
        
        
        //If not one xpath segment then error
        if (compiled.type != 3) {
            throw new Error("Cannot create from rule that isn't a single xpath"); //@todo make apf Error
        }
        

        var atAction,
            sel        = compiled.xpaths, //get first xpath
            shouldLoad = false;
        
        if (sel[0] == "#" || sel[1] == "#") {
            var m = (rule.cvalue3 || (rule.cvalue3 = apf.lm.compile(rule.value, {
                xpathmode: 5
            })))(xmlNode);
            
            var model = m.model && m.model.$isModel && m.model;
            if (model) {
                var node  = model.queryNode(m.xpath);
                xmlNode = model.data;
            }
            else {
                model = apf.xmldb.findModel(m.model);
                var node  = m.model.selectSingleNode(m.xpath);
                xmlNode = m.model;
            }

            sel[1] = m.xpath;
        }
        else {
            var model      = sel[0] && apf.nameserver.get("model", sel[0]) || this.$model,
                node       = model
                    ? model.queryNode(sel[1])
                    : (xmlNode || this.xmlRoot).selectSingleNode(sel[1]);
        }

        if (node) {
            if (apf.queryValue(node) == value) return; // Do nothing if value is unchanged

            atAction = (node.nodeType == 1 || node.nodeType == 3
                || node.nodeType == 4) ? "setTextNode" : "setAttribute";
            args = (node.nodeType == 1)
                ? [node, value]
                : (node.nodeType == 3 || node.nodeType == 4
                    ? [node.parentNode, value]
                    : [node.ownerElement || node.selectSingleNode(".."), node.nodeName, value]);
        }
        else {
            if (!this.$createModel)
                return false;

            atAction = "setValueByXpath";
            xpath    = sel[1];

            if (!xmlNode) {
                //Assuming this component is connnected to a model
                if (!model)
                    model = this.getModel();
                if (model) {
                    if (!model.data)
                        model.load("<data />");
    
                    xpath   = (model.getXpathByAmlNode(this) || ".")
                        + (xpath && xpath != "." ? "/" + xpath : "");
                    xmlNode = model.data;
                }
                else {
                    if (!this.dataParent)
                        return false;

                    xmlNode = this.dataParent.parent.selected || this.dataParent.parent.xmlRoot;
                    if (!xmlNode)
                        return false;
                    
                    xpath = (this.dataParent.xpath || ".")
                        + (xpath && xpath != "." ? "/" + xpath : "");
                    shouldLoad = true;
                }
            }

            args = [xmlNode, value, xpath];
        }
        
        if (getArgList) {
            return {
                func : atAction,
                args : args
            };
        }

        //Use Action Tracker
        this.$executeAction(atAction, args, atName, xmlNode);
        
        if (shouldLoad)
            this.load(xmlNode.selectSingleNode(xpath));
    };
    
    /**
     * Changes the value of this element.
     * @action
     * @param  {String} [string] the new value of this element.
     * @todo apf3.0 maybe not for multiselect?? - why is clearError handling not
     *       in setProperty for value
     */
    this.change = function(value, force){
        
        if (this.errBox && this.errBox.visible && this.isValid && this.isValid())
            this.clearError();
        

        
        //Not databound
        if (!this.xmlRoot && !this.$createModel || !(this.$mainBind == "value" 
          && this.hasFeature(apf.__MULTISELECT__) 
            ? this.$attrBindings["value"] 
            : this.$hasBindRule(this.$mainBind))) {
        
            if (!force && value === this.value 
              || this.dispatchEvent("beforechange", {value : value}) === false)
                return false;

            //@todo in theory one could support actions
            //@todo disabled below, because it gives unexpected behaviour when 
            //form elements are used for layout and other UI alterations
            /*this.getActionTracker().execute({
                action        : "setProperty",
                args          : [this, "value", value, false, true],
                amlNode       : this
            });*/
            this.setProperty("value", value);

            return this.dispatchEvent("afterchange", {value : value});
        
        }
        
        var valueRule = this.$attrBindings["eachvalue"] && "eachvalue" 
            || this.$bindings["value"] && "value" 
            || this.$hasBindRule("caption") && "caption";
          
        if (value == (valueRule != "value" && (this.xmlRoot 
          && this.$applyBindRule("value", this.xmlRoot, null, true)) 
          || this.value))
            return false;

        this.$executeSingleValue("change", this.$mainBind, this.xmlRoot, value);
        
    };
    
    this.$booleanProperties["render-root"] = true;
    this.$supportedProperties.push("create-model", "actions");
    
    /**
     * @attribute {Boolean} create-model whether the model this element connects
     * to is extended when the data pointed to does not exist. Defaults to true.
     * Example:
     * In this example a model is extended when the user enters information in
     * the form elements. Because no model is specified for the form elements
     * the first available model is chosen. At the start it doesn't have any
     * data, this changes when for instance the name is filled in. A root node
     * is created and under that a 'name' element with a textnode containing
     * the entered text.
     * <code>
     *  <a:bar>
     *      <a:label>Name</a:label>
     *      <a:textbox value="[name]" required="true" />
     * 
     *      <a:label>Address</a:label>
     *      <a:textarea value="[address]" />
     * 
     *      <a:label>Country</a:label>
     *      <a:dropdown 
     *        value   = "[mdlForm::country]" 
     *        model   = "countries.xml" 
     *        each    = "[country]" 
     *        caption = "[@name]" />
     *      <a:button action="submit">Submit</a:button>
     *  </a:bar>
     * </code>
     */
    this.$propHandlers["create-model"] = function(value){
        this.$createModel = value;
    };
    
    this.addEventListener("DOMNodeInsertedIntoDocument", function(e){
        if (typeof this["create-model"] == "undefined" 
          && !this.$setInheritedAttribute("create-model")) {
            this.$createModel = true;
        }
    });
};

apf.config.$inheritProperties["create-model"] = 1;



/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/cache.js)SIZE(12470)TIME(1271108667)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */

apf.__CACHE__ = 1 << 2;



/**
 * All elements inheriting from this {@link term.baseclass baseclass} have caching features. It takes care of
 * storing, retrieving and updating rendered data (in html form)
 * to overcome the waiting time while rendering the contents every time the
 * data is loaded.
 *
 * @constructor
 * @baseclass
 * @author      Ruben Daniels (ruben AT ajax DOT org)
 * @version     %I%, %G%
 * @since       0.4
 */
apf.Cache = function(){
    /* ********************************************************************
                                        PROPERTIES
    *********************************************************************/
    this.cache               = {};
    this.$subTreeCacheContext = null;

    this.caching  = true;
    this.$regbase = this.$regbase | apf.__CACHE__;

    /* ********************************************************************
                                        PUBLIC METHODS
    *********************************************************************/

    this.addEventListener("$load", function(e){
        if (!this.caching || e.forceNoCache)
            return;

        // retrieve the cacheId
        if (!this.cacheId) {
            this.cacheId = e.xmlNode.getAttribute(apf.xmldb.xmlIdTag) || 
                apf.xmldb.nodeConnect(apf.xmldb.getXmlDocId(e.xmlNode), e.xmlNode);//e.xmlNode
        }

        // Retrieve cached version of document if available
        var fromCache = getCache.call(this, this.cacheId, e.xmlNode);
        if (fromCache) {
            if (fromCache == -1)
                return false;

            var nodes = this.getTraverseNodes();

            //Information needs to be passed to the followers... even when cached...
            if (nodes.length && this.autoselect)
                this.select(nodes[0], null, null, null, true);
            else
                this.clearSelection(); //@todo apf3.0 was setProperty("selected", null

            if (!nodes.length) {
                // Remove message notifying user the control is without data
                this.$removeClearMessage();
                this.$setClearMessage(this["empty-message"], "empty");
            }
                
            
            //@todo move this to getCache??
            if (nodes.length != this.length)
                this.setProperty("length", nodes.length);
            

            return false;
        }
    });
    
    this.addEventListener("$clear", function(){
        if (!this.caching)
            return;

        /*
            Check if we borrowed an HTMLElement
            We should return it where it came from

            note: There is a potential that we can't find the exact location
            to put it back. We should then look at it's position in the xml.
            (but since I'm lazy it's not doing this right now)
            There might also be problems when removing the xmlroot
        */
        if (this.hasFeature(apf.__MULTISELECT__)
          && this.$subTreeCacheContext && this.$subTreeCacheContext.oHtml) {
            if (this.renderRoot) {
                this.$subTreeCacheContext.parentNode.insertBefore(
                    this.$subTreeCacheContext.oHtml, this.$subTreeCacheContext.beforeNode);
            }
            else {
                var container = this.$subTreeCacheContext.container || this.$container;
                while (container.childNodes.length)
                    this.$subTreeCacheContext.oHtml.appendChild(container.childNodes[0]);
            }

            this.documentId = this.xmlRoot = this.cacheId = this.$subTreeCacheContext = null;
        }
        else {
            /* If the current item was loaded whilst offline, we won't cache
             * anything
             */
            if (this.$loadedWhenOffline) {
                this.$loadedWhenOffline = false;
            }
            else {
                // Here we cache the current part
                var fragment = this.$getCurrentFragment();
                if (!fragment) return;//this.$setClearMessage(this["empty-message"]);

                fragment.documentId = this.documentId;
                fragment.xmlRoot    = this.xmlRoot;
                
                if (this.cacheId || this.xmlRoot)
                    setCache.call(this, this.cacheId ||
                        this.xmlRoot.getAttribute(apf.xmldb.xmlIdTag) || "doc"
                        + this.xmlRoot.getAttribute(apf.xmldb.xmlDocTag), fragment);
            }
        }
    });

    /**
     * Checks the cache for a cached item by ID. If the ID is found the
     * representation is loaded from cache and set active.
     *
     * @param  {String} id  the id of the cache element which is looked up.
     * @param  {Object} xmlNode
     * @return {Boolean}
     *   Possible values:
     *   true   the cache element is found and set active
     *   false  otherwise
     * @see    baseclass.databinding.method.load
     * @private
     */
    function getCache(id, xmlNode){
        /*
            Let's check if the requested source is actually
            a sub tree of an already rendered part
        */
        
        if (xmlNode && this.hasFeature(apf.__MULTISELECT__) && this.$isTreeArch) {
            var cacheItem,
                htmlId = xmlNode.getAttribute(apf.xmldb.xmlIdTag) + "|" + this.$uniqueId,
                node   = this.$pHtmlDoc.getElementById(htmlId);
            if (node) 
                cacheItem = id ? false : this.$container; //@todo what is the purpose of this statement?
            else {
                for (var prop in this.cache) {
                    if (this.cache[prop] && this.cache[prop].nodeType) {
                        node = this.cache[prop].getElementById(htmlId);
                        if (node) {
                            cacheItem = id ? prop : this.cache[prop]; //@todo what is the purpose of this statement?
                            break;
                        }
                    }
                }
            }
            
            if (cacheItem && !this.cache[id]) {
                /*
                    Ok so it is, let's borrow it for a while
                    We can't clone it, because the updates will
                    get ambiguous, so we have to put it back later
                */
                var oHtml = this.$findHtmlNode(
                    xmlNode.getAttribute(apf.xmldb.xmlIdTag) + "|" + this.$uniqueId);
                this.$subTreeCacheContext = {
                    oHtml      : oHtml,
                    parentNode : oHtml.parentNode,
                    beforeNode : oHtml.nextSibling,
                    cacheItem  : cacheItem
                };

                this.documentId = apf.xmldb.getXmlDocId(xmlNode);
                this.cacheId    = id;
                this.xmlRoot    = xmlNode;

                //Load html
                if (this.renderRoot)
                    this.$container.appendChild(oHtml);
                else {
                    while (oHtml.childNodes.length)
                        this.$container.appendChild(oHtml.childNodes[0]);
                }

                return true;
            }
        }
        

        //Checking Cache...
        if (!this.cache[id]) return false;

        //Get Fragment and clear Cache Item
        var fragment    = this.cache[id];

        this.documentId = fragment.documentId;
        this.cacheId    = id;
        this.xmlRoot    = fragment.xmlRoot;

        this.clearCacheItem(id);

        this.$setCurrentFragment(fragment);

        return true;
    }

    /**
     * Sets cache element and it's ID
     *
     * @param {String}           id        the id of the cache element to be stored.
     * @param {DocumentFragment} fragment  the data to be stored.
     * @private
     */
    function setCache(id, fragment){
        if (!this.caching) return;

        this.cache[id] = fragment;
    }

    /**
     * Finds HTML presentation node in cache by ID
     *
     * @param  {String} id  the id of the HTMLElement which is looked up.
     * @return {HTMLElement} the HTMLElement found. When no element is found, null is returned.
     */
    this.$findHtmlNode = function(id){
        var node = this.$pHtmlDoc.getElementById(id);
        if (node) return node;

        for (var prop in this.cache) {
            if (this.cache[prop] && this.cache[prop].nodeType) {
                node = this.cache[prop].getElementById(id);
                if (node) return node;
            }
        }

        return null;
    };

    /**
     * Removes an item from the cache.
     *
     * @param {String}  id       the id of the HTMLElement which is looked up.
     * @param {Boolean} [remove] whether to destroy the Fragment.
     * @see baseclass.databinding.method.clear
     * @private
     */
    this.clearCacheItem = function(id, remove){
        this.cache[id].documentId = 
        this.cache[id].cacheId    =
        this.cache[id].xmlRoot    = null;

        if (remove)
            apf.destroyHtmlNode(this.cache[id]);

        this.cache[id] = null;
    };

    /**
     * Removes all items from the cache
     *
     * @see baseclass.databinding.method.clearCacheItem
     * @private
     */
    this.clearAllCache = function(){
        for (var prop in this.cache) {
            if (this.cache[prop])
                this.clearCacheItem(prop, true);
        }
    };

    /**
     * Gets the cache item by it's id
     *
     * @param {String} id  the id of the HTMLElement which is looked up.
     * @see baseclass.databinding.method.clearCacheItem
     * @private
     */
    this.getCacheItem = function(id){
        return this.cache[id];
    };

    /**
     * Checks whether a cache item exists by the specified id
     *
     * @param {String} id  the id of the cache item to check.
     * @see baseclass.databinding.method.clearCacheItem
     * @private
     */
    this.$isCached = function(id){
        return this.cache[id] || this.cacheId == id ? true : false;
    };
    
    if (!this.$getCurrentFragment) {
        this.$getCurrentFragment = function(){
            var fragment = this.$container.ownerDocument.createDocumentFragment();
    
            while (this.$container.childNodes.length) {
                fragment.appendChild(this.$container.childNodes[0]);
            }
    
            return fragment;
        };
    
        this.$setCurrentFragment = function(fragment){
            this.$container.appendChild(fragment);
    
            if (!apf.window.hasFocus(this))
                this.blur();
        };
    }
    
    /**
     * @attribute {Boolean} caching whether caching is enabled for this element.
     */
    this.$booleanProperties["caching"] = true;
    this.$supportedProperties.push("caching");

    this.addEventListener("DOMNodeRemovedFromDocument", function(e){
        //Remove all cached Items
        this.clearAllCache();
    });
};

apf.GuiElement.propHandlers["caching"] = function(value) {
    if (!apf.isTrue(value)) return;
    
    if (!this.hasFeature(apf.__CACHE__))
        this.implement(apf.Cache);
};




/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/rename.js)SIZE(13845)TIME(1271026883)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */

apf.__RENAME__ = 1 << 10;



/**
 * All elements inheriting from this {@link term.baseclass baseclass} have the rename features. Rename is triggered by
 * pressing F2 on an item or by clicking once on an already selected item. This
 * will show an input element in place where the user can change the name of the
 * item to a new one. When the caption is changed the {@link term.datanode data node} is
 * changed accordingly.
 * Example:
 * This example shows a list containing products. Only products that have the
 * editable attribute set to 1 can be renamed by the user.
 * <code>
 *  <a:model id="mdlTest">
 *      <data>
 *          <product name="TV" />
 *          <product name="LCD" editable="1" />
 *      </data>
 *  </a:model>
 *  <a:list id="list" model="mdlTest" width="200">
 *      <a:each match="[product]">
 *          <a:caption match="[@name]" />
 *      </a:each>
 *      <a:actions>
 *          <a:rename
 *            match = "[product[@editable='1']]"
 *            set   = "rename.php" />
 *      </a:actions>
 *  </a:list>
 *       
 *  <a:button
 *    caption = "Rename"
 *    onclick = "list.startRename()" />
 * </code>
 *
 * @event stoprename Fires when a rename action is cancelled.
 *
 * @constructor
 * @baseclass
 * @author      Ruben Daniels (ruben AT ajax DOT org)
 * @version     %I%, %G%
 * @since       0.5
 */
apf.Rename = function(){
    this.$regbase      = this.$regbase|apf.__RENAME__;

    this.canrename     = true;
    this.$renameSubject =
    this.renameTimer   =
    this.lastCursor    = null;
    
    /**
     * @attribute  {Boolean}  rename  whether the user can start renaming rendered nodes in this element.
     */
    this.$booleanProperties["canrename"]  = true;
    this.$booleanProperties["autorename"] = true;
    this.$supportedProperties.push("canrename", "autorename");

    

    /**
     * Changes the data presented as the caption of a specified {@link term.datanode data node}.
     * If none is specified the indicated node is used.
     *
     * @action
     * @param  {XMLElement} xmlNode the element to change the caption of.
     * @param  {String}     value   the value to set as the caption of the {@link term.datanode data node}.
     */
    this.rename = function(xmlNode, value){
        if (!xmlNode)
            xmlNode = this.caret || this.selected;

        if (!xmlNode) return;

        this.$executeSingleValue("rename", "caption", xmlNode, value);
    };

    /**
     * Starts the rename process with a delay, allowing for cancellation when
     * necesary. Cancellation is necesary for instance, when double click was
     * intended or a dragdrop operation.
     *
     */
    this.startDelayedRename = function(e, time, userAction){
        if (e && (e.button == 2 || e.ctrlKey || e.shiftKey) 
          || userAction && this.disabled)
            return;

        clearTimeout(this.renameTimer);
        this.renameTimer = $setTimeout('apf.lookup('
            + this.$uniqueId + ').startRename()', time || 400);
    };

    /**
     * Starts the rename process by displaying an input box at the position
     * of the item that can be renamed by the user.
     *
     */
    this.startRename = function(force, startEmpty, userAction){
        if (!force && (this.renaming || !this.canrename 
          || !this.$startAction("rename", this.caret 
          || this.selected, this.stopRename))
          || userAction && this.disabled)
            return false;

        if (!this.hasFocus())
            this.focus(null, null, true);

        clearTimeout(this.renameTimer);

        var elCaption = this.$getCaptionElement
            ? this.$getCaptionElement()
            : this.$caret || this.$selected;

        if (!elCaption) 
            return this.stopRename();
        
        this.renaming      = true;
        this.$renameSubject = this.caret || this.selected;

        var wdt = elCaption.offsetWidth;
        this.lastCursor = elCaption.style.cursor;
        elCaption.style.cursor = "text";
        elCaption.parentNode.replaceChild(this.$txt, elCaption);
        elCaption.host = this;

        if (apf.isTrue(this.$getOption("main", "scalerename"))) {
            var diff = apf.getWidthDiff(this.$txt);
            this.$txt.style.width = (wdt - diff - 3) + "px";
        }

        this.$replacedNode = elCaption;
        var xmlNode       = this.$getCaptionXml
            ? this.$getCaptionXml(this.$renameSubject)
            : this.$getDataNode("caption", this.$renameSubject);

        //xmlNode.nodeType >= 2 && xmlNode.nodeType <= 4
        value =  startEmpty || !xmlNode
            ? ""
            : (xmlNode.nodeType != 1
                ? unescape(xmlNode.nodeValue) //decodeURI( - throws an error when using % in a non expected way
                : (apf.isOnlyChild(xmlNode.firstChild, [3,4])
                    ? apf.queryValue(xmlNode)
                    : this.$applyBindRule("caption", this.$renameSubject))) || "";

        if (apf.hasContentEditable) {
            if (this.$multiLineRename)
                this.$txt.innerHTML = apf.htmlCleaner.prepare(value.trim()
                    .replace(/</g, "&lt;")
                    .replace(/>/g, "&gt;")
                    .replace(/\n/g, "<br />"));
            else
                this.$txt.innerHTML = value.replace(/</g, "&lt;");
        }
        else 
            this.$txt.value = value;

        this.$txt.unselectable = "Off";
        this.$txt.host         = this;

        //this.$txt.focus();
        try {
            this.$txt.focus();
            this.$txt.select();
        }
        catch(e) {}
    };

    /**
     * Stop renaming process and change the data according to the set value.
     * Cancel the renaming process without changing data.
     *
     */
    this.stopRename = function(contextXml, success){
        clearTimeout(this.renameTimer);

        if (!this.renaming || contextXml && contextXml != this.$renameSubject
          || !this.$replacedNode)
            return false;

        if (this.$txt.parentNode && this.$txt.parentNode.nodeType == 1) {
            if (apf.isIE8 || apf.isIE7Emulate)
                this.$txt.blur();
            
            this.$txt.parentNode.replaceChild(this.$replacedNode, this.$txt);
        }

        this.renaming = false;

        if (this.$replacedNode) {
            this.$replacedNode.style.cursor = this.lastCursor || "";
            this.$replacedNode.host = null;
        }
        
        //apf.hasContentEditable ??
        if (this.$multiLineRename) {
            var value = apf.html_entity_decode(
                apf.htmlCleaner.parse(this.$txt.innerHTML, true)
                            .replace(/<br \/>/g, "")
                            .replace(/<\/?p>/g, ""));
        }
        else {
            var value = this.$txt[apf.hasContentEditable ? "innerText" : "value"]
                            .replace(/<.*?nobr>/gi, "");
        }

        if (!success || (this.$validateRename && !this.$validateRename(value))) {
            this.dispatchEvent("stoprename");
            this.$stopAction("rename");
        }
        else {
            if (this.$replacedNode) {
                this.$replacedNode.innerHTML = value.replace(/</g, "&lt;").replace(/\r?\n/g, "<br />");
            }
             //this.$selected.innerHTML = this.$txt.innerHTML;
            this.rename(this.$renameSubject, value);
        }

        if (!this.renaming) {
            this.$renameSubject    = null;
            this.$replacedNode     = null;
            this.$txt.style.width = "";
        }
        
        return true;
    };

    
    this.addEventListener("keydown", function(e){
        var key = e.keyCode;

        if (this.renaming) {
            if (key == 27 || this.$multiLineRename && e.ctrlKey && key == 13 
              || !this.$multiLineRename && key == 13) {
                this.stopRename(null, key == 13 && !this.$autocomplete);
                e.cancelBubble = true;
                return false;
            }

            return;
        }

        //F2
        if (key == 113) {
            if (this.$tempsel)
                this.$selectTemp();

            if (this.caret != this.selected) {
                if (this.multiselect || this.isSelected(this.caret)) {
                    this.selected  = this.caret;
                    this.$selected = this.$caret;
                }
                else
                    this.select(this.caret, true);
            }

            this.startRename();

            return false;
        }
    }, true);
    

    this.addEventListener("DOMNodeRemovedFromDocument", function(e){
        this.$txt.refCount--;

        if (!this.$txt.refCount) {
            this.$txt.host        =
            this.$txt.onmouseover =
            this.$txt.onmousedown =
            this.$txt.select      =
            this.$txt.onfocus     =
            this.$txt.onblur      = null;
        }
        this.$txt = null;
    });
    
    this.$init(apf.Rename.initEditableArea);
};

apf.Rename.initEditableArea = function(){
    if (!(this.$txt = document.getElementById("txt_rename"))) {
        if (apf.hasContentEditable) {
            this.$txt = document.createElement("DIV");
            this.$txt.contentEditable = true;
            if (apf.isIE6)
                this.$txt.style.width = "1px";
            //this.$txt.canHaveHTML = false;
        }
        else {
            this.$txt              = document.createElement("input");
            this.$txt.id           = "txt_rename";
            this.$txt.autocomplete = false;
        }
    
        
        if (apf.hasFocusBug)
            apf.sanitizeTextbox(this.$txt);
        
    
        this.$txt.refCount         = 0;
        this.$txt.id               = "txt_rename";
        //this.$txt.style.whiteSpace = "nowrap";
        apf.importCssString("#txt_rename{white-space:nowrap}");
        this.$txt.onselectstart    = function(e){
            (e || event).cancelBubble = true;
        };
        
        //this.$txt.host = this;
        apf.sanitizeTextbox(this.$txt);
        
    
        this.$txt.onmouseover = this.$txt.onmouseout = this.$txt.oncontextmenu =
        //this.$txt.onkeydown   = 
        this.$txt.onmousedown = function(e){ (e || event).cancelBubble = true; };
    
        this.$txt.onkeyup = function(e){
            //(e || event).cancelBubble = true;
            
            if (!this.host.$autocomplete)
                return;
    
            this.host.$lookup(this[apf.hasContentEditable ? "innerHTML" : "value"]);
        }
    
        this.$txt.select = function(){
            if (!apf.hasMsRangeObject)
                return this.focus();
    
            var r = document.selection.createRange();
            //r.moveEnd("character", this.$ext.innerText.length);
            try {
                r.moveToElementText(this);
    
                if (apf.isFalse(this.host.$getOption("main", "selectrename"))
                  || typeof this.host.$renameStartCollapse != "undefined") //@todo please deprecate renameStartCollapse
                    r.collapse(this.host.$renameStartCollapse);
            } catch(e) {} //BUG!!!!
    
            r.select();
        };
    
        
        if (apf.hasFocusBug) {
            this.$txt.onfocus = function(){
                if (apf.window)
                    apf.window.$focusfix2();
            };
        }
        
    
        this.$txt.onblur = function(){
            if (apf.isGecko)
                return; //bug in firefox calling onblur too much
    
            
            if (apf.hasFocusBug)
                apf.window.$blurfix();
            
    
            if (this.host.$autocomplete)
                return;
    
            this.host.stopRename(null, true);
        };
    }
    
    this.$txt.refCount++;
}





/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/docking.js)SIZE(14714)TIME(1269561670)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */

apf.__DOCKING__ = 1 << 18;




/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/basebutton.js)SIZE(9879)TIME(1270838606)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * Baseclass of an element that has one or two states and can be clicked on to
 * trigger an action. (i.e. {@link element.button} or {@link element.checkbox}).
 *
 * @constructor
 * @baseclass
 * @author      Abe Ginner
 * @version     %I%, %G%
 * @since       0.8
 *
 * @event click     Fires when the user presses a mousebutton while over this element and then let's the mousebutton go. 
 */
apf.BaseButton = function(){
    this.$init(true);
};

(function() {
    
    this.implement(apf.ChildValue);
    
    
    this.refKeyDown  =         // Number of keys pressed.
    this.refMouseDown = 0;     // Mouse button down?
    this.mouseOver    =        // Mouse hovering over the button?
    this.mouseLeft    = false; // Has the mouse left the control since pressing the button.

    /**** Properties and Attributes ****/

    /**
     * @attribute {string} background sets a multistate background. The arguments
     * are seperated by pipes '|' and are in the order of:
     * 'imagefilename|mapdirection|nrofstates|imagesize'
     * The mapdirection argument may have the value of 'vertical' or 'horizontal'.
     * The nrofstates argument specifies the number of states the iconfile contains:
     * 1 - normal
     * 2 - normal, hover
     * 3 - normal, hover, down
     * 4 - normal, hover, down, disabled
     * The imagesize argument specifies how high or wide each icon is inside the
     * map, depending of the mapdirection argument.
     *
     * Example:
     * A 3 state picture where each state is 16px high, vertically spaced
     * <code>
     * background="threestates.gif|vertical|3|16"
     * </code>
     */
    this.$propHandlers["background"] = function(value){
        var oNode = this.$getLayoutNode("main", "background", this.$ext);
        
        if (!oNode)
            return apf.console.warn("No background defined in the Button skin", "button");
        

        if (value) {
            var b = value.split("|");
            this.$background = b.concat(["vertical", 2, 16].slice(b.length - 1));

            oNode.style.backgroundImage  = "url(" + this.mediaPath + b[0] + ")";
            oNode.style.backgroundRepeat = "no-repeat";
        }
        else {
            oNode.style.backgroundImage  = "";
            oNode.style.backgroundRepeat = "";
            this.$background = null;
        }
    };

    /**** Keyboard Support ****/

    
    this.addEventListener("keydown", function(e){
        var key      = e.keyCode;
        //var ctrlKey  = e.ctrlKey;  << UNUSED
        //var shiftKey = e.shiftKey; << UNUSED

        switch (key) {
            case 13:
                if (this.localName != "checkbox")
                    this.$ext.onmouseup(e.htmlEvent, true);
                break;
            case 32:
                if (!e.htmlEvent.repeat) { // Only when first pressed, not on autorepeat.
                    this.refKeyDown++;
                    this.$updateState(e.htmlEvent);
                }
                return false;
        }
    }, true);

    this.addEventListener("keyup", function(e){
        var key = e.keyCode;

        switch (key) {
            case 32:
                this.refKeyDown--;

                if (this.refKeyDown < 0) {
                    this.refKeyDown = 0;
                    return false;
                }

                if (this.refKeyDown + this.refMouseDown == 0 && !this.disabled)
                    this.$ext.onmouseup(e, true);

                this.$updateState(e);
                return false;
        }
    }, true);
    

    /**** Private state handling methods ****/

    this.states = {
        "Out"   : 1,
        "Over"  : 2,
        "Down"  : 3
    };

    this.$updateState = function(e, strEvent) {
        if (e.reset) { //this.disabled || 
            this.refKeyDown   = 0;
            this.refMouseDown = 0;
            this.mouseOver    = false;
            return false;
        }

        if (this.refKeyDown > 0
          || (this.refMouseDown > 0 && this.mouseOver)
          || (this.isBoolean && this.value)) {
            this.$setState("Down", e, strEvent);
        }
        else if (this.mouseOver)
            this.$setState("Over", e, strEvent);
        else
            this.$setState("Out", e, strEvent);
    };

    this.$setupEvents = function() {
        if (this.editable)
            return;
        
        var _self = this;

        this.$ext.onmousedown = function(e) {
            e = e || window.event;

            if (_self.disabled || _self.$notfromext && (e.srcElement || e.target) == this)
                return;

            _self.refMouseDown = 1;
            _self.mouseLeft    = false;
            _self.$updateState(e, "mousedown");
        };
        
        this.$ext.onmouseup = function(e, force) {
            e = e || window.event;
            //if (e)  e.cancelBubble = true;

            if (_self.disabled || !force && (!_self.mouseOver || !_self.refMouseDown))
                return;

            _self.refMouseDown = 0;
            _self.$updateState(e, "mouseup");

            // If this is coming from a mouse click, we shouldn't have left the button.
            if (_self.disabled || (e && e.type == "click" && _self.mouseLeft == true))
                return false;

            // If there are still buttons down, this is not a real click.
            if (_self.refMouseDown + _self.refKeyDown)
                return false;

            if (_self.$clickHandler && _self.$clickHandler())
                _self.$updateState (e || event, "click");
            else
                _self.dispatchEvent("click", {htmlEvent : e});

            return false;
        };

        this.$ext.onmousemove = function(e) {
            if (!_self.mouseOver && !_self.disabled) {
                e = e || window.event;

                if (_self.$notfromext && (e.srcElement || e.target) == this)
                    return;

                _self.mouseOver = true;
                _self.$updateState(e, "mouseover");
            }
        };

        this.$ext.onmouseout = function(e) {
            e = e || window.event;

            //Check if the mouse out is meant for us
            var tEl = e.explicitOriginalTarget || e.toElement;
            if (_self.disabled || this == tEl || apf.isChildOf(this, tEl))
                return;

            _self.mouseOver    = false;
            _self.refMouseDown = 0;
            _self.mouseLeft    = true;
            _self.$updateState(e, "mouseout");
        };

        
        if (apf.isIphone)
            apf.iphone.linkEvents(this.$ext, true);
        

        if (apf.hasClickFastBug)
            this.$ext.ondblclick = this.$ext.onmouseup;
    };

    this.$doBgSwitch = function(nr){
        if (this.background && (this.$background[2] >= nr || nr == 4)) {
            if (nr == 4)
                nr = this.$background[2] + 1;

            var strBG = this.$background[1] == "vertical"
                ? "0 -" + (parseInt(this.$background[3]) * (nr - 1)) + "px"
                : "-"   + (parseInt(this.$background[3]) * (nr - 1)) + "px 0";

            this.$getLayoutNode("main", "background",
                this.$ext).style.backgroundPosition = strBG;
        }
    };

    /**** Focus Handling ****/

    this.$focus = function(){
        if (!this.$ext)
            return;

        this.$setStyleClass(this.$ext, this.$baseCSSname + "Focus");
    };

    this.$blur = function(e){
        if (!this.$ext)
            return; //FIREFOX BUG!

        this.$setStyleClass(this.$ext, "", [this.$baseCSSname + "Focus"]);
        /*this.refKeyDown   = 0;
        this.refMouseDown = 0;
        this.mouseLeft    = true;*/

        
        /*if (this.submenu) {
            if (this.value) {
                this.$setState("Down", {}, "mousedown");
                this.$hideMenu();
            }
        }*/
        

        if (e)
            this.$updateState({});//, "onblur"
    };

    /*** Clearing potential memory leaks ****/

    this.$destroy = function(skinChange){
        if (!skinChange && this.$ext) {
            this.$ext.onmousedown = this.$ext.onmouseup = this.$ext.onmouseover =
            this.$ext.onmouseout = this.$ext.onclick = this.$ext.ondblclick = null;
        }
    };

}).call(apf.BaseButton.prototype = new apf.StandardBinding());




/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/basetab.js)SIZE(39001)TIME(1270838606)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/**
 * Baseclass of a paged element. 
 *
 * @constructor
 * @baseclass
 * @allowchild page
 * @author      Ruben Daniels (ruben AT ajax DOT org)
 * @version     %I%, %G%
 * @since       0.8
 * 
 * @event beforeswitch  Fires before this element switches to another page.
 *   cancelable: Prevents the page to become active.
 *   object:
 *   {Mixed}    previous     the name or number of the current page.
 *   {Number}   previousId   the number of the current page.
 *   {apf.page} previousPage the current page.
 *   {Mixed}    next         the name or number of the page the will become active.
 *   {Number}   nextId       the number of the page the will become active.
 *   {apf.page} nextpage     the page the will become active.
 * @event afterswitch   Fires after this element has switched to another page.
 *   object:
 *   {Mixed}    previous     the name or number of the previous page.
 *   {Number}   previousId   the number of the previous page.
 *   {apf.page} previousPage the previous page.
 *   {Mixed}    next         the name or number of the current page.
 *   {Number}   nextId       the number of the the current page.
 *   {apf.page} nextpage     the the current page.   
 */
apf.BaseTab = function(){
    this.$init(true);
};

(function() {
    this.isPaged     = true;
    this.$focussable = apf.KEYBOARD;
    this.length      = 0;
    this.isLoading   = {};
    this.inited      =
    this.ready       = false;

    /**
     * Sets the current page of this element.
     * @param {mixed}    page     the name of numer of the page which is made active.
     * @param {Function} callback the function called after setting the page. Especially handy when using the src attribute.
     */
    this.set = function(page, callback, noEvent){
        if (noEvent || this.src && !this.$findPage(page, {})) {
            return this.$propHandlers["activepage"].call(
                this, page, null, null, callback, noEvent);
        }
        
        if (callback && this.activepage == page)
            return callback();

        this.$lastCallback = callback;
        this.setProperty("activepage", page);
    };

    /**** Properties and Attributes ****/

    this.$supportedProperties.push("activepage", "activepagenr", "length",
        "src", "loading");

    /**
     * @attribute {Number} activepagenr the child number of the active page.
     * Example:
     * This example uses property binding to maintain consistency between a
     * dropdown which is used as a menu, and a pages element
     * <code>
     *  <a:dropdown id="ddMenu" value="0">
     *      <a:item value="0">Home</a:item>
     *      <a:item value="1">General</a:item>
     *      <a:item value="2">Advanced</a:item>
     *  </a:dropdown>
     * 
     *  <a:pages activepagenr="{ddMenu.value}">
     *      <a:page>
     *          <h1>Home Page</h1>
     *      </a:page>
     *      <a:page>
     *          <h1>General Page</h1>
     *      </a:page>
     *      <a:page>
     *          <h1>Advanced Page</h1>
     *      </a:page>
     *  </a:pages>
     * </code>
     */
    this.$propHandlers["activepagenr"] =

    /**
     * @attribute {String} activepage the name of the active page.
     * Example:
     * <code>
     *  <a:tab activepage="general" width="250" height="100">
     *      <a:page id="home" caption="Home">
     *      ...
     *      </a:page>
     *      <a:page id="advanced" caption="Advanced">
     *          ...
     *      </a:page>
     *      <a:page id="general" caption="General">
     *          ...
     *      </a:page>
     *   </a:tab>
     * </code>
     */
    this.$propHandlers["activepage"]   = function(next, prop, force, callback, noEvent){
        if (!this.inited || apf.isNot(next)) return;

        if (!callback) {
            callback = this.$lastCallback;
            delete this.$lastCallback;
        }

        var page, info = {};
        page = this.$findPage(next, info);

        if (!page) {
            if (this.src) {
                if (this.isLoading[next])
                    return;
                
                if (this.$findPage("loading", {}))
                    this.$propHandlers["activepage"].call(this, "loading");
                
                this.setProperty("loading", true);
                this.isLoading[next] = true;

                page = this.ownerDocument.createElementNS(apf.ns.apf, "page");
                page.setAttribute("id", next);
                this.appendChild(page);

                var _self = this;
                page.insertMarkup(this.src, {
                    page     : next,
                    //@todo apf3.0 change callback arguments in xinclude
                    callback : function(options){
                        if (!options.xmlNode) {
                            var oError = new Error(apf.formatErrorString(0, null,
                                "Loading new page", "Could not load new page: "
                                + _self.src));
                                
                            _self.setProperty("loading", false);
                            
                            if (this.dispatchEvent("error", apf.extend({
                                error   : oError,
                                bubbles : true
                            }, options)) === false)
                                return true;
                            
                            throw oError;
                        }
                        else {
                            //for success
                            _self.setProperty("activepage", next);
    
                            if (callback)
                                callback();
    
                            _self.setProperty("loading", false);
                        }
                    }
                });
                return;
            }
            
            
            apf.console.warn("Setting tab page which doesn't exist, \
                              referenced by name: '" + next + "'");
            

            return false;
        }

        if (page.parentNode != this) {
            
            apf.console.warn("Setting active page on page component which \
                              isn't a child of this tab component. Cancelling.");
            

            return false;
        }

        if (!page.visible || page.disabled) {
            
            apf.console.warn("Setting active page on page component which \
                              is not visible or disabled. Cancelling.");
            

            return false;
        }

        //If page is given as first argument, let's use its position
        if (next.tagName) {
            next = info.position;
            this.activepage = page.name || next;
        }

        //Call the onbeforeswitch event;
        if (!noEvent) {
            var oEvent = {
                previous     : this.activepage,
                previousId   : this.activepagenr,
                previousPage : this.$activepage,
                next         : next,
                nextId       : info.position,
                nextpage     : page
            };

            if (this.dispatchEvent("beforeswitch", oEvent) === false) {
                //Loader support
                if (this.hideLoader)
                    this.hideLoader();

                return false;
            }
        }

        //Maintain an activepagenr property (not reentrant)
        this.activepagenr = info.position;
        this.setProperty("activepagenr", info.position);

        //Deactivate the current page, if any,  and activate the new one
        if (this.$activepage)
            this.$activepage.$deactivate();

        page.$activate();

        this.$activepage = page;
        

        //Loader support
        if (this.hideLoader) {
            if (page.$rendered !== false) {
                this.hideLoader();
            }
            else {
                //Delayed rendering support
                page.addEventListener("afterrender", function(){
                    this.parentNode.hideLoader();
                 });
            }
        }

        if (!noEvent) {
            if (page.$rendered !== false)
                this.dispatchEvent("afterswitch", oEvent);
            else {
                //Delayed rendering support
                page.addEventListener("afterrender", function(){ 
                    this.parentNode.dispatchEvent("afterswitch", oEvent);
                });
             }
        }
        
        if (typeof callback == "function") 
            callback();

        return true;
    };

    /**** Public methods ****/

    /**
     * Retrieves an array of all the page elements of this element.
     */
    this.getPages = function(){
        var r = [], nodes = this.childNodes;
        for (var i = 0, l = nodes.length; i < l; i++) {
            if ("page|case".indexOf(nodes[i].localName) > -1)
                r.push(nodes[i]);
        }
        return r;
    };

    /**
     * Retrieves a page element by it's name or child number
     * @param {mixed} nameOrId the name or child number of the page element to retrieve.
     * @return {Page} the found page element.
     */
    this.getPage = function(nameOrId){
        if (apf.isNot(nameOrId))
            return this.$activepage;
        else
            return this.$findPage(nameOrId);
    };

    /**
     * Add a new page element
     * @param {String} [caption] the text displayed on the button of the page.
     * @param {String} [name]    the name of the page which is can be referenced by.
     * @return {page} the created page element.
     */
    this.add = function(caption, name, jml){
        var page = apf.document.createElement(jml || "page");
        if (name)
            page.setAttribute("id", name);
        if (caption)
            page.setAttribute("caption", caption);
        this.appendChild(page);
        
        
        return page;
    };

    /**
     * Removes a page element from this element.
     * @param {mixed} nameOrId the name or child number of the page element to remove.
     * @return {Page} the removed page element.
     */
    this.remove = function(nameOrId){
        var page = this.$findPage(nameOrId);
        if (!page)
            return false;
        
        page.removeNode();

        
        return page;
    };

    

    /**** DOM Hooks ****/

    this.addEventListener("DOMNodeRemoved", function(e){
        var amlNode = e.currentTarget;
        if (e.$doOnlyAdmin || e.relatedNode != this 
          || amlNode.localName != "page")
            return;
        
        if (this.firstChild == amlNode && amlNode.nextSibling)
            amlNode.nextSibling.$first();
        if (this.lastChild == amlNode && amlNode.previousSibling)
            amlNode.previousSibling.$last();

        if (this.$activepage == amlNode) {
            if (amlNode.nextSibling || amlNode.previousSibling)
                this.set(amlNode.nextSibling || amlNode.previousSibling);
            else {
                
                this.$activepage  =
                this.activepage   =
                this.activepagenr = null;
            }
        }
        
        
        
        this.setProperty("length", this.childNodes.length);
        
    });

    this.addEventListener("DOMNodeInserted",function(e){
        var amlNode = e.currentTarget;
        
        if (amlNode.localName != "page" || e.relatedNode != this || amlNode.nodeType != 1)
            return;

        if (!e.$beforeNode) {
            var lastChild;
            if (lastChild = this.lastChild) {
                if (lastChild.nodeType != 1)
                    lastChild = lastChild.previousSibling;
                if (lastChild)
                    lastChild.$last(true);
            }
            amlNode.$last();
        }

        if (!this.firstChild || e.$beforeNode == this.firstChild) {
            if (this.firstChild)
                this.firstChild.$first(true);
            amlNode.$first();
        }

        if (this.$activepage) {
            var info = {};
            this.$findPage(this.$activepage, info);

            if (this.activepagenr != info.position) {
                if (parseInt(this.activepage) == this.activepage) {
                    this.activepage = info.position;
                    this.setProperty("activepage", info.position);
                }
                this.activepagenr = info.position;
                this.setProperty("activepagenr", info.position);
            }
        }
        else if (!this.$activepage)
            this.set(amlNode);
        
        
        this.setProperty("length", this.childNodes.length);
        
    });

    /**** Private state handling functions ****/

    this.$findPage = function(nameOrId, info){
        var node, nodes = this.childNodes;
        for (var t = 0, i = 0, l = nodes.length; i < l; i++) {
            node = nodes[i];
            if ("page|case".indexOf(node.localName) > -1 && (t++ == nameOrId
              || (nameOrId.localName && node || node.name) == nameOrId)) {
                if (info)
                    info.position = t - 1;
                return node;
            }
        }

        return null;
    };

    this.$enable = function(){
        var nodes = this.childNodes;
        for (var i = 0, l = nodes.length; i < l; i++) {
            if (nodes[i].enable)
                nodes[i].enable();
        }
    };

    this.$disable = function(){
        var nodes = this.childNodes;
        for (var i = 0, l = nodes.length; i < l; i++) {
            if (nodes[i].disable)
                nodes[i].disable();
        }
    };

    /**** Keyboard support ****/

    

    this.addEventListener("keydown", function(e){
        if (!this.$hasButtons)
            return;

        var page,
            key = e.keyCode;

        switch (key) {
            case 9:
                break;
            case 13:
                break;
            case 32:
                break;
            case 37: //LEFT
                page = this.getPage().previousSibling;
                while(page && (page.nodeType != 1
                  || "page|case".indexOf(page.localName) == -1 || !page.visible)) {
                    page = page.previousSibling;
                }

                if (page)
                    this.setProperty("activepage", page);
                break;
            case 39: //RIGHT
                page = this.getPage().nextSibling;
                while(page && (page.nodeType != 1 
                  || "page|case".indexOf(page.localName) == -1 || !page.visible)) {
                    page = page.nextSibling;
                }

                if (page)
                    this.setProperty("activepage", page);
                break;
            default:
                return;
        }
        //return false;
    }, true);

    

    /**** Init ****/

    this.$loadChildren = function(callback){
        var page  = false,
            _self = this,
            i, j, l, node, nodes;

        this.inited = true;

        if (this.$hasButtons) {
            this.$buttons = this.$getLayoutNode("main", "buttons", this.$ext);
            this.$buttons.setAttribute("id", this.$uniqueId + "_buttons");
        }

        this.oPages = this.$getLayoutNode("main", "pages", this.$ext);
        
        

        //Skin changing support
        if (this.$int) {
            //apf.AmlParser.replaceNode(this.oPages, oPages);
            this.$int = this.oPages;
            page      = true;

            //@todo apf3.0 skin change?
            nodes = this.childNodes;
            for (i = 0; i < nodes.length; i++) {
                node = nodes[i];
                if(node.nodeType != 1)
                    continue;
                node.$draw(true);
                if(node.$skinchange)
                    node.$skinchange();
                node.$loadAml();
            }
        }
        else {
            this.$int = this.oPages;

            //Build children
            nodes = this.childNodes;
            for (j = 0, i = 0, l = nodes.length; i < l; i++) {
                if ("page|case".indexOf((node = nodes[i]).localName) > -1) {
                    //Set first page marker
                    if (j++ == 0)
                        node.$first();
                    if (j == l)
                        node.$last();
                }
            }
        }

        //Set active page
        if (node) {
            this.activepage = (typeof this.activepage != "undefined"
                ? this.activepage
                : this.activepagenr) || 0;
            page = this.getPage(this.activepage);
            if (page.render != "runtime" || page.$rendered)
                this.$propHandlers.activepage.call(this, this.activepage);
        }
        else {
            this.isPages = false;
        }

        
        this.setProperty("length", j);
        

        this.ready = true;
        


        if (!this.activepage && this.getAttribute("src")) {
            this.src = this.getAttribute("src");
            this.$propHandlers["activepage"].call(this);
        }
    };
    
    this.$destroy = function(bSkinChange) {
        if (bSkinChange || !this.oScroller)
            return;
        
    };
}).call(apf.BaseTab.prototype = new apf.Presentation());




/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/xforms.js)SIZE(9305)TIME(1269561670)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */

apf.__XFORMS__ = 1 << 17;




/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/focussable.js)SIZE(3221)TIME(1270838606)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */

apf.__FOCUSSABLE__ = 1 << 26;


apf.Focussable = function(){
    this.$regbase = this.$regbase | apf.__FOCUSSABLE__;
    
    /**
     * Sets the position in the list that determines the sequence
     * of elements when using the tab key to move between them.
     * Call-chaining is supported.
     * @param {Number} tabindex the position in the list
     */
    this.setTabIndex = function(tabindex){
        apf.window.$removeFocus(this);
        apf.window.$addFocus(this, tabindex);
        return this;
    };

    /**
     * Gives this element the focus. This means that keyboard events
     * are send to this element.
     */
    this.focus = function(noset, e, nofix){
        if (!noset) {
            if (this.$isWindowContainer > -1) {
                apf.window.$focusLast(this, e, true);
            }
            else {
                apf.window.$focus(this, e);

                
                if (!nofix && apf.hasFocusBug)
                    apf.window.$focusfix();
                
            }

            return this;
        }

        if (this.$focus && !this.editable)
            this.$focus(e);

        this.dispatchEvent("focus", apf.extend({
            bubbles    : true
        }, e));
        return this;
    };

    /**
     * Removes the focus from this element.
     * Call-chaining is supported.
     */
    this.blur = function(noset, e){
        
        if (apf.popup.isShowing(this.$uniqueId))
            apf.popup.forceHide(); //This should be put in a more general position
        
        
        if (this.$blur)
            this.$blur(e);

        if (!noset)
            apf.window.$blur(this);

        this.dispatchEvent("blur", apf.extend({
            bubbles    : !e || !e.cancelBubble
        }, e));
        return this;
    };

    /**
     * Determines whether this element has the focus
     * @returns {Boolean} indicating whether this element has the focus
     */
    this.hasFocus = function(){
        return apf.document.activeElement == this || this.$isWindowContainer
            && (apf.document.activeElement || {}).$focusParent == this;
    };
};




/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/media.js)SIZE(18898)TIME(1270838606)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */

apf.__MEDIA__ = 1 << 20;




/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/basesimple.js)SIZE(1763)TIME(1269561670)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * Baseclass of a simple element. This are usually displaying elements 
 * (i.e. {@link element.label}, {@link element.picture})
 *
 * @constructor
 * @baseclass
 *
 * @inherits apf.StandardBinding
 * @inherits apf.DataAction
 *
 * @author      Ruben Daniels (ruben AT ajax DOT org)
 * @version     %I%, %G%
 * @since       0.8
 */
apf.BaseSimple = function(){
    this.$init(true);
};

(function() {
    
    this.implement(apf.DataAction);
    
    
    this.getValue = function(){
        return this.value;
    };

}).call(apf.BaseSimple.prototype = new apf.StandardBinding());





/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/a11y.js)SIZE(5144)TIME(1257329189)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */

apf.__ALIGNMENT__ = 1 << 29;



/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/basetree.js)SIZE(43462)TIME(1270937593)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * Baseclass of elements that allows the user to select one or more items
 * from a tree based element.
 *
 * @constructor
 * @baseclass
 *
 * @inherits apf.XForms
 * @inherits apf.MultiSelect
 * @inherits apf.Cache
 * @inherits apf.DataAction
 * @inherits apf.Rename
 *
 * @author      Ruben Daniels (ruben AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.8
 * @default_private
 *
 */
apf.BaseTree = function(){
    this.$init(true);
    
    
    this.$dynCssClasses = [];
    
    
    this.$nodes = [];
};

(function() {
    this.implement(
        
        
        apf.Rename,
        
        
        apf.DataAction,
        
        
        apf.Cache
        
    );

    /**** Properties and Attributes ****/

    //Options
    this.$isTreeArch   = true; // This element has a tree architecture.
    this.$focussable   = true; // This object can get the focus.
    this.multiselect   = false; // Initially multiselect is disabled.
    this.bufferselect  = true;
    
    this.startcollapsed  = true;
    this.$animType       = apf.tween.NORMAL;
    this.$animOpenStep   = 3;
    this.$animCloseStep  = 1;
    this.$animSpeed      = 10;
    
    var HAS_CHILD = 1 << 1,
        IS_CLOSED = 1 << 2,
        IS_LAST   = 1 << 3,
        IS_ROOT   = 1 << 4;
    
    var treeState = this.$treeState = {};
    this.$treeState[0]                               = "";
    this.$treeState[HAS_CHILD]                       = "min";
    this.$treeState[HAS_CHILD | IS_CLOSED]           = "plus";
    this.$treeState[IS_LAST]                         = "last";
    this.$treeState[IS_LAST | HAS_CHILD]             = "minlast";
    this.$treeState[IS_LAST | HAS_CHILD | IS_CLOSED] = "pluslast";
    this.$treeState[IS_ROOT]                         = "root";
    
    /**** Properties and Attributes ****/

    /**
     * @attribute {Boolean} openadd         whether the tree expands the parent to which a node is added. Defaults to true.
     * @attribute {Boolean} startcollapsed  whether the tree collapses all nodes that contain children on load. Defaults to true.
     * @attribute {Boolean} nocollapse      whether the user cannot collapse a node. Defaults to false.
     * @attribute {Boolean} singleopen      whether the tree will expand a node by a single click. Defaults to false.
     * @attribute {Boolean} prerender       whether the tree will render all the nodes at load. Defaults to true.
     */
    this.$booleanProperties["openadd"]        = true;
    this.$booleanProperties["startcollapsed"] = true;
    this.$booleanProperties["nocollapse"]     = true;
    this.$booleanProperties["singleopen"]     = true;
    this.$booleanProperties["prerender"]      = true;
    this.$booleanProperties["removecontainer"] = true;
    
    this.$supportedProperties.push("openadd", "startcollapsed", "nocollapse",
        "singleopen", "prerender", "removecontainer");
    
    this.openadd        = true;
    this.startcollapsed = 1;
    this.prerender      = true;
    
    /**** Public Methods ****/
    
    /**
     * Expands all items in the tree
     */
    this.expandAll    = function(){
        if (!this.xmlRoot)
            return;
        
        var xpath = this.each.split('|')
                        .join('[' + this.each.replace(/\|/g, " or ") + ']|.//'),
            _self = this;
        (function(node){
            var nodes = node.selectNodes(xpath);
            //for (var i = nodes.length - 1; i >= 0; i--) {
            for (var i = 0; i < nodes.length; i++) {
                _self.slideToggle(apf.xmldb.getHtmlNode(nodes[i], _self), 1, true);
                arguments.callee(nodes[i]);
            }
        })(this.xmlRoot);
    };
    
    /**
     * Collapses all items in the tree
     */
    this.collapseAll   = function(){
        if (!this.xmlRoot)
            return;
        
        var pNodes = this.xmlRoot.selectNodes(".//" + this.each
          .split('|').join('[' + this.each.replace(/\|/g, " or ") + ']|.//'));
        
        for (var i = pNodes.length - 1; i >=0; i--)
            this.slideToggle(apf.xmldb.getHtmlNode(pNodes[i], this), 2, true);
    };
    
    /**
     * Selects a node and expands each parent of it.
     */
    this.expandAndSelect = function(xmlNode) {
        if (!this.xmlRoot)
            return;
        
        var _self = this;
        (function _recur(loopNode){
            var pNode = _self.getTraverseParent(loopNode);
            if (pNode != _self.xmlRoot)
                _recur(pNode);
            _self.slideToggle(apf.xmldb.getHtmlNode(pNode, _self), 1, true);
        })(xmlNode);
        
        this.select(xmlNode);
    }
    
    /**
     * @notimplemented
     * @todo who's volunteering?
     * @private
     */
    this.selectPath = function(path){};
    
    /**** Sliding functions ****/
    
    /**
     * @private
     */
    this.slideToggle = function(htmlNode, force, immediate, userAction){
        if (this.nocollapse || userAction && this.disabled)
            return;
        
        if (!htmlNode)
            htmlNode = this.$selected;
        
        var id = htmlNode.getAttribute(apf.xmldb.htmlIdTag);
        while (!id && htmlNode.parentNode)
            id = (htmlNode = htmlNode.parentNode)
                .getAttribute(apf.xmldb.htmlIdTag);

        var container = this.$getLayoutNode("item", "container", htmlNode);
        if (!container) return;
        
        if (apf.getStyle(container, "display") == "block") {
            if (force == 1) return;
            htmlNode.className = htmlNode.className.replace(/min/, "plus");
            this.slideClose(container, apf.xmldb.getNode(htmlNode), immediate);
        }
        else {
            if (force == 2) return;
            htmlNode.className = htmlNode.className.replace(/plus/, "min");
            this.slideOpen(container, apf.xmldb.getNode(htmlNode), immediate);
        }
    };
    
    this.isCollapsed = function(xmlNode){
        return (apf.getStyle(this.$getLayoutNode("item", "container",
            apf.xmldb.getHtmlNode(xmlNode, this)), "display") == "none");
    }
    
    var lastOpened = {};
    /**
     * @private
     */
    this.slideOpen = function(container, xmlNode, immediate){
        if (!xmlNode)
            xmlNode = this.selected;
        
        var htmlNode = apf.xmldb.findHtmlNode(xmlNode, this);
        if (!container)
            container = this.$findContainer(htmlNode);
        
        //We don't slide open elements without children.
        if (!container.innerHTML && !this.getTraverseNodes(xmlNode).length)
            return; 

        if (this.singleopen) {
            var pNode = this.getTraverseParent(xmlNode),
                p     = (pNode || this.xmlRoot).getAttribute(apf.xmldb.xmlIdTag);
            if (lastOpened[p] && lastOpened[p][1] != xmlNode 
              && this.getTraverseParent(lastOpened[p][1]) == pNode)
                this.slideToggle(lastOpened[p][0], 2);//lastOpened[p][1]);
            lastOpened[p] = [htmlNode, xmlNode];
        }
        
        container.style.display = "block";

        if (!this.prerender && this.$hasLoadStatus(xmlNode, "potential") 
          && !container.innerHTML) {
            this.$extend(xmlNode, container, immediate);
            return;
        }
        
        if (immediate || container.scrollHeight > 1000) {
            container.style.height = "auto";
            container.style.overflow = "visible";
            return;
        }

        var _self = this;
        apf.tween.single(container, {
            type    : 'scrollheight', 
            from    : 0, 
            to      : container.scrollHeight, 
            anim    : this.$animType, 
            steps   : this.$animOpenStep,
            interval: this.$animSpeed,
            onfinish: function(container){
                if (xmlNode && _self.$hasLoadStatus(xmlNode, "potential")) {
                    $setTimeout(function(){
                        container.style.height = container.scrollHeight + "px";
                        container.style.overflow = "hidden";
                        _self.$extend(xmlNode, container);
                    });
                    container.style.height = "auto";
                    container.style.overflow = "visible";
                }
                else {
                    container.style.overflow = "visible";
                    container.style.height = "auto";
                }
            }
        });
    };

    /**
     * @private
     */
    this.slideClose = function(container, xmlNode, immediate){
        if (this.nocollapse) 
            return;
        
        if (!xmlNode)
            xmlNode = this.selected;
        
        if (this.singleopen) {
            var p = (this.getTraverseParent(xmlNode) || this.xmlRoot)
                .getAttribute(apf.xmldb.xmlIdTag);
            lastOpened[p] = null;
        }
        
        if (!container) {
            var htmlNode = apf.xmldb.findHtmlNode(xmlNode, this);
            container = this.$findContainer(htmlNode);
        }
        
        container.style.height   = container.offsetHeight;
        container.style.overflow = "hidden";
        
        if (immediate) {
            container.style.height = 0;
            container.style.display = "none";
            return;
        }

        apf.tween.single(container, {
            type    : 'scrollheight', 
            from    : container.scrollHeight, 
            to      : 0, 
            anim    : this.$animType, 
            steps   : this.$animCloseStep,
            interval: this.$animSpeed,
            onfinish: function(container, data){
               container.style.display = "none";
            }
        });
    };
    
    /**** Databinding Support ****/

    //@todo apf3.x refactor
    this.$add = function(xmlNode, Lid, xmlParentNode, htmlParentNode, beforeNode, isLast, depth){
        if (this.$isTreeArch && this.$needsDepth && typeof depth == "undefined") {
            var loopNode = xmlParentNode; depth = 0;
            while(loopNode != this.xmlRoot) {
                depth++;
                loopNode = loopNode.parentNode;
            }
        }
        
        var loadChildren     = this.$getBindRule("insert", xmlNode) ? true : false,
            traverseNodes    = this.getTraverseNodes(xmlNode),
            hasTraverseNodes = traverseNodes.length ? true : false,
            hasChildren      = loadChildren || hasTraverseNodes,
            startcollapsed   = this.$hasBindRule("collapsed")
                ? (this.$getDataNode("collapsed", xmlNode) ? true : false)
                : (this.$hasBindRule("expanded") 
                    ? (this.$getDataNode("expanded", xmlNode) ? false : true)
                    : this.startcollapsed),
            state            = (hasChildren ? HAS_CHILD : 0) | (startcollapsed && hasChildren
                || loadChildren ? IS_CLOSED : 0) | (isLast ? IS_LAST : 0),

            htmlNode         = this.$initNode(xmlNode, state, Lid, depth),
            container        = this.$getLayoutNode("item", "container"),
            eachLength;

        if (!startcollapsed && !this.nocollapse)
            container.setAttribute("style", "overflow:visible;height:auto;display:block;");
        
        var msg, removeContainer = (!this.removecontainer || hasChildren);

        //TEMP on for dynamic subloading
        if (!hasChildren || loadChildren)
            container.setAttribute("style", "display:none;");

        //Dynamic SubLoading (Insertion) of SubTree
        if (!this.prerender)
            eachLength = traverseNodes.length;

        if (hasChildren && !this.prerender && eachLength > 2 && startcollapsed
          || loadChildren && (!this.$hasLoadStatus(xmlNode) 
          || this.$hasLoadStatus(xmlNode, "potential")))
            this.$setLoading(xmlNode, container);
        else if (!hasTraverseNodes && (msg = this.$applyBindRule("empty", xmlNode))) {
            this.$setEmptyMessage(container, msg);
        }

        if ((!htmlParentNode || htmlParentNode == this.$container) 
          && xmlParentNode == this.xmlRoot && !beforeNode) {
            this.$nodes.push(htmlNode);
            if (!apf.isChildOf(htmlNode, container, true) && removeContainer)
                this.$nodes.push(container);
            
            this.$setStyleClass(htmlNode,  "root");
            this.$setStyleClass(container, "root");
        }
        else {
            if (!htmlParentNode) {
                htmlParentNode = apf.xmldb.findHtmlNode(xmlNode.parentNode, this);
                htmlParentNode = htmlParentNode 
                    ? this.$getLayoutNode("item", "container", htmlParentNode) 
                    : this.$container;
            }
            
            if (htmlParentNode == this.$container) {
                this.$setStyleClass(htmlNode,  "root");
                this.$setStyleClass(container, "root");
            }
            
            if (!beforeNode && this.getNextTraverse(xmlNode))
                beforeNode = apf.xmldb.findHtmlNode(this.getNextTraverse(xmlNode), this);
            if (beforeNode && beforeNode.parentNode != htmlParentNode)
                beforeNode = null;
        
            if (htmlParentNode.style 
              && this.getTraverseNodes(xmlNode.parentNode).length == 1) 
                this.$removeEmptyMessage(htmlParentNode);
        
            //alert("|" + htmlNode.nodeType + "-" + htmlParentNode.nodeType + "-" + beforeNode + ":" + container.nodeType);
            //Insert Node into Tree
            if (htmlParentNode.style) {
                apf.insertHtmlNode(htmlNode, htmlParentNode, beforeNode);
                if (!apf.isChildOf(htmlNode, container, true) && removeContainer) 
                    var container = apf.insertHtmlNode(container, 
                        htmlParentNode, beforeNode);
            }
            else {
                htmlParentNode.insertBefore(htmlNode, beforeNode);
                if (!apf.isChildOf(htmlParentNode, container, true) && removeContainer) 
                    htmlParentNode.insertBefore(container, beforeNode);
            }

            //Fix parent if child is added to drawn parentNode
            if (htmlParentNode.style) {
                if (!startcollapsed && this.openadd && htmlParentNode != this.$container 
                  && htmlParentNode.style.display != "block") 
                    this.slideOpen(htmlParentNode, xmlParentNode, true);
                
                //this.$fixItem(xmlNode, htmlNode); this one shouldn't be called, because it should be set right at init
                this.$fixItem(xmlParentNode, apf.xmldb.findHtmlNode(xmlParentNode, this));
                if (this.getNextTraverse(xmlNode, true)) { //should use each here
                    this.$fixItem(this.getNextTraverse(xmlNode, true), 
                        apf.xmldb.findHtmlNode(this.getNextTraverse(xmlNode, true),
                        this));
                }
            }
        }

        if ((this.prerender || eachLength < 3 || !startcollapsed) && (xmlNode.namespaceURI != apf.ns.apf || xmlNode.localName != "item")) {
            this.$addNodes(xmlNode, container, false, null, null, (depth || 0) + 1); //checkChildren ???
        }
        /*else {
            this.$setLoadStatus(xmlNode, "potential");
        }*/

        return container;
    };
    
    this.$fill = function(){
        if (this.$useiframe)
            this.$pHtmlDoc = this.oDoc;

        if (this.$useTable) {
            apf.insertHtmlNodes(this.$nodes, this.$container, null,
                 "<table class='records' cellpadding='0' cellspacing='0'><tbody>", 
                 "</tbody></table>");
        }
        else
            apf.insertHtmlNodes(this.$nodes, this.$container);

        this.$nodes.length = 0;
    };
    
    this.$getParentNode = function(htmlNode){
        return htmlNode 
            ? this.$getLayoutNode("item", "container", htmlNode) 
            : this.$container;
    };

    this.$fixItem = function(xmlNode, htmlNode, isDeleting, oneLeft, noChildren){
        if (!htmlNode) return;

        if (isDeleting) {
            //if isLast fix previousSibling
            var prevSib;
            if (prevSib = this.getNextTraverse(xmlNode, true))
                this.$fixItem(prevSib, this.$findHtmlNode(prevSib
                    .getAttribute(apf.xmldb.xmlIdTag) + "|" 
                    + this.$uniqueId), null, true);

            //if no sibling fix parent
            if (!this.emptyMessage && xmlNode.parentNode.selectNodes(this.each).length == 1)
                this.$fixItem(xmlNode.parentNode, this.$findHtmlNode(
                    xmlNode.parentNode.getAttribute(apf.xmldb.xmlIdTag) 
                    + "|" + this.$uniqueId), null, false, true); 
        }
        else {
            var container   = this.$getLayoutNode("item", "container", htmlNode),
                hasChildren = false;
            if (noChildren) 
                hasChildren = false;
            else if (this.getTraverseNodes(xmlNode).length > 0)
                hasChildren = true;
            else if (this.$hasLoadStatus(xmlNode, "potential"))
                hasChildren = true;
            else
                hasChildren = false;
            
            var isClosed = hasChildren && container.style.display != "block",
                isLast   = this.getNextTraverse(xmlNode, null, oneLeft ? 2 : 1)
                    ? false
                    : true,
                state = (hasChildren ? HAS_CHILD : 0)
                    | (isClosed ? IS_CLOSED : 0) | (isLast ? IS_LAST : 0);
            this.$setStyleClass(this.$getLayoutNode("item", "class", htmlNode),
                treeState[state], ["min", "plus", "last", "minlast", "pluslast"]);
            this.$setStyleClass(this.$getLayoutNode("item", "container", htmlNode),
                treeState[state], ["min", "plus", "last", "minlast", "pluslast"]);

            if(this.$getLayoutNode("item", "openclose", htmlNode))
                this.$getLayoutNode("item", "openclose", htmlNode)
                    .setAttribute("children", hasChildren);
            
            if (!hasChildren && container)
                container.style.display = "none";
        }
    };

    this.$deInitNode = function(xmlNode, htmlNode){
        //Lookup container
        var containerNode = this.$getLayoutNode("item", "container", htmlNode),
            pContainer    = htmlNode.parentNode;
        
        //Remove htmlNodes from tree
        containerNode.parentNode.removeChild(containerNode);
        pContainer.removeChild(htmlNode);
        
        //Datagrid??
        if (this.$withContainer)
            htmlNode.parentNode.removeChild(htmlNode.nextSibling);
        
        //Fix Images (+, - and lines)
        if (xmlNode.parentNode != this.xmlRoot)
            this.$fixItem(xmlNode, htmlNode, true);
        
        var msg;
        if (!pContainer.childNodes.length && (msg = this.$applyBindRule("empty", xmlNode)))
            this.$setEmptyMessage(pContainer, msg);
        
        //Fix look (tree thing)
        this.$fixItem(xmlNode, htmlNode, true);
        //this.$fixItem(xmlNode.parentNode, apf.xmldb.findHtmlNode(xmlNode.parentNode, this));
        /*throw new Error();
        if(xmlNode.previousSibling) //should use each here
            this.$fixItem(xmlNode.previousSibling, apf.xmldb.findHtmlNode(xmlNode.previousSibling, this));*/
    };
    
    this.$moveNode = function(xmlNode, htmlNode){
        if (!self.apf.debug && !htmlNode) 
            return;
            
        var container;
        if (this.$hasLoadStatus(xmlNode.parentNode, "potential")) {
            container = this.$getLayoutNode("item", "container", htmlNode);
            htmlNode.parentNode.removeChild(htmlNode);
            container.parentNode.removeChild(container);
            this.$extend(xmlNode.parentNode);
            return;
        }
        
        var oPHtmlNode = htmlNode.parentNode,
            pHtmlNode  = apf.xmldb.findHtmlNode(xmlNode.parentNode, this),
        //if(!pHtmlNode) return;
        
            nSibling = this.getNextTraverse(xmlNode),
            beforeNode = nSibling
                ? apf.xmldb.findHtmlNode(nSibling, this)
                : null,
            pContainer = pHtmlNode
                ? this.$getLayoutNode("item", "container", pHtmlNode)
                : this.$container;
        container  = this.$getLayoutNode("item", "container", htmlNode);

        if (pContainer != oPHtmlNode && this.getTraverseNodes(xmlNode.parentNode).length == 1)
            this.$removeEmptyMessage(pContainer);

        pContainer.insertBefore(htmlNode, beforeNode);
        if (container)
            pContainer.insertBefore(container, beforeNode);
        
        /*if (!this.startcollapsed) {
            pContainer.style.display = "block";
            pContainer.style.height = "auto";
        }*/
        
        var msg;
        if (!oPHtmlNode.childNodes.length && (msg = this.$applyBindRule("empty", xmlNode)))
            this.$setEmptyMessage(oPHtmlNode, msg);
        
        if (this.openadd && pHtmlNode != this.$container && pContainer.style.display != "block") 
            this.slideOpen(pContainer, pHtmlNode, true);
        
        //Fix look (tree thing)
        this.$fixItem(xmlNode, htmlNode);
        
        var tParent = this.getTraverseParent(xmlNode);
        this.$fixItem(tParent, apf.xmldb.findHtmlNode(tParent, this));
        if (this.getNextTraverse(xmlNode, true)) { //should use each here
            this.$fixItem(this.getNextTraverse(xmlNode, true),
                apf.xmldb.findHtmlNode(this.getNextTraverse(xmlNode, true),
                this));
        }
    };
    
    //???
    this.$setLoading = function(xmlNode, container){
        this.$setLoadStatus(xmlNode, "potential");
        
        var len = this.getTraverseNodes(xmlNode).length;
        if (!len || len > 20) {
            this.$getNewContext("loading");
            apf.insertHtmlNode(this.$getLayoutNode("loading"), container);
        }
    };
    
    //???
    this.$removeLoading = function(htmlNode){
        if (!htmlNode) return;
        this.$getLayoutNode("item", "container", htmlNode).innerHTML = "";
    };
    
    //check databinding for how this is normally implemented
    this.$extend = function(xmlNode, container, immediate){
        var rule       = this.$getBindRule("insert", xmlNode),
            xmlContext = rule && rule.match
                ? (rule.cmatch || rule.compile("match"))(xmlNode)
                : xmlNode;

        if (rule && xmlContext) {
            this.$setLoadStatus(xmlNode, "loading");
            
            if (rule.get) {
                
                
                this.getModel().$insertFrom(rule.getAttribute("get"), {
                    xmlNode     : xmlContext,
                    insertPoint : xmlContext, 
                    amlNode     : this
                });
            }
            else {
                if (this.$applyBindRule("insert", xmlNode))
                    this.insert(data, {insertPoint: xmlContext});
            }
        }
        else if (!this.prerender) {
            this.$setLoadStatus(xmlNode, "loading");
            this.$removeLoading(apf.xmldb.findHtmlNode(xmlNode, this));
            xmlUpdateHandler.call(this, {
                action  : "insert", 
                xmlNode : xmlNode, 
                result  : this.$addNodes(xmlNode, container, true), //checkChildren ???
                anim    : !immediate
            });
        }
    };
    
    function xmlUpdateHandler(e){
        /*
            Display the animation if the item added is 
            * Not in the cache
            - Being insterted using xmlUpdate
            - there is at least 1 child inserted
        */
        
        if (e.action == "move-away")
            this.$fixItem(e.xmlNode, apf.xmldb.findHtmlNode(e.xmlNode, this), true);

        if (e.action != "insert") return;
        
        var htmlNode = this.$findHtmlNode(e.xmlNode.getAttribute(
            apf.xmldb.xmlIdTag) + "|" + this.$uniqueId);
        if (!htmlNode) return;

        //this.$hasLoadStatus(e.xmlNode, "loading")
        if (e.action == "insert" && e.result.length > 0) {
            var container = this.$getLayoutNode("item", "container", htmlNode);
            this.slideOpen(container, e.xmlNode);//, e.$anim ? false : true
        }
        else
            this.$fixItem(e.xmlNode, htmlNode);
        
        //Can this be removed?? (because it was added in the insert function)
        //if (this.$hasLoadStatus(e.xmlNode, "loading"))
            //this.$setLoadStatus(e.xmlNode, "loaded");
    }
    
    this.addEventListener("xmlupdate", xmlUpdateHandler);
    
    /**** Keyboard Support ****/
    
    
    this.addEventListener("beforerename", function(){
        if (this.$tempsel) {
            clearTimeout(this.timer);
            this.select(this.$tempsel);

            this.$tempsel = null;
            this.timer   = null;
        }
    });
    
    
    
    this.addEventListener("keydown", function(e){
        var key      = e.keyCode,
            ctrlKey  = e.ctrlKey,
            shiftKey = e.shiftKey,
            selHtml  = this.$caret || this.$selected,
            pos, top, el, node, nodes, sNode, pNode, container;

        if (!selHtml || this.renaming) 
            return;

        var selXml = this.caret || this.selected,
            oExt   = this.$ext;

        switch (key) {
            case 13:
                if (this.$tempsel)
                    this.$selectTemp();
            
                if (this.ctrlselect == "enter")
                    this.select(this.caret, true);
            
                this.choose(selHtml);
                break;
            case 32:
                if (this.$tempsel)
                    this.$selectTemp();

                if (this.$mode && !ctrlKey) {
                    var sel = this.getSelection();
                    if (!sel.length || !this.multiselect)
                        this.checkToggle(this.caret);
                    else
                        this.checkList(sel, this.isChecked(this.selected), true);
                }
                else if (ctrlKey || !this.isSelected(this.caret))
                    this.select(this.caret, true);
                return false;
            case 46:
                if (this.$tempsel)
                    this.$selectTemp();
            
                //DELETE
                //this.remove();
                this.remove(this.caret); //this.mode != "check"
                break;
            case 36:
                //HOME
                this.$setTempSelected(this.getFirstTraverseNode(), false, shiftKey);
                oExt.scrollTop = 0;
                return false;
            case 35:
                //END
                var lastNode = this.getLastTraverseNode();
                while (!this.isCollapsed(lastNode))
                    lastNode = this.getLastTraverseNode(lastNode);
                
                this.$setTempSelected(lastNode, false, shiftKey, true);
                oExt.scrollTop = oExt.scrollHeight;
                return false;
            case 37:
                //LEFT
                if (this.$tempsel)
                    this.$selectTemp();
                    
                if (this.caret.selectSingleNode(this.each) 
                  && !this.isCollapsed(this.caret))
                    this.slideToggle(this.$caret || this.$selected, 2)
                else if (pNode = this.getTraverseParent(this.caret))
                    this.select(pNode)
                return false;
            case 107: //+
            case 187: //+
            case 39:
                //RIGHT
                if (this.$tempsel)
                    this.$selectTemp();
            
                if (this.$hasLoadStatus(this.caret, "potential") 
                  || this.getFirstTraverseNode(this.caret))
                    this.slideToggle(this.$caret || this.$selected, 1)
                break;
            case 109:
            case 189:
                //-
                if (this.getFirstTraverseNode(this.caret))
                    this.slideToggle(this.$caret || this.$selected, 2)
                break;
            case 38:
                //UP
                if (!selXml && !this.$tempsel) 
                    return;
                
                node = this.$tempsel 
                    ? apf.xmldb.getNode(this.$tempsel) 
                    : selXml;
                
                sNode = this.getNextTraverse(node, true);
                if (sNode) {
                    nodes = this.getTraverseNodes(sNode);
                    
                    do {
                        container = this.$getLayoutNode("item", "container",
                            this.$findHtmlNode(apf.xmldb.getID(sNode, this)));
                        if (container && apf.getStyle(container, "display") == "block" 
                          && nodes.length) {
                                sNode = nodes[nodes.length-1];
                        }
                        else {
                            break;
                        }
                    }
                    while (sNode && (nodes = this.getTraverseNodes(sNode)).length);
                }
                else if (this.getTraverseParent(node) == this.xmlRoot) {
                    this.dispatchEvent("selecttop");
                    return;
                }
                else
                    sNode = this.getTraverseParent(node);

                if (sNode && sNode.nodeType == 1)
                   this.$setTempSelected(sNode, ctrlKey, shiftKey, true);
                else
                    return false;
                
                selHtml = apf.xmldb.findHtmlNode(sNode, this);
                top     = apf.getAbsolutePosition(selHtml, this.$container)[1]
                     - (selHtml.offsetHeight/2);
                if (top <= oExt.scrollTop)
                    oExt.scrollTop = top;
                
                return false;
            case 40:
                //DOWN
                if (!selXml && !this.$tempsel) 
                    return;

                node = this.$tempsel 
                    ? apf.xmldb.getNode(this.$tempsel)
                    : selXml;
                
                sNode = this.getFirstTraverseNode(node);
                if (sNode) {
                    container = this.$getLayoutNode("item", "container",
                        this.$findHtmlNode(apf.xmldb.getID(node, this)));
                    if (container && apf.getStyle(container, "display") != "block")
                        sNode = null;
                }
                
                while (!sNode) {
                    pNode = this.getTraverseParent(node);
                    if (!pNode) break;
                    
                    var i = 0;
                    nodes = this.getTraverseNodes(pNode);
                    while (nodes[i] && nodes[i] != node)
                        i++;
                    sNode = nodes[i+1];
                    node  = pNode;
                }

                if (sNode && sNode.nodeType == 1)
                   this.$setTempSelected(sNode, ctrlKey, shiftKey);
                else
                    return false;
                    
                selHtml = apf.xmldb.findHtmlNode(sNode, this);
                top     = apf.getAbsolutePosition(selHtml, this.$container)[1]
                    + (selHtml.offsetHeight/2);
                if (top > oExt.scrollTop + oExt.offsetHeight)
                    oExt.scrollTop = top - oExt.offsetHeight;
                
                return false;
            case 33: //@todo
                //PGUP
                pos   = apf.getAbsolutePosition(this.$container);
                el    = document.elementFromPoint(pos[0] + this.$container.offsetWidth
                      - 2, pos[1] + 2);
                sNode = apf.xmldb.findXmlNode(el);
                if (sNode == this.selected) {
                    oExt.scrollTop -= oExt.offsetHeight - apf.getHeightDiff(oExt);
                    el    = document.elementFromPoint(pos[0] + this.$container.offsetWidth
                          - 2, pos[1] + 2);
                    sNode = apf.xmldb.findXmlNode(el);
                }
                this.select(sNode);
                
                selHtml = apf.xmldb.findHtmlNode(sNode, this);
                top     = apf.getAbsolutePosition(selHtml, this.$container)[1]
                     - (selHtml.offsetHeight / 2);
                if (top <= oExt.scrollTop)
                    oExt.scrollTop = top;
                break;
            case 34: //@todo
                //PGDN
                pos   = apf.getAbsolutePosition(this.$container);
                el    = document.elementFromPoint(pos[0] + this.$container.offsetWidth
                      - 2, pos[1] + this.$ext.offsetHeight - 4);
                sNode = apf.xmldb.findXmlNode(el);
                if (sNode == this.selected) {
                    oExt.scrollTop += oExt.offsetHeight - apf.getHeightDiff(oExt);
                    el    = document.elementFromPoint(pos[0] + this.$container.offsetWidth
                          - 2, pos[1] + this.$ext.offsetHeight - 4);
                    sNode = apf.xmldb.findXmlNode(el);
                }
                this.select(sNode);
                
                selHtml = apf.xmldb.findHtmlNode(sNode, this);
                top     = apf.getAbsolutePosition(selHtml, this.$container)[1]
                    + (selHtml.offsetHeight/2);
                if (top > oExt.scrollTop + oExt.offsetHeight)
                    oExt.scrollTop = top - oExt.offsetHeight;
                break;
            default:
                if (this.celledit) {
                    if (!ctrlKey && !e.altKey && (key > 46 && key < 112 || key > 123))
                        this.startRename(null, true);
                    return;
                }
                else if (key == 65 && ctrlKey) {
                    this.selectAll();
                    return false;
                } 
                //@todo make this work with the sorted column
                else if (this.caption || (this.bindingRules || {})["caption"]) {
                    if (!this.xmlRoot) return;
                    
                    //this should move to a onkeypress based function
                    if (!this.lookup || new Date().getTime()
                      - this.lookup.date.getTime() > 300)
                        this.lookup = {
                            str  : "",
                            date : new Date()
                        };
                    
                    this.lookup.str += String.fromCharCode(key);
    
                    var nodes = this.getTraverseNodes(); //@todo start at current indicator
                    for (var v, i = 0; i < nodes.length; i++) {
                        v = this.$applyBindRule("caption", nodes[i]);
                        if (v && v.substr(0, this.lookup.str.length)
                          .toUpperCase() == this.lookup.str) {
                            
                            if (!this.isSelected(nodes[i])) {
                                if (this.mode == "check")
                                    this.setCaret(nodes[i]);
                                else
                                    this.select(nodes[i]);
                            }
                            
                            if (selHtml)
                                this.$container.scrollTop = selHtml.offsetTop
                                    - (this.$container.offsetHeight
                                    - selHtml.offsetHeight) / 2;
                            return;
                        }
                    }
                    return;
                }
                break;
        }
    }, true);
    
    
    /**** Rename Support ****/
    
    
    this.$getCaptionElement = function(){
        if (!this.$selected) return false;
        var x = this.$getLayoutNode("item", "caption", this.$selected);
        return x.nodeType == 1 ? x : x.parentNode;
    };
    
    
    /**** Selection Support ****/
    
    this.$calcSelectRange = function(xmlStartNode, xmlEndNode){
        var r     = [],
            f     = false,
            i     = 0,
            nodes = this.hasFeature(apf.__VIRTUALVIEWPORT__)
                ? this.xmlRoot.selectNodes(this.$isTreeArch 
                    ? this.each
                    : ".//" + this.each.split('|').join('|.//'))
                : this.getTraverseNodes();

        for (; i < nodes.length; i++) {
            if (nodes[i] == xmlStartNode)
                f = true;
            if (f)
                r.push(nodes[i]);
            if (nodes[i] == xmlEndNode)
                f = false;
        }
        
        if (!r.length || f) {
            r = [];
            for (f = false, i = nodes.length - 1; i >= 0; i--) {
                if (nodes[i] == xmlStartNode)
                    f = true;
                if (f)
                    r.push(nodes[i]);
                if (nodes[i] == xmlEndNode)
                    f = false;
            }
        }
        
        return r;
    };
    
    this.$findContainer = function(htmlNode){
        return this.$getLayoutNode("item", "container", htmlNode);
    };
    
    this.$selectDefault = function(xmlNode){
        if (this.select(this.getFirstTraverseNode(xmlNode), null, null, null, true)) {
            return true;
        }
        else {
            var nodes = this.getTraverseNodes(xmlNode);
            for (var i = 0; i < nodes.length; i++) {
                if (this.$selectDefault(nodes[i]))
                    return true;
            }
        }
    };
    
    this.$setEmptyMessage = function(htmlNode, msg){
        this.$getNewContext("empty");
        var xmlEmpty = this.$getLayoutNode("empty");
        if (!xmlEmpty) return;

        var empty = apf.insertHtmlNode(xmlEmpty, htmlNode);
        var caption = this.$getLayoutNode("empty", "caption", empty);

        if (caption)
            apf.setNodeValue(caption, msg || "");
        
        if (htmlNode.style)
            this.slideOpen(htmlNode, null, true);
        else
            htmlNode.setAttribute("style", "overflow:visible;height:auto;display:block;");
    }
    
    this.$removeEmptyMessage = function(htmlNode){
        var cNode = htmlNode.firstChild;
        if (!cNode)
            return;

        do {
            if (cNode.className == "message") { //@todo hack
                htmlNode.removeChild(cNode);
                return;
            }
            cNode = cNode.nextSibling;
        }
        while(cNode);
    }
    
    /**** Init ****/

    /**
     * @event click Fires when the user presses a mousebutton while over this
     *              element and then let's the mousebutton go.
     * @see baseclass.multiselect.event.beforeselect
     * @see baseclass.multiselect.event.afterselect
     * @see baseclass.multiselect.event.beforechoose
     * @see baseclass.multiselect.event.afterchoose
     */
    this.$drawBase = function(){
        //@todo apf3.0 checkmode, radiomode
        /*if (!this.getAttribute("skin")) {
            var mode = this.getAttribute("mode");
            this.skinName = null;
            this.skin = mode + "tree";
            this.$loadSkin();
        }*/
        
        //Build Main Skin
        this.$ext = this.$getExternal(); 
        this.$container = this.$getLayoutNode("main", "container", this.$ext);
        this.opencloseaction = this.$getOption("main", "openclose");
        
        //Need fix...
        //this.$ext.style.MozUserSelect = "none";

        if (apf.hasCssUpdateScrollbarBug && !this.mode)
            this.$fixScrollBug();
        
        var _self = this;
        this.$ext.onclick = function(e){
            _self.dispatchEvent("click", {htmlEvent : e || event});
        };
    };
    
    this.addEventListener("DOMNodeInsertedIntoDocument", function(){
        if (this.nocollapse)
            this.startcollapsed = false;
        else if (this.startcollapsed === 1)
            this.startcollapsed = !apf.isFalse(this.$getOption("main", "startcollapsed"));
    });
    
    this.addEventListener("DOMNodeRemovedFromDocument", function(){
        this.$ext.onclick = null;
        
        apf.destroyHtmlNode(this.oDrag);
        this.oDrag = null;
    });

}).call(apf.BaseTree.prototype = new apf.MultiSelect());





/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/transaction.js)SIZE(23494)TIME(1270838606)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */

apf.__TRANSACTION__ = 1 << 3;



/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/baselist.js)SIZE(37374)TIME(1270162865)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */







/**
 * Baseclass of elements that allows the user to select one or more items
 * out of a list.
 *
 * @constructor
 * @baseclass
 *
 * @inherits apf.MultiSelect
 * @inherits apf.Cache
 * @inherits apf.DataAction
 * @inherits apf.XForms
 *
 * @author      Ruben Daniels (ruben AT ajax DOT org)
 * @version     %I%, %G%
 * @since       0.8
 * @default_private
 *
 * @binding caption  Determines the caption of a node.
 * @binding icon     Determines the icon of a node. This binding rule is used
 * to determine the icon displayed when using a list skin. The {@link baseclass.baselist.binding.image image binding}
 * is used to determine the image in the thumbnail skin.
 * @binding image    Determines the image of a node. This binding rule is used
 * to determine the image displayed when using a thumbnail skin. The {@link baseclass.baselist.binding.icon icon binding}
 * is used to determine the icon in the list skin.
 * Example:
 * In this example the image url is read from the thumbnail attribute of the data node.
 * <code>
 *  <a:thumbnail>
 *      <a:model>
 *          <data>
 *              <image caption="Thumb 1" thumbnail="img1" />
 *              <image caption="Thumb 2" thumbnail="img2" />
 *              <image caption="Thumb 3" />
 *          </data>
 *      </a:model>
 *      <a:bindings>
 *          <a:caption match="[@caption]" />
 *          <a:image match="[@thumbnail]" value="images/slideshow_img/[@thumbnail]_small.jpg" />
 *          <a:image value="images/slideshow_img/img29_small.jpg" />
 *          <a:each match="[image]" />
 *      </a:bindings>
 *  </a:thumbnail>
 * </code>
 * @binding css      Determines a css class for a node.
 * Example:
 * In this example a node is bold when the folder contains unread messages:
 * <code>
 *  <a:tree>
 *      <a:model>
 *          <data>
 *              <folder caption="Folder 1">
 *                  <message unread="true" caption="message 1" />
 *              </folder>
 *              <folder caption="Folder 2" icon="email.png">
 *                  <message caption="message 2" />
 *              </folder>
 *              <folder caption="Folder 3">
 *                  <message caption="message 3" />
 *                  <message caption="message 4" />
 *              </folder>
 *          </data>
 *      </a:model>
 *      <a:bindings>
 *          <a:caption match="[@caption]" />
 *          <a:css match="[message[@unread]]" value="highlighUnread" />
 *          <a:icon match="[@icon]" />
 *          <a:icon match="[folder]" value="Famfolder.gif" />
 *          <a:each match="[folder|message]" />
 *      </a:bindings>
 *  </a:tree>
 * </code>
 * @binding tooltip  Determines the tooltip of a node.
 * @event notunique Fires when the more attribute is set and an item is added that has a caption that already exists in the list.
 *   object:
 *   {String} value the value that was entered.
 */
apf.BaseList = function(){
    this.$init(true);
    
    
    this.$dynCssClasses = [];
    
    
    this.listNodes   = [];
};

(function() {
    this.implement(
        
        apf.Cache,
        
        
        apf.DataAction
        
        
    );

    /**** Properties and Attributes ****/

    this.$focussable = true; // This object can get the focus
    this.multiselect = true; // Initially Disable MultiSelect
    this.mode        = "normal";

    /**
     * @attribute {String} fill the set of items that should be loaded into this
     * element. A start and an end seperated by a -.
     * Example:
     * This example loads a list with items starting at 1980 and ending at 2050.
     * <code>
     *  <a:dropdown fill="1980-2050" />
     *  <a:dropdown fill="red,green,blue,white" />
     *  <a:dropdown fill="None,100-110,1000-1100" />
     *  <a:dropdown fill="01-10" />
     *  <a:dropdown fill="1-10" />
     * </code>
     */
    this.$propHandlers["fill"] = function(value){
        if (value)
            this.loadFillData(this.getAttribute("fill"));
        else
            this.clear();
    };
    
    //@todo unsetter
    this.$propHandlers["template"] = function(value){
        this.$template = typeof value == "object" 
          ? value 
          : apf.nameserver.get("template", value);

        if (!this.$template) {
            var f;
            apf.addEventListener("parsestop", f = function(){
                _self.$propHandlers["template"].call(_self, value);
                apf.removeEventListener("parsestop", f);
            });
            return;
        }
        
        //this.setProperty("skin", "templatelist");
        
        //@todo solve the model inheritance problem
        this.$deInitNode = function(xmlNode, htmlNode){
            var Lid = xmlNode.getAttribute(apf.xmldb.xmlIdTag) + "|" + this.$uniqueId;
            this.$template.destroyInstance(Lid);
            
            if (htmlNode)
                htmlNode.parentNode.removeChild(htmlNode);
        };

        this.$updateNode = function(xmlNode, htmlNode, noModifier){
            //Do nothing
        };

        this.$moveNode = function(xmlNode, htmlNode){
            //@todo
        };

        var docFrag = document.createDocumentFragment();

        this.$add = function(xmlNode, Lid, xmlParentNode, htmlParentNode, beforeNode){
            /*this.$getNewContext("item");
            var item = this.$getLayoutNode("item");
            item.setAttribute("id", Lid);
            var htmlNode = apf.insertHtmlNode(item, htmlParentNode || this.$container, beforeNode);*/
            var htmlNode = document.createElement("div");
            htmlNode.setAttribute("id", Lid);
            docFrag.appendChild(htmlNode);

            this.$template.getNewInstance(
                this.$getLayoutNode("item", "container", htmlNode), Lid, xmlNode, true);
            //docFrag.setProperty("model", xmlNode);
        };
        
        this.$fill = function(){
            //Do nothing (optimization later?)
            //apf.AmlParser.parseLastPass();
            //apf.isParsing = false;
            
            this.$container.appendChild(docFrag);
            
            apf.queue.empty();
        };
        
        //@todo changing template
        this.$checkLoadQueue();
    };

    /**** Keyboard support ****/

    

    //Handler for a plane list
    this.$keyHandler = function(e){
        var key      = e.keyCode,
            ctrlKey  = e.ctrlKey,
            shiftKey = e.shiftKey,
            selHtml  = this.$selected || this.$caret;

        if (e.returnValue == -1 || !selHtml || this.renaming) //@todo how about allowdeselect?
            return;

        var selXml = this.caret || this.selected,
            oExt   = this.$ext,
            // variables used in the switch statement below:
            node, margin, items, lines, hasScroll, hasScrollX, hasScrollY;

        switch (key) {
            case 13:
                if (this.$tempsel)
                    this.$selectTemp();

                if (this.ctrlselect == "enter")
                    this.select(this.caret, true);

                this.choose(this.selected);
                break;
            case 32:
                if (ctrlKey || this.mode != "normal" || !this.isSelected(this.caret))
                    this.select(this.caret, ctrlKey);
                break;
            case 109:
            case 46:
                //DELETE
                if (this.disableremove)
                    return;

                if (this.$tempsel)
                    this.$selectTemp();

                this.remove(this.mode != "normal" ? this.caret : null); //this.mode != "check"
                break;
            case 36:
                //HOME
                if (this.hasFeature(apf.__VIRTUALVIEWPORT__)) 
                    this.viewport.change(0, null, true, true);
                    
                this.select(this.getFirstTraverseNode(), false, shiftKey);
                this.$container.scrollTop = 0;
                break;
            case 35:
                //END
                if (this.hasFeature(apf.__VIRTUALVIEWPORT__)) 
                    this.viewport.change(this.viewport.length, null, true, true);
                
                this.select(this.getLastTraverseNode(), false, shiftKey);
                this.$container.scrollTop = this.$container.scrollHeight;
                break;
            case 107:
                //+
                if (this.more)
                    this.startMore();
                break;
            case 37:
                //LEFT
                if (!selXml && !this.$tempsel)
                    return;

                node   = this.$tempsel
                    ? apf.xmldb.getNode(this.$tempsel)
                    : selXml;
                margin = apf.getBox(apf.getStyle(selHtml, "margin"));
                items  = selHtml.offsetWidth
                    ? Math.floor((oExt.offsetWidth
                        - (hasScroll ? 15 : 0)) / (selHtml.offsetWidth
                        + margin[1] + margin[3]))
                    : 1;

                margin = apf.getBox(apf.getStyle(selHtml, "margin"));

                node   = this.getNextTraverseSelected(node, false);
                if (node)
                    this.$setTempSelected(node, ctrlKey, shiftKey, true);
                else
                    return;

                selHtml = apf.xmldb.findHtmlNode(node, this);
                if (selHtml.offsetTop < oExt.scrollTop) {
                    oExt.scrollTop = Array.prototype.indexOf.call(this.getTraverseNodes(), node) < items
                        ? 0
                        : selHtml.offsetTop - margin[0];
                }
                break;
            case 38:
                //UP
                if (!selXml && !this.$tempsel)
                    return;

                node = this.$tempsel
                    ? apf.xmldb.getNode(this.$tempsel)
                    : selXml;

                margin    = apf.getBox(apf.getStyle(selHtml, "margin"));
                hasScroll = oExt.scrollHeight > oExt.offsetHeight;
                items     = selHtml.offsetWidth
                    ? Math.floor((oExt.offsetWidth
                        - (hasScroll ? 15 : 0)) / (selHtml.offsetWidth
                        + margin[1] + margin[3]))
                    : 1;

                node      = this.getNextTraverseSelected(node, false, items);
                if (node)
                    this.$setTempSelected (node, ctrlKey, shiftKey, true);
                else
                    return;

                selHtml = apf.xmldb.findHtmlNode(node, this);
                if (selHtml.offsetTop < oExt.scrollTop) {
                    oExt.scrollTop = Array.prototype.indexOf.call(this.getTraverseNodes(), node) < items
                        ? 0
                        : selHtml.offsetTop - margin[0];
                }
                break;
            case 39:
                //RIGHT
                if (!selXml && !this.$tempsel)
                    return;

                node = this.$tempsel
                    ? apf.xmldb.getNode(this.$tempsel)
                    : selXml;
                margin = apf.getBox(apf.getStyle(selHtml, "margin"));
                node   = this.getNextTraverseSelected(node, true);
                if (node)
                    this.$setTempSelected (node, ctrlKey, shiftKey);
                else
                    return;

                selHtml = apf.xmldb.findHtmlNode(node, this);
                if (selHtml.offsetTop + selHtml.offsetHeight
                  > oExt.scrollTop + oExt.offsetHeight) {
                    oExt.scrollTop = selHtml.offsetTop
                        - oExt.offsetHeight + selHtml.offsetHeight
                        + margin[0];
                }
                break;
            case 40:
                //DOWN
                if (!selXml && !this.$tempsel)
                    return;

                node = this.$tempsel
                    ? apf.xmldb.getNode(this.$tempsel)
                    : selXml;

                margin    = apf.getBox(apf.getStyle(selHtml, "margin"));
                hasScroll = oExt.scrollHeight > oExt.offsetHeight;
                items     = selHtml.offsetWidth
                    ? Math.floor((oExt.offsetWidth
                        - (hasScroll ? 15 : 0)) / (selHtml.offsetWidth
                        + margin[1] + margin[3]))
                    : 1;

                node      = this.getNextTraverseSelected(node, true, items);
                if (node)
                    this.$setTempSelected (node, ctrlKey, shiftKey);
                else
                    return;

                selHtml = apf.xmldb.findHtmlNode(node, this);
                if (selHtml.offsetTop + selHtml.offsetHeight
                  > oExt.scrollTop + oExt.offsetHeight) { // - (hasScroll ? 10 : 0)
                    oExt.scrollTop = selHtml.offsetTop
                        - oExt.offsetHeight + selHtml.offsetHeight
                        + margin[0]; //+ (hasScroll ? 10 : 0)
                }
                break;
            case 33:
                //PGUP
                if (!selXml && !this.$tempsel)
                    return;

                node = this.$tempsel
                    ? apf.xmldb.getNode(this.$tempsel)
                    : selXml;

                margin     = apf.getBox(apf.getStyle(selHtml, "margin"));
                hasScrollY = oExt.scrollHeight > oExt.offsetHeight;
                hasScrollX = oExt.scrollWidth > oExt.offsetWidth;
                items      = Math.floor((oExt.offsetWidth
                    - (hasScrollY ? 15 : 0)) / (selHtml.offsetWidth
                    + margin[1] + margin[3]));
                lines      = Math.floor((oExt.offsetHeight
                    - (hasScrollX ? 15 : 0)) / (selHtml.offsetHeight
                    + margin[0] + margin[2]));

                node       = this.getNextTraverseSelected(node, false, items * lines);
                if (!node)
                    node = this.getFirstTraverseNode();
                if (node)
                    this.$setTempSelected (node, ctrlKey, shiftKey, true);
                else
                    return;

                selHtml = apf.xmldb.findHtmlNode(node, this);
                if (selHtml.offsetTop < oExt.scrollTop) {
                    oExt.scrollTop = Array.prototype.indexOf.call(this.getTraverseNodes(), node) < items
                        ? 0
                        : selHtml.offsetTop - margin[0];
                }
                break;
            case 34:
                //PGDN
                if (!selXml && !this.$tempsel)
                    return;

                node = this.$tempsel
                    ? apf.xmldb.getNode(this.$tempsel)
                    : selXml;

                margin     = apf.getBox(apf.getStyle(selHtml, "margin"));
                hasScrollY = oExt.scrollHeight > oExt.offsetHeight;
                hasScrollX = oExt.scrollWidth > oExt.offsetWidth;
                items      = Math.floor((oExt.offsetWidth - (hasScrollY ? 15 : 0))
                    / (selHtml.offsetWidth + margin[1] + margin[3]));
                lines      = Math.floor((oExt.offsetHeight - (hasScrollX ? 15 : 0))
                    / (selHtml.offsetHeight + margin[0] + margin[2]));

                node       = this.getNextTraverseSelected(selXml, true, items * lines);
                if (!node)
                    node = this.getLastTraverseNode();
                if (node)
                    this.$setTempSelected (node, ctrlKey, shiftKey);
                else
                    return;

                selHtml = apf.xmldb.findHtmlNode(node, this);
                if (selHtml.offsetTop + selHtml.offsetHeight
                  > oExt.scrollTop + oExt.offsetHeight) { // - (hasScrollY ? 10 : 0)
                    oExt.scrollTop = selHtml.offsetTop
                        - oExt.offsetHeight + selHtml.offsetHeight
                        + margin[0]; //+ 10 + (hasScrollY ? 10 : 0)
                }
                break;

            default:
                if (key == 65 && ctrlKey) {
                    this.selectAll();
                }
                else if (this.$hasBindRule("caption")) {
                    if (!this.xmlRoot || this.autorename) return;

                    //this should move to a onkeypress based function
                    if (!this.lookup || new Date().getTime()
                      - this.lookup.date.getTime() > 300) {
                        this.lookup = {
                            str  : "",
                            date : new Date()
                        };
                    }

                    this.lookup.str += String.fromCharCode(key);

                    var nodes = this.getTraverseNodes(); //@todo start at current indicator
                    for (var v, i = 0; i < nodes.length; i++) {
                        v = this.$applyBindRule("caption", nodes[i]);
                        if (v && v.substr(0, this.lookup.str.length)
                          .toUpperCase() == this.lookup.str) {

                            if (!this.isSelected(nodes[i])) {
                                if (this.mode == "check")
                                    this.setCaret(nodes[i]);
                                else
                                    this.select(nodes[i]);
                            }

                            if (selHtml) {
                                this.$container.scrollTop = selHtml.offsetTop
                                    - (this.$container.offsetHeight
                                    - selHtml.offsetHeight) / 2;
                            }
                            return;
                        }
                    }
                    return;
                }
                break;
        }

        this.lookup = null;
        return false;
    };

    

    /**** Private databinding functions ****/

    this.$deInitNode   = function(xmlNode, htmlNode){
        if (!htmlNode) return;

        //Remove htmlNodes from tree
        htmlNode.parentNode.removeChild(htmlNode);
    };

    this.$updateNode   = function(xmlNode, htmlNode, noModifier){
        //Update Identity (Look)
        var elIcon = this.$getLayoutNode("item", "icon", htmlNode);

        if (elIcon) {
            if (elIcon.nodeType == 1) {
                elIcon.style.backgroundImage = "url(" + 
                  apf.getAbsolutePath(this.iconPath,
                      this.$applyBindRule("icon", xmlNode)) + ")";
            }
            else {
                elIcon.nodeValue = apf.getAbsolutePath(this.iconPath,
                    this.$applyBindRule("icon", xmlNode));
            }
        }
        else {
            //.style.backgroundImage = "url(" + this.$applyBindRule("image", xmlNode) + ")";
            var elImage = this.$getLayoutNode("item", "image", htmlNode);
            if (elImage) {
                if (elImage.nodeType == 1) {
                    elImage.style.backgroundImage = "url(" + 
                        apf.getAbsolutePath(apf.hostPath,
                            this.$applyBindRule("image", xmlNode)) + ")";
                }
                else {
                    elImage.nodeValue = apf.getAbsolutePath(apf.hostPath, 
                        this.$applyBindRule("image", xmlNode));
                }
            }
        }

        //this.$getLayoutNode("item", "caption", htmlNode).nodeValue = this.$applyBindRule("Caption", xmlNode);
        var elCaption = this.$getLayoutNode("item", "caption", htmlNode);
        if (elCaption) {
            if (elCaption.nodeType == 1)
                elCaption.innerHTML = this.$applyBindRule("caption", xmlNode);
            else
                elCaption.nodeValue = this.$applyBindRule("caption", xmlNode);
        }

        htmlNode.title = this.$applyBindRule("title", xmlNode) || "";

        
        var cssClass = this.$applyBindRule("css", xmlNode);

        if (cssClass || this.$dynCssClasses.length) {
            this.$setStyleClass(htmlNode, cssClass, this.$dynCssClasses);
            if (cssClass && !this.$dynCssClasses.contains(cssClass)) {
                this.$dynCssClasses.push(cssClass);
            }
        }
        

        if (!noModifier && this.$updateModifier)
            this.$updateModifier(xmlNode, htmlNode);
    };

    this.$moveNode = function(xmlNode, htmlNode){
        if (!htmlNode) return;

        var oPHtmlNode = htmlNode.parentNode;
        var nNode      = this.getNextTraverse(xmlNode);
        var beforeNode = nNode
            ? apf.xmldb.findHtmlNode(nNode, this)
            : null;

        oPHtmlNode.insertBefore(htmlNode, beforeNode);
        //if(this.emptyMessage && !oPHtmlNode.childNodes.length) this.setEmpty(oPHtmlNode);
    };

    this.$add = function(xmlNode, Lid, xmlParentNode, htmlParentNode, beforeNode){
        //Build Row
        this.$getNewContext("item");
        var oItem      = this.$getLayoutNode("item"),
            elSelect   = this.$getLayoutNode("item", "select"),
            elIcon     = this.$getLayoutNode("item", "icon"),
            elImage    = this.$getLayoutNode("item", "image"),
            //elCheckbox = this.$getLayoutNode("item", "checkbox"), // NOT USED
            elCaption  = this.$getLayoutNode("item", "caption");

        oItem.setAttribute("id", Lid);

        elSelect.setAttribute("onmouseover",   "var o = apf.lookup(" + this.$uniqueId 
        	+ "); o.$setStyleClass(this, 'hover', null, true);");
        elSelect.setAttribute("onselectstart", "return false;");
        elSelect.setAttribute("style",         (elSelect.getAttribute("style") || "") 
        	+ ";user-select:none;-moz-user-select:none;-webkit-user-select:none;");

        if (this.hasFeature(apf.__RENAME__) || this.hasFeature(apf.__DRAGDROP__)) {
            elSelect.setAttribute("ondblclick", "var o = apf.lookup(" + this.$uniqueId + "); " +
                
                "o.stopRename();" +
                
                " o.choose()");
            elSelect.setAttribute("onmouseout", "var o = apf.lookup(" + this.$uniqueId + ");\
            	  o.$setStyleClass(this, '', ['hover'], true);\
                this.hasPassedDown = false;");
            elSelect.setAttribute(this.itemSelectEvent || "onmousedown",
                'var o = apf.lookup(' + this.$uniqueId + ');\
                 var xmlNode = apf.xmldb.findXmlNode(this);\
                 var isSelected = o.isSelected(xmlNode);\
                 this.hasPassedDown = true;\
                 if (!o.renaming && o.hasFocus() && isSelected == 1) \
                    this.dorename = true;\
                 if (!o.hasFeature(apf.__DRAGDROP__) || o.mode != "normal" || !isSelected && !event.ctrlKey)\
                     o.select(this, event.ctrlKey, event.shiftKey, -1)');
            elSelect.setAttribute("onmouseup", 'if (!this.hasPassedDown) return;\
                var o = apf.lookup(' + this.$uniqueId + ');' +
                
                'if (o.hasFeature(apf.__RENAME__) && this.dorename && o.mode == "normal")\
                    o.startDelayedRename(event, null, true);' +
                
                'this.dorename = false;\
                 var xmlNode = apf.xmldb.findXmlNode(this);\
                 var isSelected = o.isSelected(xmlNode);\
                 if (o.mode == "normal" && o.hasFeature(apf.__DRAGDROP__))\
                     o.select(this, event.ctrlKey, event.shiftKey, -1)');
        } //@todo add DRAGDROP ifdefs
        else {
            elSelect.setAttribute("onmouseout",    "apf.setStyleClass(this, '', ['hover']);");
            elSelect.setAttribute("ondblclick", 'var o = apf.lookup('
                + this.$uniqueId + '); o.choose(null, true)');
            elSelect.setAttribute(this.itemSelectEvent
                || "onmousedown", 'var o = apf.lookup(' + this.$uniqueId
                + '); o.select(this, event.ctrlKey, event.shiftKey, -1)');
        }
        
        this.$listGrid = this.$getOption("main", "list-mode") == "grid"; 
        
        if (this.$listGrid) {
            oItem.setAttribute("onmouseover", 
                oItem.getAttribute("onmouseover") + 'var o = apf.lookup(' + this.$uniqueId + ');o.$selectSeries(event);');
        }

        //Setup Nodes Identity (Look)
        if (elIcon) {
            if (elIcon.nodeType == 1) {
                elIcon.setAttribute("style", "background-image:url("
                    + apf.getAbsolutePath(this.iconPath, this.$applyBindRule("icon", xmlNode))
                    + ")");
            }
            else {
                elIcon.nodeValue = apf.getAbsolutePath(this.iconPath,
                    this.$applyBindRule("icon", xmlNode));
            }
        }
        else if (elImage) {
            if (elImage.nodeType == 1) {
                if ((elImage.tagName || "").toLowerCase() == "img") {
                    elImage.setAttribute("src", apf.getAbsolutePath(apf.hostPath, this.$applyBindRule("image", xmlNode)));
                }
                else {
                    elImage.setAttribute("style", "background-image:url("
                        + apf.getAbsolutePath(apf.hostPath, this.$applyBindRule("image", xmlNode))
                        + ")");
                }
            }
            else {
                if (apf.isSafariOld) { //@todo this should be changed... blrgh..
                    var p   = elImage.ownerElement.parentNode,
                        img = p.appendChild(p.ownerDocument.createElement("img"));
                    img.setAttribute("src", 
                        apf.getAbsolutePath(apf.hostPath, this.$applyBindRule("image", xmlNode)));
                }
                else {
                    elImage.nodeValue = 
                        apf.getAbsolutePath(apf.hostPath, this.$applyBindRule("image", xmlNode));
                }
            }
        }

        if (elCaption) {
            apf.setNodeValue(elCaption,
                this.$applyBindRule("caption", xmlNode));
        }
        oItem.setAttribute("title", this.$applyBindRule("tooltip", xmlNode) || "");

        
        var cssClass = this.$applyBindRule("css", xmlNode);
        if (cssClass) {
            this.$setStyleClass(oItem, cssClass);
            if (cssClass)
                this.$dynCssClasses.push(cssClass);
        }
        

        if (this.$addModifier)
            this.$addModifier(xmlNode, oItem);

        if (htmlParentNode)
            apf.insertHtmlNode(oItem, htmlParentNode, beforeNode);
        else
            this.listNodes.push(oItem);
    };

    this.$fill = function(){
        if (this.more && !this.moreItem) {
            this.$getNewContext("item");
            var Item      = this.$getLayoutNode("item"),
                elCaption = this.$getLayoutNode("item", "caption"),
                elSelect  = this.$getLayoutNode("item", "select");

            Item.setAttribute("class", "more");
            elSelect.setAttribute("onmousedown", 'var o = apf.lookup(' + this.$uniqueId
                + ');o.clearSelection();o.$setStyleClass(this, "more_down", null, true);');
            elSelect.setAttribute("onmouseout", 'apf.lookup(' + this.$uniqueId
                + ').$setStyleClass(this, "", ["more_down"], true);');
            elSelect.setAttribute("onmouseup", 'apf.lookup(' + this.$uniqueId
                + ').startMore(this, true)');

            if (elCaption)
                apf.setNodeValue(elCaption,
                    this.more.match(/caption:(.*)(;|$)/i)[1]);
            this.listNodes.push(Item);
        }

        apf.insertHtmlNodes(this.listNodes, this.$container);
        this.listNodes.length = 0;

        if (this.more && !this.moreItem)
            this.moreItem = this.$container.lastChild;
    };

    /**
     * Adds a new item to the list and lets the users type in the new name.
     * This functionality is especially useful in the interface when
     * {@link element.list.attribute.mode} is set to check or radio. For instance in a form.
     * @see element.list.attribute.more
     */
    this.startMore = function(o, userAction){
        if (userAction && this.disabled)
            return;

        this.$setStyleClass(o, "", ["more_down"]);

        var xmlNode;
        if (!this.$actions["add"]) {
            if (this.each && !this.each.match(/[\/\[]/)) {
                xmlNode = "<" + this.each + (this.each.match(/^a:/) 
                    ? " xmlns:a='" + apf.ns.aml + "'" 
                    : "") + " custom='1' />";
            }
            else {
                
                throw new Error(apf.formatErrorString(0, this,
                    "Could not start more",
                    "No add action rule is defined for this component",
                    this.$aml));
                
                return false;
            }
        }

        this.add(xmlNode, null, null, function(addedNode){
            this.select(addedNode, null, null, null, null, true);
            this.$container.appendChild(this.moreItem);
    
            var undoLastAction = function(){
                this.getActionTracker().undo(this.autoselect ? 2 : 1);
    
                this.removeEventListener("stoprename", undoLastAction);
                this.removeEventListener("beforerename", removeSetRenameEvent);
                this.removeEventListener("afterrename",  afterRename);
            }
            var afterRename = function(){
                //this.select(addedNode);
                this.removeEventListener("afterrename",  afterRename);
            };
            var removeSetRenameEvent = function(e){
                this.removeEventListener("stoprename", undoLastAction);
                this.removeEventListener("beforerename", removeSetRenameEvent);
    
                //There is already a choice with the same value
                var xmlNode = this.findXmlNodeByValue(e.args[1]);
                if (xmlNode || !e.args[1]) {
                    if (e.args[1] && this.dispatchEvent("notunique", {
                        value : e.args[1]
                    }) === false) {
                        this.startRename();
                        
                        this.addEventListener("stoprename",   undoLastAction);
                        this.addEventListener("beforerename", removeSetRenameEvent);
                    }
                    else {
                        this.removeEventListener("afterrename", afterRename);
                        
                        this.getActionTracker().undo();//this.autoselect ? 2 : 1);
                        if (!this.isSelected(xmlNode))
                            this.select(xmlNode);
                    }
                    
                    return false;
                }
            };
    
            this.addEventListener("stoprename",   undoLastAction);
            this.addEventListener("beforerename", removeSetRenameEvent);
            this.addEventListener("afterrename",  afterRename);
    
            /*if (this.mode == "radio") {
                this.moreItem.style.display = "none";
                if (lastAddedMore)
                    this.removeEventListener("xmlupdate", lastAddedMore);
    
                lastAddedMore = function(){
                    this.moreItem.style.display = addedNode.parentNode
                        ? "none"
                        : "block";
                };
                this.addEventListener("xmlupdate", lastAddedMore);
            }*/
    
          
            
            this.startDelayedRename({}, 1);
            
        });
    };

    /**** Selection ****/

    this.$calcSelectRange = function(xmlStartNode, xmlEndNode){
        var r = [],
            nodes = this.hasFeature(apf.__VIRTUALVIEWPORT__)
                ? this.xmlRoot.selectNodes(this.each)
                : this.getTraverseNodes(),
            f, i;
        for (f = false, i = 0; i < nodes.length; i++) {
            if (nodes[i] == xmlStartNode)
                f = true;
            if (f)
                r.push(nodes[i]);
            if (nodes[i] == xmlEndNode)
                f = false;
        }

        if (!r.length || f) {
            r = [];
            for (f = false, i = nodes.length - 1; i >= 0; i--) {
                if (nodes[i] == xmlStartNode)
                    f = true;
                if (f)
                    r.push(nodes[i]);
                if (nodes[i] == xmlEndNode)
                    f = false;
            }
        }

        return r;
    };

    this.$selectDefault = function(XMLRoot){
        this.select(this.getTraverseNodes()[0], null, null, null, true);
    };

    /**
     * Generates a list of items based on a string.
     * @param {String} str the description of the items. Items are seperated by a comma (,). Ranges are specified by a start and end value seperated by a dash (-).
     * Example:
     * This example loads a list with items starting at 1980 and ending at 2050.
     * <code>
     *  lst.loadFillData("1980-2050");
     *  lst.loadFillData("red,green,blue,white");
     *  lst.loadFillData("None,100-110,1000-1100");
     *  lst.loadFillData("1-10"); // 1 2 3 4 etc
     *  lst.loadFillData("01-10"); //01, 02, 03, 04, etc
     * </code>
     */
    this.loadFillData = function(str){
        var len, start, end, parts = str.splitSafe(","), data = [];
        
        for (var p, part, i = 0; i < parts.length; i++) {
            if ((part = parts[i]).match(/^\d+-\d+$/)) {
                p     = part.split("-");
                start = parseInt(p[0]);
                end   = parseInt(p[1]);
                
                if (p[0].length == p[1].length) {
                    len = Math.max(p[0].length, p[1].length);
                    for (var j = start; j < end + 1; j++) {
                        data.push("<item>" + (j + "").pad(len, "0") + "</item>");
                    }
                }
                else {
                    for (var j = start; j < end + 1; j++) {
                        data.push("<item>" + j + "</item>");
                    }
                }
            }
            else {
                data.push("<item>" + part + "</item>");
            }
        }
        
        //@todo this is all an ugly hack (copied from item.js line 486)
        //this.$preventDataLoad = true;//@todo apf3.0 add remove for this
        
        this.$initingModel = true;
        
        this.each = "item";
        this.$setDynamicProperty("caption", "[label/text()|@caption|text()]");
        this.$setDynamicProperty("eachvalue", "[value/text()|@value|text()]");
        this.$canLoadDataAttr = false;

        this.load("<data>" + data.join("") + "</data>");
    };

}).call(apf.BaseList.prototype = new apf.MultiSelect());





/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/virtualviewport.js)SIZE(28854)TIME(1269561670)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */

apf.__VIRTUALVIEWPORT__ = 1 << 19;




/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/basestatebuttons.js)SIZE(23802)TIME(1270838606)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * @constructor
 * @baseclass
 *
 * @author      Ruben Daniels (ruben AT ajax DOT org)
 * @version     %I%, %G%
 * @since       0.8
 */
apf.BaseStateButtons = function(){
    this.state   = "normal";
    this.edit    = false;
    this.animate = true;//!apf.hasSingleRszEvent; // experimental
    
    var actions  = {
        "min"   : ["minimized", "minimize", "restore"],
        "max"   : ["maximized", "maximize", "restore"],
        "edit"  : ["edit", "edit", "closeedit"],
        "close" : ["closed", "close", "show"]
    };
    this.$lastheight  = null;
    this.$lastpos     = null;
    this.$lastzindex  = null;

    this.$lastState = {"normal":true};    
    this.$booleanProperties["animate"] = true;
    this.$supportedProperties.push("buttons", "animate", "state");
    
    /**
     * Close the window. It can be reopened by using {@link baseclass.guielement.method.show}
     * Call-chaining is supported.
     * @todo show should unset closed
     */
    this.close = function(){
        this.setProperty("state", this.state.split("|")
            .pushUnique("closed").join("|"), false, true);
        return this;
    };

    /**
     * Minimize the window. The window will become the height of the title of
     * the window.
     * Call-chaining is supported.
     */
    this.minimize = function(){
        this.setProperty("state", this.state.split("|")
            .remove("maximized")
            .remove("normal")
            .pushUnique("minimized").join("|"), false, true);
        return this;
    };

    /**
     * Maximize the window. The window will become the width and height of the
     * browser window.
     * Call-chaining is supported.
     */
    this.maximize = function(){
        this.setProperty("state", this.state.split("|")
            .remove("minimized")
            .remove("normal")
            .pushUnique("maximized").join("|"), false, true);
        return this;
    };

    /**
     * Restore the size of the window. The window will become the width and
     * height it had before it was minimized or maximized.
     * Call-chaining is supported.
     */
    this.restore = function(){
        this.setProperty("state", this.state.split("|")
            .remove("minimized")
            .remove("maximized")
            .pushUnique("normal").join("|"), false, true);
        return this;
    };
    
     /**
     * Set the window into edit state. The configuration panel is shown.
     * Call-chaining is supported.
     */
    this.edit = function(value){
        this.setProperty("state", this.state.split("|")
            .pushUnique("edit").join("|"), false, true);
        return this;
    };

    /**
     * Removes the edit state of this window. The configuration panel is hidden.
     * Call-chaining is supported.
     */
    this.closeedit = function(value){
        this.setProperty("state", this.state.split("|")
            .remove("edit").join("|"), false, true);
        return this;
    };
    
    this.$toggle = function(type){
        var c = actions[type][0];
        this[actions[type][this.state.indexOf(c) > -1 ? 2 : 1]]();
    };
    
    this.$propHandlers["refparent"] = function(value){
        if (typeof value == "string")
            this.$refParent = self[value] && self[value].$ext || document.getElementById(value);
        else this.$refParent = value;
    }
    
    /**
     * @attribute {String} state the state of the window. The state can be a
     * combination of multiple states seperated by a pipe '|' character.
     *   Possible values:
     *   normal     The window has it's normal size and position. Default value.
     *   minimized  The window is minimized.
     *   maximized  The window is maximized.
     *   edit       The window is in the edit state.
     *   closed     The window is closed.
     */
    this.$propHandlers["state"] = function(value, noanim, comp, reenter){
        var _self = this;
        if (!this.$amlLoaded) { //@todo I still think this is weird and should not be needed
            apf.queue.add("state" + this.$uniqueId, function(){
                _self.$propHandlers["state"].call(_self, value, noanim);
            });
            return;
        }

        var i, pNode, position, l, t,
            o          = {},
            s          = value.split("|"),
            lastState  = this.$lastState,
            styleClass = [];

        for (i = 0; i < s.length; i++)
            o[s[i]] = true;
        o.value = value;

        if (!o.maximized && !o.minimized)
            o.normal = true;

        if (!reenter && this.dispatchEvent("beforestatechange", {
          from : lastState, 
          to   : o}) === false) {
            this.state = lastState.value;
            return false;
        }

        //Closed state
        if (o.closed == this.visible) {//change detected
            this.setProperty("visible", !o["closed"]);
            //@todo difference is, we're not clearing the other states, check the docking example
        }

        //Restore state
        if (o.normal != lastState.normal
          || !o.normal && (o.minimized != lastState.minimized
            || o.maximized != lastState.maximized)) {

            if (this.$lastheight) // this.aData && this.aData.hidden == 3 ??
                this.$ext.style.height = this.$lastheight;//(this.$lastheight - apf.getHeightDiff(this.$ext)) + "px";

            if (this.$lastpos) {
                if (this.animate && !noanim) {
                    //Pre remove paused event because of not having onresize
                    //if (apf.hasSingleRszEvent)
                        //delete apf.layout.onresize[apf.layout.getHtmlId(this.$pHtmlNode)];

                    var htmlNode = this.$ext;
                    position = apf.getStyle(htmlNode, "position");
                    if (position != "absolute") {
                        l = parseInt(apf.getStyle(htmlNode, "left")) || 0;
                        t = parseInt(apf.getStyle(htmlNode, "top")) || 0;
                    }
                    else {
                        l = htmlNode.offsetLeft;
                        t = htmlNode.offsetTop;
                    }

                    this.animstate = 1;
                    apf.tween.multi(htmlNode, {
                        steps    : 5,
                        interval : 10,
                        tweens   : [
                            {type: "left",   from: l,    to: this.$lastpos.px[0]},
                            {type: "top",    from: t,    to: this.$lastpos.px[1]},
                            {type: "width",  from: this.$ext.offsetWidth - hordiff,
                                to: this.$lastpos.px[2]},
                            {type: "height", from: this.$ext.offsetHeight - verdiff,
                                to: this.$lastpos.px[3]}
                        ],
                        oneach   : function(){
                            
                            if (apf.hasSingleRszEvent)
                                apf.layout.forceResize(_self.$int);
                            
                        },
                        onfinish : function(){
                            _self.$propHandlers["state"].call(_self, value, true,
                                null, true);
                        }
                    });

                    return;
                }

                this.$ext.style.left   = this.$lastpos.css[0];
                this.$ext.style.top    = this.$lastpos.css[1];
                this.$ext.style.width  = this.$lastpos.css[2];
                this.$ext.style.height = this.$lastpos.css[3];
                
                pNode = this.$lastpos.parentNode;
                pNode.style.width    = this.$lastpos.parent[0];
                pNode.style.height   = this.$lastpos.parent[1];
                pNode.style.overflow = this.$lastpos.parent[2];
            }

            
            if (this.aData && this.aData.restore)
                this.aData.restore();
            

            
            if (apf.layout)
                apf.layout.play(this.$pHtmlNode);
            
            if (this.$lastzindex) {
                this.$ext.style.zIndex = this.$lastzindex[0];
                if (this.oCover)
                    this.oCover.style.zIndex = this.$lastzindex[1];
            }

            this.$lastheight = this.$lastpos = this.$lastzindex = null;

            if (o.normal)
                styleClass.push("",
                    this.$baseCSSname + "Max",
                    this.$baseCSSname + "Min");
        }

        if (o.minimized != lastState.minimized) {
            if (o.minimized) {
                styleClass.unshift(
                    this.$baseCSSname + "Min",
                    this.$baseCSSname + "Max",
                    this.$baseCSSname + "Edit");

                
                if (this.aData && this.aData.minimize)
                    this.aData.minimize(this.collapsedHeight);
                

                if (!this.aData || !this.aData.minimize) {
                    this.$lastheight = apf.getStyle(this.$ext, "height");//this.$ext.offsetHeight;

                    this.$ext.style.height = Math.max(0, this.collapsedHeight
                        - apf.getHeightDiff(this.$ext)) + "px";
                }

                if (this.hasFocus())
                    apf.window.moveNext(null, this, true);
                //else if(apf.document.activeElement)
                    //apf.document.activeElement.$focus({mouse: true});
            }
            else {
                styleClass.push(this.$baseCSSname + "Min");

                $setTimeout(function(){
                    apf.window.$focusLast(_self);
                });
            }
        }

        if (o.maximized != lastState.maximized) {
            if (o.maximized) {
                styleClass.unshift(
                    this.$baseCSSname + "Max",
                    this.$baseCSSname + "Min",
                    this.$baseCSSname + "Edit");

                pNode = this.$refParent;
                if (!pNode)
                    pNode = (this.$ext.offsetParent == document.body
                      ? document.documentElement
                      : this.$ext.parentNode);

                _self.animstate = 0;
                var hasAnimated = false, htmlNode = this.$ext;
                
                var position = apf.getStyle(htmlNode, "position");
                if (position == "absolute") {
                    pNode.style.overflow = "hidden";
                    l = htmlNode.offsetLeft;
                    t = htmlNode.offsetTop;
                }
                else {
                    var pos = apf.getAbsolutePosition(htmlNode, pNode);
                    l = pos[0];//parseInt(apf.getStyle(htmlNode, "left")) || 0;
                    t = pos[1];//parseInt(apf.getStyle(htmlNode, "top")) || 0;
                }
                
                this.$lastpos = {
                    css    : [this.$ext.style.left, this.$ext.style.top,
                              this.$ext.style.width, this.$ext.style.height],
                    px     : [l, t, this.$ext.offsetWidth - hordiff, 
                              this.$ext.offsetHeight - verdiff],
                    parent : [pNode.style.width, pNode.style.height, 
                              pNode.style.overflow],
                    parentNode : pNode
                };

                var from = [htmlNode.offsetWidth, htmlNode.offsetHeight];
                function setMax(){
                    var w = !apf.isIE && pNode == document.documentElement
                            ? window.innerWidth
                            : pNode.offsetWidth,
                        h = !apf.isIE && pNode == document.documentElement
                            ? window.innerHeight
                            : pNode.offsetHeight;
                    
                    if (position != "absolute") {
                        var diff = apf.getDiff(pNode);
                        w -= diff[0] + (!_self.$refParent && apf.isIE8 ? 4 : 0);//@todo dirty hack!
                        h -= diff[0] + (!_self.$refParent && apf.isIE8 ? 4 : 0);//@todo dirty hack!
                    }
                    //@todo dirty hack!
                    else if (!_self.$refParent && apf.isIE8) {
                        w -= 4;
                        h -= 4;
                    }
                    
                    var box = _self.$refParent ? [0,0,0,0] : marginBox,
                        pos = pNode != htmlNode.offsetParent
                            ? apf.getAbsolutePosition(pNode, htmlNode.offsetParent)
                            : [0, 0],
                        pDiff = apf.getDiff(pNode);

                    pNode.style.width  = (pNode.offsetWidth - pDiff[0]) + "px";
                    pNode.style.height = (pNode.offsetHeight - pDiff[1]) + "px";
                    
                    if (_self.animate && !hasAnimated) {
                        _self.animstate = 1;
                        hasAnimated     = true;
                        apf.tween.multi(htmlNode, {
                            steps    : 5,
                            interval : 10,
                            tweens   : [
                                {type: "left",   from: l, to: pos[0] - box[3]},
                                {type: "top",    from: t, to: pos[1] - box[0]},
                                {type: "width",  from: from[0] - hordiff,
                                    to: (w - hordiff + box[1] + box[3])},
                                {type: "height", from: from[1] - verdiff,
                                    to: (h - verdiff + box[0] + box[2])}
                            ],
                            oneach   : function(){
                                
                                if (apf.hasSingleRszEvent)
                                    apf.layout.forceResize(_self.$int);
                                
                            },
                            onfinish : function(){
                                _self.animstate = 0;
                                
                                _self.dispatchEvent("afterstatechange", {
                                  from : lastState, 
                                  to   : o});
                            }
                        });
                    }
                    else if (!_self.animstate) {
                        htmlNode.style.left = (pos[0] - box[3]) + "px";
                        htmlNode.style.top  = (pos[1] - box[0]) + "px";

                        htmlNode.style.width  = (w
                            - hordiff + box[1] + box[3]) + "px";
                        htmlNode.style.height = (h
                            - verdiff + box[0] + box[2]) + "px";
                    }
                }
                
                if (apf.layout)
                    apf.layout.pause(this.$pHtmlNode, setMax);
                
                this.$lastzindex = [
                    this.$ext.style.zIndex || 1, 
                    this.oCover && this.oCover.style.zIndex || 1
                ];
                
                if (this.oCover)
                    this.oCover.style.zIndex = apf.WinServer.count + 1;
                this.$ext.style.zIndex = apf.WinServer.count + 2;
            }
            else {
                styleClass.push(this.$baseCSSname + "Max");
            }
        }

        if (o.edit != lastState.edit) {
            if (o.edit) {
                styleClass.unshift(
                    this.$baseCSSname + "Edit",
                    this.$baseCSSname + "Max",
                    this.$baseCSSname + "Min");

                if (this.btnedit)
                    oButtons.edit.innerHTML = "close"; //hack

                this.dispatchEvent('editstart');
            }
            else {
                if (this.dispatchEvent('editstop') === false)
                    return false;

                styleClass.push(this.$baseCSSname + "Edit");
                if (styleClass.length == 1)
                    styleClass.unshift("");

                if (this.btnedit)
                    oButtons.edit.innerHTML = "edit"; //hack
            }
        }

        if (styleClass.length || o.closed != lastState.closed) {
            if (styleClass.length)
                this.$setStyleClass(this.$ext, styleClass.shift(), styleClass);
                
            if (o.edit) { //@todo apf3.0
                this.dispatchEvent("prop.visible", {value:true});
                
                if (_self.oSettings)
                    apf.layout.forceResize(_self.oSettings);
                
            }

            if (!o.maximized || lastState.maximized && _self.animate) {
                _self.dispatchEvent("afterstatechange", {
                  from : lastState, 
                  to   : o});
            }
            
            this.$lastState = o;

            
            if (this.aData && !o.maximized) { //@todo is this the most optimal position?
                this.$purgeAlignment();
            }
            

            
            if (!this.animate && apf.hasSingleRszEvent && apf.layout)
                apf.layout.forceResize(_self.$int);
            
        }
    };

    var marginBox, hordiff, verdiff, oButtons = {}
    /**
     * @attribute {String} buttons the buttons that the window displays. This
     * can be multiple values seperated by a pipe '|' character.
     *   Possible values:
     *   min    The button that minimizes the window.
     *   max    The button that maximizes the window.
     *   close  The button that closes the window.
     *   edit   The button that puts the window into the edit state.
     */
    this.$propHandlers["buttons"] = function(value){
        
        if (apf.isIphone) return;
        
        if (!this.$hasLayoutNode("button"))
            return;

        var buttons   = value && (value = value.replace(/(\|)\||\|$/, "$1")).split("|") || [],
            nodes     = this.$buttons.childNodes,
            re        = value && new RegExp("(" + value + ")"),
            found     = {},
            idleNodes = [];

        //Check if we can 'remove' buttons
        for (var i = 0; i < nodes.length; i++) {
            if (nodes[i].nodeType != 1 || nodes[i].tagName != "DIV") //@todo temp hack
                continue;

            if (nodes[i].getAttribute("button") && (!value 
              || !nodes[i].className || !nodes[i].className.match(re))) {
                nodes[i].style.display = "none";
                this.$setStyleClass(nodes[i], "", ["min", "max", "close", "edit"]);
                idleNodes.push(nodes[i]);
            }
            else {
                found[RegExp.$1] = nodes[i];
            }
        }

        //Create new buttons if needed
        for (i = 0; i < buttons.length; i++) {
            if (!buttons[i])
                continue;
            
            if (found[buttons[i]]) {
                this.$buttons.insertBefore(found[buttons[i]], this.$buttons.firstChild);
                continue;
            }

            var btn = idleNodes.pop();
            if (!btn) {
                this.$getNewContext("button");
                btn = this.$getLayoutNode("button");
                btn.setAttribute("button", "button");
                setButtonEvents.call(this, btn);
                btn = apf.insertHtmlNode(btn, this.$buttons);
            }

            this.$setStyleClass(btn, buttons[i], ["min", "max", "close", "edit"]);
            btn.onclick = new Function("apf.lookup(" + this.$uniqueId + ").$toggle('"
                                       + buttons[i] + "')");
            btn.style.display = "block";
            oButtons[buttons[i]] = btn;
            this.$buttons.insertBefore(btn, this.$buttons.firstChild);
        }
        
        var diff = apf.getDiff(this.$ext);
        hordiff  = diff[0]; 
        verdiff  = diff[1];
        marginBox = apf.getBox(apf.getStyle(this.$ext, "borderWidth"));
    };
    
    function setButtonEvents(btn){
        //@todo can this cancelBubble just go?
        //event.cancelBubble = true; \
        btn.setAttribute("onmousedown",
            "var o = apf.all[" + this.$uniqueId + "]\
             o.$setStyleClass(this, 'down', null, true);\
             event.cancelBubble = true; \
             var o = apf.findHost(this).$ext;\
             if (o.onmousedown) o.onmousedown(event);\
             event.cancelBubble = true;\
             apf.window.$mousedown(event);");
        btn.setAttribute("onmouseup",
            "var o = apf.all[" + this.$uniqueId + "]\
             o.$setStyleClass(this, '', ['down'], true)");
        btn.setAttribute("onmouseover",
            "var o = apf.all[" + this.$uniqueId + "]\
             o.$setStyleClass(this, 'hover', null, true)");
        btn.setAttribute("onmouseout",
            "var o = apf.all[" + this.$uniqueId + "]\
             o.$setStyleClass(this, '', ['hover', 'down'], true)");
    }
    
    this.$initButtons = function(oExt){
        this.collapsedHeight = this.$getOption("Main", "collapsed-height");

        var oButtons = this.$getLayoutNode("main", "buttons", oExt);
        if (!oButtons || apf.isIphone || !this.getAttribute("buttons") 
          || !this.$hasLayoutNode("button"))
            return;

        var len = (this.getAttribute("buttons") || "").split("|").length;
        for (var btn, i = 0; i < len; i++) {
            this.$getNewContext("button");
            btn = oButtons.appendChild(this.$getLayoutNode("button"));
            btn.setAttribute("button", "button");
            setButtonEvents.call(this, btn);
        }
    };
    
    this.addEventListener("DOMNodeRemovedFromDocument", function(e){
        for (var name in oButtons) {
            oButtons[name].onclick = null;
        }
    });
};




/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/teleport.js)SIZE(7149)TIME(1260316863)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * Element which specifies the ways the application can communicate to remote
 * data sources.
 * Example:
 * Example of the {@link teleport.cgi rpc module with the cgi protocol}.
 * <code>
 *  <a:rpc id="comm" protocol="cgi">
 *      <a:method
 *        name    = "searchProduct"
 *        url     = "http://example.com/search.php"
 *        receive = "processSearch">
 *          <a:variable name="search" />
 *          <a:variable name="page" />
 *          <a:variable name="textbanner" value="1" />
 *      </a:method>
 *      <a:method
 *        name = "loadProduct"
 *        url  = "http://example.com/show-product.php">
 *          <a:variable name="id" />
 *          <a:variable name="search_id" />
 *      </a:method>
 *  </a:rpc>
 *
 *  <a:script>
 *      //This function is called when the search returns
 *      function processSearch(data, state, extra){
 *          alert(data)
 *      }
 *
 *      //Execute a search for the product car
 *      comm.searchProduct('car', 10);
 *  </a:script>
 * </code>
 * Example:
 * Example of the {@link teleport.soap rpc module with the soap protocol}.
 * <code>
 *  <a:rpc id="comm" 
 *    protocol    = "soap" 
 *    url         = "http://example.com/show-product.php" 
 *    soap-prefix = "m" 
 *    soap-xmlns  = "http://example.com">
 *      <a:method 
 *        name    = "searchProduct" 
 *        receive = "processSearch">
 *          <a:variable name="search" />
 *          <a:variable name="page" />
 *          <a:variable name="textbanner" value="1" />
 *      </a:method>
 *      <a:method 
 *        name = "loadProduct">
 *          <a:variable name="id" />
 *          <a:variable name="search_id" />
 *      </a:method>
 *  </a:rpc>
 *
 *  <a:script>
 *      //This function is called when the search returns
 *      function processSearch(data, state, extra){
 *          alert(data)
 *      }
 *
 *      //Execute a search for the product car
 *      comm.searchProduct('car', 10);
 *  </a:script>
 * </code>
 * Example:
 * Writing to a file with a WebDAV connector
 * <code>
 *   <a:webdav id="myWebDAV"
 *    url   = "http://my-webdav-server.com/dav_files/" />
 *     
 *  <a:script>
 *      // write the text 'bar' to a file on the server called 'foo.txt'
 *      myWebDAV.write('http://my-webdav-server.com/dav_files/foo.txt', 'bar');
 *  </a:script>
 * </code>
 * Example:
 * XMPP connector with new message notification
 * <code>
 *  <a:xmpp id="myXMPP"
 *    url           = "http://my-jabber-server.com:5280/http-bind"
 *    model         = "mdlRoster"
 *    connection    = "bosh"
 *    onreceivechat = "messageReceived(arguments[0].from)" />
 *
 *  <a:script>
 *      // This function is called when a message has arrived
 *      function messageReceived(from){
 *          alert('Received message from ' + from);
 *      }
 *
 *      // Send a message to John
 *      myXMPP.sendMessage('john@my-jabber-server.com', 'A test message', '',
 *          apf.xmpp.MSG_CHAT);
 *  </a:script>
 * </code>
 *
 * @attribute {String}  url              the location of the server that is
 *                                       recipient of the rpc messages.
 * @attribute {String}  [route-server]   String specifying the url to the route script.
 *                                       Remarks:
 *                                       The route script will receive the route information in 3 extra headers:
 *                                           X-Route-Request     - Containing the destination url.<br />
 *                                           X-Proxy-Request     - Containing the destination url.<br />
 *                                           X-Compress-Response - Set to 'gzip'.<br />
 * @attribute {Boolean} [autoroute]      whether the call should be routed
 *                                       through a proxy when a permission
 *                                       error occurs due to the same domein policy.
 * @attribute {Number}  [timeout]        the number of milliseconds after
 *                                       which the call is considered timed out.
 *
 * 
 * @define teleport
 * @addnode global
 * @allowchild {teleport}
 *
 * @default_private
 */
apf.Teleport = function(){
    this.$init(true);
};

apf.__TELEPORT__ = 1 << 28;

(function() {
    this.$parsePrio = "002";
    
    this.$regbase = this.$regbase | apf.__TELEPORT__;

    this.$booleanProperties["autoroute"] = true;
    
    this.$supportedProperties.push("url", "timeout", "protocol", "route-server",
        "autoroute");

    this.$propHandlers["url"] = function(value) {
        var url = new apf.url(value);

        // do some extra startup/ syntax error checking
        if (!url.protocol) {
            throw new Error(apf.formatErrorString(0, this,
                "Communication (Teleport) initialization error",
                "Invalid server url provided."));
        }

        this.$domain   = url.host;
        this.$rootPath = url.path;
        this.$server   = value.replace(new RegExp(this.$rootPath + "$"), "");
    };

    this.$propHandlers["timeout"] = function(value) {
        this.timeout = parseInt(value) || 10000;
    };

    this.$propHandlers["protocol"] = function(value) {
        var proto = value.toLowerCase();
        if (!apf[proto]) {
            throw new Error(apf.formatErrorString(1025, null, "Teleport baseclass",
                "Could not find Ajax.org Teleport RPC Component '" + proto + "'", this));
        }
        this.implement(apf[proto]);
    };
    
    /**
     * Returns a string representation of this object.
     */
    this.toString = function(){
        return "[Ajax.org Teleport Component : " + (this.name || "")
            + " (" + this.type + ")]";
    };

    this.addEventListener("DOMNodeInsertedIntoDocument", function() {
        // Implement HTTP Module
        if (!apf.http) {
            throw new Error(apf.formatErrorString(1024, null, "Teleport baseclass", 
                "Could not find Ajax.org Teleport HTTP Component", this.$aml));
        }
        this.implement(apf.http);

        if (this.id)
            apf.$asyncObjects[this.id] = 1;
    });
}).call(apf.Teleport.prototype = new apf.AmlElement());



apf.Init.run("teleport");


/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/interactive.js)SIZE(27496)TIME(1270838606)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */

apf.__INTERACTIVE__ = 1 << 21;



/**
 * All elements inheriting from this {@link term.baseclass baseclass} have interactive features, making an
 * element draggable and resizable.
 * Example:
 * <code>
 *  <a:textarea draggable="true" resizable="true" />
 * </code>
 * 
 * @attribute {Boolean} draggable whether an element is draggable. The user will
 * able to move the element around while holding the mouse button down on the 
 * element.
 * Example:
 * <code>
 *  <a:bar 
 *    draggable = "true" 
 *    width     = "200" 
 *    height    = "200" 
 *    left      = "10" 
 *    top       = "10" />
 * </code>
 * @attribute {Boolean} resizable whether an element is resizable. The user will able
 * to resize the element by grabbing one of the four edges of the element and 
 * pulling it in either direction. Grabbing the corners allows users to 
 * resize horizontally and vertically at the same time. The right bottom corner 
 * is special, because it offers an especially big grab area. The size of this
 * area can be configured in the skin of the element.
 * Example:
 * <code>
 *  <a:window 
 *    resizable = "true"
 *    visible   = "true" 
 *    width     = "400" 
 *    height    = "200" />
 * </code>
 * @attribute {Number} minwidth  the minimum horizontal size the element can get when resizing.
 * @attribute {Number} minheight the minimum vertical size the element can get when resizing.
 * @attribute {Number} maxwidth  the maximum horizontal size the element can get when resizing.
 * @attribute {Number} maxheight the maximum vertical size the element can get when resizing.
 *
 * @event drag          Fires when the widget has been dragged.
 * @event resizestart   Fires before the widget is resized.
 *   cancelable: Prevents this resize action to start.
 *   object:
 *   {String} type the type of resize. This is a combination of the four directions, n, s, e, w.
 * @event resize        Fires when the widget has been resized.
 *
 * @constructor
 *
 * @author      Ruben Daniels (ruben AT ajax DOT org)
 * @version     %I%, %G%
 * @since       1.0
 *
 * @see element.appsettings.attribute.outline
 * @see element.appsettings.attribute.resize-outline
 * @see element.appsettings.attribute.drag-outline
 */
apf.Interactive = function(){
    var nX, nY, rX, rY, startPos, lastCursor = null, l, t, lMax, tMax, lMin, 
        tMin, w, h, we, no, ea, so, rszborder, rszcorner, marginBox,
        verdiff, hordiff, _self = this, posAbs, oX, oY, overThreshold,
        dragOutline, resizeOutline, myPos;

    this.$regbase = this.$regbase | apf.__INTERACTIVE__;

    this.$propHandlers["draggable"] = function(value){
        if (apf.isFalse(value))
            this.draggable = value = false;
        else if (apf.isTrue(value))
            this.draggable = value = true;
        
        var o = this.oDrag || this.$ext;
        if (o.interactive & 1) 
            return;

        var mdown = o.onmousedown;
        o.onmousedown = function(e, reparent){
            if (!_self.editable && mdown && mdown.apply(this, arguments) === false)
                return;
            
            if (!reparent && (e || event).button == 2)
                return;
            
            dragStart.apply(this, arguments);
        }
        o.interactive = (o.interactive||0)+1;
        
        //this.$ext.style.position = "absolute";
    };

    this.$propHandlers["resizable"] = function(value){
        if (apf.isFalse(value))
            this.resizable = value = false;
        else if (apf.isTrue(value))
            this.resizable = value = true;
        
        var o = this.oResize || this.$ext;
        if (o.interactive & 2) 
            return;

        if (!_self.editable) {        
            var mdown = o.onmousedown;
            var mmove = o.onmousemove;
    
            o.onmousedown = function(){
                if (mdown && mdown.apply(this, arguments) === false)
                    return;
    
                resizeStart.apply(this, arguments);
            };
    
            o.onmousemove = function(){
                if (mmove && mmove.apply(this, arguments) === false)
                    return;
    
                resizeIndicate.apply(this, arguments);
            };
        }
        
        o.interactive = (o.interactive||0)+2;
        
        //this.$ext.style.position = "absolute";
        
        rszborder = this.$getOption && parseInt(this.$getOption("Main", "resize-border")) || 3;
        rszcorner = this.$getOption && parseInt(this.$getOption("Main", "resize-corner")) || 12;
        marginBox = apf.getBox(apf.getStyle(this.$ext, apf.isIE ? "borderWidth" : "border-width"));
    };
    
    /*
    this.$propHandlers["minwidth"]  = 
    this.$propHandlers["maxwidth"]  = 
    this.$propHandlers["minheight"] = 
    this.$propHandlers["maxheight"] = function(value, prop){
        if (this.aData)
            this.aData[prop] = parseInt(value);
    }
    if (this.aData) {
        this.aData.minwidth = this.minwidth;
        this.aData.minheight = this.minheight;
    }*/
    
    this.$cancelInteractive = function(){
        document.onmouseup(null, true);
    }
    
    function dragStart(e, reparent){
        if (!e) e = event;

        if (!reparent && (!_self.draggable || apf.dragMode))//_self.editable || 
            return;
        
        
        dragOutline = false;        
        
        
        apf.dragMode  = true;
        overThreshold = false;
        
        
        apf.popup.forceHide();
        
        
        posAbs = "absolute|fixed".indexOf(apf.getStyle(_self.$ext, "position")) > -1;
        if (!posAbs) {
            _self.$ext.style.position = posAbs //(posAbs = _self.dragSelection) 
                ? "absolute" : "relative";
        }
        if (_self.editable)
            posAbs = true;

        //@todo not for docking
        
        if (posAbs && !_self.aData) {
            apf.plane.show(dragOutline
                ? oOutline
                : _self.$ext);//, true
        }
        

        var pos = posAbs
            ? apf.getAbsolutePosition(_self.$ext, _self.$ext.offsetParent, true) 
            : [parseInt(apf.getStyle(_self.$ext, "left")) || 0, 
               parseInt(apf.getStyle(_self.$ext, "top")) || 0];

        nX = pos[0] - (oX = e.clientX);
        nY = pos[1] - (oY = e.clientY);
        
        //if (_self.hasFeature && _self.hasFeature(apf.__ANCHORING__))
            //_self.$disableAnchoring();

        
        {
            if (_self.$ext.style.right) {
                _self.$ext.style.left = pos[0] + "px";
                _self.$ext.style.right = "";
            }
            if (_self.$ext.style.bottom) {
                _self.$ext.style.top = pos[1] + "px";
                _self.$ext.style.bottom = "";
            }
        }

        document.onmousemove = dragMove;
        document.onmouseup   = function(e, cancel){
            document.onmousemove = document.onmouseup = null;

            
            if (posAbs && !_self.aData)
                apf.plane.hide();
            
            
            var htmlNode = dragOutline
                ? oOutline
                : _self.$ext;

            if (overThreshold) {
                if (cancel) {
                    l = _self.left;
                    t = _self.top;
                    r = _self.right;
                    b = _self.bottom;
                    w = _self.width;
                    h = _self.height;
                }
                
                if (_self.setProperty) {
                    updateProperties();
                }
                else if (dragOutline) {
                    _self.$ext.style.left = l + "px";
                    _self.$ext.style.top  = t + "px";
                }
            }
            
            l = t = w = h = null;
            
            if (!posAbs)
                _self.$ext.style.position = "relative";
            
            if (_self.showdragging)
                apf.setStyleClass(_self.$ext, "", ["dragging"]);
            
            if (posAbs && dragOutline)
                oOutline.style.display = "none";
            
            apf.dragMode = false;

            if (_self.dispatchEvent)
                _self.dispatchEvent("afterdrag", {
                    htmlNode : htmlNode
                });
        };
        
        if (reparent)
            document.onmousemove(e);
        else if (apf.isIE)
            apf.window.$mousedown(e);

        return false;
    };
    
    function dragMove(e){
        if(!e) e = event;
        
        //if (_self.dragSelection)
            //overThreshold = true;
        
        if (!overThreshold && _self.showdragging)
            apf.setStyleClass(_self.$ext, "dragging");
        
        // usability rule: start dragging ONLY when mouse pointer has moved delta x pixels
        var dx = e.clientX - oX,
            dy = e.clientY - oY,
            distance; 

        if (!overThreshold 
          && (distance = dx*dx > dy*dy ? dx : dy) * distance < 2)
            return;

        //Drag outline support
        else if (!overThreshold) {
            if (dragOutline 
              && oOutline.style.display != "block")
                oOutline.style.display = "block";

            if (_self.dispatchEvent && _self.dispatchEvent("beforedrag") === false) {
                document.onmouseup();
                return;
            }
        }

        var oHtml = dragOutline
            ? oOutline
            : _self.$ext;

        oHtml.style.left = (l = e.clientX + nX) + "px";
        oHtml.style.top  = (t = e.clientY + nY) + "px";

        if (_self.realtime) {
            var change = _self.$stick = {};
            _self.$showDrag(l, t, oHtml, e, change);
            
            if (typeof change.l != "undefined") 
                l = change.l, oHtml.style.left = l + "px";
            if (typeof change.t != "undefined") 
                t = change.t, oHtml.style.top = t + "px";
        }

        overThreshold = true;
    };
    
    this.$resizeStart = resizeStart;
    function resizeStart(e, options){
        if (!e) e = event;

        //|| _self.editable 
        if (!_self.resizable 
          || String(_self.height).indexOf("%") > -1 && _self.parentNode.localName == "vbox" //can't resize percentage based for now
          || String(_self.width).indexOf("%") > -1 && _self.parentNode.localName == "hbox") //can't resize percentage based for now
            return;

        
        resizeOutline = false;        
        
        
        if (!resizeOutline) {
            var diff = apf.getDiff(_self.$ext);
            hordiff  = diff[0];
            verdiff  = diff[1];
        }
        
        //@todo This is probably not gen purpose
        startPos = apf.getAbsolutePosition(_self.$ext);//, _self.$ext.offsetParent);
        startPos.push(_self.$ext.offsetWidth);
        startPos.push(_self.$ext.offsetHeight);
        myPos    = apf.getAbsolutePosition(_self.$ext, _self.$ext.offsetParent, true);

        var sLeft = 0,
            sTop  = 0,
            x     = (oX = e.clientX) - startPos[0] + sLeft + document.documentElement.scrollLeft,
            y     = (oY = e.clientY) - startPos[1] + sTop + document.documentElement.scrollTop,
            resizeType;

        if (options && options.resizeType) {
            posAbs = "absolute|fixed".indexOf(apf.getStyle(_self.$ext, "position")) > -1;
            resizeType = options.resizeType;
        }
        else {
            resizeType = getResizeType.call(_self.$ext, x, y);
        }
        rX = x;
        rY = y;

        if (!resizeType)
            return;

        if (_self.dispatchEvent && _self.dispatchEvent("beforeresize", {
            type    : resizeType,
            setType : function(type){
                resizeType = type;
            }
          }) === false) {
            if (apf.isIE)
                apf.window.$mousedown(e); //@todo is this necessary?
            return;
        }
        
        
        apf.popup.forceHide();
        

        //if (_self.hasFeature && _self.hasFeature(apf.__ANCHORING__))
            //_self.$disableAnchoring();
        
        apf.dragMode  = true;
        overThreshold = false;

        we = resizeType.indexOf("w") > -1;
        no = resizeType.indexOf("n") > -1;
        ea = resizeType.indexOf("e") > -1;
        so = resizeType.indexOf("s") > -1;
        
        if (!_self.minwidth)  _self.minwidth  = 0;
        if (!_self.minheight) _self.minheight = 0;
        if (!_self.maxwidth)  _self.maxwidth  = 10000;
        if (!_self.maxheight) _self.maxheight = 10000;

        if (posAbs) {
            lMax = myPos[0] + startPos[2];
            tMax = myPos[1] + startPos[3];
            lMin = myPos[0] + startPos[2];
            tMin = myPos[1] + startPos[3];
            document.title = tMax + ":" + tMin;
        }

        
        if (posAbs) {
            apf.plane.show(resizeOutline
                ? oOutline
                : _self.$ext);//, true
        }
        
        
        
        {
            if (_self.$ext.style.right) {
                _self.$ext.style.left = myPos[0] + "px";
                //_self.$ext.style.right = "";
            }
            if (_self.$ext.style.bottom) {
                _self.$ext.style.top = myPos[1] + "px";
                //_self.$ext.style.bottom = "";
            }
        }
        
        if (!options || !options.nocursor) {
            if (lastCursor === null)
                lastCursor = document.body.style.cursor;//apf.getStyle(document.body, "cursor");
            document.body.style.cursor = resizeType + "-resize";
        }
        
        document.onmousemove = resizeMove;
        document.onmouseup   = function(e, cancel){
            document.onmousemove = document.onmouseup = null;
            
            
            if (posAbs)
                apf.plane.hide();
            
            
            clearTimeout(timer);
            
            if (resizeOutline) {
                var diff = apf.getDiff(_self.$ext);
                hordiff  = diff[0];
                verdiff  = diff[1];
            }

            if (cancel) {
                l = _self.left;
                t = _self.top;
                r = _self.right;
                b = _self.bottom;
                w = _self.width;
                h = _self.height;
            }
            else
                doResize(e || event, true);

            if (_self.setProperty)
                updateProperties();
            
            l = t = w = h = null;

            document.body.style.cursor = lastCursor;
            lastCursor = null;
            
            if (resizeOutline)
                oOutline.style.display = "none";
            
            apf.dragMode = false;

            if (_self.dispatchEvent)
                _self.dispatchEvent("afterresize");
        };
        
        if (apf.isIE)
            apf.window.$mousedown(e);
        
        return false;
    }
    
    function updateProperties(left, top, width, height, hdiff, vdiff){
        if (typeof left == "undefined") {
            left = l, top = t, width = w, height = h, 
                vdiff = verdiff, hdiff  = hordiff;
        }

        var hasLeft   = _self.left || _self.left === 0;
        var hasRight  = _self.right || _self.right === 0;
        var hasBottom = _self.bottom || _self.bottom === 0;
        var hasTop    = _self.top || _self.top === 0;

        if (posAbs) {
            var htmlNode = oOutline.style.display == "block"
                ? oOutline
                : _self.$ext;

            if (hasRight) {
                _self.setProperty("right", apf.getHtmlRight(htmlNode), 0, _self.editable);
                if (!_self.left)
                    htmlNode.style.left = "";
            }
            
            if (hasBottom) {
                _self.setProperty("bottom", apf.getHtmlBottom(htmlNode), 0, _self.editable);
                if (!_self.top)
                    htmlNode.style.top = "";
            }
        
            if ((left || left === 0) && (!hasRight || hasLeft)) 
                _self.setProperty("left", left, 0, _self.editable);
            if ((top || top === 0) && (!hasBottom || hasTop)) 
                _self.setProperty("top", top, 0, _self.editable);
        }

        if (width && (!hasLeft || !hasRight)) 
            _self.setProperty("width", width + hdiff, 0, _self.editable) 
        if (height && (!_self.top || !hasBottom)) 
            _self.setProperty("height", height + vdiff, 0, _self.editable); 
    }
    this.$updateProperties = updateProperties;
    
    var min = Math.min, max = Math.max, lastTime, timer;
    function resizeMove(e){
        if(!e) e = event;
        
        //if (!e.button)
            //return this.onmouseup();
        
        // usability rule: start dragging ONLY when mouse pointer has moved delta x pixels
        /*var dx = e.clientX - oX,
            dy = e.clientY - oY,
            distance; 
        
        if (!overThreshold 
          && (distance = dx*dx > dy*dy ? dx : dy) * distance < 4)
            return;*/
        
        clearTimeout(timer);
        if (lastTime && new Date().getTime() 
          - lastTime < (resizeOutline ? 6 : apf.mouseEventBuffer)) {
            var z = {
                clientX: e.clientX,
                clientY: e.clientY
            }
            timer = setTimeout(function(){
                doResize(z);
            }, 10);
            return;
        }
        lastTime = new Date().getTime();
        
        doResize(e);
        
        //overThreshold = true;
    }
    
    function doResize(e, force){
        var oHtml = resizeOutline && !force
            ? oOutline
            : _self.$ext;

        var sLeft = document.documentElement.scrollLeft,
            sTop  = document.documentElement.scrollTop;
        
        if (we) {
            if (posAbs)
                oHtml.style.left = (l = max((lMin - _self.maxwidth), 
                    min((lMax - _self.minwidth), 
                    myPos[0] + e.clientX - oX + sLeft))) + "px";
            oHtml.style.width = (w = min(_self.maxwidth - hordiff, 
                max(hordiff, _self.minwidth, 
                    startPos[2] - (e.clientX - oX) + sLeft
                    ) - hordiff)) + "px"; //@todo
        }
        
        if (no) {
            if (posAbs)
                oHtml.style.top = (t = max((tMin - _self.maxheight), 
                    min((tMax - _self.minheight), 
                    myPos[1] + e.clientY - oY + sTop))) + "px";
            oHtml.style.height = (h = min(_self.maxheight - verdiff, 
                max(verdiff, _self.minheight, 
                    startPos[3] - (e.clientY - oY) + sTop
                    ) - verdiff)) + "px"; //@todo
        }

        if (ea)
            oHtml.style.width  = (w = min(_self.maxwidth - hordiff, 
                max(hordiff, _self.minwidth, 
                    e.clientX - startPos[0] + (startPos[2] - rX) + sLeft)
                    - hordiff)) + "px";

        if (so)
            oHtml.style.height = (h = min(_self.maxheight - verdiff, 
                max(verdiff, _self.minheight, 
                    e.clientY - startPos[1] + (startPos[3] - rY) + sTop)
                    - verdiff)) + "px";

        //@todo apf3.0 this is execution wise inefficient
        if (_self.parentNode && _self.parentNode.localName == "table") {
            updateProperties();
            apf.layout.processQueue();
        }
        
        if (_self.realtime) {
            var change = _self.$stick = {};
            
            //@todo calc l and t once at start of resize (subtract borders)
            _self.$showResize(l || apf.getHtmlLeft(oHtml), t || apf.getHtmlTop(oHtml), 
                w && w + hordiff || oHtml.offsetWidth, 
                h && h + verdiff || oHtml.offsetHeight, e, change, we, no, ea, so);

            if (we && typeof change.l != "undefined")
                oHtml.style.left = (l = max((lMin - _self.maxwidth), min((lMax - _self.minwidth), change.l))) + "px";
            
            if (no && typeof change.t != "undefined")
                oHtml.style.top = (t = max((tMin - _self.maxheight), min((tMax - _self.minheight), change.t))) + "px";
            
            if (typeof change.w != "undefined") 
                oHtml.style.width = (w = min(_self.maxwidth - hordiff, 
                    max(hordiff, _self.minwidth, 
                        change.w) - hordiff)) + "px";
            if (typeof change.h != "undefined") 
                oHtml.style.height = (h = min(_self.maxheight - verdiff, 
                    max(verdiff, _self.minheight, 
                        change.h) - verdiff)) + "px";
        }

        
        if (apf.hasSingleRszEvent)
            apf.layout.forceResize(_self.$int);
        
    }
    
    function getResizeType(x, y){
        var cursor  = "", 
            tcursor = "";
        posAbs = "absolute|fixed".indexOf(apf.getStyle(_self.$ext, "position")) > -1;

        if (_self.resizable == true || _self.resizable == "vertical") {
            if (y < rszborder + marginBox[0])
                cursor = posAbs ? "n" : "";
            else if (y > this.offsetHeight - rszborder) //marginBox[0] - marginBox[2] - 
                cursor = "s";
            else if (y > this.offsetHeight - rszcorner) //marginBox[0] - marginBox[2] - 
                tcursor = "s";
        }
        
        if (_self.resizable == true || _self.resizable == "horizontal") {
            if (x < (cursor ? rszcorner : rszborder) + marginBox[0])
                cursor += tcursor + (posAbs ? "w" : "");
            else if (x > this.offsetWidth - (cursor || tcursor ? rszcorner : rszborder)) //marginBox[1] - marginBox[3] - 
                cursor += tcursor + "e";
        }
        
        return cursor;
    }
    
    var originalCursor;
    function resizeIndicate(e){
        if(!e) e = event;
        
        if (!_self.resizable || _self.editable || document.onmousemove)
            return;

        //@todo This is probably not gen purpose
        var pos   = apf.getAbsolutePosition(_self.$ext),//, _self.$ext.offsetParent
            sLeft = 0,
            sTop  = 0,
            x     = e.clientX - pos[0] + sLeft + document.documentElement.scrollLeft,
            y     = e.clientY - pos[1] + sTop + document.documentElement.scrollTop;
        
        if (!originalCursor)
            originalCursor = apf.getStyle(this, "cursor");

        var cursor = getResizeType.call(_self.$ext, x, y);
        this.style.cursor = cursor 
            ? cursor + "-resize" 
            : originalCursor || "default";
    };

    
    
    /*this.addEventListener("DOMNodeRemovedFromDocument", function(e){
        oOutline.refCount--;
        
        if (!oOutline.refCount) {
            //destroy
        }
    });*/
};

apf.GuiElement.propHandlers["resizable"] = function(value){
    this.implement(apf.Interactive);
    this.$propHandlers["resizable"].apply(this, arguments);
}

apf.GuiElement.propHandlers["draggable"] = function(value){
    this.implement(apf.Interactive);
    this.$propHandlers["draggable"].apply(this, arguments);
};




/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/delayedrender.js)SIZE(5044)TIME(1269561670)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */

apf.__DELAYEDRENDER__ = 1 << 11



/**
 * All elements inheriting from this {@link term.baseclass baseclass} have delayed
 * rendering features. Any element that is (partially) hidden at startup has the
 * possibility to delay rendering it's childNodes by setting render="runtime" on
 * the element. These elements include window, tab, pages, form and container.
 * For instance a Tab page in a container is initally hidden and does not
 * need to be rendered. When the tab button is pressed to activate the page
 * the page is rendered and then displayed. This can dramatically decrease
 * the startup time of the application.
 * Example:
 * In this example the button isn't rendered until the advanced tab becomes active.
 * <code>
 *  <a:tab width="200" height="150">
 *      <a:page caption="General">
 *      ...
 *      </a:page>
 *      <a:page caption="Advanced" render="runtime">
 *         <a:button>OK</a:button>
 *      </a:page>
 *  </a:tab>
 * </code>
 *
 * @event beforerender  Fires before elements are rendered. Use this event to display a loader.
 *   cancelable: Prevents rendering of the childNodes
 * @event afterrender   Fires after elements are rendered. User this event to hide a loader.
 *
 * @attribute {String}  render           when the contents of this element is rendered.
 *   Possible values:
 *   init     elements are rendered during init of the application.
 *   runtime  elements are rendered when the user requests them.
 * @attribute {Boolean} use-render-delay whether there's a short delay between showing this element and rendering it's contents.
 *   Possible values:
 *   true   The elements are rendered immediately
 *   false  There is a delay between showing this element and the actual rendering,
 *          allowing the browsers' render engine to draw (for instance a loader).
 *
 * @constructor
 * @baseclass
 * @author      Ruben Daniels (ruben AT ajax DOT org)
 * @version     %I%, %G%
 * @since       0.8.9
 */
apf.DelayedRender = function(){
    this.$regbase   = this.$regbase | apf.__DELAYEDRENDER__;
    this.$rendered  = false;
    
    /**
     * Renders the children of this element.
     *
     * @param {Boolean} [usedelay] whether a delay is added between calling 
     * this function and the actual rendering. This allows the browsers' 
     * render engine to draw (for instance a loader).
     */
    this.$render = function(usedelay){
        if (this.$rendered)
            return;

        if (this.dispatchEvent("beforerender") === false)
            return;

        if (this["render-delay"] || usedelay)
            $setTimeout("apf.lookup(" + this.$uniqueId + ").$renderparse()", 10);
        else
            this.$renderparse();
    };

    this.$renderparse = function(){
        if (this.$rendered)
            return;

        var domParser = this.ownerDocument.$domParser;
        domParser.parseFromXml(this.$aml, {
            amlNode       : this,
            doc           : this.ownerDocument,
            //nodelay       : true,
            delayedRender : true
        });
        domParser.$continueParsing(this);

        this.$rendered = true;

        this.dispatchEvent("afterrender");
    };
    
    var f;
    this.addEventListener("prop.visible", f = function(){
        if (arguments[0].value) {
            
            this.$render();
            
            
            this.removeEventListener("prop.visible", f);
        }
    });
};

apf.GuiElement.propHandlers["render"] = function(value) {
    if (!this.hasFeature(apf.__DELAYEDRENDER__) && value == "runtime") {
        this.implement(apf.DelayedRender);
    
        if (this.localName != "page") {
            this.visible = false;
            this.$ext.style.display = "none";
        }
        
        if (typeof this["render-delay"] == "undefined")
            this.$setInheritedAttribute("render-delay");
    }
};

apf.config.$inheritProperties["render-delay"] = 1;



/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/dragdrop.js)SIZE(53625)TIME(1270838606)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */

apf.__DRAGDROP__ = 1 << 5;




/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/multicheck.js)SIZE(16325)TIME(1270838606)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */

apf.__MULTICHECK__ = 1 << 22;



/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/contenteditable2/commands.js)SIZE(26695)TIME(1271110244)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/contenteditable2/clipboard.js)SIZE(1127)TIME(1270838605)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/contenteditable2/interactive.js)SIZE(48739)TIME(1270838605)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/contenteditable2/visualselect.js)SIZE(13619)TIME(1270838605)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/*FILEHEAD(/var/lib/platform/source/trunk/core/baseclasses/contenteditable2/selectrect.js)SIZE(5449)TIME(1270838605)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/*FILEHEAD(/var/lib/platform/source/trunk/core/window-o3.js)SIZE(5397)TIME(1269561670)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/core/window.js)SIZE(50160)TIME(1271105953)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * Object representing the window of the aml application. The semantic is
 * similar to that of a window in the browser, except that this window is not
 * the same as the javascript global object. It handles the focussing within
 * the document and several other events such as exit and the keyboard events.
 *
 * @event blur              Fires when the browser window looses focus.
 * @event focus             Fires when the browser window receives focus.
 *
 * @constructor
 * @inherits apf.Class
 * @default_private
 *
 * @author      Ruben Daniels (ruben AT ajax DOT org)
 * @version     %I%, %G%
 * @since       0.8
 */
apf.window = function(){
    this.$uniqueId = apf.all.push(this);
    this.apf       = apf;

    /**
     * Returns a string representation of this object.
     */
    this.toString = function(){
        return "[apf.window]";
    };
    
    /**
     * Retrieves the primary {@link element.actiontracker action tracker} of the application.
     */
    this.getActionTracker = function(){
        return this.$at
    };

    /**
     * @private
     */
    this.loadCodeFile = function(url){
        //if(apf.isWebkit) return;
        if (self[url])
            apf.importClass(self[url], true, this.win);
        else
            apf.include(url);//, this.document);
    };

    

    /**
     * Show the browser window.
     */
    this.show = function(){
        if (apf.isDeskrun)
            jdwin.Show();
    };

    /**
     * Hide the browser window.
     */
    this.hide = function(){
        if (apf.isDeskrun) {
            jdwin.Hide();
        }
        else {
            this.loaded = false;
            if (this.win)
                this.win.close();
        }
    };

    /**
     * Focus the browser window.
     */
    this.focus = function(){
        if (apf.isDeskrun)
            jdwin.SetFocus();
        else
            window.focus();
    };

    /**
     * Set the icon of the browser window.
     * @param {String} url the location of the .ico file.
     */
    this.setIcon = function(url){
        if (apf.isDeskrun)
            jdwin.icon = parseInt(url) == url ? parseInt(url) : url;
    };

    /**
     * Set the title of the browser window.
     * @param {String} value the new title of the window.
     */
    this.setTitle = function(value){
        this.title = value || "";

        if (apf.isDeskrun)
            jdwin.caption = value;
        else
            document.title = (value || "");
    };

    /**
     * @private
     */
    this.loadAml = function(x){
        if (x[apf.TAGNAME] == "deskrun")
            this.loadDeskRun(x);
        /*else {

        }*/
    };

    
    var jdwin   = apf.isDeskrun ? window.external : null,
        jdshell = apf.isDeskrun ? jdwin.shell     : null;

    /**
     * @private
     */
    this.loadDeskRun = function(q){
        jdwin.style = q.getAttribute("style")
            || "ismain|taskbar|btn-close|btn-max|btn-min|resizable";

        apf.config.drRegName = q.getAttribute("record");
        if (q.getAttribute("minwidth"))
            jdwin.setMin(q.getAttribute("minwidth"), q.getAttribute("minheight"));
        if (q.getAttribute("record")
          && jdshell.RegGet(apf.config.drRegName + "/window")) {
            var winpos = jdshell.RegGet(apf.config.drRegName + "/window");
            if (winpos) {
                winpos = winpos.split(",");
                window.external.width  = Math.max(q.getAttribute("minwidth"),
                    Math.min(parseInt(winpos[2]),
                    window.external.shell.GetSysValue("deskwidth")));
                window.external.height = Math.max(q.getAttribute("minheight"),
                    Math.min(parseInt(winpos[3]),
                    window.external.shell.GetSysValue("deskheight")));
                window.external.left   = Math.max(0, Math.min(parseInt(winpos[0]),
                    screen.width - window.external.width));
                window.external.top    = Math.max(0, Math.min(parseInt(winpos[1]),
                    screen.height - window.external.height));
            }
        }
        else {
            jdwin.left   = q.getAttribute("left")   || 200;
            jdwin.top    = q.getAttribute("top")    || 200;
            jdwin.width  = q.getAttribute("width")  || 800;
            jdwin.height = q.getAttribute("height") || 600;
        }

        jdwin.caption = q.getAttribute("caption") || "DeskRun";
        jdwin.icon    = q.getAttribute("icon") || 100;

        var ct = $xmlns(q, "context", apf.ns.aml);
        if (ct.length) {
            ct = ct[0];
            if (!apf.config.tray)
                apf.config.tray = window.external.CreateWidget("trayicon")
            var tray = apf.config.tray;

            tray.icon = q.getAttribute("tray") || 100;
            tray.tip  = q.getAttribute("tooltip") || "DeskRun";
            tray.PopupClear();
            tray.PopupItemAdd("Exit", 3);
            tray.PopupItemAdd("SEP", function(){});

            var nodes = ct.childNodes;
            for (var i = nodes.length - 1; i >= 0; i--) {
                if (nodes[i].nodeType != 1)
                    continue;

                if (nodes[i][apf.TAGNAME] == "divider") {
                    tray.PopupItemAdd("SEP", function(){});
                }
                else {
                    tray.PopupItemAdd(apf.queryValue(nodes[i], "."),
                        nodes[i].getAttribute("href")
                        ? new Function("window.open('" + nodes[i].getAttribute("href") + "')")
                        : new Function(nodes[i].getAttribute("onclick")));
                }
            }
        }

        jdwin.shell.debug = apf.debug ? 7 : 0;
        jdwin.Show();
        jdwin.SetFocus();
    };
    

    /**** Focus Internals ****/

    

    this.$tabList = [];

    this.$addFocus = function(amlNode, tabindex, isAdmin){
        if (!isAdmin) {
            amlNode.addEventListener("DOMNodeInserted", moveFocus);
            amlNode.addEventListener("DOMNodeRemoved", removeFocus);

            if (amlNode.$isWindowContainer > -2) {
                amlNode.addEventListener("focus", trackChildFocus);
                amlNode.addEventListener("blur", trackChildFocus);

                amlNode.$focusParent = amlNode;

                if (amlNode.$isWindowContainer > -1) {
                    if (!amlNode.$tabList)
                        amlNode.$tabList = [amlNode];
                    
                    this.$tabList.push(amlNode);
                    return;
                }
                else {
                    amlNode.$tabList = [amlNode];
                }
            }
        }

        var fParent = findFocusParent(amlNode),
            list    = fParent.$tabList;

        
        if (list[tabindex]) {
            apf.console.warn("Aml node already exist for tabindex " + tabindex
                             + ". Will insert " + amlNode.tagName + " ["
                             + (amlNode.name || "") + "] before existing one");
        }
        

        if (!amlNode.$isWindowContainer)
            amlNode.$focusParent = fParent;

        if (list[tabindex])
            list.insertIndex(amlNode, tabindex);
        else
            list.push(amlNode);
    };

    this.$removeFocus = function(amlNode){
        if (!amlNode.$focusParent)
            return;

        amlNode.$focusParent.$tabList.remove(amlNode);

        if (!amlNode.$isWindowContainer) {
            amlNode.removeEventListener("DOMNodeInserted", moveFocus);
            amlNode.removeEventListener("DOMNodeRemoved", removeFocus);
        }

        if (amlNode.$isWindowContainer > -2) {
            amlNode.removeEventListener("focus", trackChildFocus); 
            amlNode.removeEventListener("blur", trackChildFocus);
        }
    };

    var focusLoopDetect;
    this.$focus = function(amlNode, e, force){
        var aEl = this.document.activeElement;
        if (aEl == amlNode && !force)
            return; //or maybe when force do $focus

        
        var hadAlreadyFocus = aEl == amlNode;
        

        this.$settingFocus = amlNode;

        if (!e)
            e = {};

        if (aEl && aEl != amlNode && focusLoopDetect != aEl) {
            focusLoopDetect = aEl;
            e.toElement     = amlNode;
            e.fromElement   = aEl;

            aEl.blur(true, e);

            
            
            if (focusLoopDetect != aEl)
                return false;
        }

        (apf.activeElement = this.document.activeElement = amlNode).focus(true, e);

        this.$settingFocus = null;

        apf.dispatchEvent("movefocus", {
            toElement : amlNode
        });

        

        
        if (!hadAlreadyFocus)
            apf.console.info("Focus given to " + amlNode.localName +
                " [" + (amlNode.name || "") + "]");
        

        
    };

    this.$blur = function(amlNode){
        var aEl = this.document.activeElement;
        if (aEl != amlNode)
            return false;

        
        apf.console.info(aEl.localName + " ["
            + (aEl.name || "") + "] was blurred.");
        

        aEl.$focusParent.$lastFocussed = null;
        apf.activeElement = this.document.activeElement = null;

        apf.dispatchEvent("movefocus", {
            fromElement : amlNode
        });

        
    };
    
    var lastFocusParent;

    this.$focusDefault = function(amlNode, e){
        var fParent = findFocusParent(amlNode);
        this.$focusLast(fParent, e);
    };

    this.$focusRoot = function(e){
        var docEl = apf.document.documentElement;
        if (this.$focusLast(docEl, e) === false) {
            //docEl.$lastFocussed = null;
            //this.moveNext(null, apf.document.documentElement, true, e);
        }
    };

    this.$focusLast = function(amlNode, e, ignoreVisible){
        var lf = amlNode.$lastFocussed;

        if (lf && lf.parentNode && lf.$focussable === true
          && (ignoreVisible || lf.$ext.offsetHeight)) {
            this.$focus(lf, e, true);
        }
        else { //Let's find the object to focus first
            var next, node = amlNode, skip;
            while (node) {
                if (!skip && node.focussable !== false && node.$focussable === true && !node.$tabList
                  && (ignoreVisible || node.$ext.offsetHeight) && !node.disabled) {
                    this.$focus(node, e, true);
                    break;
                }
                
                //Walk sub tree
                if ((next = !skip && node.firstChild || !(skip = false) && node.nextSibling)) {
                    node = next;
                    if (node.$isWindowContainer > 0)
                        skip = true;
                }
                else if (node == amlNode) {
                    if (node.$isWindowContainer)
                        this.$focus(node, e, true);
                    return;
                }
                else {
                    do {
                        node = node.parentNode;
                    } while (node && !node.nextSibling && node != amlNode 
                      && !node.$isWindowContainer)
                    
                    if (node == amlNode)
                        return; //do nothing
                    
                    if (node) {
                        if (node.$isWindowContainer) {
                            this.$focus(node, e, true);
                            break;
                        }
                        
                        node = node.nextSibling;
                    }
                }
            }

            if (!node)
                this.$focus(apf.document.documentElement);//return false;//

            /*@todo get this back from SVN
            var node, list = amlNode.$tabList;
            for (var i = 0; i < list.length; i++) {
                node = list[i];
                if (node.focussable !== false && node.$focussable === true
                  && (ignoreVisible || node.$ext.offsetHeight)) {
                    this.$focus(node, e, true);
                    return;
                }
            }

            this.$focus(apf.document.documentElement);*/
        }
    };

    function trackChildFocus(e){
        if (e.name == "blur") {
            if (e.srcElement != this && this.$blur)
                this.$blur();
            return;
        }
        
        if (e.srcElement != this && this.$focus)
            this.$focus();
        
        if (e.srcElement == this || e.trackedChild) {
            e.trackedChild = true;
            return;
        }

        this.$lastFocussed = e.srcElement;

        if (this.localName.indexOf("window") > -1)
            e.trackedChild = true;
    }

    function findFocusParent(amlNode){
        var node = amlNode;
        do {
            node = node.parentNode;
        } while(node && !node.$isWindowContainer);
        //(!node.$focussable || node.focussable === false)

        return node || apf.document.documentElement;
    }

    //Dom handler
    //@todo make this look at the dom tree insertion point to determine tabindex
    function moveFocus(e){
        if (e && e.currentTarget != this)
            return;
        
        if (this.$isWindowContainer)
            apf.window.$tabList.pushUnique(this);
        else
            apf.window.$addFocus(this, this.tabindex, true)
    }

    //Dom handler
    function removeFocus(e){
        if (e && (e.currentTarget != this || e.$doOnlyAdmin))
            return;
        
        if (apf.document.activeElement == this)
            apf.window.moveNext();
        
        if (this.$isWindowContainer) {
            apf.window.$tabList.remove(this);
            return;
        }

        if (!this.$focusParent)
            return;

        this.$focusParent.$tabList.remove(this);
        //this.$focusParent = null; //@experimental to not execute this
    }

    /**** Focus API ****/

    /**
     * Determines whether a given aml element has the focus.
     * @param {AMLElement} the element to check
     * @returns {Boolean} whether the element has focus.
     */
    this.hasFocus = function(amlNode){
        return this.document.activeElement == amlNode;
    };

    /**
     * @private
     */
    this.moveNext = function(shiftKey, relObject, switchWindows, e){
        if (switchWindows && apf.document.activeElement) {
            var p = apf.document.activeElement.$focusParent;
            if (p.visible && p.modal)
                return false;
        }

        var dir, start, next,
            amlNode = relObject || apf.document.activeElement,
            fParent = amlNode
                ? (switchWindows && amlNode.$isWindowContainer > 0
                    ? apf.window
                    : amlNode.$focusParent)
                : apf.document.documentElement,
            list    = fParent.$tabList;

        if (amlNode && (switchWindows || amlNode != apf.document.documentElement)) {
            start   = (list || []).indexOf(amlNode);
            if (start == -1) {
                
                apf.console.warn("Moving focus from element which isn't in the list\
                                  of it's parent. This should never happen.");
                

                return;
            }
        }
        else {
            start = -1;
        }

        if (this.document.activeElement && this.document.activeElement == amlNode
          && list.length == 1 || list.length == 0)
            return false;

        dir  = (shiftKey ? -1 : 1);
        next = start;
        if (start < 0)
            start = 0;
        do {
            next += dir;

            if (next >= list.length)
                next = 0;
            else if (next < 0)
                next = list.length - 1;

            if (start == next && amlNode) {
                if (list[0].$isWindowContainer)
                    this.$focus(list[0], e);
                
                return false; //No visible enabled element was found
            }

            amlNode = list[next];
        }
        while (!amlNode
            || amlNode.disabled
            || amlNode == apf.document.activeElement
            || (switchWindows ? !amlNode.visible : amlNode.$ext && !amlNode.$ext.offsetHeight)
            || amlNode.focussable === false
            || switchWindows && !amlNode.$tabList.length);

        if (fParent == apf.window) {
            this.$focusLast(amlNode, {mouse:true}, switchWindows);
        }
        else {
            (e || (e = {})).shiftKey = shiftKey;
            this.$focus(amlNode, e);
        }

        
    };

    /**
     * @private
     */
    this.focusDefault = function(){
        

        if (this.moveNext() === false)
            this.moveNext(null, apf.document.documentElement, true)
    };

    

    /**** Set Window Events ****/

    apf.addListener(window, "beforeunload", function(){
        return apf.dispatchEvent("exit");
    });

    //@todo apf3.x why is this loaded twice
    apf.addListener(window, "unload", function(){
        if (!apf)
            return;
        
        apf.window.isExiting = true;
        apf.window.destroy();
    });

    

    var timer, state = "", last = "";
    this.$focusfix = function(){
        
        if (apf.isIphone) return;
        
        state += "a";
        clearTimeout(timer);
        $setTimeout("window.focus();");
        timer = $setTimeout(determineAction);
    };

    this.$focusfix2 = function(){
        
        if (apf.isIphone) return;
        
        state += "b";
        clearTimeout(timer);
        timer = $setTimeout(determineAction);
    };

    this.$blurfix = function(){
        
        if (apf.isIphone) return;
        
        state += "c";
        clearTimeout(timer);
        timer = $setTimeout(determineAction);
    };

    function determineAction(){
        clearTimeout(timer);

        //apf.console.info(state);
        if (state == "e" || state == "c"
          || state.charAt(0) == "x" && !state.match(/eb$/)
          || state == "ce" || state == "de") { //|| state == "ae"
            if (last != "blur") {
                last = "blur";
                apf.window.dispatchEvent("blur");
                //apf.console.warn("blur");
            }
        }
        else {
            if (last != "focus") {
                last = "focus";
                apf.window.dispatchEvent("focus");
                //apf.console.warn("focus");
            }
        }

        state = "";
        timer = null;
    }

    apf.addListener(window, "focus", this.$focusevent = function(){
        
        if (apf.isIphone)
            return apf.window.dispatchEvent("focus");
        
        if (apf.hasFocusBug) {
            state += "d";
            clearTimeout(timer);
            timer = $setTimeout(determineAction);
        }
        else {
            clearTimeout(iframeFixTimer)
            iframeFix.newState = "focus";
            //apf.console.warn("win-focus");
            iframeFixTimer = $setTimeout(iframeFix, 10);
        }
    });

    apf.addListener(window, "blur", this.$blurevent = function(){
        if (!apf) return;
        
        
        if (apf.isIphone)
            return apf.window.dispatchEvent("blur");
        
        if (apf.hasFocusBug) {
            state += "e";
            clearTimeout(timer);
            timer = $setTimeout(determineAction);
        }
        else {
            clearTimeout(iframeFixTimer)
            iframeFix.newState = "blur";
            //apf.console.warn("win-blur");
            iframeFixTimer = $setTimeout(iframeFix, 10);
        }
    });

    var iframeFixTimer;
    function iframeFix(){
        clearTimeout(iframeFixTimer);

        var newState = iframeFix.newState;
        if (last == newState)
            return;

        last = newState;

        apf.dispatchEvent(last);
        //apf.console.warn(last);
    }

    this.hasFocus = function(){
        return (last == "focus");
    };

    

    /**** Keyboard and Focus Handling ****/

    apf.addListener(document, "contextmenu", function(e){
        if (!e)
            e = event;

        
        var pos, ev,
            amlNode = apf.findHost(e.srcElement || e.target)
              || apf.document.activeElement
              || apf.document && apf.document.documentElement;

        if (amlNode && amlNode.localName == "menu") //The menu is already visible
            return false;


        //if (amlNode && amlNode.localName == "menu")
            //amlNode = amlNode.parentNode;

        if (apf.contextMenuKeyboard) {
            if (amlNode) {
                pos = amlNode.selected
                    ? apf.getAbsolutePosition(amlNode.$selected)
                    : apf.getAbsolutePosition(amlNode.$ext || amlNode.$pHtmlNode);
            }
            else {
                pos = [0, 0];
            }

            ev = {
                x         : pos[0] + 10 + document.documentElement.scrollLeft,
                y         : pos[1] + 10 + document.documentElement.scrollTop,
                htmlEvent : e
            }
        }
        else {
            if (e.htmlEvent) {
                ev = e;
            }
            else {
                ev = { //@todo probably have to deduct the border of the window
                    x         : e.clientX + document.documentElement.scrollLeft,
                    y         : e.clientY + document.documentElement.scrollTop,
                    htmlEvent : e
                }
            }
        }

        ev.bubbles = true; //@todo discuss this, are we ok with bubbling?

        apf.contextMenuKeyboard = null;

        if ((amlNode || apf).dispatchEvent("contextmenu", ev) === false
          || ev.returnValue === false) {
            if (e.preventDefault)
                e.preventDefault();
            return false;
        }
        

        if (apf.config.disableRightClick) {
            if (e.preventDefault)
                e.preventDefault();
            return false;
        }
    });

    var ta = {"INPUT":1, "TEXTAREA":1, "SELECT":1};
    apf.addListener(document, "mousedown", this.$mousedown = function(e){
        e = e || window.event;

        var p,
            amlNode   = apf.findHost(e.srcElement || e.target),
            cEditable = amlNode && amlNode.$editable
              
            ;

        
        if (apf.popup.last && (!amlNode || apf.popup.last != amlNode.$uniqueId))
            apf.popup.forceHide();
        

        
        //Make sure the user cannot leave a modal window
        if ((!amlNode || !amlNode.$focussable || amlNode.focussable === false)
          && apf.config.allowBlur && amlNode.canHaveChildren != 2) {
            lastFocusParent = null;
            if (apf.document.activeElement)
                apf.document.activeElement.blur();
        }
        else if (amlNode) { //@todo check this for documentElement apf3.0
            if ((p = apf.document.activeElement
              && apf.document.activeElement.$focusParent || lastFocusParent)
              && p.visible && p.modal && amlNode.$focusParent != p) {
                apf.window.$focusLast(p, {mouse: true, ctrlKey: e.ctrlKey});
            }
            else if (!amlNode && apf.document.activeElement) {
                apf.window.$focusRoot();
            }
            else if (amlNode.$isWindowContainer == -1) {
                if (amlNode.$tabList.length)
                    apf.window.moveNext(null, amlNode.$tabList[0], null, {mouse: true});
                else
                    apf.window.$focus(amlNode);
            }
            else if (!amlNode.disabled && amlNode.focussable !== false) {
                if (amlNode.$focussable === apf.KEYBOARD_MOUSE) {
                    apf.window.$focus(amlNode, {mouse: true, ctrlKey: e.ctrlKey});
                }
                else if (amlNode.canHaveChildren == 2) {
                    if (!apf.config.allowBlur || !apf.document.activeElement 
                      || apf.document.activeElement.$focusParent != amlNode)
                        apf.window.$focusLast(amlNode, {mouse: true, ctrlKey: e.ctrlKey});
                }
                else {
                    apf.window.$focusDefault(amlNode, {mouse: true, ctrlKey: e.ctrlKey});
                }
            }
            else {
                apf.window.$focusDefault(amlNode, {mouse: true, ctrlKey: e.ctrlKey});
            }
    
            
            if (apf.hasFocusBug) {
                var isContentEditable = ta[(e.srcElement || e.target).tagName]
                    && !(e.srcElement || e.target).disabled
                    || (e.srcElement && e.srcElement.isContentEditable)
                    || amlNode.$isContentEditable
                    && amlNode.$isContentEditable(e) && !amlNode.disabled;
    
                if (!amlNode || !isContentEditable)
                    apf.window.$focusfix();
            }
            else if (!last) {
                apf.window.$focusevent();
            }
            
        }
        
        
        apf.dispatchEvent("mousedown", {
            htmlEvent : e,
            amlNode   : amlNode || apf.document.documentElement
        });

        //Non IE/ iPhone selection handling
        if (apf.isIE || apf.isIphone)
            return;

        var canSelect = !((!apf.document
          && (!apf.isParsingPartial || amlNode)
          
          || apf.dragMode
          
          ) && !ta[e.target.tagName]);

        if (canSelect) {
            amlNode = apf.findHost(e.target);
            if (amlNode){
                var isContentEditable = ta[(e.srcElement || e.target).tagName]
                    && !(e.srcElement || e.target).disabled
                    || (e.srcElement && e.srcElement.isContentEditable)
                    || amlNode.$isContentEditable
                    && amlNode.$isContentEditable(e) && !amlNode.disabled;
            
                //(!amlNode.canHaveChildren || !apf.isChildOf(amlNode.$int, e.srcElement))
                if (!isContentEditable 
                  && !apf.config.allowSelect
                  && amlNode.nodeType != amlNode.NODE_PROCESSING_INSTRUCTION 
                  && !amlNode.$allowSelect 
                  && !amlNode.$int) //getElementsByTagNameNS(apf.ns.xhtml, "*").length
                    canSelect = false;
            }
        }
       
        if (!canSelect && !cEditable) {
            if (e.preventDefault)
                e.preventDefault();
            return false;
        }
    });

    //IE selection handling
    apf.addListener(document, "selectstart", function(e){
        if (!e) e = event;

        var canSelect = !(!apf.document
          
          || apf.dragMode
          
        );

        var amlNode = apf.findHost(e.srcElement);
        if (canSelect) {
            //(!amlNode.canHaveChildren || !apf.isChildOf(amlNode.$int, e.srcElement))
            if (!apf.config.allowSelect 
              && amlNode && amlNode.nodeType != amlNode.NODE_PROCESSING_INSTRUCTION 
              && !amlNode.$allowSelect 
              && !amlNode.$int) //getElementsByTagNameNS(apf.ns.xhtml, "*").length
                canSelect = false;
        }

        if (!canSelect) {
            e.returnValue = false;
            return false;
        }
    });

    // Keyboard forwarding to focussed object
    apf.addListener(document, "keyup", this.$keyup = function(e){
        if (!e) e = event;

        
        if (apf.document && apf.document.activeElement
          && !apf.document.activeElement.disableKeyboard
          && apf.document.activeElement.dispatchEvent("keyup", {
                keyCode  : e.keyCode,
                ctrlKey  : e.ctrlKey,
                shiftKey : e.shiftKey,
                altKey   : e.altkey,
                htmlEvent: e
            }) === false) {
            e.returnValue = false;
            return false;
        }
        

        apf.dispatchEvent("keyup", null, e);
    });

    
    function wheel(e) {
        if (!e)
            e = event;

        var delta = null;
        if (e.wheelDelta) {
            delta = e.wheelDelta / 120;
            if (apf.isOpera)
                delta *= -1;
        }
        else if (e.detail) {
            delta = -e.detail / 3;
        }

        if (delta !== null) {
            //Fix for scrolling too much
            if (apf.isIE) {
                var el = e.srcElement || e.target;
                while (el && el.scrollHeight <= el.offsetHeight)
                    el = el.parentNode;
                
                if (!el) return;
                
                if (el.nodeType == 9)
                    el = el.documentElement;
                
                if (el && el.tagName == "BODY" && "auto|scroll".indexOf(apf.getStyle(el, "overflowY")) == -1)
                    el = document.documentElement;

                if (el && "auto|scroll".indexOf(apf.getStyle(el, "overflowY")) > -1) {
                    var max, dist = 0.35 * el.offsetHeight * delta;
                    if (delta < 0) {
                        if (el && el.scrollTop >= (max = el.scrollHeight - el.offsetHeight + apf.getVerBorders(el)) + dist) {
                            el.scrollTop = max;
                            e.returnValue = false;
                        }
                    }
                    else {
                        if (el && el.scrollTop <= dist) {
                            el.scrollTop = 0;
                            e.returnValue = false;
                        }
                    }
                }
            }
            
            var ev  = {
              delta: delta, 
              target   : e.target || e.srcElement, 
              button   : e.button, 
              ctrlKey  : e.ctrlKey, 
              shiftKey : e.shiftKey, 
              altKey   : e.altKey
            },
                res = apf.dispatchEvent("mousescroll", ev);
            if (res === false || ev.returnValue === false) {
                if (e.preventDefault)
                    e.preventDefault();

                e.returnValue = false;
            }
        }
    }

    if (document.addEventListener)
        document.addEventListener('DOMMouseScroll', wheel, false);

    window.onmousewheel   =
    document.onmousewheel = wheel; //@todo 2 keer events??
    

    //var browserNavKeys = {32:1,33:1,34:1,35:1,36:1,37:1,38:1,39:1,40:1}
    
    //@todo optimize this function
    apf.addListener(document, "keydown", this.$keydown = function(e){
        e = e || event;

        
        if (e.keyCode == 120 || e.ctrlKey && e.altKey && e.keyCode == 68) {
            apf.$debugwin.activate();
        }
        

        
        if (e.keyCode == 93)
            apf.contextMenuKeyboard = true;
        
        
        var amlNode           = apf.findHost(e.srcElement || e.target),
            isContentEditable = ta[(e.explicitOriginalTarget || e.srcElement || e.target).tagName]
              || (e.srcElement && e.srcElement.isContentEditable)
              
            ;

        
        //@todo move this to appsettings and use with_hotkey
        var o,
            ctrlKey = apf.isMac ? e.metaKey : e.ctrlKey;
        if (!isContentEditable && apf.config.undokeys && ctrlKey) {
            //Ctrl-Z - Undo
            if (e.keyCode == 90) {
                o = apf.document.activeElement;
                while (o && !o.getActionTracker && !o.$at)
                    o = o.parentNode;
                if (!o) o = apf.window;
                (o.$at || o.getActionTracker()).undo();
            }
            //Ctrl-Y - Redo
            else if (e.keyCode == 89) {
                o = apf.document.activeElement;
                while (o && !o.getActionTracker && !o.$at)
                    o = o.parentNode;
                if (!o) o = apf.window;
                (o.$at || o.getActionTracker()).redo();
            }
        }
        

        var eInfo = {
            ctrlKey   : e.ctrlKey,
            metaKey   : e.metaKey,
            shiftKey  : e.shiftKey,
            altKey    : e.altKey,
            keyCode   : e.keyCode,
            htmlEvent : e,
            bubbles   : true
        };
        
        
        //Hotkey
        if (!isContentEditable && apf.dispatchEvent("hotkey", eInfo) === false 
          || eInfo.returnValue === false) {
            e.returnValue  = false;
            e.cancelBubble = true;
            if (e.stopPropagation)
                e.stopPropagation();
            if (apf.canDisableKeyCodes) {
                try {
                    e.keyCode = 0;
                }
                catch(e) {}
            }
            if (e.preventDefault)
                e.preventDefault();
            return false;
        }
        

        

        delete eInfo.currentTarget;

        
        //Keyboard forwarding to focussed object
        if ((apf.document.activeElement && !apf.document.activeElement.disableKeyboard
          && !apf.document.activeElement.editable
          && apf.document.activeElement.dispatchEvent("keydown", eInfo) 
          || apf.dispatchEvent("keydown", eInfo)) === false) {
            e.returnValue  = false;
            e.cancelBubble = true;
            if (apf.canDisableKeyCodes) {
                try {
                    e.keyCode = 0;
                }
                catch(e) {}
            }
            if (e.preventDefault)
                e.preventDefault();
            return false;
        }
        
        //Focus handling
        else if ((!apf.config.disableTabbing || apf.document.activeElement) && e.keyCode == 9) {
            //Window focus handling
            if (e.ctrlKey && apf.document.activeElement) {
                var w = apf.document.activeElement.$focusParent;
                if (w.modal) {
                    if (e.preventDefault)
                        e.preventDefault();
                    return false;
                }

                apf.window.moveNext(e.shiftKey,
                    apf.document.activeElement.$focusParent, true);

                w = apf.document.activeElement.$focusParent;
                if (w && w.bringToFront)
                    w.bringToFront();
            }
            //Element focus handling
            else if(!apf.document.activeElement || apf.document.activeElement.tagName != "menu") {
                apf.window.moveNext(e.shiftKey);
            }

            if (e.preventDefault)
                e.preventDefault();
            return false;
        }
        

        //Disable backspace behaviour triggering the backbutton behaviour
        var altKey = apf.isMac ? e.metaKey : e.altKey;
        if (apf.config.disableBackspace
          && e.keyCode == 8// || (altKey && (e.keyCode == 37 || e.keyCode == 39)))
          && !isContentEditable) {
            if (apf.canDisableKeyCodes) {
                try {
                    e.keyCode = 0;
                }
                catch(e) {}
            }
            e.returnValue = false;
        }

        //Disable space behaviour of scrolling down the page
        /*if(Application.disableSpace && e.keyCode == 32 && e.srcElement.tagName.toLowerCase() != "input"){
            e.keyCode = 0;
            e.returnValue = false;
        }*/

        //Disable F5 refresh behaviour
        if (apf.config.disableF5 && (e.keyCode == 116 || e.keyCode == 117)) {
            if (apf.canDisableKeyCodes) {
                try {
                    e.keyCode = 0;
                }
                catch(e) {}
            }
            else {
                e.preventDefault();
                e.stopPropagation();
            }
            //return false;
        }
        
        
        /*if (browserNavKeys[e.keyCode] && apf.document.activeElement 
          && apf.config.autoDisableNavKeys)
            e.returnValue = false;*/

        if (e.keyCode == 27)
            e.returnValue = false;

        if (!apf.config.allowSelect
          && e.shiftKey && (e.keyCode > 32 && e.keyCode < 41)
          && !isContentEditable) {
            e.returnValue = false;
        }

        //apf.dispatchEvent("keydown", null, eInfo);

        if (e.returnValue === false && e.preventDefault)
            e.preventDefault();

        return e.returnValue;
        
    });
    
    apf.document = {};
    this.init = function(strAml){
        
        if (apf.actiontracker) {
            this.$at      = new apf.actiontracker();
            this.$at.name = "default";
            apf.nameserver.register("actiontracker", "default", this.$at);
        }
        
        
        

         
        apf.console.info("Start parsing main application");
        
        
        apf.Latometer.start();
        
        
        //Put this in callback in between the two phases
        

        this.$domParser = new apf.DOMParser();
        this.document = apf.document = this.$domParser.parseFromString(strAml, 
          "text/xml", {
            
            timeout   : apf.config.initdelay,
            
            callback  : function(doc){
                //@todo apf3.0

                //Call the onload event (prevent recursion)
                if (apf.parsed != 2) {
                    //@todo apf3.0 onload is being called too often
                    var inital = apf.parsed;
                    apf.parsed = 2;
                    apf.dispatchEvent("parse", { //@todo apf3.0 document
                        initial : inital
                    });
                    apf.parsed = true;
                }
        
                if (!apf.loaded) {
                    
                    if (apf.isDeskrun)
                        apf.window.deskrun.Show();
                    
        
                    
                    //Set the default selected element
                    if (!apf.document.activeElement && !apf.config.allowBlur)
                        apf.window.focusDefault();
                    

                    apf.loaded = true;
                    $setTimeout(function() {
                        apf.dispatchEvent("load");
                    });
                }
        
                //END OF ENTIRE APPLICATION STARTUP
        
                
                apf.console.info("Initialization finished");
                
                
                
                apf.Latometer.end();
                apf.Latometer.addPoint("Total load time");
                apf.Latometer.start(true);
                
          }
        }); //async

        
        this.addEventListener("focus", function(e){
            if (!apf.document.activeElement && lastFocusParent && !apf.isIphone) {
                if (lastFocusParent.$isWindowContainer == -1) {
                    if (lastFocusParent.$tabList.length)
                        apf.window.moveNext(null, lastFocusParent.$tabList[0]);
                    else
                        apf.window.$focus(lastFocusParent);
                }
                else 
                    apf.window.$focusLast(lastFocusParent);
            }
        });
        this.addEventListener("blur", function(e){
            if (!apf.document.activeElement || apf.isIphone)
                return;
    
            apf.document.activeElement.blur(true, {srcElement: this});//, {cancelBubble: true}
            lastFocusParent = apf.document.activeElement.$focusParent;
            apf.activeElement = apf.document.activeElement = null;
        });
      
    };

    /**
     * @private
     */
    this.destroy = function(){
        this.$at = null;

        apf.unload(this);

        apf           =
        this.win      =
        this.window   =
        this.document = null;

        //@todo this is not needed... maybe use apf.removeListener
        window.onfocus        =
        window.onerror        =
        window.onunload       =
        window.onbeforeunload =
        window.onbeforeprint  =
        window.onafterprint   =
        window.onmousewheel   =
        window.onblur         = null;

        document.oncontextmenu =
        document.onmousedown   =
        document.onmousemove   =
        document.onmouseup     =
        document.onselectstart =
        document.onmousewheel  =
        document.onkeyup       =
        document.onkeydown     = null

        if (document.body) {
            document.body.onmousedown =
            document.body.onmousemove =
            document.body.onmouseup   = null;

            document.body.innerHTML = "";
        }
    };
};
apf.window.prototype = new apf.Class().$init();
apf.window = new apf.window();


/**
 * @private
 */
apf.sanitizeTextbox = function(oTxt){
    oTxt.onfocus = function(){
        if (apf.window)
            apf.window.$focusfix2();
    };

    oTxt.onblur = function(){
        if (apf.window)
            apf.window.$blurfix();
    };
};




/*FILEHEAD(/var/lib/platform/source/trunk/core/browsers/gecko.js)SIZE(6402)TIME(1270838604)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


/**
 * Compatibility layer for Gecko based browsers.
 * @private
 */
apf.runGecko = function(){
    if (apf.runNonIe)
        apf.runNonIe();

    /* ***************************************************************************
     XSLT
     ****************************************************************************/
    
    
    //XMLDocument.selectNodes
    HTMLDocument.prototype.selectNodes = XMLDocument.prototype.selectNodes = function(sExpr, contextNode){
        try {
            var oResult = this.evaluate(sExpr, (contextNode || this),
                this.createNSResolver(this.documentElement),
                7, null);//XPathResult.ORDERED_NODE_SNAPSHOT_TYPE
        }
        catch(ex) {
            var msg = ex.message;
            if (ex.code == ex.INVALID_EXPRESSION_ERR)
                msg = msg.replace(/the expression/i, "'" + sExpr + "'");
            throw new Error(ex.lineNumber, "XPath error: " + msg);
        }
        
        var nodeList = new Array(oResult.snapshotLength);
        nodeList.expr = sExpr;
        for (var i = nodeList.length - 1; i >= 0; i--) 
            nodeList[i] = oResult.snapshotItem(i);
        return nodeList;
    };
    
    //Element.selectNodes
    Text.prototype.selectNodes =
    Element.prototype.selectNodes = function(sExpr){
       return this.ownerDocument.selectNodes(sExpr, this);
    };
    
    //XMLDocument.selectSingleNode
    HTMLDocument.prototype.selectSingleNode = XMLDocument.prototype.selectSingleNode = function(sExpr, contextNode){
        var nodeList = this.selectNodes(sExpr + "[1]", contextNode || null);
        return nodeList[0] || null;
    };
    
    //Element.selectSingleNode
    Text.prototype.selectSingleNode =
    Element.prototype.selectSingleNode = function(sExpr){
        return this.ownerDocument.selectSingleNode(sExpr, this);
    };
    
    
    
    var serializer = new XMLSerializer();
    apf.insertHtmlNodes = function(nodeList, htmlNode, beforeNode) {
        var o    = document.createElement("div"),
            frag = document.createDocumentFragment(),
            i    = nodeList.length - 1,
            l, node;
        for (; i >= 0; i--) {
            node = nodeList[i];
            frag.insertBefore(node, frag.firstChild);
        }

        o.innerHTML = apf.html_entity_decode(serializer.serializeToString(frag))
            .replace(/<([^>]+)\/>/g, "<$1></$1>");

        frag = document.createDocumentFragment();
        for (i = 0, l = o.childNodes.length; i < l; i++) {
            node = o.childNodes[0];
            frag.appendChild(node);
        }

        if (beforeNode)
            htmlNode.insertBefore(frag, beforeNode);
        htmlNode.appendChild(frag);
    };

    apf.insertHtmlNode = function(xmlNode, htmlNode, beforeNode, s) {
        if (htmlNode.nodeType != 11 && !htmlNode.style)
            return htmlNode.appendChild(xmlNode);
        
        var o = document.createElement("div");

        if (!s) {
            s = apf.html_entity_decode(xmlNode.serialize
                ? xmlNode.serialize(true)
                : ((xmlNode.nodeType == 3 || xmlNode.nodeType == 4 || xmlNode.nodeType == 2)
                    ? xmlNode.nodeValue
                    : serializer.serializeToString(xmlNode)));
        }

        o.innerHTML = s.replace(/<([^>]+)\/>/g, "<$1></$1>");

        if (beforeNode)
            htmlNode.insertBefore(o.firstChild, beforeNode);
        htmlNode.appendChild(o.firstChild);

        return beforeNode ? beforeNode.previousSibling : htmlNode.lastChild;
    };
    
    /* ******** Error Compatibility **********************************************
     Error Object like IE
     ****************************************************************************/
    function Error(nr, msg){
        
        if (!apf.$debugwin.nativedebug) 
            apf.$debugwin.errorHandler(msg, "", 0);
        
        
        this.message = msg;
        this.nr = nr;
    }
    
    apf.getHtmlLeft = function(oHtml){
        return (oHtml.offsetLeft
            + (parseInt(apf.getStyle(oHtml.parentNode, "border-left-width")) || 0));
    }
    apf.getHtmlRight = function(oHtml){
        var p;
        return (((p = oHtml.offsetParent).tagName == "BODY" 
          ? apf.getWindowWidth()
          : p.offsetWidth)
            - oHtml.offsetLeft - oHtml.offsetWidth
            - (2 * (parseInt(apf.getStyle(p, "border-left-width")) || 0))
            - (parseInt(apf.getStyle(p, "border-right-width")) || 0));
    }
    apf.getHtmlTop = function(oHtml){
        return (oHtml.offsetTop
            + (parseInt(apf.getStyle(oHtml.parentNode, "border-top-width")) || 0));
    }
    apf.getHtmlBottom = function(oHtml){
        var p;
        return (((p = oHtml.offsetParent).tagName == "BODY" 
          ? apf.getWindowHeight()
          : p.offsetHeight)
            - oHtml.offsetTop - oHtml.offsetHeight
            - (2 * (parseInt(apf.getStyle(p, "border-top-width")) || 0))
            - (parseInt(apf.getStyle(p, "border-bottom-width")) || 0));
    }
    apf.getBorderOffset = function(oHtml){
        return [-1 * (parseInt(apf.getStyle(oHtml, "border-left-width")) || 0),
            -1 * (parseInt(apf.getStyle(oHtml, "border-top-width")) || 0)];
    }
}




/*FILEHEAD(/var/lib/platform/source/trunk/core/browsers/gears.js)SIZE(1347)TIME(1260921679)*/


/**
 * @private
 */
apf.initGears = function(){
    // summary:
    //		factory method to get a Google Gears plugin instance to
    //		expose in the browser runtime environment, if present
    var factory, results;

    var gearsObj = apf.nameserver.get("google", "gears");
    if(gearsObj)
        return gearsObj; // already defined elsewhere

    if (typeof GearsFactory != "undefined") { // Firefox
        factory = new GearsFactory();
    }
    else {
        if(apf.isIE){
            // IE
            try {
                factory = new ActiveXObject("Gears.Factory");
            }
            catch(e) {
                // ok to squelch; there's no gears factory.  move on.
            }
        }
        else if(navigator.mimeTypes["application/x-googlegears"]) {
            // Safari?
            factory = document.createElement("object");
            factory.setAttribute("type", "application/x-googlegears");
            factory.setAttribute("width", 0);
            factory.setAttribute("height", 0);
            factory.style.display = "none";
            document.documentElement.appendChild(factory);
        }
    }

    // still nothing?
    if (!factory)
        return null;

    return apf.nameserver.register("google", "gears", factory);
};


/*FILEHEAD(/var/lib/platform/source/trunk/core/browsers/iphone.js)SIZE(11827)TIME(1265328064)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


/**
 * @private
 */
apf.runIphone = function() {
    if (!apf.isIphone) return;

    $setTimeout(function() {
        
        apf.importCssString(
           'html, body {\
                margin: 0;\
                font-family: Helvetica;\
                background: #fff;\
                color: #000000;\
                overflow-x: hidden;\
                -webkit-user-select: none;\
                -webkit-text-size-adjust: none;\
                -webkit-touch-callout: none;\
            }\
            body > *:not(.toolbar) {\
                min-height: 372px;\
            }\
            body[orient="landscape"] > *:not(.toolbar) {\
                min-height: 268px;\
            }\
            body > *[selected="true"] {\
                display: block;\
            }', "screen");
        

        var head = document.getElementsByTagName("head")[0];
        if (apf.config.iphoneIcon) {
            var link = document.createElement("link");
            link.setAttribute("rel", "apple-touch-icon"
                + (apf.config.iphoneIconIsGlossy ? "" : "-precomposed"));
            link.setAttribute("href", "apf.config.iphoneIcon");
            head.appendChild(link);
        }

        function appendMeta(name, content) {
            var meta = document.createElement("meta");
            meta.setAttribute("name", name);
            meta.setAttribute("content", content);
            head.appendChild(meta);
        }

        if (apf.config.iphoneFixedViewport) {
            appendMeta("viewport",
                "width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0;");
        }

        if (apf.config.iphoneFullScreen) {
            appendMeta("apple-mobile-web-app-capable", "yes");

            if (apf.config.iphoneStatusBar)
                appendMeta("apple-mobile-web-app-status-bar-style",
                    "apf.config.iphoneStatusBar");
        }
    });

    var hasOrientationEvent = false,
        currentWidth        = 0,
        portraitVal         = "portrait",
        landscapeVal        = "landscape",
        checkTimer          = null;

    apf.addDomLoadEvent(function() {
        $setTimeout(checkOrientAndLocation, 0);
        checkTimer = setInterval(checkOrientAndLocation, 300);
    });

    function orientChangeHandler() {
        switch(window.orientation) {
            case 0:
                setOrientation(portraitVal);
                break;
            case 90:
            case -90:
                setOrientation(landscapeVal);
                break;
        }
    }

    if (typeof window.onorientationchange == "object") {
        window.onorientationchange = orientChangeHandler;
        hasOrientationEvent = true;
        $setTimeout(orientChangeHandler, 0);
    }

    function checkOrientAndLocation() {
        if (!hasOrientationEvent) {
            if (window.innerWidth != currentWidth) {
                currentWidth = window.innerWidth;
                var orient   = currentWidth == 320 ? portraitVal : landscapeVal;
                setOrientation(orient);
            }
        }

        /*if (location.hash != currentHash) {
            var pageId = location.hash.substr(hashPrefix.length);
            iui.showPageById(pageId);
        }*/
    }

    function setOrientation(orient) {
        document.body.setAttribute("orient", orient);
        $setTimeout("scrollTo(0,1)", 100);
    }

    /* register event listeners:
     * - touchstart (skip)
     * - touchmove (skip)
     * - touchend (skip)
     * - touchcancel (skip)
     * - gesturestart
     * - gesturechange
     * - gestureend
     * - orientationchange
     */
    ["gesturestart", "gesturechange", "gestureend",
     "orientationchange"].forEach(function(type) {
        document["on" + type] = function(evt) {
            if (apf.dispatchEvent)
                apf.dispatchEvent(type, evt);
        };
    });

    apf.iphone = {
        titleNode : null,

        linkEvents: function(el, bClick) {
            return;
            el[bClick ? "onclick" : "ontouchstart"] = function(evt) {
                if (!evt.touches || evt.touches.length != 1) return;

                var e = evt.touches[0];
                if (typeof this.onmousedown == "function") {
                    this.onmousedown(e);
                    if (this != document)
                        return false;
                }
            };

            el.ontouchmove = function(evt) {
                if (!evt.touches || evt.touches.length != 1) return;

                var e = evt.touches[0];
                if (typeof this.onmousemove == "function") {
                    this.onmousemove(e);
                    if (this != document)
                        return false;
                }
            };

            var _touching = false;

            el.ontouchend = el.ontouchcancel = function(evt) {
                if (_touching) return;

                var e = evt.touches && evt.touches.length
                    ? evt.touches[0]
                    : evt.changedTouches[0];
                if (!e) return;

                _touching = true;
                $setTimeout(function() { _touching = false; });
                if (typeof this.onmouseup == "function") {
                    this.onmouseup(e);
                    if (this != document)
                        return false;
                }
            };

            return this;
        },
        nav: {
            sections     : null,
            active       : null,
            def          : "home",
            divideChar   : "/",
            levelTwoChar : "-",

            go: function(where, noanim) {
                var i, p, _self = apf.iphone.nav;
                _self.update();

                if (!(p = _self.sections[where.page])) return;

                scrollTo(0, 1);
                apf.dispatchEvent("pagechange", where);

                var sTitle = p.getAttribute("title");
                if (apf.iphone.titleNode && sTitle)
                    apf.iphone.titleNode.innerHTML = sTitle;

                if (noanim) {
                    for (i in _self.sections)
                        _self.sections[i].hide();
                    p.show();
                }
                else {
                    for (i in _self.sections) {
                        if (!_self.sections[i].visible || i == where.page)
                            continue;
                        var section = _self.sections[i];
                        section.setProperty("zindex", 0);
                        apf.tween.single(section.$ext, {
                            steps   : 5,
                            interval: 10,
                            from    : section.$ext.offsetLeft,
                            to      : (where.index < 0) ? 1000 : -1000,
                            type    : "left",
                            anim    : apf.tween.EASEOUT,
                            onfinish: function() {
                                section.setProperty("visible", false);
                            }
                        });
                    }

                    var pad   = 10,
                        el    = p.$ext,
                        iFrom = (where.index < 0)
                            ? -(el.offsetWidth) - pad
                            : window.innerWidth + el.offsetLeft + pad;
                    p.setProperty("visible", true);
                    p.setProperty("zindex",  apf.all.length + 1);
                    
                    apf.tween.single(el, {
                        steps   : 5,
                        interval: 10,
                        from    : iFrom,
                        to      : 0,
                        type    : "left",
                        anim    : apf.tween.EASEIN
                    });
                    
                }
            },

            update: function(force) {
                if (this.sections && !force) return;
                this.sections = {};
                for (var i in window) {
                    if (window[i] && window[i]["tagName"]
                      && window[i].tagName == "section")
                        this.sections[i] = window[i];
                }
            }
        }
    };

    $setTimeout(function() {
        apf.addEventListener("hashchange", apf.iphone.nav.go);
        if (location.href.match(/#(.*)$/))
    		apf.history.init(decodeURI(RegExp.$1));
        else if (apf._GET.page)
            apf.history.init(apf._GET.page);
        else
            apf.history.init();
    });

    // make sure that document event link to mouse events already. Since the
    // document object on top of the event bubble chain, it will probably also
    // be hooked by other APF elements.
    //apf.iphone.linkEvents(document);
    document.ontouchstart = function(evt) {
        if (!evt.touches || evt.touches.length != 1) return;

        var e       = evt.touches[0],
            el      = e.target,
            amlNode = apf.findHost(e.target);
        if (!amlNode) return;

        while (typeof el["onmousedown"] != "function" && el != document.body)
            el = el.parentNode;
        if (typeof el.onmousedown == "function") {
            if (typeof el.onmouseover == "function")
                el.onmouseover(e);
            else if (typeof el.onmousemove == "function")
                el.onmousemove(e);
            el.onmousedown(e);
            return false;
        }
    };

    document.ontouchmove = function(evt) {
        if (!evt.touches || evt.touches.length != 1) return;

        var e       = evt.touches[0],
            el      = e.target,
            amlNode = apf.findHost(e.target);
        if (!amlNode) return;

        while (typeof el["onmousemove"] != "function" && el != document.body)
            el = el.parentNode;
        if (typeof el.onmousemove == "function") {
            el.onmousemove(e);
            return false;
        }
        else if (typeof document["onmousemove"] == "function") {
            return document.onmousemove(e);
        }
    };

    document.ontouchend = document.ontouchcancel = function(evt) {
        var e = evt.touches && evt.touches.length
            ? evt.touches[0]
            : evt.changedTouches[0];
        if (!e) return;
        var el      = e.target,
            amlNode = apf.findHost(e.target);
        if (!amlNode) return;

        while (typeof el["onmouseup"] != "function" && el != document.body)
            el = el.parentNode;
        if (typeof el.onmouseup == "function") {
            if (typeof el.onmouseout == "function")
                el.onmouseout(e);
            el.onmouseup(e, true);
            return false;
        }
        else if (typeof document["onmouseup"] == "function") {
            return document.onmouseup(e);
        }
    };
};



/*FILEHEAD(/var/lib/platform/source/trunk/core/browsers/ie.js)SIZE(16447)TIME(1270838604)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


/**
 * Compatibility layer for Internet Explorer browsers.
 * @private
 */
apf.runIE = function(){
    /* ******** XML Compatibility ************************************************
     Extensions to the xmldb
     ****************************************************************************/
    var hasIE7Security = false,
        hasIESecurity  = false;
    
    if (self.XMLHttpRequest)
        try {
            new XMLHttpRequest()
        }
        catch (e) {
            hasIE7Security = true
        }
    try {
        new ActiveXObject("microsoft.XMLHTTP")
    }
    catch (e) {
        hasIESecurity = true
    }
    

    
     if (hasIESecurity)
        apf.importClass(runTpIframe, true, self);
     
    

    apf.getHttpReq = hasIESecurity
        ? function(){
            if (apf.availHTTP.length)
                return apf.availHTTP.pop();

            
            //if(apf.isDeskrun && !self.useNativeHttp)
            //    return jdshell.CreateComponent("XMLHTTP");
            

            return new XMLHttpRequest();
        }
        : function(){
            if (apf.availHTTP.length)
                return apf.availHTTP.pop();

            
            //if(apf.isDeskrun && !apf.useNativeHttp)
            //    return jdshell.CreateComponent("XMLHTTP");
            

            return new ActiveXObject("microsoft.XMLHTTP");
        };

    apf.getXmlDom = hasIESecurity
        ? function(message, noError){
            var xmlParser = getDOMParser(message, noError);
            return xmlParser;
        }
        : function(message, noError, preserveWhiteSpaces){
            var xmlParser = new ActiveXObject("microsoft.XMLDOM");
            xmlParser.setProperty("SelectionLanguage", "XPath");
            if (preserveWhiteSpaces)
                xmlParser.preserveWhiteSpace = true;

            if (message) {
                if (apf.cantParseXmlDefinition)
                    message = message.replace(/\] \]/g, "] ]")
                                     .replace(/^<\?[^>]*\?>/, "");//replace xml definition <?xml .* ?> for IE5.0

                xmlParser.loadXML(message);

                
                if (!noError)
                    this.xmlParseError(xmlParser);
            }

            return xmlParser;
        };

    apf.xmlParseError = function(xml){
        var xmlParseError = xml.parseError;
        if (xmlParseError != 0) {
            /*
             http://msdn.microsoft.com/library/en-us/xmlsdk30/htm/xmobjpmexmldomparseerror.asp?frame=true

             errorCode     Contains the error code of the last parse error. Read-only.
             filepos         Contains the absolute file position where the error occurred. Read-only.
             line             Specifies the line number that contains the error. Read-only.
             linepos         Contains the character position within the line where the error occurred. Read-only.
             reason         Explains the reason for the error. Read-only.
             srcText         Returns the full text of the line containing the error. Read-only.
             url             Contains the URL of the XML document containing the last error. Read-only.
             */
            throw new Error(apf.formatErrorString(1050, null,
                "XML Parse error on line " + xmlParseError.line,
                xmlParseError.reason + "Source Text:\n"
                    + xmlParseError.srcText.replace(/\t/gi, " ")
            ));
        }

        return xml;
    };
    
    /**
     * This method retrieves the current value of a property on a HTML element
     * @param {HTMLElement} el    the element to read the property from
     * @param {String}      prop  the property to read
     * @returns {String}
     */
    apf.getStyle = function(el, prop) {
        return el.currentStyle[prop];
    };
  
    apf.insertHtmlNodes = function(nodeList, htmlNode, beforeNode){
        for (var str = [], i = 0, l = nodeList.length; i < l; i++)
            str[i] = nodeList[i].xml;

        str = apf.html_entity_decode(str.join(""));
        
        if (apf.isIE < 7)
            str = str.replace(/style="background-image:([^"]*)"/g, 
              "find='$1' style='background-image:$1'");

        try {
            (beforeNode || htmlNode).insertAdjacentHTML(beforeNode
                ? "beforebegin"
                : "beforeend", str);
        }
        catch (e) {
            //IE table hack
            document.body.insertAdjacentHTML("beforeend", "<table><tr>"
                + str + "</tr></table>");

            var x = document.body.lastChild.firstChild.firstChild;
            for (i = x.childNodes.length - 1; i >= 0; i--)
                htmlNode.appendChild(x.childNodes[apf.hasDynamicItemList ? 0 : i]);
        }

        //Fix IE image loading bug
        if (apf.isIE < 7) {
            $setTimeout(function(){
                var nodes = htmlNode.getElementsByTagName("*");
                for (var s, i = 0, l = nodes.length; i < l; i++) {
                    if (s = nodes[i].getAttribute("find"))
                        nodes[i].style.backgroundImage = s.trim(); //@todo apf3.0 why is this needed?
                }
            });
        }
    }
    
    /* I have no idea what below code should do
    
    if (pNode.nodeType == 11) {
        id = xmlNode.getAttribute("id");
        if (!id)
            throw new Error(apf.formatErrorString(1049, null, "xmldb", "Inserting Cache Item in Document Fragment without an ID"));

        document.body.insertAdjacentHTML(beforeNode ? "beforebegin" : "beforeend", strHTML);
        pNode.appendChild(document.getElementById(id));
    }*/
    apf.insertHtmlNode = function(xmlNode, htmlNode, beforeNode, str){
        if (htmlNode.nodeType != 11 && !htmlNode.style)
            return htmlNode.appendChild(xmlNode);
        
        var pNode = beforeNode || htmlNode;
        
        if (!str)
            str = apf.html_entity_decode(xmlNode.serialize
                ? xmlNode.serialize(true)
                : xmlNode.xml || xmlNode.outerHTML || xmlNode.nodeValue);
        try {
            pNode.insertAdjacentHTML(beforeNode 
                ? "beforeBegin" 
                : "beforeEnd", str);
        }
        catch(e) {
            
            apf.console.warn("Warning found block element inside a " 
              + pNode.tagName 
              + " element. Rendering will give unexpected results");
            
            
            pNode.insertAdjacentHTML("afterEnd", str);
            return pNode.nextSibling;
        }

        if (beforeNode)
            return beforeNode.previousSibling;
        else 
            return htmlNode.lastChild.nodeType == 1 
                ? htmlNode.lastChild 
                : htmlNode.lastChild.previousSibling;
            
    }
    
    apf.getHorBorders = function(oHtml){
        return ((parseInt(oHtml.currentStyle["borderLeftWidth"]) || 0)
            + (parseInt(oHtml.currentStyle["borderRightWidth"]) || 0))
    };

    apf.getVerBorders = function(oHtml){
        return (0,
              (parseInt(oHtml.currentStyle["borderTopWidth"]) || 0)
            + (parseInt(oHtml.currentStyle["borderBottomWidth"]) || 0))
    };

    apf.getWidthDiff = function(oHtml){
        return Math.max(0, (parseInt(oHtml.currentStyle["paddingLeft"]) || 0)
            + (parseInt(oHtml.currentStyle["paddingRight"]) || 0)
            + (parseInt(oHtml.currentStyle["borderLeftWidth"]) || 0)
            + (parseInt(oHtml.currentStyle["borderRightWidth"]) || 0))
    };

    apf.getHeightDiff = function(oHtml){
        return Math.max(0, (parseInt(oHtml.currentStyle["paddingTop"]) || 0)
            + (parseInt(oHtml.currentStyle["paddingBottom"]) || 0)
            + (parseInt(oHtml.currentStyle["borderTopWidth"]) || 0)
            + (parseInt(oHtml.currentStyle["borderBottomWidth"]) || 0))
    };

    apf.getDiff = function(oHtml){
        return [Math.max(0, (parseInt(oHtml.currentStyle["paddingLeft"]) || 0)
            + (parseInt(oHtml.currentStyle["paddingRight"]) || 0)
            + (parseInt(oHtml.currentStyle["borderLeftWidth"]) || 0)
            + (parseInt(oHtml.currentStyle["borderRightWidth"]) || 0)),
            Math.max(0, (parseInt(oHtml.currentStyle["paddingTop"]) || 0)
            + (parseInt(oHtml.currentStyle["paddingBottom"]) || 0)
            + (parseInt(oHtml.currentStyle["borderTopWidth"]) || 0)
            + (parseInt(oHtml.currentStyle["borderBottomWidth"]) || 0))]
    };
    
    apf.getMargin = function(oHtml) {
        return [Math.max(0, (parseInt(oHtml.currentStyle["marginLeft"]) || 0)
            + (parseInt(oHtml.currentStyle["marginRight"]) || 0)),
            Math.max(0, (parseInt(oHtml.currentStyle["marginTop"]) || 0)
            + (parseInt(oHtml.currentStyle["marginBottom"]) || 0))]
    };
    
    apf.getHtmlLeft = function(oHtml){
        return (oHtml.offsetLeft
            - (apf.isIE > 7 && parseInt(oHtml.parentNode.currentStyle["borderLeftWidth"]) || 0));
    }
    apf.getHtmlRight = function(oHtml){
        var p;
        return (((p = oHtml.offsetParent).tagName == "BODY" 
          ? apf.getWindowWidth()
          : p.offsetWidth)
            - oHtml.offsetLeft - oHtml.offsetWidth
            - (apf.isIE < 8 && parseInt(p.currentStyle["borderLeftWidth"]) || 0)
            - (parseInt(p.currentStyle["borderRightWidth"]) || 0));
    }
    apf.getHtmlTop = function(oHtml){
        return (oHtml.offsetTop
            - (apf.isIE > 7 && parseInt(oHtml.offsetParent.currentStyle["borderTopWidth"]) || 0));
    }
    apf.getHtmlBottom = function(oHtml){
        var p;
        return (((p = oHtml.offsetParent).tagName == "BODY" 
          ? apf.getWindowHeight()
          : p.offsetHeight)
            - oHtml.offsetTop - oHtml.offsetHeight
            - (apf.isIE < 8 && parseInt(p.currentStyle["borderTopWidth"]) || 0)
            - (parseInt(p.currentStyle["borderBottomidth"]) || 0));
    }
    apf.getBorderOffset = function(oHtml){
        return apf.isIE < 8 && [0,0] || [parseInt(oHtml.currentStyle["borderLeftWidth"]) || 0,
                parseInt(oHtml.currentStyle["borderTopWidth"]) || 0]
    }
    
    apf.getHtmlInnerWidth = function(oHtml){
        return (oHtml.offsetWidth
            - (parseInt(oHtml.currentStyle["borderLeftWidth"]) || 0)
            - (parseInt(oHtml.currentStyle["borderRightWidth"]) || 0));
    }
    apf.getHtmlInnerHeight = function(oHtml){
        return (oHtml.offsetHeight
            - (parseInt(oHtml.currentStyle["borderTopWidth"]) || 0)
            - (parseInt(oHtml.currentStyle["borderBottomWidth"]) || 0));
    }
    
    apf.getOpacity = function(oHtml) {
        return parseInt(((oHtml.currentStyle["filter"] || "").match(/alpha\(opacity=(\d*)\)/) || [0,0])[1]) / 100;
    };
    apf.setOpacity = function(oHtml, value){
        oHtml.style.filter = "alpha(opacity=" + Math.round(value * 100) + ")";
    };
    
    
    /**
     * @private
     */
    apf.popup2 = {
        cache: {},
        setContent: function(cacheId, content, style, width, height){
            if (!this.popup)
                this.init();

            this.cache[cacheId] = {
                content: content,
                style  : style,
                width  : width,
                height : height
            };
            if (content.parentNode)
                content.parentNode.removeChild(content);
            if (style)
                apf.importCssString(style, this.popup.document);

            return this.popup.document;
        },

        removeContent: function(cacheId){
            this.cache[cacheId] = null;
            delete this.cache[cacheId];
        },

        init: function(){
            this.popup = window.createPopup();

            this.popup.document.write('<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">\
                <html xmlns="http://www.w3.org/1999/xhtml" xmlns:a=' + apf.ns.aml + ' xmlns:xsl="http://www.w3.org/1999/XSL/Transform">\
                <head>\
                    <script>\
                    var apf = {\
                        all: [],\
                        lookup:function(uniqueId){\
                            return this.all[uniqueId] || {\
                                $setStyleClass:function(){}\
                            };\
                        }\
                    };\
                    function destroy(){\
                        apf.all=null;\
                    }\
                    </script>\
                    <style>\
                    HTML{border:0;overflow:hidden;margin:0}\
                    BODY{margin:0}\
                    </style>\
                </head>\
                <body onmouseover="if(!self.apf) return;if(this.c){apf.all = this.c.all;this.c.Popup.parentDoc=self;}"></body>\
                </html>');

            var c = apf;
            this.popup.document.body.onmousemove = function(){
                this.c = c
            }
        },

        show: function(cacheId, x, y, animate, ref, width, height, callback){
            if (!this.popup)
                this.init();
            var o = this.cache[cacheId];
            //if(this.last != cacheId)
            this.popup.document.body.innerHTML = o.content.outerHTML;

            if (animate) {
                var iVal, steps = 7, i = 0, popup = this.popup;
                iVal = setInterval(function(){
                    var value = ++i * ((height || o.height) / steps);
                    popup.show(x, y, width || o.width, value, ref);
                    popup.document.body.firstChild.style.marginTop
                        = (i - steps - 1) * ((height || o.height) / steps);
                    if (i > steps) {
                        clearInterval(iVal)
                        callback(popup.document.body.firstChild);
                    }
                }, 10);
            }
            else {
                this.popup.show(x, y, width || o.width, height || o.height, ref);
            }

            this.last = cacheId;
        },

        hide: function(){
            if (this.popup)
                this.popup.hide();
        },

        forceHide: function(){
            if (this.last)
                apf.lookup(this.last).dispatchEvent("popuphide");
        },

        destroy: function(){
            if (!this.popup)
                return;
            this.popup.document.body.c = null;
            this.popup.document.body.onmouseover = null;
        }
    };
    

    
    apf.importClass(apf.runXpath, true, self);
    
}




/*FILEHEAD(/var/lib/platform/source/trunk/core/browsers/non_ie.js)SIZE(26283)TIME(1270838604)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


/**
 * @private
 */
apf.runNonIe = function (){
    

    DocumentFragment.prototype.getElementById = function(id){
        return this.childNodes.length ? this.childNodes[0].ownerDocument.getElementById(id) : null;
    };
    
    /**** XML Serialization ****/
    if (XMLDocument.prototype.__defineGetter__) {
        //XMLDocument.xml
        XMLDocument.prototype.__defineGetter__("xml", function(){
            return (new XMLSerializer()).serializeToString(this);
        });
        XMLDocument.prototype.__defineSetter__("xml", function(){
            throw new Error(apf.formatErrorString(1042, null, "XML serializer", "Invalid assignment on read-only property 'xml'."));
        });
        
        //Node.xml
        Node.prototype.__defineGetter__("xml", function(){
            if (this.nodeType == 3 || this.nodeType == 4 || this.nodeType == 2) 
                return this.nodeValue;
            return (new XMLSerializer()).serializeToString(this);
        });
        
        //Node.xml
        Element.prototype.__defineGetter__("xml", function(){
            return (new XMLSerializer()).serializeToString(this);
        });
    }
    
    /* ******** HTML Interfaces **************************************************
        insertAdjacentHTML(), insertAdjacentText() and insertAdjacentElement()
    ****************************************************************************/
    if (typeof HTMLElement!="undefined") {
        if (!HTMLElement.prototype.insertAdjacentElement) {
            Text.prototype.insertAdjacentElement =
            HTMLElement.prototype.insertAdjacentElement = function(where,parsedNode){
                switch (where.toLowerCase()) {
                    case "beforebegin":
                        this.parentNode.insertBefore(parsedNode,this);
                        break;
                    case "afterbegin":
                        this.insertBefore(parsedNode,this.firstChild);
                        break;
                    case "beforeend":
                        this.appendChild(parsedNode);
                        break;
                    case "afterend":
                        if (this.nextSibling)
                            this.parentNode.insertBefore(parsedNode,this.nextSibling);
                        else
                            this.parentNode.appendChild(parsedNode);
                        break;
                }
            };
        }

        if (!HTMLElement.prototype.insertAdjacentHTML) {
            Text.prototype.insertAdjacentHTML =
            HTMLElement.prototype.insertAdjacentHTML = function(where,htmlStr){
                var r = this.ownerDocument.createRange();
                r.setStartBefore(apf.isWebkit
                    ? document.body
                    : (self.document ? document.body : this));
                var parsedHTML = r.createContextualFragment(htmlStr);
                this.insertAdjacentElement(where, parsedHTML);
            };
        }

        if (!HTMLBodyElement.prototype.insertAdjacentHTML) //apf.isWebkit)
            HTMLBodyElement.prototype.insertAdjacentHTML = HTMLElement.prototype.insertAdjacentHTML;
    
        if (!HTMLElement.prototype.insertAdjacentText) {
            Text.prototype.insertAdjacentText =
            HTMLElement.prototype.insertAdjacentText = function(where,txtStr){
                var parsedText = document.createTextNode(txtStr);
                this.insertAdjacentElement(where,parsedText);
            };
        }
        
        //HTMLElement.removeNode
        HTMLElement.prototype.removeNode = function(){
            if (!this.parentNode) return;

            this.parentNode.removeChild(this);
        };
        
        //Currently only supported by Gecko
        if (HTMLElement.prototype.__defineSetter__) {
            //HTMLElement.innerText
            HTMLElement.prototype.__defineSetter__("innerText", function(sText){
                var s = "" + sText;
                this.innerHTML = s.replace(/\&/g, "&amp;")
                    .replace(/</g, "&lt;").replace(/>/g, "&gt;");
            });
        
            HTMLElement.prototype.__defineGetter__("innerText", function(){
                return this.innerHTML.replace(/<[^>]+>/g,"")
                    .replace(/\s\s+/g, " ").replace(/^\s*|\s*$/g, " ")
            });
            
            HTMLElement.prototype.__defineGetter__("outerHTML", function(){
                return (new XMLSerializer()).serializeToString(this);
            });
        }
    }
    
    /* ******** XML Compatibility ************************************************
        Giving the Mozilla XML Parser the same interface as IE's Parser
    ****************************************************************************/
    var ASYNCNOTSUPPORTED = false;
    
    //Test if Async is supported
    try {
        XMLDocument.prototype.async = true;
        ASYNCNOTSUPPORTED           = true;
    } catch(e) {/*trap*/} 
    
    Document.prototype.onreadystatechange = null;
    Document.prototype.parseError         = 0;
    
    Array.prototype.item = function(i){return this[i];};
    Array.prototype.expr = "";
    
    try{
        XMLDocument.prototype.readyState = 0;
    }catch(e){}
    
    XMLDocument.prototype.$clearDOM = function(){
        while (this.hasChildNodes())
            this.removeChild(this.firstChild);
    };
    
    XMLDocument.prototype.$copyDOM = function(oDoc){
        this.$clearDOM();
        
        if (oDoc.nodeType == 9 || oDoc.nodeType == 11) {
           var oNodes = oDoc.childNodes;
    
           for (var i = 0; i < oNodes.length; i++)
                this.appendChild(this.importNode(oNodes[i], true));
        }
        else if (oDoc.nodeType == 1)
            this.appendChild(this.importNode(oDoc, true));
    };
    
    //XMLDocument.loadXML();
    XMLDocument.prototype.loadXML = function(strXML){
        apf.xmldb.setReadyState(this, 1);
        var sOldXML = this.xml || this.serialize();
        var oDoc    = (new DOMParser()).parseFromString(strXML, "text/xml");
        apf.xmldb.setReadyState(this, 2);
        this.$copyDOM(oDoc);
        apf.xmldb.setReadyState(this, 3);
        apf.xmldb.loadHandler(this);
        return sOldXML;
    };
    
    Node.prototype.getElementById = function(id){};
    
    HTMLElement.prototype.replaceNode = 
    Element.prototype.replaceNode     = function(xmlNode){
        if (!this.parentNode) return;

        this.parentNode.insertBefore(xmlNode, this);
        this.parentNode.removeChild(this);
    };
    
    //XMLDocument.load
    XMLDocument.prototype.$load = XMLDocument.prototype.load;
    XMLDocument.prototype.load  = function(sURI){
        var oDoc = document.implementation.createDocument("", "", null);
        oDoc.$copyDOM(this);
        this.parseError = 0;
        apf.xmldb.setReadyState(this, 1);
    
        try {
            if (this.async == false && ASYNCNOTSUPPORTED) {
                var tmp = new XMLHttpRequest();
                tmp.open("GET", sURI, false);
                tmp.overrideMimeType("text/xml");
                tmp.send(null);
                apf.xmldb.setReadyState(this, 2);
                this.$copyDOM(tmp.responseXML);
                apf.xmldb.setReadyState(this, 3);
            } else
                this.$load(sURI);
        }
        catch (objException) {
            this.parseError = -1;
        }
        finally {
            apf.xmldb.loadHandler(this);
        }
    
        return oDoc;
    };
    
    
    
    
    
    /**
     * This method retrieves the current value of a property on a HTML element
     * @param {HTMLElement} el    the element to read the property from
     * @param {String}      prop  the property to read
     * @returns {String}
     */
    apf.getStyle = function(el, prop) {
        return window.getComputedStyle(el, '').getPropertyValue(prop);
    };
    
    //XMLDocument.setProperty
    HTMLDocument.prototype.setProperty = 
    XMLDocument.prototype.setProperty  = function(x,y){};
    
    /* ******** XML Compatibility ************************************************
        Extensions to the xmldb
    ****************************************************************************/
    apf.getHttpReq = function(){
        if (apf.availHTTP.length)
            return apf.availHTTP.pop();
        return new XMLHttpRequest();
    };

    apf.getXmlDom = function(message, noError){
        var xmlParser;
        if (message) {
            xmlParser = new DOMParser();
            xmlParser = xmlParser.parseFromString(message, "text/xml");

            
            if (!noError)
                this.xmlParseError(xmlParser);
        }
        else {
            xmlParser = document.implementation.createDocument("", "", null);
        }
        
        return xmlParser;
    };
    
    apf.xmlParseError = function(xml){
        //if (xml.documentElement.tagName == "parsererror") {
        if (xml.getElementsByTagName("parsererror").length) { 
            var str     = xml.documentElement.firstChild.nodeValue.split("\n"),
                linenr  = str[2].match(/\w+ (\d+)/)[1],
                message = str[0].replace(/\w+ \w+ \w+: (.*)/, "$1"),
            
                srcText = xml.documentElement.lastChild.firstChild.nodeValue.split("\n")[0];
            
            throw new Error(apf.formatErrorString(1050, null, 
                "XML Parse Error on line " +  linenr, message + 
                "\nSource Text : " + srcText.replace(/\t/gi, " ")));
        }
        
        return xml;
    };

    
    apf.xmldb.setReadyState = function(oDoc, iReadyState) {
        oDoc.readyState = iReadyState;
        if (oDoc.onreadystatechange != null && typeof oDoc.onreadystatechange == "function")
            oDoc.onreadystatechange();
    };
    
    apf.xmldb.loadHandler = function(oDoc){
        if (!oDoc.documentElement || oDoc.documentElement.tagName == "parsererror")
            oDoc.parseError = -1;
        
        apf.xmldb.setReadyState(oDoc, 4);
    };
    
    //
    //Fix XML Data-Island Support Problem with Form Tag
    apf.Init.add(function(){
        var i, nodes = document.getElementsByTagName("form");
        for (i = 0; i < nodes.length; i++)
            nodes[i].removeNode();
        nodes = document.getElementsByTagName("xml");
        for(i = 0; i < nodes.length; i++)
            nodes[i].removeNode();
        nodes = null;
    });
    
    /*window.onerror = function(message, filename, linenr){
        if(++ERROR_COUNT > MAXMSG) return;
        filename = filename ? filename.match(/\/([^\/]*)$/)[1] : "[Mozilla Library]";
        new Error("---- APF Error ----\nProcess : Javascript code in '" + filename +  "'\nLine : " + linenr + "\nMessage : " + message);
        return false;
    }*/
    
    if (document.body)
        document.body.focus = function(){};
    
    

    apf.getHorBorders = function(oHtml){
        return Math.max(0, 
              (parseInt(apf.getStyle(oHtml, "border-left-width")) || 0)
            + (parseInt(apf.getStyle(oHtml, "border-right-width")) || 0));
    };
    
    apf.getVerBorders = function(oHtml){
        return Math.max(0, 
              (parseInt(apf.getStyle(oHtml, "border-top-width")) || 0)
            + (parseInt(apf.getStyle(oHtml, "border-bottom-width")) || 0));
    };

    apf.getWidthDiff = function(oHtml){
        return Math.max(0, (parseInt(apf.getStyle(oHtml, "padding-left")) || 0)
            + (parseInt(apf.getStyle(oHtml, "padding-right")) || 0)
            + (parseInt(apf.getStyle(oHtml, "border-left-width")) || 0)
            + (parseInt(apf.getStyle(oHtml, "border-right-width")) || 0));
    };
    
    apf.getHeightDiff = function(oHtml){
        return Math.max(0, (parseInt(apf.getStyle(oHtml, "padding-top")) || 0)
            + (parseInt(apf.getStyle(oHtml, "padding-bottom")) || 0)
            + (parseInt(apf.getStyle(oHtml, "border-top-width")) || 0)
            + (parseInt(apf.getStyle(oHtml, "border-bottom-width")) || 0));
    };
    
    apf.getDiff = function(oHtml){
        return [Math.max(0, parseInt(apf.getStyle(oHtml, "padding-left"))
            + parseInt(apf.getStyle(oHtml, "padding-right"))
            + parseInt(apf.getStyle(oHtml, "border-left-width"))
            + parseInt(apf.getStyle(oHtml, "border-right-width")) || 0),
            Math.max(0, parseInt(apf.getStyle(oHtml, "padding-top"))
            + parseInt(apf.getStyle(oHtml, "padding-bottom"))
            + parseInt(apf.getStyle(oHtml, "border-top-width"))
            + parseInt(apf.getStyle(oHtml, "border-bottom-width")) || 0)];
    };
    
    apf.getMargin = function(oHtml) {
        return [Math.max(0, (parseInt(apf.getStyle(oHtml, "margin-left")) || 0)
            + (parseInt(apf.getStyle(oHtml, "margin-right")) || 0)),
            Math.max(0, (parseInt(apf.getStyle(oHtml, "margin-top")) || 0)
            + (parseInt(apf.getStyle(oHtml, "margin-bottom")) || 0))]
    };
    
    apf.getHtmlInnerWidth = function(oHtml){
        return (oHtml.offsetWidth
            - (parseInt(apf.getStyle(oHtml, "border-left-width")) || 0)
            - (parseInt(apf.getStyle(oHtml, "border-right-width")) || 0));
    }
    apf.getHtmlInnerHeight = function(oHtml){
        return (oHtml.offsetHeight
            - (parseInt(apf.getStyle(oHtml, "border-top-width")) || 0)
            - (parseInt(apf.getStyle(oHtml, "border-bottom-width")) || 0));
    }
    
    apf.getOpacity = function(oHtml) {
        return apf.getStyle(oHtml, "opacity");
    };
    
    apf.setOpacity = function(oHtml, value){
        oHtml.style.opacity = value;
    };
}



/*FILEHEAD(/var/lib/platform/source/trunk/core/browsers/opera.js)SIZE(6613)TIME(1270838604)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


/**
 * Compatibility layer for Opera browsers.
 * @private
 */
apf.runOpera = function (){
    if (apf.runNonIe)
        apf.runNonIe();
    
    /* ***************************************************************************
     XML Serialization
     ****************************************************************************/
    //XMLDocument.xml
    
    //Node.xml
    /*Node.prototype.serialize = function(){
     return (new XMLSerializer()).serializeToString(this);
     }
    //Node.xml
    
    Node.prototype.serialize        =
    XMLDocument.prototype.serialize =
    Element.prototype.serialize     = function(){
        return (new XMLSerializer()).serializeToString(this);
    };*/
    
    
    
    //XMLDocument.selectNodes
    Document.prototype.selectNodes     = 
    XMLDocument.prototype.selectNodes  =
    HTMLDocument.prototype.selectNodes = function(sExpr, contextNode){
        var oResult = this.evaluate(sExpr, (contextNode ? contextNode : this),
            this.createNSResolver(this.documentElement),
            XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null);
        var nodeList = new Array(oResult.snapshotLength);
        nodeList.expr = sExpr;
        for (var i = 0; i < nodeList.length; i++) 
            nodeList[i] = oResult.snapshotItem(i);
        return nodeList;
    };
    
    //Element.selectNodes
    Text.prototype.selectNodes =
    Element.prototype.selectNodes = function(sExpr){
        var doc = this.ownerDocument;
        if (!doc.selectSingleNode) {
            doc.selectSingleNode = HTMLDocument.prototype.selectSingleNode;
            doc.selectNodes = HTMLDocument.prototype.selectNodes;
        }
        
        if (doc.selectNodes) 
            return doc.selectNodes(sExpr, this);
        else {
            throw new Error(apf.formatErrorString(1047, null, "XPath Selection", 
                "Method selectNodes is only supported by XML Nodes"));
        }
    };
    
    //XMLDocument.selectSingleNode
    Document.prototype.selectSingleNode     =
    XMLDocument.prototype.selectSingleNode  =
    HTMLDocument.prototype.selectSingleNode = function(sExpr, contextNode){
        var nodeList = this.selectNodes(sExpr + "[1]", contextNode ? contextNode : null);
        return nodeList.length > 0 ? nodeList[0] : null;
    };
    
    //Element.selectSingleNode
    Text.prototype.selectSingleNode =
    Element.prototype.selectSingleNode = function(sExpr){
        var doc = this.ownerDocument;
        if (!doc.selectSingleNode) {
            doc.selectSingleNode = HTMLDocument.prototype.selectSingleNode;
            doc.selectNodes = HTMLDocument.prototype.selectNodes;
        }
        
        if (doc.selectSingleNode) {
            return doc.selectSingleNode(sExpr, this);
        }
        else {
            throw new Error(apf.formatErrorString(1048, null, "XPath Selection", 
                "Method selectSingleNode is only supported by XML Nodes. \nInfo : " + e));
        }
    };
    
    
    
    var serializer = new XMLSerializer();
    apf.insertHtmlNodes = function(nodeList, htmlNode, beforeNode) {
        var node,
            frag = document.createDocumentFragment(),
            i    = 0,
            l    = nodeList.length
        for (; i < l; i++) {
            if (!(node = nodeList[i])) continue;
            frag.appendChild(node);
        }
        (beforeNode || htmlNode).insertAdjacentHTML(beforeNode
            ? "beforebegin"
            : "beforeend", apf.html_entity_decode(serializer.serializeToString(frag)).replace(/<([^>]+)\/>/g, "<$1></$1>"));
    };

    apf.insertHtmlNode = function(xmlNode, htmlNode, beforeNode, s) {
        if (htmlNode.nodeType != 11 && !htmlNode.style)
            return htmlNode.appendChild(xmlNode);
        
        if (!s) {
            s = apf.html_entity_decode(xmlNode.serialize 
                ? xmlNode.serialize(true)
                : ((xmlNode.nodeType == 3 || xmlNode.nodeType == 4 || xmlNode.nodeType == 2)
                    ? xmlNode.nodeValue
                    : serializer.serializeToString(xmlNode)));
        }
        
        (beforeNode || htmlNode).insertAdjacentHTML(beforeNode
            ? "beforebegin"
            : "beforeend", s.replace(/<([^>]+)\/>/g, "<$1></$1>"));

        return beforeNode ? beforeNode.previousSibling : htmlNode.lastChild;
    };
    
    apf.getHtmlLeft = function(oHtml){
        return (oHtml.offsetLeft
            - (parseInt(apf.getStyle(oHtml.parentNode, "border-left-width")) || 0));
    }
    apf.getHtmlRight = function(oHtml){
        var p;
        return (((p = oHtml.offsetParent).tagName == "BODY" 
          ? apf.getWindowWidth()
          : p.offsetWidth)
            - oHtml.offsetLeft - oHtml.offsetWidth
            - (parseInt(apf.getStyle(p, "border-right-width")) || 0));
    }
    apf.getHtmlTop = function(oHtml){
        return (oHtml.offsetTop
            - (parseInt(apf.getStyle(oHtml.offsetParent, "border-top-width")) || 0));
    }
    apf.getHtmlBottom = function(oHtml){
        var p;
        return (((p = oHtml.offsetParent).tagName == "BODY" 
          ? apf.getWindowHeight()
          : p.offsetHeight)
            - oHtml.offsetTop - oHtml.offsetHeight
            - (parseInt(apf.getStyle(p, "border-bottom-width")) || 0));
    }
    apf.getBorderOffset = function(oHtml){
        return [parseInt(apf.getStyle(oHtml, "border-left-width")) || 0,
                parseInt(apf.getStyle(oHtml, "border-top-width")) || 0]
    }
};




/*FILEHEAD(/var/lib/platform/source/trunk/core/browsers/webkit.js)SIZE(7605)TIME(1270838604)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


/**
 * Compatibility layer for Webkit based browsers.
 * @private
 */
apf.runWebkit = function(){
    
    
    
    
    
    
    HTMLDocument.prototype.selectNodes = XMLDocument.prototype.selectNodes = function(sExpr, contextNode){
        if (sExpr.substr(0,2) == "//")
            sExpr = "." + sExpr;
        
        try {
            var oResult = this.evaluate(sExpr, (contextNode || this),
                this.createNSResolver(this.documentElement),
                7, null);//XPathResult.ORDERED_NODE_SNAPSHOT_TYPE
        }
        catch(ex) {
            try {
                var oResult = this.evaluate("child::" + sExpr, (contextNode || this),
                    this.createNSResolver(this.documentElement),
                    7, null);//XPathResult.ORDERED_NODE_SNAPSHOT_TYPE
            }
            catch(ex) {
                throw new Error("XPath error: " + ex.message + "\nLine: " + ex.lineNumber  + "\nExpression: '" + sExpr + "'");
            }
        }
        
        var nodeList = new Array(oResult.snapshotLength);
        nodeList.expr = sExpr;
        for (var i = nodeList.length - 1; i >= 0; i--) 
            nodeList[i] = oResult.snapshotItem(i);
        return nodeList;
    };
    
    //Element.selectNodes
    Text.prototype.selectNodes =
    Element.prototype.selectNodes = function(sExpr){
       return this.ownerDocument.selectNodes(sExpr, this);
    };
    
    //XMLDocument.selectSingleNode
    HTMLDocument.prototype.selectSingleNode = XMLDocument.prototype.selectSingleNode = function(sExpr, contextNode){
        var nodeList = this.selectNodes(sExpr, contextNode || null);
        return nodeList[0] || null;
    };
    
    //Element.selectSingleNode
    Text.prototype.selectSingleNode =
    Element.prototype.selectSingleNode = function(sExpr){
        return this.ownerDocument.selectSingleNode(sExpr, this);
    };
    
    
    
    var serializer = new XMLSerializer();
    apf.insertHtmlNodes = function(nodeList, htmlNode, beforeNode) {
        var node,
            frag = document.createDocumentFragment(),
            a = [], i = 0, l = nodeList.length;
        for (; i < l; i++) {
            if (!(node = nodeList[i])) continue;
            frag.appendChild(node);
        }

        (beforeNode || htmlNode).insertAdjacentHTML(beforeNode
            ? "beforebegin"
            : "beforeend", apf.html_entity_decode(serializer.serializeToString(frag))
                .replace(/<([^>]+)\/>/g, "<$1></$1>"));
    };

    apf.insertHtmlNode = function(xmlNode, htmlNode, beforeNode, s) {
        if (htmlNode.nodeType != 11 && !htmlNode.style)
            return htmlNode.appendChild(xmlNode);
        
        if (!s) {
            s = apf.html_entity_decode(xmlNode.serialize 
                ? xmlNode.serialize(true)
                : ((xmlNode.nodeType == 3 || xmlNode.nodeType == 4 || xmlNode.nodeType == 2)
                    ? xmlNode.nodeValue
                    : serializer.serializeToString(xmlNode)));
        }
        
        (beforeNode || htmlNode).insertAdjacentHTML(beforeNode
            ? "beforebegin"
            : "beforeend", s.replace(/<([^>]+)\/>/g, "<$1></$1>"));

        return beforeNode ? beforeNode.previousSibling : htmlNode.lastChild;
    };

    apf.getHtmlLeft = function(oHtml){
        return oHtml.offsetLeft;
    }
    apf.getHtmlRight = function(oHtml){
        var p;
        return (((p = oHtml.offsetParent).tagName == "BODY" 
          ? apf.getWindowWidth()
          : p.offsetWidth)
            - oHtml.offsetLeft - oHtml.offsetWidth
            - (parseInt(apf.getStyle(p, "border-left-width")) || 0)
            - (parseInt(apf.getStyle(p, "border-right-width")) || 0));
    }
    apf.getHtmlTop = function(oHtml){
        return oHtml.offsetTop
    }
    apf.getHtmlBottom = function(oHtml){
        var p;
        return (((p = oHtml.offsetParent).tagName == "BODY" 
          ? apf.getWindowHeight()
          : p.offsetHeight)
            - oHtml.offsetTop - oHtml.offsetHeight
            - (parseInt(apf.getStyle(p, "border-top-width")) || 0)
            - (parseInt(apf.getStyle(p, "border-bottom-width")) || 0));
    }
    apf.getBorderOffset = function(oHtml){
        return [0,0];
    }
    
    if (apf.runNonIe)
        apf.runNonIe();
};




/*FILEHEAD(/var/lib/platform/source/trunk/core/browsers/o3.js)SIZE(8825)TIME(1265038748)*/




/*FILEHEAD(/var/lib/platform/source/trunk/core/crypto/bigint.js)SIZE(20439)TIME(1257329185)*/

/**
 * BigInt, a suite of routines for performing multiple-precision arithmetic in
 * JavaScript.
 *
 * Copyright 1998-2005 David Shapiro.
 *
 * You may use, re-use, abuse,
 * copy, and modify this code to your liking, but please keep this header.
 * Thanks!
 *
 * @author Dave Shapiro <dave AT ohdave DOT com>
 * @author Ian Bunning
 *
 * IMPORTANT THING: Be sure to set maxDigits according to your precision
 * needs. Use the setMaxDigits() function to do this. See comments below.
 *
 * Tweaked by Ian Bunning
 * Alterations:
 * Fix bug in function biFromHex(s) to allow
 * parsing of strings of length != 0 (mod 4)
 *
 * Changes made by Dave Shapiro as of 12/30/2004:
 *
 * The BigInt() constructor doesn't take a string anymore. If you want to
 * create a BigInt from a string, use biFromDecimal() for base-10
 * representations, biFromHex() for base-16 representations, or
 * biFromString() for base-2-to-36 representations.
 *
 * biFromArray() has been removed. Use biCopy() instead, passing a BigInt
 * instead of an array.
 *
 * The BigInt() constructor now only constructs a zeroed-out array.
 * Alternatively, if you pass <true>, it won't construct any array. See the
 * biCopy() method for an example of this.
 *
 * Be sure to set maxDigits depending on your precision needs. The default
 * zeroed-out array ZERO_ARRAY is constructed inside the setMaxDigits()
 * function. So use this function to set the variable. DON'T JUST SET THE
 * VALUE. USE THE FUNCTION.
 *
 * ZERO_ARRAY exists to hopefully speed up construction of BigInts(). By
 * precalculating the zero array, we can just use slice(0) to make copies of
 * it. Presumably this calls faster native code, as opposed to setting the
 * elements one at a time. I have not done any timing tests to verify this
 * claim.
 * Max number = 10^16 - 2 = 9999999999999998;
 *               2^53     = 9007199254740992;
 */




/*FILEHEAD(/var/lib/platform/source/trunk/core/crypto/sha1.js)SIZE(5258)TIME(1257329185)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/core/crypto/base64.js)SIZE(6758)TIME(1257329185)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/core/crypto/rsa.js)SIZE(5048)TIME(1257329185)*/

/**
 * RSA, a suite of routines for performing RSA public-key computations in
 * JavaScript.
 *
 * Requires BigInt.js and Barrett.js.
 *
 * Copyright 1998-2005 David Shapiro.
 *
 * You may use, re-use, abuse, copy, and modify this code to your liking, but
 * please keep this header.
 *
 * Thanks!
 * 
 * @author Dave Shapiro <dave AT ohdave DOT com>
 */





/*FILEHEAD(/var/lib/platform/source/trunk/core/crypto/md5.js)SIZE(10878)TIME(1257329185)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/core/crypto/md4.js)SIZE(9799)TIME(1257329185)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/core/crypto/blowfish.js)SIZE(26046)TIME(1257329185)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/core/crypto/barrett.js)SIZE(2650)TIME(1257329185)*/

/**
 * Crypt.Barrett, a class for performing Barrett modular reduction computations in
 * JavaScript.
 *
 * Requires BigInt.js.
 *
 * Copyright 2004-2005 David Shapiro.
 *
 * You may use, re-use, abuse, copy, and modify this code to your liking, but
 * please keep this header.
 *
 * Thanks!
 * 
 * @author Dave Shapiro <dave AT ohdave DOT com>
 */




/*FILEHEAD(/var/lib/platform/source/trunk/core/parsers/js.js)SIZE(7973)TIME(1269561667)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/core/parsers/livemarkup.js)SIZE(113426)TIME(1271196961)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * @term livemarkup
 * Live Markup is an extension to Javascript, and it allows APF to have
 * a simple consistent syntax for all attribute values and templates.
 * Live markup is used for templating, rpc, data binding,
 * property binding, formatting and even events.
 * Live Markup generates text-output via the default-output of statements,
 * and APF maintains knowledge of all properties and data used to create
 * this output allowing for a Live update when any of this information changes.
 * Nearly all attributes in APF are processed as a live markup " " string
 * Some attributes (like events) and <?lm ?> blocks are processed as code.
 * LiveMarkup features:
 * <ol>
 *  <li>inline xpaths</li>
 *  <li>E4X-like xml literals</li>
 *  <li>automatic statement/expression output and concat</li>
 *  <li>code and xpath expansion in-strings</li>
 *  <li>virtual-sync of async calls</li>
 * </ol>
 * Examples:
 * <code>
 *    var x = [folder/@name]; // value of xpath
 *    [folder/@name] = 'hello'; // set an attribute
 *    [folder/file] += <file/>; // add a new file node to folder/file list
 *    var y = <folder><file name={x}/></folder> // e4x-style xml
 *    x; //automatic output
 *    <xml/>; // automatic output
 *    if(a)func(); // automatic output of function returnvalue
 *    x = 15; // not outputted, assignments are never output.
 *    var z = "string with jsvars: {x} and xpath: [folder/@name]";
 *    alert(comm.someRpcCall(x)); // async call returns sync value
 * </code>
 * LiveMarkup syntax has one conflict with normal JS syntax; an array of 1 item vs xpath.
 * Arrays are recognised if there is atleast one , present: [1,2] and 1 item: [,1]
 *
 * Another important feature of LiveMarkup is that its infinitely nestable:
 * Outer construct: inner constructs
 * <ol>
 *  <li>string: xpath, code</li>
 *  <li>xpath: code, xpath(its a sub-xpath when NOT after [)\w] or IS inside "str" or 'str' )</li>
 *  <li>code: xpath, code, string, xml</li>
 *  <li>xml: xpath, code</li>
 * </ol>
 * Example of code in xpath in xml in code in string, for the sake of argument:
 * <code>
 * var x = "str{<xml id=[xp{y}]/>}"
 * </code>
 * since code has an auto-output, it is also possible to use scope { } delimiters holding a value
 * and used as an expression.
 * var x = {..code with auto output..}
 * The ^ character at the beginning of a statement can force 'no output' but is very rarely needed.
 *
 * It is important to realise that Live Markup is converted to normal Javascript
 * in a single compile pass, and does not constitute black-magic.
 * As rarely debugging might force you to look at generated code, its useful to know it exists.
 * For instance:
 * XML literals are turned into normal JS strings: <xml/> becomes "<xml/>"
 * in generated code. This is different from E4X where they are special type of object.
 * xpaths and operators are turned into functioncalls: [xpath] becomes _val(_n,"xpath")
 * and nesting becomes concatenation: "a{x}b" becomes ("str"+(x)+"str")
 *
 * Live markup xpath reference
 * Different xpath types:
 * [xpath] - value xpath (string)
 * %[xpath] - single node
 * *[xpath] - node set
 * #[xpath] - number of nodes selected by xpath
 * $[symbol] - language 'xpath', fetches value from language symbol library
 * [model::xpath] - xpath value on model with name 'model'
 * [{x}::xpath] - xpath value on xml node or model with js variable x
 * [{rpc.thing()}::xpath] - xpath value on an rpc call
 * [xpath] = 'value' - assign text-value to xpath (nodeValue = ..)
 * [xpath] = <xml/> - replace node with right hand xml
 * [xpath] = xmlNode - replace node with right hand node, removing xmlNode from its old position
 * [xpath] += 'value' - appends text-value to nodeValue
 * [xpath] += <xml/> - appends the <xml/> after the selected node
 * [xpath] += xmlNode - appends the node and removes from its old position
 *
 * Macro reference
 * localName(n) - returns the localName of the context node or supplied argument
 * tagName(n) - tagName of context node or supplied argument
 * nodeValue(n) - value of context nore or supplied argment similar to [.]
 * local(n){..code..} - a codeblock with a new context node n, n can be xml-string too
 * each(set){..code..) iterates over the set. usually used as: each(*[xpath]){}
 *
 */

/**
 * @constructor
 * @parser
 *
 * @author      Rik Arends
 * @version     %I%, %G%
 * @since       3.0
 */
apf.lm = new (function(){

    var statement_lut = { // all js statements to see its NOT an expression
            "var": 1, "for": 1, "while": 1, "do": 1, "if": 1, "else": 1,
            "switch": 1, "case": 1, "break": 1, "continue": 1, "default": 1,
            "function":2, "return": 1, "try": 1, "catch": 1, "throw":1,
            "debugger": 1, "alert": 1, "confirm": 1,"setTimeout": 1,"setInterval": 1,"delete": 1, "export": 1, "import": 1,
            "label": 1, "foreach":1, "each": 1, "node": 1, "local": 1, "yield": 1,
            "let":1, "finally":1, "delete":1
        },
        type_lut = { // used for optimizing the parse regexp
            "\n": 1, "\r\n": 1, "==":2, "++":2, "--":2, '"': 5, "'": 5,
            "<!--": 6, "-->": 6, "/*": 6, "//": 6, "*/": 6, "{": 7, "}": 8,
            "[": 9, "]": 10, "(": 11, ")": 12, "<": 13, ">": 14, "+=":2,
            "-=":2, "/=":2, "*=":2, "!=":2
        },
        type_close = { // handy
            "{": "}", "[": "]", "(": ")", "{{":"}"
        },
        xpath_axes = { // used to detect xpath axes or model
            "ancestor": 1, "ancestor-or-self": 1, "attribute": 1, "child": 1,
            "descendant": 1, "descendant-or-self": 1, "following": 1,
            "following-sibling": 1, "namespace": 1, "parent": 1, "preceding": 1,
            "self": 1
        },
        misc_tok = { // misc token lookup
            ";":1, ",":2, "^":3, "=":4, "+=":4, "-=":4, "/=":4, "*=":4, "/":5, ":":6
        },
        xpath_lut_code = { // which autoxpath to use when doing macro({xpath})
            "~": "_val(_n,", "%": "_nod(_n,", "*": "_nods(_n,", "#": "_cnt(_n,", "$": "_lng("
        },
        xpath_lut_text = { // which autoxpath to use when doing xpath macros in textmode
            "~": "_val(_n,", "%": "_xml(_n,", "*": "_xmls(_n,", "#": "_cnt(_n,", "$": "_lng("
        },
        xpath_lut_attr = { // xpath lut for node attributes
            "~": "_val(_n,", "%": "_val(_n,", "*": "_val(_n,", "#": "_cnt(_n,", "$": "_lng("
        },
        xpath_lut_node,
        xpath_lut_node_normal = { // normal xpath lookup
            "~": "_val(_n,", "%": "_xml(_n,", "*": "_xmls(_n,", "#": "_cnt(_n,", "$": "_lng("
        },
        xpath_lut_node_langedit = { // language edit xpath lookup
            "~": "_val(_n,", "%": "_xml(_n,", "*": "_xmls(_n,", "#": "_cnt(_n,", "$": "_lnged("
        },
        pre_regexp = {
            "[":1, "(":1, ",":1, "=":1, "return":1, "throw":1
        },
        pre_xpath = {
            "else":1, "return":1, "delete":1
        },
        pre_plain = {
            "do":1, "else":1, "try":1
        },
        op_lut = { // obj.prop += operator lut
            "=" : "_asn(", "+=": "_add(", "-=": "_sub(", "/=": "_div(", "*=": "_mul("
        },
        new_block = {
            "+":1, "%":1, "-":1, "/":1, "=":1, "(":1, "?":1, "|":1, "^":1, "[":1,
            "&":1, "*":1, "!":1, ":":1, "<":1, ",":1
        },
        out_context_word = { // token preceeding a word signalling a new output
            "{":1, "} ":1, ")":1, ")   ":1, ";":1, "\n":1, "else":1
        },
        out_context_paren = { // token preceeding a paren signalling a new output
            "{":1, ";":1, "\n":1, "else":1
        }, // special markers: ') ' tail of xpath macro. ')  ' func def, tok=')    ' its not an if while etc.
        markup_in_code_lut = {
            "} ":1, ")   ":1,// the } used when it wasnt a code-expression
            "(":1, /*")":1,*/ ";":1, "&":1, "^":1, "|":1, ",":1, '"':1, "'":1, "=":1,
            "!=":2,"+=":2, "-=":2, "/=":2, "*=":2, "?":1, "{":1, "}":1, ">":1, "[":1,
            /*"]":1,*/ "+":1, ":":1, "else":1, "return":1
        },
        block_autoappend = { // token preceeding block signalling auto append
            '"':1, "'":1, ">":1, "]":1, "}":1
        },
        unesc_lut = { // unescape in code and xpath mode
            "\\\"": "\"", "\\\'": "\'", "\\{": "{", "\\}": "}", "\\[": "[",
            "\\]": "]", "\\(":"(", "\\)":")", "\\\\":"\\"
        },
        call_exclusion = {
            "alert": 1, "confirm" :1, "setTimeout":1, "setInterval":1, "switch":1,
            "call":1, "return":1, "throw":1, "case":1, "catch":1
        },
        is_out_space = {
            " ":1, "\n":1
        },
        newline_notallowed = {
            "{":1, ";":1, "(":1, "\n":1
        },//@todo !verify and document! character escaping system
        unesc_str = { // unescape in string mode
            "\\{": "{", "\\}": "}", "\\[": "[", "\\]": "]", "\\(": "(", "\\)": ")"
        },
        unesc_txt = { // unescape in text mode
            "\\{" : "{", "\\}" : "}", "\\[" : "[", "\\]" : "]", "\\(" : "(",
            "\\)" : ")", "\\\\": "\\\\\\\\", "\\"  :"\\\\", "\\<" : "<", "\\>" : ">"
        },
        xml_code_operators = { // word to operand lookup table for easy use in xml
            "lte": "<=", "gte": ">=", "lt": "<", "gt": ">", "and": "&&", "or": "||",
            "andbin": "&", "orbin": "|", "LTE": "<=", "GTE": ">=", "LT": "<",
            "GT": ">", "AND": "&&", "OR": "||", "ANDBIN": "&", "ORBIN": "|"
        },
        xpath_macro = { // which autoxpath to use when doing macro({xpath})
            0 : "_val(_n,",
            1 : "_valcr(_n,_cr,",
            2 : "_nod(_n,",
            3 : "_nodcr(_n,_cr,",
            4 : "_nods(_n,",
            5 : "_xpt(_n,",
            6 : "_valst(_n,",
            7 : "_valed(_n,",
            8 : "_valattr(_n,",
            "foreach"   : "_nods(_n,",
            "each"      : "_nods(_n,",
            "local"     : "_nod(_n,",
            "tagName"   : "_nod(_n,",
            "localName" : "_nod(_n,",
            "xml"       : "_xmlq(",
            "_call"     : "_val(_n,"
        },
        xpath_model = { // which autoxpath to use when doing macro({xpath})
            "_val(_n,"      : "_valm(",
            "_valcr(_n,_cr,": "_valcr(0,_cr,",
            "_nod(_n,"      : "_nodm(",
            "_nodcr(_n,_cr,": "_nodcr(0,_cr,",
            "_nods(_n,"     : "_nodsm(",
            "_xml(_n,"      : "_xml(0,",
            "_xmls(_n,"     : "_xmls(0,",
            "_cnt(_n,"      : "_cntm(",
            "_xpt(_n,"      : "_xptm(",
            "_valst(_n,"    : "_valm(",
            "_valed(_n,"    : "_valed(0,",
            "_lng("         : "_lng(",
            "_lnged("       : "_lnged(",
            "_nod_del(_n,"  : "_nod_del(0,",
            "_nods_del(_n," : "_nods_del(0,"
        },
        xpath_op = { // which autoxpath to use when doing macro({xpath})
            "=":{
                "_val(_n,"      : "_nod_asn(_n,",
                "_valm("        : "_nod_asn(0,",
                "_valcr(_n,_cr,": "_nod_asn(_n,",
                "_valcr(0,_cr," : "_nod_asn(0,",
                "_nod(_n,"      : "_nod_asn(_n,",
                "_nodm("        : "_nod_asn(0,",
                "_nodcr(_n,_cr,": "_nod_asn(_n,",
                "_nodcr(0,_cr," : "_nod_asn(0,",
                "_nods(_n,"     : "_nods_asn(_n,",
                "_nodsm("       : "_nods_asn(0,"
            },
            "+=":{ // which autoxpath to use when doing macro({xpath})
                "_val(_n,"      : "_nod_add(_n,",
                "_valm("        : "_nod_add(0,",
                "_valcr(_n,_cr,": "_nod_add(_n,",
                "_valcr(0,_cr," : "_nod_add(0,",
                "_nod(_n,"      : "_nod_add(_n,",
                "_nodm("        : "_nod_add(0,",
                "_nodcr(_n,_cr,": "_nod_add(_n,",
                "_nodcr(0,_cr," : "_nod_add(0,",
                "_nods(_n,"     : "_nods_add(_n,",
                "_nodsm("       : "_nods_add(0,"
            }
        },
        xpath_del = {
            "_cnt(_n,"      : "_nod_del(_n,",
            "_xpt(_n,"      : "_nod_del(_n,",
            "_val(_n,"      : "_nod_del(_n,",
            "_valcr(_n,"    : "_nod_del(_n,",
            "_nod(_n,"      : "_nod_del(_n,",
            "_nodcr(_n,_cr,": "_nod_del(_n,",
            "_nods(_n,"     : "_nods_del(_n,"
        },
        parserx = /(\r?[\n]|\/\*|\*\/|\/\/|\<\!\-\-|\-\-\>|[=\!+\/\*-]=|\+\+|\-\-|["'{(\[\])}\]\<\>]|$)|([ \t]+)|([a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF.$_][\w.$_]*)|(\d[x\d.]*)|(\\?[\w._?,:;!=+-\\\/^&|*"'[\]{}()%$#@~`<>]?)/g,
		selfrx = /(^|\|)(?!\@|text\(\)|\.\.|[\w\-\:]+?\:\:)/g, // inject self regexp
        macro_o = {},
        macro_c = {},
        macro_m = {},
        // config vars
        c_async_lut = apf.$asyncObjects || { // used to figure out if the thing before the. is an async obj
            "comm" :1,
            "rpc"  :1,
            "http" :1,
            "apf.ajax" :1
        },
        c_xpathmode,    // guess 'node' as the type for {} o_xpathpairs, 1 = node, 2 = nodes
        c_elemxpath,    // which xpath macro to use inside a ns'ed element
        c_statexpath,   // which xpath to use for the stateful value
        c_injectself,   // add self:: in some o_xpathpairs
		c_propassign, 	// support property assigns
		c_funcglobal,	// globalize function
        // outputs
        o, ol,          // output and output len
        o_asyncs,       // number of async calls
        o_xpathpairs,   // all xpaths and their models in pairs
        o_props,        // the js properties found
        o_segs,     	// segments at groundlevel
        o_xpaths,    	// xpaths at groundlevel
        o_models,       // number of xpaths with models
        // temp and state vars
        s = [], sl,     // scopestack and scopestack len
        bt = [],        // backtrack lut
        bts = [],       // backtrack string stack
        parse_mode,     // the parse parse_mode
        scope,          // ol of a scope begni
        segment,        // the ol of a segment begin
        start_tok,      // the token a string or comment was started with
        str,str_len,           // length of the input string
        line_no,        // line number we are at
        nesting,        // nesting count
        // last state vars
        last_tok,       // last token
        last_type,      // last type
        last_dot,       // . pos when last token was a word
        last_model,     // last model found
        last_prop,      // last property found
        last_cmt_mode,	// the parse mode outside the comment
        last_cmt_tok,	// last token before comment
        last_cmt_type,	// last type before comment
        last_line,      // offset of last newline
        last_ns,        // last namespace found
        last_word; 	    // last word in code mode
    // macros used in code()
    macro_o["if"]       = "if(",
    macro_c["if"]       = ")",
    macro_o["while"] 	= "while(",
    macro_c["while"] 	= ")",
    macro_o["for"]      = "for(",
    macro_c["for"]      = ")",
    macro_o["switch"] 	= "switch(",
    macro_c["switch"] 	= ")",
    macro_o["catch"] 	= "catch(",
    macro_c["catch"] 	= ")",
    macro_c["function"] = ")  ";

    macro_o.foreach 	=
    macro_o.each        = "\nfor(var _t=_t||[],_t=(_t.push(_n,0,("
    macro_c.foreach 	=
    macro_c.each        = ")||[]),_t);(_n=_t[_t.length-1][_t[_t.length-2]++])||(_t.length-=2,_n=_t.pop(),0);)"
    macro_o.local       = "\nfor(var _t=_t||[],_t=(_t.push(_n,((_n=_local("
    macro_c.local       = ")),1)),_t);(_t[_t.length-1]--&&_n)||(_t.length--,_n=_t.pop(),0);)"
    macro_o.localName   = "_localName(_n",
    macro_c.localName 	= ")"
    macro_o.output  	= "_o.join(''",
    macro_c.output      = ")"
    macro_o.reset       = "(_o=[],l=0",
    macro_c.reset       = ")"
    macro_o.index       = "apf.getChildNumber(_n",
    macro_c.index       = ")",
    macro_o.item        = "(_t[_t.length-1][_t[_t.length-2]-1]",
    macro_c.item        = ")",
    macro_o.first       = "(_t[_t.length-2]==1",
    macro_c.first       = ")",
    macro_o.last        = "(_t[_t.length-2]==_t[_t.length-1].length",
    macro_c.last        = ")",
    macro_o.total       = "(_t[_t.length-1].length",
    macro_c.total       = ")",
    macro_o.pos	        = "(_t[_t.length-2]-1",
    macro_c.pos	        = ")",

    macro_o.tagName     = "_tagName(_n",
    macro_c.tagName  	= ")"
    macro_o._nodeValue  = "_nodeValue(_n",
    macro_c._nodeValue  = ")"
    macro_c.async       = "])";
    macro_c.precall     = "])";
    macro_c._call       = ")";

    var call_args_lut = {
            _call     : ".call(_n",
            localName : macro_o.localName,
            tagName   : macro_o.tagName,
            nodeValue : macro_o.nodeValue,
            index : macro_o.index
        },

        // centralized code fragments used in parser/generator
        cf_block_o     = "(function(){var _o=[],_l=0;\n",
        cf_block_c     = ";return _l==1?_o[0]:_o.join('');})()",
        cf_async_o     = "_async(_n,_c,_a,_w,_f,this,",
        cf_async_m     = "',_a[++_a.i]||[",
        cf_obj_output  = "_r=",
        cf_mode_output,
        cf_str_output  = "_o[_l++]=",
        cf_def_output  = "",
        cf_func_o      = "{var _o=[],_l=0,_n=this;\n",
        cf_func_c      = ";\nreturn _l==1?_o[0]:_o.join('');}",

        // compile chunks used in compile/match
        cc_async_o     = "(_a=_a||{}).i=0;try{\n",
        cc_async_c     = "}catch(_e){if(_e.x)return;throw(_e);}\n",
        //cc_async_o     = "(_a=_a||{}).i=0;",
        //cc_async_c     = "",
        cc_pc_o        = "(_a=_a||{}).i=0;try{_pc(_w);",
        cc_pc_c        = "}catch(_e){if(_e.x)return;throw(_e);}",
        cc_opt_o       = "with(_w){",
        cc_opt_c       = "}",
        cc_v_blk_o     = "var _o=[],_l=0;_o[_l++]=",
        cc_v_blk_ob    = "var _o=[],_l=0;\n",
        cc_v_blk_c     = ";\nreturn _ret(_l==1?_o[0]:_o.join(''));",
        cc_v_blk_cb    = ";\n_c(_ret(_l==1?_o[0]:_o.join('')),apf.SUCCESS,apf.$lmx);apf.$lmx=null;",
        cc_v_ret_o     = "return _ret(",
        cc_v_ret_c     = ");",
        cc_v_cb_o      = "_c(_ret(",
        cc_v_cb_c      = "),apf.SUCCESS,apf.$lmx);apf.$lmx=null;\n",

        cc_o_blk_o     = "var _r=",
        cc_o_blk_ob    = "var _r;",

        cc_o_blk_c     = ";\nreturn _r;",
        cc_o_blk_cb    = ";\n_c(_r,apf.SUCCESS,apf.$lmx);apf.$lmx=null;",
        cc_o_blk_ce    = ";\n_c(0,apf.SUCCESS,apf.$lmx);apf.$lmx=null;;",
        cc_o_ret_o     = "return ",
        cc_o_ret_c     = "",
        cc_o_cb_o      = "_c(",
        cc_o_cb_c      = ",apf.SUCCESS);",
        cc_f_async_o   = "var _f=function(_n,_c,_w,_a){",
        cc_f_opt_o     = "var _f=function(_n,_w){",
        cc_f_o         = "var _f=function(_n){",
        cc_fc_async_o  = "var _f=function(_n,_c,_w,_cr,_a){",
        cc_fc_opt_o    = "var _f=function(_n,_w,_cr,){",
        cc_fc_o        = "var _f=function(_n,_cr){",
        cc_fe_async_o  = "var _f=function(event,_c,_w,_a,_n){",
        cc_fe_opt_o    = "var _f=function(event,_w,_n){",
        cc_fe_o        = "var _f=function(event,_n){",
        cc_f_c         = "}",
        cc_f_match_o   = "var _f=function(_m){",

        cc_m_m_blk     = ";\nif(_n=_r){if(!_n.nodeType)_n=_m;",
        cc_m_m_value_o = ";\nif(_n=",
        cc_m_m_value_c = "){if(!_n.nodeType)_n=_m;",
        cc_m_v_string  = "\nreturn ",
        cc_m_v_o       = "\nreturn _ret(",
        cc_m_v_c       = ");",
        cc_m_n_string  = "\nreturn _n;",
        cc_m_n_o       = "\nreturn (_r = (",
		// decision point for compileMatch node-mode for the return type
        cc_m_n_c       = "))?(_r.nodeType?_r:_n):(_r===null?null:_n);",

        cc_m_o         = "var _r, _n = _m;",
        cc_m_brk       = ";\n_n = _m;",
        cc_m_v_ret     = "\nreturn _ret(_nodeValue(_n));" ,
        cc_m_n_ret     = "\nreturn _n;" ,
        cc_m_c         = "\n}";

    function switchToBlock(no_output){ // used to switch expression mode to block mode
        var u, v;
        if (o[scope-1] == "{{")
            u = scope-1; // scan for our root expression block to switch to block
        else
            for (v = sl - 2, u = 0; v >= 0 && o[u=(s[v] & 0xfffffff) - 1] != "{{"; v -=2 ){};
		
        if (!no_output && ol > u + 1)  // inject auto output unless no output or nothing to output in buffer
            o[u] = cf_block_o + cf_str_output
        else
            o[u] = cf_block_o;
        parse_mode = 1;
    }

    function parser(tok, rx_lut, rx_white, rx_word, rx_num, rx_misc, pos){
        var u, v, w,
            type = rx_lut ? type_lut[rx_lut] : (rx_white ? 0 : (rx_word ? 3 : (rx_num ? 4 : (tok ? 2 : 15))));
        switch (parse_mode) {
            case 0: // =====================  expression parse_mode =========================
            case 1: // ==========================  block parse_mode =========================
                switch (type) {
                    case 0: // -------- whitespace --------
                        if ((last_type == 3 && last_tok!='$') || last_type == 4)
                            o[ol++] = " ";
                        else if(xpath_lut_code[last_tok])
                            last_type = 0;// make last_type visible to xpathmode select
                        break;
                    case 1: // -------- newline --------
                        line_no++,
                        last_line = pos;
                        if (o[ol-1] != "\n" && !newline_notallowed[last_tok])
                            o[ol++] = "\n";
                        if (xpath_lut_code[last_tok])
                            last_type = 0;// make last_type visible to xpathmode select
                        break;
                    case 2: // -------- misc --------
                        if (v = misc_tok[tok]) {
                            switch (v) {
                                case 1: // ';'
                                    if (!s[sl-1]) {// close = macro
                                        o[ol++] = ")",
                                        sl     -= 2;
                                    }

                                    if (!parse_mode) { // dont do ; inject newline instead
                                        if (o[ol-1] != "\n" && last_tok != "{" && last_tok != ";")
                                            o[ol++] = "\n";
                                    }
                                    else if(!sl || s[sl - 1]) // dont inject ; if we are in nested assignment macros
                                        o[ol++] = ";";
                                    break;
                                case 2: // ','
                                    if (!s[sl - 1]) { // close = macro
                                        o[ol++] = ")",
                                        sl     -= 2;
                                    }
                                    o[ol++] = ",";
                                    break;
                                case 3: //'^' // dont output
                                    if (o[ol-1] == "\n" || o[ol - 1] == ";" || last_tok=="{"
                                      || last_tok == "} " || ol == scope) { // dont output-shortcut requirements
                                        if (!parse_mode)
                                            switchToBlock();
                                        o[ol++] = "  "; // two spaces make it modify the output-ifs outcome
                                    }
                                    else
                                        o[ol++] = "^";
                                    break;
                                case 4: //'= += -= assignment macro mode
									if(last_tok!='<' && last_tok!='>'){
										// we should only switch to block when we are not in a ( ) scope
										if (!parse_mode && o[scope-1]!='(')
											switchToBlock(true);
										o[ol++] = tok;
										// lets scan in reverse to see if we have an output or a non-output

										for (v = ol; v >= scope && !statement_lut[o[v]] && !((o[v] == "  " 
											|| o[v] == (nesting ? cf_str_output : cf_mode_output)) && (o[v]="",1)); v--){};

										if (last_type == 3 && last_dot>0 && last_tok.charAt(0)!="."){ // prop = macro
											if(c_propassign){
												ol -= 2;
												while (is_out_space[o[ol]])
													ol--;
												w = last_tok;
												o[ol++] = op_lut[tok], o[ol++] = w.slice(0,last_dot), 
												o[ol++] = ",'", o[ol++] = w.slice(last_dot+1),
												o[ol++] = "',", s[sl++] = scope | (parse_mode << 28),
												s[sl++] = ""; // notabene, this stored item is checked everywhere
											}
										}
										else if (o[v = ol - 2] == ") ") { // recognise tail of xpath macro
											if (!(u = xpath_op[tok]) || !(u = u[ o[w = s[sl] & 0xfffffff]]))
												throw {
													t: "Invalid xpath assign",
													p: pos
												};
											o[w] = u,o[v] = ",", o[v + 1] = "", o[v + 2] = "";
											s[sl++] = scope | (parse_mode << 28),
											s[sl++] = "" // this value is checked everywhere
										}
									}else{
										o[ol++] = tok;
									}break;
                                case 5: // '/' // regexp mode
                                    if (pre_regexp[last_tok]) {
                                        s[sl++] = scope | (parse_mode << 28);
                                        s[sl++] = o[ol++] = tok;
                                        scope   = segment = ol - 1;
                                        nesting++, parse_mode = 5, start_tok = tok;
                                    }
                                    else
                                        o[ol++] = "/";
                                    break;
                                case 6: // ':' // switch to {x:1} object mode
                                    if (sl > 2 && s[sl - 1] == "{{" && (ol < scope + 4 && last_type == 5)
                                      || (ol < scope + 3 && (last_type == 3 || last_type == 4))) {
                                        o[scope-1] = s[sl-1] = "{"
                                        parse_mode = (v = s[sl - 2]) >> 28;
                                        s[sl-2]    = v & 0xfffffff,
                                        nesting--;
                                    }
                                    else if(o[ol - 3] == "case" || (last_type == 5 && last_word == "case"))
                                        tok = ";"; //fixes auto output problem
                                    o[ol++] = ":";
                                    break;
								default:
									 o[ol++] = tok;
									break;
                            }
                        }
                        else
                            o[ol++] = unesc_lut[tok] || tok;
                        break;
                    case 3: // -------- word --------
                    case 4: // ------- number -------
                        v = u = w = 0;// last_word used for case 'bla bla':
                        last_dot = (last_word = tok).lastIndexOf(".");
						if (tok.charAt(0) != '.' // .obj shouldnt trigger block
                          && ((v = (u = ((out_context_word[last_tok]  // check if we need to switch
                                || o[ol - 1] == "\n")  && !new_block[last_tok]))
                                && !s[sl - 1].indexOf("{") && ol > scope)
                                || (w = statement_lut[tok])) && !parse_mode){ // check statement
							if(w == 2 && s[sl - 1].indexOf("{")) w = 0; // (function() shouldnt trigger blockmode
							switchToBlock(w);  // pass in statement_lut[tok] as outputflag
						}
                        if (u && !s[sl - 1]) { // assign macro close
                            o[ol-1] == "\n" && (o[ol - 1] = ""), o[ol++] = ")",
                            o[ol++] = "\n", v = 1, sl -= 2;
                        }
                        if (v && parse_mode && !statement_lut[tok] && !call_exclusion[tok]) // inject output
                            o[ol++] = (nesting ? cf_str_output : cf_mode_output);

                        if (last_dot > 0 && tok.charAt(0) != ".") // store property
                            o_props[o[ol++] = last_prop = tok] = 1;
                        else // lookup and/or/etc
                            o[ol++] = xml_code_operators[tok] || tok;
                        break;
                    case 5: // -------- stringquotes --------
                        if ((v = (u = ((out_context_word[last_tok] || o[ol - 1]== "\n" )
                          && !new_block[last_tok])) && !s[sl - 1].indexOf("{")
                          && ol > scope) && !parse_mode) // check if we need to switch to block mode
                            switchToBlock();

                        if (u && !s[sl - 1]) { // close = macro
                            o[ol - 1] == "\n" && (o[ol - 1] = ""), o[ol++] = ")",
                            o[ol++] = "\n", v = 1, sl -= 2;
                        }
                        if (v) { // generate output
                            o[ol++] = (o[ol-2] != "\n" && block_autoappend[last_tok])
                                ? "+"
                                : (nesting ? cf_str_output : cf_mode_output);
                        }
                        else if (block_autoappend[last_tok])
                            o[ol++] = "+";

                        s[sl++] = scope | (parse_mode << 28), s[sl++] = o[ol++] = tok;
                        scope   = segment = ol - 1, nesting++, parse_mode = 5, start_tok = tok;
                        break;
                    case 6: // -------- comment --------
                        if (tok == "*/" || tok== "-->")
                            throw {
                                t: "Unmatched comment "+tok,
                                p: pos
                            };
                        last_cmt_mode = parse_mode, last_cmt_tok = last_tok,
                        last_cmt_type = last_type, parse_mode = 6, start_tok = tok;
                        break;
                    case 7: // -------- { --------
                        if (o[ol - 1] == ")  " || (o[ol - 2] == ")  " && ol--)) { // ')  ' is function def
                            if (s[sl - 1] != "(" && s[sl - 1] != "[") {
                                s[sl++] = scope | (parse_mode << 28),
                                s[sl++] = "{{", o[ol++] = cf_func_o,
                                scope = ol, parse_mode = 1, nesting++, o[ol++] = ""; // make the scope check pass
                            }
                            else {
                                s[sl++] = scope, s[sl++] = o[ol++] = tok, scope = ol;
                                parse_mode = 1;
                            }// for do else..etc below
                        }
                        else if ((macro_o[s[sl + 1]] && last_tok == ")   ") || pre_plain[last_tok]) {
                            s[sl++] = scope, s[sl++] = o[ol++] = tok, scope = ol;
                            o[ol++] = "";
                        }
                        else {
                            if ((v = (u = ((out_context_word[last_tok]||o[ol - 1] == "\n")
                              && !new_block[last_tok]))
                              && !s[sl - 1].indexOf("{") && ol > scope) && !parse_mode)
                                switchToBlock(); // block mode detection

                            if (u && !s[sl - 1]) { // close = macro
                                o[ol - 1] == "\n" && (o[ol - 1] = ""),
                                o[ol++] = ")", o[ol++] = "\n", v = 1, sl -= 2;
                            }
                            if (v) { // inject output, +''+ is when between two { } { } (supposedly)
                                o[ol++] = (o[ol - 2] != "\n" && block_autoappend[last_tok])
                                    ? "+''+"
                                    : (nesting ? cf_str_output : cf_mode_output);
                            }
                            else if (block_autoappend[last_tok]) // inject append
                                o[ol++] = (last_tok == "}") ? "+''+" : "+";

                            s[sl++] = scope | (parse_mode << 28), s[sl++] = o[ol++] = "{{";

                            if (!nesting && scope != ol) // count output segments on nesting 0
                                o_segs++;

                            nesting++, segment = scope = ol, parse_mode = 0;
                        }
                        break;
                    case 8: // -------- } --------
                        if (!s[sl - 1]) // close = macro
                            o[ol++] = ")", o[ol++] = "\n",sl -= 2;

                        if (type_close[v = s[--sl]] != (o[ol++] = tok))
                            throw {
                                t: "Cannot close " + v + " with " + tok,
                                p: pos
                            };

                        if (v == "{{") { // closing code block
                            if (scope == ol - 1) {
                                if( (s[sl - 1] >> 28) <= 1) // empty code in code
                                    o[scope-1] = "{", o[ol - 1] = "}";
                                else // empty code elsewhere
                                    o[scope - 1] = o[ol - 1] = "'";
                            }
                            else {
                                if (!parse_mode) { // expression wraps in ()
                                    o[scope - 1] = "(",
                                    o[ol - 1]    = ")";
                                }
                                else { // codeblock wraps in (function(){})()
                                    if (o[scope - 1] == cf_func_o) {
                                        if (scope == ol - 2)
                                            o[scope - 1] = "{", o[ol - 1] = "}";
                                        else
                                            o[ol - 1] = cf_func_c;
                                    }
                                    else
                                        o[ol - 1] = cf_block_c;
                                }
                            }
                            parse_mode = (v=s[--sl])>>28, scope = v&0x0fffffff;
                            segment = ol, nesting--;

                            if(!nesting) // count segs on nesting level 0
                                o_segs++;

                            if (parse_mode == 7) // attribute hack
                                o[ol++] = "+\"\\\"", parse_mode = 4;
                        } else scope = s[--sl]; // was object def or if(){}

                        break;
                    case 9: // -------- [ --------
                        if (((last_type == 3 && !pre_xpath[last_tok] && last_tok!='$') || last_tok == ")" || last_tok == "]") && o[ol - 1] != "\n") {
                            o[ol++] = "[", s[sl++] = scope | (parse_mode << 28), //was array index
                            s[sl++] = tok, segment = scope = ol;
                        }
                        else {
                            last_model = null;

                            if ((w = xpath_lut_code[last_tok])) {
                                ol--, last_tok = o[ol-1]; // xpath with *%$#
                                if (o[ol - 1] == "delete" || (o[ol - 2] == "delete" && ol--))
                                    w = xpath_del[w], ol--; // delete *[xpath]
                            }
                            else {
                                w = xpath_macro[s[sl - 1]] || xpath_macro[nesting ? 0 : c_xpathmode];
                                if (last_tok == "delete") // delete [xpath]
                                    w = xpath_del[w], ol -= 2;
                            }
                            if ((v = (u = ((out_context_word[last_tok] || o[ol - 1] == "\n")
                              && !new_block[last_tok])) && !s[sl - 1].indexOf("{")
                              && (ol > scope || s[sl - 1].length == 1)) && !parse_mode)
                                switchToBlock(); // check if we need to switch to block mode

                            if (u && !s[sl - 1]) { // close = macro
                                o[ol - 1] == "\n" && (o[ol - 1] = ""), o[ol++] = ")",
                                o[ol++] = "\n", v = 1, sl -= 2;
                            }

                            if (v) { // inject output
                                o[ol++] = (o[ol - 2] != "\n" && block_autoappend[last_tok])
                                    ? "+"
                                    : (nesting ? cf_str_output : cf_mode_output);
                            }
                            else if (block_autoappend[last_tok]) // inject append
                                o[ol++] = "+";

                            if(!nesting && ol!=scope)
                                o_segs++;
                            // store scope in bt for reparse of array
                            nesting++, s[sl++] = scope|(parse_mode<<28), s[sl++] = o[ol++] = w,
                            segment = scope = ol, bt[scope] = pos, parse_mode = 3;
                        }
                        break;
                    case 10: // -------- ] --------
                        if(!s[sl-1]) // close = macro
                            o[ol++]=")",sl -=2;

                        if ( type_close[v = s[--sl]] != (o[ol++] = tok))
                            throw {
                                t: "Cannot close " + v + " with " + tok,
                                p: pos
                            };

                        scope = s[--sl]&0xfffffff; // clean scope of possible parse_mode 1
                        break;
                    case 11: // -------- ( --------
                        if ( ((v = (u=((out_context_paren[last_tok]||o[ol-1]=="\n") &&
                            !new_block[last_tok])) && !s[sl-1].indexOf("{") &&
                            ol>scope)) && !parse_mode)
                            switchToBlock();

                        if (u && !s[sl-1]) // close = macro
                            o[ol-1]=="\n"&&(o[ol-1]=""),o[ol++]=")", o[ol++]="\n",v = 1,sl -=2;
						
                        if (v && parse_mode) // inject output
                            o[ol++] = (nesting?cf_str_output:cf_mode_output), last_type = 0;

                        if (w = macro_o[last_tok]) {
                            if (o[ol-1]==" ") ol--; // support func ()
                            o[ol-1] = w, s[sl++] = scope, s[sl++] = last_tok, scope = segment = ol;
                        }
                        else {
                            if (last_type == 3) { // word(
                                if (last_dot < 0) { // no dot
                                    v = 0;
                                    if (last_tok == "function" || o[ol - 3] == "function" || o[ol - 4] == "function") {
                                        s[sl++] = scope, s[sl++] = "function", //func def
                                        o[ol++] = "(", scope = segment = ol;
										//TODO! check the depth with which functions are made global
										if(last_tok!="function" && c_funcglobal && sl==4){
											o[v=(o[ol - 4] == "function")?(ol-4):(ol-5)] =
												"var "+last_tok+" = self."+last_tok+" = function";
											o[v+2] = "";
										}
                                    }
                                    else { // its a call and not a new
                                        if (!call_exclusion[last_tok] && o[ol-3]!="new") {
                                            o[ol++] = ".call(_n", s[sl++] = scope,
                                            s[sl++] = "_call", scope = segment = ol;
                                        }
                                        else { // its an excluded call
                                            s[sl++] = scope, s[sl++] = o[ol++] = tok,
                                            scope = segment = ol;
                                        }
                                    }
                                }
                                else {
                                    if (last_dot > 1 && (c_async_lut[v = last_tok.substring(0,last_dot)] || c_async_lut[v = last_tok])) {// its an async call
                                    if (o[--ol] == " ")
                                        ol--;
                                    o[ol++] = cf_async_o, o[ol++] = v, o[ol++] = ",'";
                                    o[ol++] = last_tok.slice(last_dot + 1);
                                    o[ol++] = cf_async_m, s[sl++] = scope, s[sl++] = "async",
                                    scope = segment = ol, o_asyncs++;
                                    }
                                    else { // its a obj.prop() type call
                                        if(last_tok.indexOf('.')!=last_dot) // obj.prop.call();
                                            o_props[last_tok.slice(0,last_dot)] = 1;
                                            
                                        s[sl++] = scope, s[sl++] = o[ol++] = tok,
                                        scope = segment = ol;
                                    }
                                }
                            }
                            else { // function object call
                                s[sl++] = scope, s[sl++] = o[ol++] = tok,
                                scope = segment = ol;
                            } // dont store calls as props
                            if (last_tok == last_prop)
                                delete o_props[last_tok];
                        }
                        break;
                    case 12: // -------- ) --------
                        if (!s[sl - 1]) { // close = macro
                            o[ol-1] == "\n" && (o[ol-1] = ""), o[ol++] = ")",
                            o[ol++]="\n", v = 1, sl -= 2;
                        }

                        if (w = macro_c[v = s[--sl]]) { // closing a macro
                            if (v != "_call")
                                tok = ")   "; // make sure any [ ] doesnt get interpreted as array index
                            if ((u = call_args_lut[v]) && u != o[ol - 1])
                                o[scope - 1] = u + ",";// do , insertion for argless macros
                            o[ol++] = w; // write close-end of macro
                        }
                        else if (type_close[v] != (o[ol++] = tok)) {
                            throw {
                                t:"Cannot close " + v + " with " + tok,
                                p: pos
                            };
                        }
                        scope = s[--sl] & 0xfffffff; // scope should be unimpacted
                        break;
                    case 13: // -------- < --------
                        // check if < is markup or not
                        if (ol == scope || markup_in_code_lut[last_tok] || o[ol - 1] == "\n"){
                            if ((v = (u = ((out_context_word[last_tok] || o[ol - 1] == "\n")
                              && !new_block[last_tok])) && !s[sl - 1].indexOf("{")
                              && ol > scope) && !parse_mode)
                                switchToBlock(); // switch to block mode

                            if (u && !s[sl - 1]) { // close = macro
                                o[ol - 1] == "\n" && (o[ol - 1] = ""), o[ol++] = ")",
                                o[ol++] = "\n", v = 1, sl -= 2;
                            }
                            if (v) {
                                o[ol++] = (o[ol - 2] != "\n" && block_autoappend[last_tok])
                                    ? "+''+"
                                    : (nesting ? cf_str_output : cf_mode_output);
                            }
                            else if (block_autoappend[last_tok])
                                o[ol++] = "+";
                            // start markup mode with the markup-stack counting
                            last_ns = null, o[ol++] = '"', o[ol++] = "<", nesting++,
                            s[sl++] = scope | (parse_mode << 28), sl += 3,
                            s[sl - 2] = s[sl - 1] = 0;

                            segment = scope = ol - 1, parse_mode = 4;
                        }
                        else
                            o[ol++] = "<";
                        break;
                    case 14: // -------- < --------
                        o[ol++] = ">";
                        break;
                    case 15: // end
                        if (sl && !s[sl - 1]) { // close = macro
                            o[ol - 1] == "\n" && (o[ol - 1] = ""), o[ol++] = ")",
                            o[ol++] = "\n", v = 1, sl -= 2;
                        }
                        break;
                }
                break;
            case 2: // ==========================  text parse_mode ==========================
                switch (type) {
                    case 1: // -------- newline --------
                        line_no++, last_line = pos;
                        if (ol != scope && ol != segment) // only output when not first
                            o[ol++] = "\\n";
                        break;
                    case 2: // -------- misc --------
                        if (ol == segment) // segment connectors
                            o[ol] = (ol++ == scope) ? "\"" : "+\"";

                        o[ol++] = unesc_txt[tok] || tok;
                        break;
					case 3: // word
                        if (ol == segment)
                            o[ol] = (ol++ == scope) ? "\"" : "+\"";
						if(tok.charAt(tok.length-1)=='$'){
							o[ol++] = tok.slice(0,-1);
							o[ol++] = tok = '$';// fix word$[xpath] 
						}else o[ol++] = tok;
						break;
                    case 5: // -------- stringquotes --------
                        if (ol == segment)
                            o[ol] = (ol++ == scope) ? "\"" : "+\"";

                        o[ol++] = (tok == '"') ? "\\\"" : "'";
                        break;
                    case 7: // -------- { -------- code mode
                        if (ol == segment){
                            if (ol != scope )
                                o[ol++] =  "+";
                        }
                        else
                            o[ol++] = "\"+", nesting || o_segs++;
                        s[sl++] = scope | 0x20000000, s[sl++] = o[ol++] = "{{",
                        nesting++, segment = scope = ol, parse_mode = 0;
                        break;
                    case 9:  // -------- [ --------  xpath mode
                        last_model = null; // get xpath macro
                        if ((w = xpath_lut_text[last_tok]) && o[ol - 1] == last_tok) {
                            if (--ol - 1 == scope)
                                ol --; // remove first ""
                        }
                        else // only select c_xpathmode when nesting == 0
                            w = xpath_macro[(nesting || scope != ol) ? 0 : c_xpathmode];

                        if (ol != scope) {
                            o[ol] = (ol++ == segment) ? "+" : (nesting || o_segs++, "\"+");

                            if (!nesting)
                                o_segs++;
                        }

                        s[sl++] = scope | 0x20000000, s[sl++] = o[ol++] = w,
                        segment = scope = ol, nesting++, parse_mode = 3;
                        break;
                    case 15: // -------- end --------
                        if (sl)
                            throw {
                                t: "Unclosed " + s[sl-1] + " found at end in textmode",
                                p: pos
                            };
                        if (ol != scope && ol != segment)
                            o[ol++] = "\"", nesting || o_segs++;
                        break;
                    default: // -------- default --------
                        if (ol == segment)
                            o[ol] = (ol++ == scope) ? "\"" : "+\"";
                        o[ol++] = tok;
                }
                break;
            case 3: // ==========================  xpath parse_mode =========================
                switch(type){
                    case 0: // -------- whitespace --------
                        if (ol != scope){ // strip initial spaces\l
                            if (ol == segment)
                                o[ol++] = "+\"";
                            o[ol++] = tok;
                        }
                        break;
                    case 1: // -------- newline --------
                        line_no++, last_line = pos;
                        break;
                    case 2: // -------- misc --------
                        if (tok == ":" && last_tok == ":" && !xpath_axes[w = o[ol - 2]] 
                          && ((v = s[sl - 2]) >> 28) != 6) { // found model::xpath split
                            if (o[ol - 2] == '+"') // model is calculated
                                o[ol - 2] = o[ol - 1] = "", last_model = "#";
                            else {
                                o[ol - 1] = '"';
                                if (segment == scope) // model is normal name
                                    last_model = o.slice(segment + 1, ol - 1).join("");
                                else // model is calculated
                                    last_model = "#";
                            }
                            if (!(w = xpath_model[o[scope - 1]]))
                                throw {
                                    t: "Invalid model found for: "+o[scope-1],
                                    p: pos
                                };

                            o[scope - 1] = w, o[ol++] = ",", segment = scope = ol;
                        }
                        else {
                            if (tok == "," && (v = (s[sl - 2] >> 28)) <= 1) { // xpath is an array in code
                                ol = scope-1, u = str.slice(bt[scope] + 1, pos + 1);
                                // fix up stack to not be an xpath but an array
                                last_type = 9, parse_mode = v, o[ol++] = last_tok = "[";
                                s[sl - 2] = (s[sl - 2] & 0xfffffff) | (parse_mode << 28),
                                s[sl - 1] = last_tok, segment = scope = ol, nesting--;

                                if (!nesting)
                                    o_xpaths--;
                                if (u.length > 1) { // ignore [, optimized escaping
                                    bts.push(str); // push str so str always is the string in replace
                                    (str = u).replace(parserx, parser); // reparse it
                                    str = bts.pop(); // pop it again
                                }
                            }
                            else {
                                if (ol == segment)
                                    o[ol] = (ol++ == scope) ? "\"" : "+\"";
                                o[ol++] = unesc_lut[tok] || tok;
                            }
                        }
                        break;
					case 3: // word
						if (ol == segment)
                            o[ol] = (ol++ == scope) ? "\"" : "+\"";					
                        if(tok.charAt(tok.length-1)=='$'){
							o[ol++] = tok.slice(0,-1);
							o[ol++] = tok = '$';// fix word$[xpath] 
						}else o[ol++] = tok;
						break
                    case 5: // -------- stringquotes --------
                        if (ol == segment)
                            o[ol] = (ol++ == scope) ? "\"" : "+\"";
                        if (s[sl - 1] == "[") // strings only are used in [ ]
                            s[sl - 1] = tok;
                        else if(s[sl - 1] == tok) // close string
                            s[sl - 1] = "[";

                        if (tok == '"')
                            o[ol++] = "\\";
                        o[ol++] = tok;
                        break;
                    case 7: // -------- { --------
                        if (ol == segment) {
                            if (ol != scope)
                                o[ol++] = "+''+";
                        }
                        else
                            o[ol++] = "\"+";

                        s[sl++] = scope | 0x30000000, s[sl++] = o[ol++] = "{{",
                        nesting++, segment = scope = ol, parse_mode = 0;

                        if (last_model && s[sl - 3] != xpath_lut_text["$"]) {
                            o_xpathpairs.push(last_model, "#");
                            last_model = null, o_models++;
                        }
                        break;
                    case 9: // -------- [ --------
                        // lets see if we are an xpath
                        if (s[sl - 1] == "'" || s[sl - 1] == '"' || 
							((last_type != 3 || last_tok=='$') && last_tok != ")" && last_tok != "]") ) {
                            if (last_model)
                                o_xpathpairs.push(last_model, "#"), o_models++;
                            last_model = null;

                            if ((w = xpath_lut_text[last_tok]) && o[ol - 1] == last_tok)
                                ol--;
                            else
                                w = xpath_macro[0];

                            if (ol == segment){
                                if (ol != scope)
                                    o[ol++] = "+";
                            }
                            else o[ol++] = "\"+";

                            s[sl++] = scope | 0x30000000, s[sl++] = o[ol++] = w, nesting++,
                            segment = scope = ol, parse_mode = 3;
                        }
                        else {
                            if (ol == segment)
                                o[ol] = (ol++ == scope) ? "\"" : "+\"";

                            s[sl++] = scope|0x60000000, s[sl++] = o[ol++] = "["; // keep track of [, abuse mode 6
                        }
                        break;
                    case 10: // -------- ] --------
                        sl--, parse_mode = (w = s[--sl]) >> 28, w = w & 0x0fffffff;

                        if (parse_mode == 6){ // was part of [] internally to xpath, see above
                            if (s[sl + 1] != "[")
                                throw {
                                    t:"In xpath, cannot close " + s[sl + 1] + " with " + tok,
                                    p: pos
                                };
                            if (ol == segment)
                                o[ol] = (ol++ == scope) ? "\"" : "+\"";

                            o[ol++] = "]";
                            parse_mode = 3;
                        }
                        else {
                            if (ol == scope ) {
                                if ((s[sl] >> 28) <= 1) // empty array in code
                                    o[scope - 1] = "[", o[ol++] = "]";
                                else // empty xpath elsewhere
                                    o[scope - 1] = o[ol++] = "\"" ;
                                segment = ol;
                            }
                            else {
                                //if( s[sl+1] != '[' )
                                //    throw {t:"Unclosed string in xpath"+s[sl+1], p: pos};
                                if (ol != segment)
                                    o[ol++] = "\"";
                                if (segment == scope){ // we might have an xpath name
                                    v = o.slice(segment + 1, ol - 1).join("");
                                    if (c_injectself && o[scope - 1] != "," // inject self
                                      && v != (u = v.replace(selfrx, "$1self::"))
                                      && s[sl + 1] != xpath_lut_text["$"]) {
                                        o[scope+1] = v = u;
                                        for (u = scope + 2; u < ol - 1; u++)
                                            o[u] = "";
                                    }
                                }
                                else {
                                    if ((u = o[scope - 1]) != ",") {
                                        v = "#";
                                        if (c_injectself)// inject dyn self if dyn xpath
                                            o[scope - 1] = u + "_injself(", o[ol++] = ")";
                                    } 
                                    else
                                        v = "";
                                }
                                if (s[sl + 1] != xpath_lut_text["$"] && v) {
                                    o_xpathpairs.push(last_model, v);  // only store if not _lng
                                    if (last_model)
                                        o_models++;
                                }
                                o[ol++] = ") ", segment = ol; // close xpath with ') ' marker
                                //logw("CLOSING XPATH"+o.join('#')+nesting);
                                if (parse_mode == 7) // attribute assign in xml mode
                                    o[ol++] = "+\"\\\"", parse_mode = 4;
                            }
                            // lets output an xpath if we werent a language symbol
                            nesting--, last_model = null;
                            if (!nesting)
                                o_segs++, o_xpaths++;
                        }
                        scope = w;
                        break;
                    case 11: // -------- ( --------
                        if (ol == segment)
                            o[ol] = (ol++ == scope) ? "\"" : "+\"";
                        s[sl++] = scope | 0x30000000, // keep track of () in xpath
                        s[sl++] = o[ol++] =  "(";//, last_model = null;
                        break;
                    case 12: // -------- ) --------
                        if (ol == segment)
                            o[ol] = (ol++ == scope) ? "\"" : "+\"";

                        if (type_close[v = s[--sl]] != (o[ol++] = tok))
                            throw {
                                t:"Cannot close " + v + " with " + tok,
                                p: pos
                            };

                        scope = s[--sl] & 0xfffffff;
                        break;
                    case 15: // -------- end --------
                        throw {
                            t: "Unexpected end whilst parsing xpath",
                            p: pos
                        };
                        break;
                    default: // -------- default --------
                        if (ol == segment)
                            o[ol] = (ol++ == scope) ? "\"" : "+\"";
                        o[ol++] = tok;
                        break;
                }
                break;
            case 4: // ===========================  xml parse_mode ==========================
                switch (type) {// stack: '<'sl+4,outside=0, '</'sl-4  '>'sl-2,outside=1 '/>'sl-4,outside=1
                    case 0: // -------- whitespace --------
                        if (ol == segment)
                            o[ol++] = "+\"";

                        o[ol++] = " ", last_type = 0;
                        break;
                    case 1: // -------- newline --------
                        if (ol == segment)
                            o[ol++] = "+\"";

                        line_no++, last_line = pos, o[ol++] = "\\n", last_type = 1;
                        break;
                    case 2: // -------- misc --------
                        if (ol == segment)
                            o[ol++] = "+\"";
                        if (tok == "/" && last_tok == "<") {
                            sl -= 4; // </ closing tag, drop stacklevel by 4
                            if (s[sl] || s[sl + 2])
                                throw {
                                    t: "Unexpected closing tag whilst parsing xml",
                                    p: pos
                                };
                        }
                        else if (tok == ":" && last_type == 3 && o[ol - 2] == "<")
                            last_ns = last_tok; // found a namespace item in a tag
                        o[ol++] = unesc_txt[tok] || tok;
                        break;
					case 3: // word
                        if (ol == segment)
                            o[ol++] = "+\"";		
                        if(tok.charAt(tok.length-1)=='$'){
							o[ol++] = tok.slice(0,-1);
							o[ol++] = tok = '$';// fix word$[xpath] 
						}else o[ol++] = tok;
						break						
                    case 5: // -------- stringquotes --------
                        if (ol == segment)
                            o[ol++] = "+\"";

                        if (tok == '"')
                            o[ol++] = "\\";
                        o[ol++] = tok;
                        break;
                    case 6: // -------- comment --------
                        if (tok == "//" && !s[sl - 1]) {
                            if (ol == segment)
                                o[ol++] = "+\"";  // < char ups stack by 4, outside= 0
                            o[ol++] = tok;
                        }
                        else {
                            if (tok == "*/")
                                throw {
                                    t: "Unmatched comment "+tok,
                                    p: pos
                                };
                            last_cmt_mode = parse_mode, last_cmt_tok = last_tok,
                            last_cmt_type = last_type, parse_mode = 6, start_tok = tok;
                        }
                        break;
                    case 13: // -------- < --------
                        last_ns = null;
                        if (ol == segment)
                            o[ol++] = "+\"";  // < char ups stack by 4, outside= 0
                        o[ol++] = tok, s[sl] = s[sl + 2] = 0, sl += 4, s[sl - 1]=0;
                        break;
                    case 14: // -------- > --------
                        if (ol == segment)
                            o[ol++] = "+\"";

                        o[ol++] = tok;
                        if (last_tok != "<") {
                            if (last_tok == "/") {
                                sl -= 4; // self close tag /> drops stack -4
                                if (s[sl + 2])
                                    throw {
                                        t: "Unexpected / whilst parsing xml",
                                        p: pos
                                    }
                                if (o[ol - 3] == "<") // remove empty </> from output
                                    ol -= 2, o[ol - 1] = "";
                            }
                            else
                                sl -= 2; // <tag> nets stackdepth of 2
                            if (s[sl]) { // end of xml mode
                                nesting--, o[ol++] = "\"", scope = s[sl], segment = ol,
                                parse_mode = scope >> 28, scope = scope & 0x0fffffff;
                            }
                            else
                                s[sl - 1] = 1; // we are outside a tag, flag it on the stack
                        }
                        else // remove empty <> from output
                            ol--, o[ol - 1] = "";
                        break;
                    case 9:  // -------- [ --------  xpath mode
                        last_model = null;

                        if (last_tok == "!" && o[ol - 2] == "<" && !s[sl - 1]) { // CDATA mode
                            o[ol++] = tok, s[sl++] = scope | (parse_mode << 28);
                            s[sl++] = "]]>", scope = segment = ol - 1;
                            nesting++, parse_mode = 5;
                        }
                        else {
                            if (s[sl - 1]) { // we are outside a tag
                                if((v = xpath_lut_node[last_tok]))
                                    ol --;
                                else
                                    v = xpath_macro[last_ns ? c_elemxpath : 0];
                                s[sl++] = scope | 0x40000000
                            }
                            else {
                                s[sl++] = scope | 0x40000000
                                if ((v = xpath_lut_attr[last_tok])) {
                                    ol--;
                                    if (o[ol - 1] == "=")
                                        last_tok = "=";
                                }
                                else
                                    v = xpath_macro[last_ns ? c_statexpath : 8];
								
                                if (last_tok == "=")//0x7 flags xpath-in-missing-quotes <a i=[xp]/>
                                    o[ol++] = "\\\"", s[sl - 1] = scope | 0x70000000;
                            }
                            o[ol] = (ol++ == segment) ? "+''+" : "\"+";
                            nesting++, s[sl++] = o[ol++] = v,
                            segment = scope = ol, parse_mode = 3;
                        }
                        break;
                    case 7: // -------- { -------- code mode
                        if ( !s[sl - 1] && last_tok == "=") // 0x7 flags code-in-missing-quotes <a i={x}/>
                            o[ol++] = "\\\"", s[sl++] = scope | 0x70000000;
                        else
                            s[sl++] = scope | 0x40000000

                        o[ol] = (ol++ == segment) ? "+''+" : "\"+";
                        s[sl++] = o[ol++] = "{{", nesting++;
                        segment = scope = ol, parse_mode = 0;
                        break;
                    default:
                        if (ol == segment)
                            o[ol++] = "+\"";
                        o[ol++] = tok;
                        break;
                    case 15: // -------- end --------
                        throw {
                            t: "Unexpected end whilst parsing xml",
                            p: pos
                        };
                        break;
                }break
            case 5: // ==========================  string parse_mode ========================
                switch (type) {
                    case 1: // -------- newline --------
                        line_no++, last_line = pos;
                        if (ol == segment)
                            o[ol] = (ol++ == scope) ? "\"" : "+\"";
                        o[ol++] = "\\n";
                        break;
                    case 2: // -------- misc --------
                        if (tok == "/" && s[sl - 1] == "/") { // regexp closing character
                            o[ol++]    = "/", scope = s[sl -= 2], segment = ol,
                            parse_mode = scope >> 28,
                            scope      = scope & 0x0fffffff, nesting--;
                        }
                        else {
                            if (ol == segment)
                                o[ol] = (ol++ == scope) ? "\"" : "+\"";
                            o[ol++] = (s[sl - 1] != "/" && unesc_str[tok]) || tok;
                        }
                        break;
					case 3: // word
						if (ol == segment)
                            o[ol] = (ol++ == scope) ? "" : "+\"";		
                        if(tok.charAt(tok.length-1)=='$'){
							o[ol++] = tok.slice(0,-1);
							o[ol++] = tok = '$';// fix word$[xpath] 
						}else o[ol++] = tok;
						break							
                    case 5: // -------- stringquotes --------
                        if (s[sl - 1] == tok) { // closed by matching quote
                            if (scope != segment) // string is segmented, output )
                                o[ol] = (ol++ != segment) ? (tok + ")") : ")";
                            else
                                o[ol++] = tok; // else just close
                            scope = s[sl -= 2], segment = ol, parse_mode = scope >> 28;
                            scope = scope & 0x0fffffff, nesting--;
                        }
                        else {
                            if (ol == segment)
                                o[ol] = (ol++ == scope) ? "\"" : "+\"";
                            o[ol++] = tok == '"' ? "\\\"" : tok;
                        }
                        break;
                    case 6: // -------- default --------
                        if (s[sl - 1] == "/" && tok == "*/") { // caught faux comment in regexp /a*/, is close
                            o[ol++] = "*/", scope = s[sl -= 2], segment = ol,
                            parse_mode = scope >> 28, scope = scope & 0x0fffffff, nesting--;
                        }
                        else {
                            if (ol == segment)
                                o[ol] = (ol++ == scope) ? "" : "+\"";
                            o[ol++] = tok;
                        }
                        break;
                    case 7: // -------- { -------- code mode
                        if (s[sl - 1] != "'" && s[sl - 1] != "/") {
                            if (s[sl - 1] == '"')
                                o[scope] = '("';
                            if (ol == segment) {
                                if (ol != scope)
                                    o[ol++] = "+";
                            }
                            else
                                o[ol++] = "\"+";
                            s[sl++] = scope | 0x50000000, o[ol++] =  s[sl++] = "{{",
                            nesting++, segment = scope = ol, parse_mode = 0;
                        }
                        else
                            o[ol++] = tok;
                        break;
                    case 9:  // -------- [ --------  xpath mode
                        if (s[sl - 1] != "'" && s[sl - 1] != "/" // ignore in '' and CDATA[, else xpath
                          && (s[sl - 1] == '"' && (o[scope] = '("') || ol != scope + 2
                          || last_tok != "CDATA") ) {
                            last_model = null;
                            if ((w = xpath_lut_text[last_tok])  && o[ol - 1] == last_tok)
                                ol--;
                            else
                                w = xpath_macro[0]

                            if (ol != scope)
                                o[ol] = (ol++ == segment) ? "+" : "\"+";

                            s[sl++] = scope | 0x50000000, s[sl++] = o[ol++] = w,
                            segment = scope = ol, nesting++, parse_mode = 3;
                        }
                        else
                            o[ol++] = tok;
                        break;
                    case 14: // -------- > --------
                        if (ol == segment)
                            o[ol] = (ol++ == scope) ? "" : "+\"";
                        o[ol++] = tok;

                        if (s[sl - 1] == "]]>" && last_tok == "]" && o[ol - 3]=="]") { // check if CDATA close
                            scope = s[sl -= 2], parse_mode = scope >> 28;
                            scope = scope & 0x0fffffff, nesting--;
                            sl -= 4; // close the tag since we came from XML mode
                            if (s[sl]) // was last tag, jump up the stack one more.
                                nesting--, o[ol++] = "\"", scope = s[sl], segment = ol,
                                parse_mode = scope >> 28, scope = scope & 0x0fffffff;
                            else
                                s[sl - 1] = 1;
                        }
                        break;
                    case 15: // -------- end --------
                        throw {
                            t: "Unexpected end whilst parsing string",
                            p: pos
                        };
                        break;
                    default: // -------- default --------
                        if (ol == segment)
                            o[ol] = (ol++ == scope) ? "" : "+\"";
                        o[ol++] = tok;
                        break;
                }
                break;
            case 6: // =========================  comment parse_mode ========================
                switch (type) {
                    case 1: // -------- newline --------
                        line_no++, last_line = pos;
                        if (start_tok == "//")
                            parse_mode = last_cmt_mode,
                            tok = last_tok = last_cmt_tok,
                            type = last_type = last_cmt_type;
                        break;
                    case 6: // -------- comment --------
                        if ((start_tok == "/*" && tok == "*/") 
                          || (start_tok == "<!--" && tok == "-->")) {
                            parse_mode = last_cmt_mode,
                            tok = last_tok = last_cmt_tok,
                            type = last_type = last_cmt_type;
                        }
                        break;
                    case 15: // -------- end --------
                        if(start_tok != "//"){
                            throw {
                                t: "Unexpected end whilst parsing comment",
                                p: pos
                            }
                        } else {
                            parse_mode = last_cmt_mode,
                            tok = last_tok = last_cmt_tok,
                            type = last_type = last_cmt_type;                        
                            if (sl && !s[sl - 1]) { // close = macro
                                o[ol - 1] == "\n" && (o[ol - 1] = ""), o[ol++] = ")",
                                o[ol++] = "\n", v = 1, sl -= 2;
                            }  
                        };
                        break;
                }
                break;
        }
        if (type > 1)
            last_tok = tok, last_type = type;
    }

    this.lastCode = function(){
        if (typeof(o) == "object")
            return o.join("");
        return o;
    };

    function handleError(e, last_line, part){
        // TODO: make a proper APF exception with this information:
        if (e.t) {
            throw new Error(apf.formatErrorString(0, null,
                "Parsing live markup source",
                "Error whilst parsing: " + e.t + " on line:"+ line_no
                + " col:" + (e.p - last_line - 2)
                + (part ? (" part: " + part) : "") + "\n" + str));
        }
        else {
            throw new Error(apf.formatErrorString(0, null,
                "Compiling live markup function",
                "Error whilst compiling: " + e.message + "\nInput:\n" + str
                + "\nGenerated:\n" + apf.lm.lastCode()));
        }
    }

    /**
     * description of the method.
     * Remarks:
     *   function{type:1,xpaths:[ model,name], props: ['obj.propname','obj2.otherpropname'], asyncs=1}
     *   this is a normal compiled function with extra properties
     *   if the xpath model and/or name is '#' it means it is a runtime calculated modelname or xpath.
     *   obj{type:2, str:str} it was single string by cfg option !alwayscode
     *   obj{type:3, xpaths:[ model, name ] } it was a single xpath  by cfg simplexpath
     *
     * @param  {String}  str      the code to compile
     * @param  {Object}  options
     *   Properties:
     *   {Boolean} withopt     creates with(_w){  code using an options block. (reqd for precall)
     *   {Boolean} precall     wraps 1 async call into precallstore. call with _w._pc = 1 to precall, second time to execute.
     *   {Boolean} alwayscb    always call callback function, even if not async
     *   {Boolean} nostring    even generate code for a simple string
     *   {Number} xpathmode    default type of root level xpath in code mode
     *      Possible values:
     *      0: value
     *      1: value with createnode
     *      2: node
     *      3: node with createnode
     *      4: nodes
     *      5: xpathobj        returns a {model:model,xpath:xpath} object from xpaths
     *   {Boolean} parsecode   start in codemode. if 0 its textmode.
      *  {Boolean} nostate       dont' use _valst macro on [xpath] in namespaced xml.
     *   {Boolean} editable    use the _valed macro for <xml>[xpath]</xml> in namespaced xml.
     *   {Boolean} langedit    use of language items in namespaced xml text.
     *   {Boolean} injectself  injects self:: to suitable xpaths
     *   {Boolean} event       its an event thats being compiled, results in no returnvalue for this function.
     *                         and the first argument is now an 'e' for the event object.
     *   {Boolean} funcglobal  all functions defined in LM are made global

     *
     * @return  {Function} returns a function with extra properties
     *   Properties:
     *   {Number}  type         description
     *      Possible values:
     *      1  Function return type
     *      2  Parsed data is a pure string
     *      3  Function return type, but its a single xpath
     *   {Array}   xpaths       array of [model,xpath, model,xpath] pairs if model
     *                          or xpath is '#', its dynamic if model is null its a local xpath
     *   {Number}  models        number of models
     *   {Array}   props        description
     *   {Number}  asyncs       description
     *   {String]  str            optional, returned with type 2
     */
    var cache    = {},
        emptyCfg = {};
    this.resetCache = function(){
        cache = {};
    };
	var lmcache_rx = /^\s*~~(c\d+)~~/;
    this.compile = function(istr, cfg){
        if (!cfg)
            cfg = emptyCfg;
		if(istr == null || !istr.length){
			return cfg.nostring?function(){return istr}:{
                type: 2,
                str :istr
            };
		}
		// lets see if we need to fetch precompiled cachemarker
		var c, f;
		if(istr.charAt(0)=="~" && (c=istr.match(lmcache_rx))){
            if(c=apf.lm_exec[c[1]]) return c;
			alert("ERROR, undefined live markup cache marker found:"+istr);
			return {type:2,str:istr};
		}
			
        var key = (cfg.xpathmode | (cfg.withopt && 0x10) | (cfg.precall && 0x20)
                | (cfg.alwayscb && 0x40) | (cfg.nostring && 0x80)  | (cfg.parsecode && 0x100)
                | (cfg.nostate && 0x200) | (cfg.editable && 0x400) | (cfg.langedit && 0x800)
                | (cfg.injectself && 0x1000) | (cfg.event && 0x2000) | (cfg.funcglobal && 0x4000)) + istr;

        if (c = cache[key])
            return c;

        c_injectself = cfg.injectself,  c_xpathmode = cfg.xpathmode||0,
        c_statexpath = cfg.nostate ? 0 : 6, c_elemxpath = cfg.editable ? 7:0;
		c_funcglobal = cfg.funcglobal;
		
        xpath_lut_node = cfg.langedit ? xpath_lut_node_langedit : xpath_lut_node_normal;

        o_props = {}, o_xpathpairs = [], s = [], o = ["","","",""], str = istr,
        str_len = str.length;
        ol = scope = segment = o.length,
        o_segs = o_xpaths = o_asyncs = o_models = nesting = line_no = last_type = last_line = 0;

        if (cfg.parsecode) {
            parse_mode = 0, sl = 2, s[0] = ol, s[1]  = "{{", last_tok = "{",
            cf_mode_output = cfg.event ? "" : (c_xpathmode <= 1 ? cf_str_output : cf_obj_output);
        }
        else
            parse_mode = 2, sl = last_tok = 0, cf_mode_output = cf_str_output;

        if (cfg.nothrow) {
            str.replace(parserx, parser);
        }
        else {
            try {
                str.replace(parserx, parser);
            }
            catch(e) {
                handleError(e, last_line);
                return null;
            }
        }

        if (cfg.parsecode) {
            if (nesting || s[sl - 1].length == 1)
                handleError({
                    t: "Unclosed " + s[sl-1] + " found at end in codemode",
                    p: str_len
                },last_line);
            if (segment!=ol)
                o_segs++
        }
        if (!cfg.nostring && (parse_mode == 2 && segment == 4 || ol == 4)) {
            return {
                type: 2,
                str : o.slice(5, -1).join("").replace(/\\n/g, "\n").replace(/\\"/g, '"')
            }; // string only
        }
        if (o_asyncs || cfg.alwayscb) {

            if (cfg.event) { // event
                if (parse_mode == 1)
                    o[3] = "";
                o[ol++] = cc_o_blk_ce;
            }
            else if (c_xpathmode) { // object return
                if (parse_mode == 1) {
                    o[3]    = (o[3] != cf_block_o) ? cc_o_blk_o : cc_o_blk_ob,
                    o[ol++] = cc_o_blk_cb; 
                }
                else
                    o[3] = cc_o_cb_o, o[ol++] = cc_o_cb_c;
            }
            else { // value return
                if (parse_mode == 1)
                    o[3] = (o[3] != cf_block_o) ? cc_v_blk_o : cc_v_blk_ob,
                    o[ol++] = cc_v_blk_cb;
                else
                    o[3] = cc_v_cb_o, o[ol++] = cc_v_cb_c;
            }
			
            if (o_asyncs) { 
				// for parse_mode == 1 we can squeeze in before [3] and cb close
				// else we put var _r= in 3 and put our ending last and put
				// the cb at the end
				if(parse_mode==1){
					if (cfg.precall)
						o[2] = cc_pc_o, o[ol-1] = cc_pc_c + o[ol-1];
					else
						o[2] = cc_async_o, o[ol-1] = cc_async_c + o[ol-1];
				}else{
					o[ol++] = o[3] + '_r' + o[ol-2];
					if (cfg.precall)
						o[2] = cc_pc_o, o[3] = cc_o_blk_o, o[ol-2] = cc_pc_c;
					else
						o[2] = cc_async_o, o[3] = cc_o_blk_o, o[ol-2] = cc_async_c;
				}
				/*
				if (cfg.precall)
					o[2] = cc_pc_o, o[ol++] = cc_pc_c;
				else
					o[2] = cc_async_o, o[ol++] = cc_async_c;
				*/
            }

            if (cfg.withopt)
                o[1] = cc_opt_o, o[ol++] = cc_opt_c;
				
            o[0] = cfg.event 
                ? cc_fe_async_o
                : ((c_xpathmode == 1 || c_xpathmode == 3) ? cc_fc_async_o : cc_f_async_o);
            o[ol++] = cc_f_c;
        }
        else {
            if (cfg.event) { // event
                if (parse_mode == 1)
                    o[3] = "";
            }
            else if(c_xpathmode) { // object return
                if (parse_mode == 1) {
                    o[3]    = (o[3] != cf_block_o) ? cc_o_blk_o : cc_o_blk_ob,
                    o[ol++] = cc_o_blk_c;
                }
                else
                    o[3] = cc_o_ret_o, o[ol++] = cc_o_ret_c;
            }
            else { // value return
                if (parse_mode == 1) {
                    o[3]    = (o[3] != cf_block_o) ? cc_v_blk_o : cc_v_blk_ob,
                    o[ol++] = cc_v_blk_c;
                }
                else
                    o[3] = cc_v_ret_o, o[ol++] = cc_v_ret_c;
            }
            if (cfg.withopt)
                o[2] = cc_opt_o, o[ol++] = cc_opt_c;

            o[0] = cfg.event
                ? (cfg.withopt ? cc_fe_opt_o : cc_fe_o)
                : (cfg.withopt
                    ? ((c_xpathmode == 1 || c_xpathmode == 3) ? cc_fc_opt_o : cc_f_opt_o)
                    : ((c_xpathmode == 1 || c_xpathmode == 3) ? cc_fc_o : cc_f_o));
            o[ol++] = cc_f_c;
        }

        if (cfg.nothrow) {
            f = apf.lm_exec.compile(o.join(""));
        }
        else {
            try {
                f = apf.lm_exec.compile(o.join(""));
            }
            catch(e){
                handleError(e,last_line);
                return null;
            }
        }
        f.type   = (o_segs == 1 && o_xpaths == 1) ? 3 : 1;
        f.xpaths = o_xpathpairs, f.models = o_models,
        f.props  = o_props, f.asyncs = o_asyncs;

        cache[key] = f;
        return f;
    };

	/**
     * description of the method.
     * Remarks:
     * @param  {String}  str      the code to compile
     * @param  {Object}  options
     *   Properties:
     *   {Boolean} node      tries to return a node, used as a dual-compile with 'normal mode'
     *
     * @return  {Function} returns a function with extra properties
     *   Properties:
     *   {Number}  type         description
     *      Possible values:
     *      1  Function return type
     *      2  Parsed data is a pure string
     *      3  Function return type, but its a single xpath
     *   {Array}   xpaths       array of [model,xpath, model,xpath] pairs if model
     *                          or xpath is '#', its dynamic if model is null its a local xpath
     *   {Number}  models        number of models
     *   {Array}   props        description
     *   {Number}  asyncs       description
     *   {String]  str          optional, returned with type 2
     */
	
    this.compileMatch = function(strarray, cfg){
        if (!cfg)
            cfg = emptyCfg;

        o_props = {}, o_xpathpairs = [], o = [cc_f_match_o, cc_m_o], s = [],
        nesting = 0, ol = o.length, xpath_lut_node = xpath_lut_node_normal;

        for (var st, ob, i = 0, j = strarray.length; i < j; i += 2) {
            if (str = strarray[i]) {
                str_len = s.length, c_xpathmode = 2;
                if (i)
                    o[ol++] = cc_m_brk;
                o[ol++] = "";
                s[0] = ob = ol = scope = segment = o.length, cf_mode_output = cf_obj_output;
                line_no = last_type = o_segs = o_xpaths = o_asyncs = parse_mode = last_line = 0;
                sl = 2, s[1]  = "{{", last_tok = "{";
                c_injectself = 1;

                if (cfg.nothrow) {
                    str.replace(parserx, parser);
                }
                else {
                    try {
                        str.replace(parserx, parser);
                    }
                    catch(e) {
                        handleError(e,last_line);
                        return null;
                    }
                }

                if (nesting || s[sl - 1].length == 1)
                    handleError({
                        t: "Unclosed " + s[sl - 1] + " found at end in codemode",
                        p: str_len
                    });

                if (o_asyncs)
                    handleError({t:"Asynchronous calls not supported in match/value"});

                if (parse_mode == 1) { // block mode
                    o[ob - 1] = (o[ob - 1] != cf_block_o) ? cf_mode_output : "",
                    o[ol++]   = cc_m_m_blk;
                }
                else // value mode
                    o[ob-1] = cc_m_m_value_o, o[ol++] = cc_m_m_value_c;
            }
            if (str = strarray[i + 1]) {
                str_len = s.length;
                if(!strarray[i] && i)
                    o[ol++] = cc_m_brk;
                o[ol++] = "";
                ob = ol = scope = segment = o.length, cf_mode_output = cf_str_output;
                c_xpathmode = c_injectself = last_tok = sl = line_no = o_segs = o_xpaths =
                last_type = o_asyncs = last_line = 0;
				if(cfg.node)
					c_xpathmode = 2;
                parse_mode = 2, c_injectself = 0;
				
                if (cfg.nothrow) {
                    str.replace(parserx, parser);
                }
                else {
                    try {
                        str.replace(parserx, parser);
                    }
                    catch(e) {
                        handleError(e,last_line);
                        return null;
                    }
                }

                if (o_asyncs)
                    handleError({t:"Asynchronous calls not supported in match/value"});
				
				if(cfg.node){
					if (parse_mode == 2 && segment == ob || ol == ob)
						o[ob-1] = cc_m_n_string;
					else
						o[ob-1] = cc_m_n_o, o[ol++] = cc_m_n_c;
				}else{
					if (parse_mode == 2 && segment == ob || ol == ob)
						o[ob-1] = cc_m_v_string;
					else
						o[ob-1] = cc_m_v_o, o[ol++] = cc_m_v_c;
				}

                if (strarray[i])
                    o[ol++] = cc_m_c;
                else
                    break;
            }
            else {
                if (!strarray[i])
                    handleError({t:"Both match and value are empty"});

				if(cfg.node)
					o[ol++] = cc_m_n_ret;				
				else
					o[ol++] = cc_m_v_ret;				
				
				c_xpathmode = 2;
					
                o[ol++] = cc_m_c;
            }
        }
        o[ol++] = cc_f_c;

        var f;
        if (cfg.nothrow) {
            f = apf.lm_exec.compile(o.join(""));
        }
        else {
            try{
                f = apf.lm_exec.compile(o.join(""));
            }
            catch(e){
                handleError(e,last_line);
                return null;
            }
        }

        f.type  = 1, f.xpaths = o_xpathpairs,
        f.props = o_props, f.asyncs = o_asyncs;
        return f;
    };

    this.setWarnLevel = function(lvl){
        apf.lm_exec.setWarnLevel(lvl);
    };
})();

// apf lm_exec makes sure there is no scope pollution for eval'ed live markup.
apf.lm_exec = new (function(){
    var wlvl = 1; // 0: no warnings 1: language/models missing, 2:nodes missing, 3:all failed xpaths

    //warning functions
    this.setWarnLevel = function(lvl){
        wlvl = lvl;
    };

    function wxpath(x, t){
        apf.console.warn("Live Markup warning in " + t + ", no results for xpath: '" + x + "'");
    }

    function wnode(x, t){
        apf.console.warn("Live Markup warning in " + t + ", xpath on null node: '" + x + "'");
    }

    function wmodel(m, x, t){
        apf.console.log("Live Markup warning in " + t + ", xpath on empty model: '" + m + "' xpath: '" + x + "'");
    }

    function wlang(x, t){
        apf.console.log("Live Markup warning in " + t + ", language symbol not found: '" + x + "'");
    }

    // xml parse function used by all livemarkup objects
    function xmlParse(str){
        var n = apf.getXmlDom("<_apflmlist_>" + str + "</_apflmlist_>");
        if (!n || !(n = n.documentElement))
            return null;
        return (n.firstChild == n.lastChild) ? n.firstChild : n;
    }

    // value of node by xpath
    function __val(n, x){
        if (!n)
            return (wlvl > 1 && wnode(x),"")
        return (n = (n.nodeType != 1 && n || (n = n.selectSingleNode(x)) 
          && (n.nodeType != 1 && n || (n = n.firstChild) && n.nodeType!=1 && n)))
          && n.nodeValue || (wlvl > 2 && wxpath(x, "_val"),"");
    }

	var __valattrrx = /(["'])/g;
	function __valattrrp(m,a){
		return m=='"'?"&quot;":"&apos;";
	}
    function __valattr(n, x){
        if (!n)
            return (wlvl > 1 && wnode(x),"")
        return (n = (n.nodeType != 1 && n || (n = n.selectSingleNode(x)) 
          && (n.nodeType != 1 && n || (n = n.firstChild) && n.nodeType!=1 && n)))
          &&  n.nodeValue.replace(__valattrrx,__valattrrp) || (wlvl > 2 && wxpath(x, "_val"),"");
    }

	
    // value of model node by xpath
    function __valm(m, x){
        var n;
        if (!m || !(n = (m.charAt && ((m.charAt(0) == "<" && xmlParse(m))
          || ((n = apf.nameserver.lookup.model[m]) && n.data)))
          || (m.$isModel ? m.data : (m.charAt ? 0 : m))))
            return (wlvl > 0 && wmodel(m, x, "_valm"),"");
        return (n = (n.nodeType != 1 && n || (n = n.selectSingleNode(x)) 
          && (n.nodeType != 1 && n || (n = n.firstChild) && n.nodeType!=1 && n)))
          && n.nodeValue || (wlvl > 2 && wxpath(x),"");
    }

    function __nod(n, x){			// node by xpath
        return n ? n.selectSingleNode(x) : (wlvl > 1 && wnode(x, "_nod"),null);
    }

    function _nods(n, x){			// array of nodes by xpath
        return n ? n.selectNodes(x) : (wlvl > 1 && wnode(x, "_nods"),[]);
    }

    function __nodm(m, x){			// node of model by xpath
        var n;
        if (!m || !(n = (m.charAt && ((m.charAt(0) == "<" && xmlParse(m))
          || ((n = apf.nameserver.lookup.model[m]) && n.data)))
          || (m.$isModel ? m.data : (m.charAt ? 0 : m))))
            return (wlvl > 0 && wmodel(m, x, "_nodm"),null);

        return n.selectSingleNode(x);
    }

    function _nodsm(m, x){			// array of nodes from model by xpath
        var n;
        if (!m || !(n = (m.charAt && ((m.charAt(0) == "<" && xmlParse(m))
          || ((n = apf.nameserver.lookup.model[m]) && n.data)))
          || (m.$isModel ? m.data : (m.charAt ? 0 : m))))
            return (wlvl > 0 && wmodel(m, x, "_nodsm"),[]);

        return n.selectNodes(x);
    }

    function __cnt(n, x){		 // count nodes by xpath
        return n ? n.selectNodes(x).length:(wlvl > 1 && wnode(x, "_cnt"),0);
    }

    function __cntm(m, x){		// count nodes from model by xpath
        var n;
        if (!m || !(n = (m.charAt && ((m.charAt(0) == "<" && xmlParse(m))
          || ((n = apf.nameserver.lookup.model[m]) && n.data)))
          || (m.$isModel ? m.data : (m.charAt ? 0 : m))))
            return (wlvl>0&&wmodel(m,x,"_cntm"),0);

        return n.selectNodes(x).length;
    }

    function _xpt(n, x){		// return the query wrapped in an object
        return {
            xpath   : x,
            toString: function(){
                return "LM Xpath object: " + this.x
            }
        };
    }

    function _xptm(m, x){		// return the query with model wrapped in an object
        return {
            model:    m,
            xpath:    x,
            toString: function(){
                return "LM Xpath object with model: " + this.x
            }
        };
    }

    //----- the following functions are combined model and normal mode ------

    function _xml(n, m, x){		// serialize node by xpath via .xml
        if(n) x = m;
        else if(!m || !(n=(m.charAt && ((m.charAt(0)=="<" && xmlParse(m)) ||
            ((n = apf.nameserver.lookup.model[m]) && n.data))) ||
        (m.$isModel?m.data:(m.charAt?0:m))))
            return (wlvl>0&&wmodel(m,x,"_xml"),"");

        return (n && (n = n.selectSingleNode(x))) && n.xml ||
        (wlvl>0&&!n&&wnode(x,"_xml"),"");
    }

    function _xmls(n, m, x){	// serialize nodes by xpath with .xml concatenated
        if(n) x = m;
        else if(!m || !(n=(m.charAt && ((m.charAt(0)=="<" && xmlParse(m)) ||
            ((n = apf.nameserver.lookup.model[m]) && n.data))) ||
        (m.$isModel?m.data:(m.charAt?0:m))))
            return (wlvl>0&&wmodel(m,x,"_xmls"),"");
        for(var i = 0,j = ((n=n.selectNodes(x))).length,o = [];i<j;i++)
            o[i] = n[i].xml;
        return o.join("");
    }

    function _valcr(n, cr, m, x){ // value with a create flag
        if(n) x = m;
        else if(!m || !(n=(m.charAt && ((m.charAt(0)=="<" && xmlParse(m)) ||
            ((n = apf.nameserver.lookup.model[m]) && n.data))) ||
        (m.$isModel?m.data:(m.charAt?0:m))))
            return (wlvl>0&&wmodel(m,x,"_valcr"),"");

        if(cr){
            apf.createNodeFromXpath( ni, x );
        }else
        if( n = ni.selectSingleNode(x) ){
            return (n = (n.nodeType != 1 && n || (n = n.selectSingleNode(x)) &&
                (n.nodeType != 1 && n || (n = n.firstChild) && n.nodeType!=1 && n))) && n.nodeValue || ""
        }
        return (wlvl>2&&wxpath(x,"_valcr"),"");
    }

    function _nodcr(n, cr, m, x){ // node with create flag
        if(n) x = m;
        else if(!m || !(n=(m.charAt && ((m.charAt(0)=="<" && xmlParse(m)) ||
            ((n = apf.nameserver.lookup.model[m]) && n.data))) ||
        (m.$isModel?m.data:(m.charAt?0:m))))
            return (wlvl>0&&wmodel(m,x,"_nodcr"),null);
        return n.selectSingleNode(x) || (cr && apf.createNodeFromXpath( n, x ));
    }

    function _valst(n, x){  	// a value with state holding
        var m = apf.xmldb.findModel(n);
        if(!m)
            return (wlvl>0&&wmodel(m,x,"_valst"),"");
        return "[" + m.id + "::" + apf.xmlToXpath(n, m.data, true) + "/" + x + "]";
    }

    function _valed(n, m, x){ 	// a value with editable div
        if(n) x = m;
        return "<div contenteditable='true' class='contenteditable'>CONTENT_EDITABLE_TODO</div>";
    }

    function _nod_del(n, m, x){ // delete node
        if(n) x = m;
        else if(!m || !(n=(m.charAt && ((m.charAt(0)=="<" && xmlParse(m)) ||
            ((n = apf.nameserver.lookup.model[m]) && n.data))) ||
        (m.$isModel?m.data:(m.charAt?0:m))))
            return (wlvl>0&&wmodel(m,x,"_nod_del"),null);
        if( !(n=n.selectSingleNode(x)) )
            return (wlvl>2&&wxpath(m,x,"_nod_del"),null);
        apf.xmldb.removeNode(n);
    }

    function _nods_del(n, m, x){ // delete nodes
        if(n) x = m;
        else if(!m || !(n=(m.charAt && ((m.charAt(0)=="<" && xmlParse(m)) ||
            ((n = apf.nameserver.lookup.model[m]) && n.data))) ||
        (m.$isModel?m.data:(m.charAt?0:m))))
            return (wlvl>0&&wmodel(m,x,"_nods_del"),null);

        if(!(n = n.selectNodes(x)))
            return;
        apf.xmldb.removeNodeList(n);
    }

    function _nod_asn(n, m, x, v){ // assign node
        if(n) v = x, x = m;
        else if(!m || !(n=(m.charAt && ((m.charAt(0)=="<" && xmlParse(m)) ||
            ((n = apf.nameserver.lookup.model[m]) && n.data))) ||
        (m.$isModel?m.data:(m.charAt?0:m))))
            throw new Error(apf.formatErrorString(0,0,"LM Xpath Assign",
                "Cannot assign to nonresolving model:"+m+"\nxpath:"+x+"\nvalue:"+v));

        if(!n || (x && !(n=apf.createNodeFromXpath(n, x))) )
            throw new Error(apf.formatErrorString(0,0,"LM Xpath Assign",
                "Cannot assign could not resolve \nxpath:"+x+"\nvalue:"+v));

        var c;
        if(!v || (v.charAt && (c=v.charAt(0)!="<")) || typeof(v)=="number"){
            apf.setNodeValue( n, v, true);
            return v;
        }
        if(!c){
            if(n.nodeType!=1)
                throw new Error(apf.formatErrorString(0,0,"LM Xpath Assign",
                    "Cannot assign to a non-element node\nxpath:"+x+"\nvalue:"+v));

            if(!(c = xmlParse(v)))
                throw new Error(apf.formatErrorString(0,0,"LM Xpath append",
                    "Cannot append broken XML.\nxpath:"+x+"\nvalue:"+v));
            if(c.tagName != "_apflmlist_"){
                return apf.xmldb.replaceNode( c, n );
            }else{
                c = c.childNodes;
                apf.xmldb.replaceNode( n = c[0], n );
                for(var i = 0, j = c.length;i<j;i++)
                    n = apf.xmldb.appendChild( n.parentNode, c[0], n.nextSibling );
                return n;
            }
        }else{
            if(v.length){ //@todo implement this its an array thingy
                throw new Error(apf.formatErrorString(0,0,"LM Xpath Assign",
                    "Assign of xpath nodelists not yet supported\nxpath:"+x+"\nvalue:"+v));
            }else{
                if(!v.selectNodes)
                    throw new Error(apf.formatErrorString(0,0,"LM Xpath Assign",
                        "Cannot assign non-element node\nxpath:"+x+"\nvalue:"+v));

                if(v.nodeType == 2){
                    if(n.nodeType != 2)
                        throw new Error(apf.formatErrorString(0,0,"LM Xpath Assign",
                            "Cannot assign attribute node to replace non attribute, use += xpath:"+x+"\nvalue:"+v));

                    apf.xmldb.removeAttribute(c = n.ownerElement || n.selectSingleNode(".."),
                        n.nodeName);

                    apf.xmldb.setAttribute(c, v.nodeName, v.nodeValue);

                    c.getAttributeNode(v.nodeName);
                }else
                    apf.xmldb.replaceNode(v, n);
            }
        }
        return v;
    }

    function _nods_asn(n, m, x, v){ // assign nodes
        if(n) v = x, x = m;
        else if(!m || !(n=(m.charAt && ((m.charAt(0)=="<" && xmlParse(m)) ||
            ((n = apf.nameserver.lookup.model[m]) && n.data))) ||
        (m.$isModel?m.data:(m.charAt?0:m))))
            throw new Error(apf.formatErrorString(0,0,"LM Xpath Assign",
                "Cannot assign to nonresolving model:"+m+"\nxpath:"+x+"\nvalue:"+v));

        for(var i = 0, j = (n = n.selectNodes(x)).length;i<j;i++)
            _nod_asn( n[i], null, v);

        return v;
    }


    function _nod_add(n, m, x, v){ // add node
        if(n) v = x, x = m;
        else if(!m || !(n=(m.charAt && ((m.charAt(0)=="<" && xmlParse(m)) ||
            ((n = apf.nameserver.lookup.model[m]) && n.data))) ||
        (m.$isModel?m.data:(m.charAt?0:m))))
            throw new Error(apf.formatErrorString(0,0,"LM Xpath append",
                "Cannot append to nonresolving model:"+m+"\nxpath:"+x+"\nvalue:"+v));

        if(!n || (x && !(n=n.selectSingleNode(x))) ){ // can only add when the xpath exists.
            return _nod_asn(n,0,x,v);
        }

        var c;
        if(!v || (v.charAt && (c=v.charAt(0)!="<")) || typeof(v)=="number"){
            apf.setNodeValue( n,  // append v to node value
                v= ((n = (n.nodeType != 1 && n || (n = n.selectSingleNode(x)) &&
                    (n.nodeType != 1 && n || (n = n.firstChild) && n.nodeType!=1 && n))) && n.nodeValue || "")+v,
                true);
            return v;
        }
        if(!c){
            if(n.nodeType!=1)
                throw new Error(apf.formatErrorString(0,0,"LM Xpath append",
                    "Cannot append to a non-element node\nxpath:"+x+"\nvalue:"+v));
            // check the parsed XML.
            if(!(c = xmlParse(v)))
                throw new Error(apf.formatErrorString(0,0,"LM Xpath append",
                    "Cannot append broken XML.\nxpath:"+x+"\nvalue:"+v));
            if(c.tagName != "_apflmlist_"){
                return apf.xmldb.appendChild( n.parentNode, xmlParse(v), n.nextSibling );
            }else{
                c = c.childNodes;
                for(var i = 0, j = c.length;i<j;i++) // c nodelist gets smaller.
                    n = apf.xmldb.appendChild( n.parentNode, c[0], n.nextSibling );
                return n;
            }
        }else{
            if(v.length){ //@todo implement this, its an array rhs
                throw new Error(apf.formatErrorString(0,0,"LM Xpath append",
                    "Nodelists not yet supported\nxpath:"+x+"\nvalue:"+v));
            }else{
                if(!v.selectNodes)
                    throw new Error(apf.formatErrorString(0,0,"LM Xpath append",
                        "Cannot assign non-element node\nxpath:"+x+"\nvalue:"+v));

                if(v.nodeType == 2){
                    if(n.nodeType != 1)
                        throw new Error(apf.formatErrorString(0,0,"LM Xpath append",
                            "Cannot append attribute to anything but element node"));

                    apf.xmldb.setAttribute(c = n.ownerElement || n.selectSingleNode(".."),
                        v.nodeName, v.nodeValue);

                    apf.xmldb.removeAttribute(v.ownerElement || v.selectSingleNode(".."),
                        v.nodeName);

                    return c.getAttributeNode(v.nodeName);
                }else
                    return apf.xmldb.appendChild( n.parentNode, v, n.nextSibling );
            }
        }
    }

    function _nods_add(n, m, x, v){ // add nodes
        if(n) v = x, x = m;
        else if(!m || !(n=(m.charAt && ((m.charAt(0)=="<" && xmlParse(m)) ||
            ((n = apf.nameserver.lookup.model[m]) && n.data))) ||
        (m.$isModel?m.data:(m.charAt?0:m))))
            throw new Error(apf.formatErrorString(0,0,"LM Xpath Assign",
                "Cannot append to nonresolving model:"+m+"\nxpath:"+x+"\nvalue:"+v));

        for(var i = 0, j = (n = n.selectNodes(x)).length;i<j;i++)
            _nod_add( n[i], null, v);

        return v;
    }

    function _asn(o, p, v){		// assign propert
        if(!o || typeof(o)!="object")
            throw new Error(apf.formatErrorString(0,0,"LM Property Assign",
                "Cannot assign property on non object, property:"+p));

        if(o.setAttribute)
            o.setAttribute(p,v);
        else
            o[p] = v;
        return v;
    }

    function _add(o, p, v){		// += property
        return _asn(o,p,o && o[p]+v);
    }

    function _sub(o, p, v){		// -= propery
        return _asn(o,p,o && o[p]-v);
    }

    function _div(o, p, v){		// /= property
        return _asn(o,p,o && o[p]/v);
    }

    function _mul(o, p, v){		// *= property
        return _asn(o,p,o && o[p]*v);
    }

    // macro implementations
    function _local(n){			// local(x) for local n
        // check what n is.. if string parse
        if(n && n.charAt && n.charAt(0)=="<")
            return apf.getXmlDom(n).documentElement;
        if(!n && wlvl>1)wnode("-","_local");
        return n;
    }

    function _tagName(n1, n2){	// tagname macro
        return (n2 && n2.tagName) || (n1 && n1.tagName);
    }

    function _localName(n1, n2){	// localname macro
        return (n2 && n2[apf.TAGNAME]) || (n1 && n1[apf.TAGNAME]);
    }

    function _nodeValue(n,n2){		// value of a node, or localnode.
        if(n2) n = n2;
        return (n = (n.nodeType != 1 && n ||
            (n.nodeType != 1 && n || (n = n.firstChild) && n.nodeType!=1 && n))) && n.nodeValue || ""
    }

    // Language processing
    var langrx = /(\\*)\$\[(.*?)\]/g;
    var lang = apf.language;

	apf.$lm_has_lang = 0;

    function _lngrx(tok,esc,x){	// language replacement regex callback
        apf.$lm_has_lang = 1;
		if(esc)
			return "$["+x+"]";
         return lang.words[x] || (wlvl>1&&wlang(x,"_lngrx"),"");
    }

    function __ret(r){			// return function, translates $[lang] things in data
        if(r && r.indexOf && r.indexOf("$[")!=-1)
            return r.replace(langrx, _lngrx);
        return r;
    }

    function __lng(x,x2){			// the language macro
        apf.$lm_has_lang = 1;
        return lang.words[x] || (wlvl>1&&wlang(x,"_lng"),"");
    }

    function _lnged(x,x2){			// editable language macro
        apf.$lm_has_lang = 1;
        return lang.words[x] || (wlvl>1&&wlang(x,"_lnged"),"");
    }

    function _injself(s){			// self inject helper func
        return s.charAt?s.replace(selfrx, "$1self::"):s;
    }

	apf.$lmx = null;

    function _async(_n,_c,_a,_w,_f,_this,obj,func,args){ // Async handling
        var i = _a.i, v;

        if(!_a.ret)_a.ret = [];

        if (_a[i])
            return _a.ret[i];

        _a[i] = true;   // flag this ID so args dont get computed again

        if (!obj.exec)
            return  _a.ret[i]=(func)?obj[func].apply(obj,args):obj.apply(obj,args);
		
        if(_w && _w._pc){
            _w._pc = {
                obj:obj,
                func: func,
                args:args,
                _c:_c
            };
        }else{
            obj.exec(func,args,function(data, state, extra){
                if (state!= apf.SUCCESS){
                    _c(null, state, extra);
                }else{
					apf.$lmx = extra;
                    _a.ret[i] = data;

                    if (_w)
                        _f.call(_this,_n,_c,_w,_a);
                    else
                        _f.call(_this,_n,_c,_a);
                }
            });
        }
        throw({
            x:1
        });
    }

    function _pc(_w){ // precall
        var o;
        if(typeof(o = _w._pc) != "object" || !o)
            return;

        o.obj.exec(o.func,o.args, o._c);

        throw({x:1});
    }

    this.compile = function(code){
        // up-scope much used functions
        var _ret = __ret, _val = __val,_valm = __valm, _nod = __nod,
        _nodm = __nodm, _cnt = __cnt, _cntm = __cntm, _lng = __lng, _valattr = __valattr;
        eval(code);
        return _f;
    }

	var LMBEGINCACHE;
	/*LIVEMARKUP BEGIN CACHE
	var _ret = __ret, _val = __val,_valm = __valm, _nod = __nod,
	_nodm = __nodm, _cnt = __cnt, _cntm = __cntm, _lng = __lng, _valattr = __valattr;
	this.c342 = function(_n,_a,_w){
		..cached LM function..
	}
	this.c342.type = 2; 
	this.c342.xpaths = {...}; 
	this.c342.props = {...};
	this.c723 = function(....){
	
	}
	// replace
	d.replace(/var_LMBEGINCACHE;[\s\S]*var_LMBEGINCACHE;/,"code");
	_async(_n,_c,_a,_w,_f,this,
	_async(_n,_c,_a,_w,apf.lm_exec.c342,this,
	LIVEMARKUP END CACHE*/
	var LMENDCACHE;
})();


/*FILEHEAD(/var/lib/platform/source/trunk/core/parsers/url.js)SIZE(4451)TIME(1259091142)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * Object that represents a URI, broken down to its parts, according to RFC3986.
 * All parts are publicly accessible after parsing like 'url.port' or 'url.host'.
 * Example:
 * <code>
 *   var url = new apf.url('http://usr:pwd@www.test.com:81/dir/dir.2/index.htm?q1=0&&test1&test2=value#top');
 *   alert(url.port); //will show '81'
 *   alert(url.host); //will show 'www.test.com'
 *   alert(url.isSameLocation()) // will show 'true' when the browser is surfing on the www.test.com domain
 *
 * </code>
 *
 * @see http://tools.ietf.org/html/rfc3986
 * @constructor
 * @parser
 * @default_private
 *
 * @author      Mike de Boer
 * @version     %I%, %G%
 * @since       1.0
 */
apf.url = function(str) {
    var base;
    if (str.indexOf(":") == -1 && (base = location.toString()).indexOf(":") != -1) {
        base = new apf.url(base);
        str = apf.getAbsolutePath(base.protocol + "://" + base.host + "/"
            + (base.directory.charAt(base.directory.length - 1) == "/"
                 ? base.directory
                 : base.directory + '/'), str).replace(/\/\/\/\//, "///");
    }
    var o    = apf.url.options,
    m        = o.parser[o.strictMode ? "strict" : "loose"].exec(str),
    i        = 14;
    this.uri = str.toString(); //copy string

    while (i--)
        this[o.key[i]] = m[i] || "";

    this[o.q.name] = {};
    var _self = this;
    this[o.key[12]].replace(o.q.parser, function($0, $1, $2){
        if ($1)
            _self[o.q.name][$1] = $2;
    });

    /**
     * Checks if the same origin policy is in effect for this URI.
     * @see http://developer.mozilla.org/index.php?title=En/Same_origin_policy_for_JavaScript
     *
     * @returns {Boolean}
     */
    this.isSameLocation = function(){
        // filter out anchors
        if (this.uri.length && this.uri.charAt(0) == "#")
            return false;
        // totally relative -- ../../someFile.html
        if (!this.protocol && !this.port && !this.host)
            return true;

        // scheme relative with port specified -- foo.com:8080
        if (!this.protocol && this.host && this.port
          && window.location.hostname == this.host
          && window.location.port     == this.port) {
            return true;
        }
        // scheme relative with no-port specified -- foo.com
        if (!this.protocol && this.host && !this.port
          && window.location.hostname == this.host
          && window.location.port     == 80) {
            return true;
        }
        return window.location.protocol == (this.protocol + ":")
            && window.location.hostname == this.host
            && (window.location.port    == this.port || !window.location.port && !this.port);
    }
};

apf.url.options = {
    strictMode: false,
    key: ["source", "protocol", "authority", "userInfo", "user", "password",
          "host", "port", "relative", "path", "directory", "file", "query",
          "anchor"],
    q  : {
        name  : "queryKey",
        parser: /(?:^|&)([^&=]*)=?([^&]*)/g
    },
    parser: {
        strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*):?([^:@]*))?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
        loose : /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*):?([^:@]*))?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/
    }
};




/*FILEHEAD(/var/lib/platform/source/trunk/core/parsers/xpath.js)SIZE(22407)TIME(1270838604)*/


/**
 * @private
 */
apf.runXpath = function(){

/**
 *    Workaround for the lack of having an XPath parser on safari.
 *    It works on Safari's document and XMLDocument object.
 *
 *    It doesn't support the full XPath spec, but just enought for
 *    the skinning engine which needs XPath on the HTML document.
 *
 *    Supports:
 *    - Compilation of xpath statements
 *    - Caching of XPath statements
 *
 * @parser
 * @private
 */
apf.XPath = {
    cache : {},

    getSelf : function(htmlNode, tagName, info, count, num, sResult){
        var numfound = 0, result = null, data = info[count];

        if (data)
            data[0](htmlNode, data[1], info, count + 1, numfound++ , sResult);
        else
            sResult.push(htmlNode);
    },

    getChildNode : function(htmlNode, tagName, info, count, num, sResult){
        var numfound = 0, result = null, data = info[count];

        var nodes = htmlNode.childNodes;
        if (!nodes) return; //Weird bug in Safari
        for (var i = 0; i < nodes.length; i++) {
            //if (nodes[i].nodeType != 1)
                //continue;

            if (tagName && (tagName != nodes[i].tagName) && (nodes[i].style
              ? nodes[i].tagName.toLowerCase()
              : nodes[i].tagName) != tagName)
                continue;// || numsearch && ++numfound != numsearch
            
            htmlNode = nodes[i];

            if (data)
                data[0](nodes[i], data[1], info, count + 1, numfound++ , sResult);
            else
                sResult.push(nodes[i]);
        }

        //commented out :  && (!numsearch || numsearch == numfound)
    },

    doQuery : function(htmlNode, qData, info, count, num, sResult){
        var result = null, data = info[count];
        var query = qData[0];
        var returnResult = qData[1];
        try {
            var qResult = eval(query);
        }catch(e){
            apf.console.error(e.name + " " + e.type + ":" + apf.XPath.lastExpr + "\n\n" + query);
            return;
        }

        if (returnResult)
            return sResult.push(qResult);
        if (!qResult || qResult.dataType == apf.ARRAY && !qResult.length) 
            return;

        if (data)
            data[0](htmlNode, data[1], info, count + 1, 0, sResult);
        else
            sResult.push(htmlNode);
    },

    getTextNode : function(htmlNode, empty, info, count, num, sResult){
        var data  = info[count],
            nodes = htmlNode.childNodes;

        for (var i = 0; i < nodes.length; i++) {
            if (nodes[i].nodeType != 3 && nodes[i].nodeType != 4)
                continue;

            if (data)
                data[0](nodes[i], data[1], info, count + 1, i, sResult);
            else
                sResult.push(nodes[i]);
        }
    },

    getAnyNode : function(htmlNode, empty, info, count, num, sResult){
        var data  = info[count],
            nodes = htmlNode.getElementsByTagName("*");//childNodes;

        for (var i = 0; i < nodes.length; i++) {
            if (data)
                data[0](nodes[i], data[1], info, count + 1, i, sResult);
            else
                sResult.push(nodes[i]);
        }
    },

    getAttributeNode : function(htmlNode, attrName, info, count, num, sResult){
        if (!htmlNode || htmlNode.nodeType != 1) return;

        if (attrName == "*") {
            var nodes = htmlNode.attributes;
            for (var i = 0; i < nodes.length; i++) {
                arguments.callee.call(this, htmlNode, nodes[i].nodeName, info,
                    count, i, sResult);
            }
            return;
        }

        var data = info[count],
            value = htmlNode.getAttributeNode(attrName);//htmlNode.attributes[attrName];//

        if (data)
            data[0](value, data[1], info, count + 1, 0, sResult);
        else if (value)
            sResult.push(value);
    },

    getAllNodes : function(htmlNode, x, info, count, num, sResult){
        var data = info[count],
            tagName  = x[0],
            inclSelf = x[1],
            prefix   = x[2],
            nodes, i, l;

        if (inclSelf && (htmlNode.tagName == tagName || tagName == "*" || tagName == "node()")) {
            if (data)
                data[0](htmlNode, data[1], info, count + 1, 0, sResult);
            else
                sResult.push(htmlNode);
        }

        if (tagName == "node()") {
            tagName = "*";
            prefix = "";
            if (apf.isIE) {
                nodes = htmlNode.getElementsByTagName("*");
            }
            else {
                nodes = [];
                (function recur(x){
                    for (var n, i = 0; i < x.childNodes.length; i++) {
                        n = x.childNodes[i];
                        if (n.nodeType != 1)
                            continue;
                        nodes.push(n);
                        
                        recur(n);
                    }
                })(htmlNode);
            }
        }
        else {
            nodes = htmlNode.getElementsByTagName((prefix
              && (apf.isGecko || apf.isOpera || htmlNode.nodeFunc) ? prefix + ":" : "") + tagName);
        }

        for (i = 0, l = nodes.length; i < l; i++) {
            if (data)
                data[0](nodes[i], data[1], info, count + 1, i, sResult);
            else
                sResult.push(nodes[i]);
        }
    },

    getAllAncestorNodes : function(htmlNode, x, info, count, num, sResult){
        var data = info[count],
            tagName  = x[0],
            inclSelf = x[1],
            i        = 0,
            s        = inclSelf ? htmlNode : htmlNode.parentNode;
        while (s && s.nodeType == 1) {
            if (s.tagName == tagName || tagName == "*" || tagName == "node()") {
                if (data)
                    data[0](s, data[1], info, count + 1, ++i, sResult);
                else
                    sResult.push(s);
            }
            s = s.parentNode
        }
    },

    getParentNode : function(htmlNode, empty, info, count, num, sResult){
        var data = info[count],
            node = htmlNode.parentNode;

        if (data)
            data[0](node, data[1], info, count + 1, 0, sResult);
        else if (node)
            sResult.push(node);
    },

    //precsiblg[3] might not be conform spec
    getPrecedingSibling : function(htmlNode, tagName, info, count, num, sResult){
        var data = info[count],
            node = htmlNode.previousSibling;

        while (node) {
            if (tagName != "node()" && (node.style
              ? node.tagName.toLowerCase()
              : node.tagName) != tagName){
                node = node.previousSibling;
                continue;
            }

            if (data)
                data[0](node, data[1], info, count+1, 0, sResult);
            else if (node) {
                sResult.push(node);
                break;
            }
        }
    },

    //flwsiblg[3] might not be conform spec
    getFollowingSibling : function(htmlNode, tagName, info, count, num, sResult){
        var result = null, data = info[count];

        var node = htmlNode.nextSibling;
        while (node) {
            if (tagName != "node()" && (node.style
              ? node.tagName.toLowerCase()
              : node.tagName) != tagName) {
                node = node.nextSibling;
                continue;
            }

            if (data)
                data[0](node, data[1], info, count+1, 0, sResult);
            else if (node) {
                sResult.push(node);
                break;
            }
        }
    },

    multiXpaths : function(contextNode, list, info, count, num, sResult){
        for (var i = 0; i < list.length; i++) {
            info = list[i][0];
            var rootNode = (info[3]
                ? contextNode.ownerDocument.documentElement
                : contextNode);//document.body
            info[0](rootNode, info[1], list[i], 1, 0, sResult);
        }

        sResult.makeUnique();
    },

    compile : function(sExpr){
        var isAbsolute = sExpr.match(/^\//);//[^\/]/

        sExpr = sExpr.replace(/\[(\d+)\]/g, "/##$1")
            .replace(/\|\|(\d+)\|\|\d+/g, "##$1")
            .replace(/\.\|\|\d+/g, ".")
            .replace(/\[([^\]]*)\]/g, function(match, m1){
                return "/##" + m1.replace(/\|/g, "_@_");
            }); //wrong assumption think of |

        if (sExpr == "/" || sExpr == ".")
            return sExpr;

        //Mark // elements
        //sExpr = sExpr.replace(/\/\//g, "/[]/self::");

        //Check if this is an absolute query
        return this.processXpath(sExpr.replace(/\/\//g, "descendant::"), isAbsolute);
    },

    processXpath : function(sExpr, isAbsolute){
        var results = [],
            i, l, m, query;
        sExpr = sExpr.replace(/'[^']*'/g, function(m){
            return m.replace("|", "_@_");
        });

        sExpr = sExpr.split("\|");
        for (i = 0, l = sExpr.length; i < l; i++)
            sExpr[i] = sExpr[i].replace(/_\@\_/g, "|");//replace(/('[^']*)\_\@\_([^']*')/g, "$1|$2");

        if (sExpr.length == 1) {
            sExpr = sExpr[0];
        }
        else {
            for (i = 0, l = sExpr.length; i < l; i++)
                sExpr[i] = this.processXpath(sExpr[i]);
            results.push([this.multiXpaths, sExpr]);
            return results;
        }

        var sections   = sExpr.split("/");
        for (i = 0, l = sections.length; i < l; i++) {
            if (sections[i] == "." || sections[i] == "")
                continue;
            else if (sections[i] == "..")
                results.push([this.getParentNode, null]);
            else if (sections[i].match(/^[\w-_\.]+(?:\:[\w-_\.]+){0,1}$/))
                results.push([this.getChildNode, sections[i]]);//.toUpperCase()
            else if (sections[i].match(/^\#\#(\d+)$/))
                results.push([this.doQuery, ["num+1 == " + parseInt(RegExp.$1)]]);
            else if (sections[i].match(/^\#\#(.*)$/)) {
                //FIX THIS CODE
                query = RegExp.$1;
                m     = [query.match(/\(/g), query.match(/\)/g)];
                if (m[0] || m[1]) {
                    while (!m[0] && m[1] || m[0] && !m[1]
                      || m[0].length != m[1].length){
                        if (!sections[++i]) break;
                        query += "/" + sections[i];
                        m = [query.match(/\(/g), query.match(/\)/g)];
                    }
                }

                results.push([this.doQuery, [this.compileQuery(query)]]);
            }
            else if (sections[i] == "*")
                results.push([this.getChildNode, null]); //FIX - put in def function
            else if (sections[i].substr(0,2) == "[]")
                results.push([this.getAllNodes, ["*", false]]);//sections[i].substr(2) ||
            else if (sections[i].match(/descendant-or-self::node\(\)$/))
                results.push([this.getAllNodes, ["*", true]]);
            else if (sections[i].match(/descendant-or-self::([^\:]*)(?:\:(.*)){0,1}$/))
                results.push([this.getAllNodes, [RegExp.$2 || RegExp.$1, true, RegExp.$1]]);
            else if (sections[i].match(/descendant::([^\:]*)(?:\:(.*)){0,1}$/))
                results.push([this.getAllNodes, [RegExp.$2 || RegExp.$1, false, RegExp.$1]]);
            else if (sections[i].match(/ancestor-or-self::([^\:]*)(?:\:(.*)){0,1}$/))
                results.push([this.getAllAncestorNodes, [RegExp.$2 || RegExp.$1, true, RegExp.$1]]);
            else if (sections[i].match(/ancestor::([^\:]*)(?:\:(.*)){0,1}$/))
                results.push([this.getAllAncestorNodes, [RegExp.$2 || RegExp.$1, false, RegExp.$1]]);
            else if (sections[i].match(/^\@(.*)$/))
                results.push([this.getAttributeNode, RegExp.$1]);
            else if (sections[i] == "text()")
                results.push([this.getTextNode, null]);
            else if (sections[i] == "node()")
                results.push([this.getChildNode, null]);//FIX - put in def function
            else if (sections[i].match(/following-sibling::(.*)$/))
                results.push([this.getFollowingSibling, RegExp.$1.toLowerCase()]);
            else if (sections[i].match(/preceding-sibling::(.*)$/))
                results.push([this.getPrecedingSibling, RegExp.$1.toLowerCase()]);
            else if (sections[i] == "self::node()")
                results.push([this.getSelf, null]);
            else if (sections[i].match(/self::(.*)$/))
                results.push([this.doQuery, ["apf.XPath.doXpathFunc(htmlNode, 'local-name') == '" + RegExp.$1 + "'"]]);
            else {
                //@todo FIX THIS CODE
                //add some checking here
                query = sections[i];
                m     = [query.match(/\(/g), query.match(/\)/g)];
                if (m[0] || m[1]) {
                    while (!m[0] && m[1] || m[0] && !m[1] || m[0].length != m[1].length) {
                        if (!sections[++i]) break;
                        query += "/" + sections[i];
                        m = [query.match(/\(/g), query.match(/\)/g)];
                    }
                }

                results.push([this.doQuery, [this.compileQuery(query), true]])

                //throw new Error("---- APF Error ----\nMessage : Could not match XPath statement: '" + sections[i] + "' in '" + sExpr + "'");
            }
        }

        results[0][3] = isAbsolute;
        return results;
    },

    compileQuery : function(code){
        return new apf.CodeCompilation(code).compile();
    },

    doXpathFunc : function(contextNode, type, nodelist, arg2, arg3, xmlNode, force){
        if (!nodelist || nodelist.length == 0)
            nodelist = "";

        if (type == "not")
            return !nodelist;

        if (!force) {
            var arg1, i, l;
            if (typeof nodelist == "object" || nodelist.dataType == apf.ARRAY) {
                if (nodelist && !nodelist.length)
                    nodelist = [nodelist];
                
                var res = false, value;
                for (i = 0, l = nodelist.length; i < l; i++) {
                    xmlNode = nodelist[i];
                    if (!xmlNode || typeof xmlNode == "string"
                      || "position|last|count|local-name|name".indexOf(type) > -1) {
                        value = xmlNode;
                    }
                    else {
                        if (xmlNode.nodeType == 1 && xmlNode.firstChild && xmlNode.firstChild.nodeType != 1)
                            xmlNode = xmlNode.firstChild;
                        value = xmlNode.nodeValue;
                    }
    
                    if (res = arguments.callee.call(this, contextNode, type, value, arg2, arg3, xmlNode, true))
                        return res;
                }
                return res;
            }
            else {
                arg1 = nodelist;
            }
        }
        
        switch(type){
            case "position":
                return apf.getChildNumber(contextNode) + 1;
            case "format-number":
                return apf.formatNumber(arg1); //@todo this should actually do something
            case "floor":
                return Math.floor(arg1);
            case "ceiling":
                return Math.ceil(arg1);
            case "starts-with":
                return arg1 ? arg1.substr(0, arg2.length) == arg2 : false;
            case "string-length":
                return arg1 ? arg1.length : 0;
            case "count":
                return arg1 ? arg1.length : 0;
            case "last":
                return arg1 ? arg1[arg1.length-1] : null;
            case "name":
                var c = xmlNode || contextNode;
                return c.nodeName || c.tagName;
            case "local-name":
                var c = xmlNode || contextNode;
                if (c.nodeType != 1) return false;
                return c.tagName.split(":").pop();//[apf.TAGNAME]
            case "substring":
                return arg1 && arg2 ? arg1.substring(arg2, arg3 || 0) : "";
            case "contains":
                return arg1 && arg2 ? arg1.indexOf(arg2) > -1 : false;
            case "concat":
                var str = ""
                for (i = 1, l = arguments.length; i < l; i++) {
                    if (typeof arguments[i] == "object") {
                        str += getNodeValue(arguments[i][0]);
                        continue;
                    }
                    str += arguments[i];
                }
                return str;
            case "translate":
                for (i = 0, l = arg2.length; i < l; i++)
                    arg1 = arg1.replace(arg2.substr(i,1), arg3.substr(i,1));
                return arg1;
        }
    },

    selectNodeExtended : function(sExpr, contextNode, match){
        var sResult = this.selectNodes(sExpr, contextNode);

        if (sResult.length == 0)
            return null;
        if (!match)
            return sResult;

        for (var i = 0, l = sResult.length; i < l; i++) {
            if (getNodeValue(sResult[i]) == match)
                return [sResult[i]];
        }

        return null;
    },
    
    getRoot : function(xmlNode){
        while (xmlNode.parentNode && xmlNode.parentNode.nodeType == 1)
            xmlNode = xmlNode.parentNode;
        
        return xmlNode.parentNode;
    },

    selectNodes : function(sExpr, contextNode){
        if (!this.cache[sExpr])
            this.cache[sExpr] = this.compile(sExpr);

        
        if (sExpr.length > 20) {
            this.lastExpr    = sExpr;
            this.lastCompile = this.cache[sExpr];
        }
        
        
        if (typeof this.cache[sExpr] == "string"){
            if (this.cache[sExpr] == ".")
                return [contextNode];
            if (this.cache[sExpr] == "/") {
                return [(contextNode.nodeType == 9
                    ? contextNode.documentElement
                    : this.getRoot(contextNode))];
            }
        }

        if (typeof this.cache[sExpr] == "string" && this.cache[sExpr] == ".")
            return [contextNode];

        var info     = this.cache[sExpr][0],
            rootNode = (info[3]
                ? (contextNode.nodeType == 9
                    ? contextNode.documentElement
                    : this.getRoot(contextNode))
                : contextNode),//document.body*/
            sResult  = [];

        if (rootNode)
            info[0](rootNode, info[1], this.cache[sExpr], 1, 0, sResult);

        return sResult;
    }
};

function getNodeValue(sResult){
    if (sResult.nodeType == 1)
        return sResult.firstChild ? sResult.firstChild.nodeValue : "";
    if (sResult.nodeType > 1 || sResult.nodeType < 5)
        return sResult.nodeValue;
    return sResult;
}

/**
 * @constructor
 * @private
 */
apf.CodeCompilation = function(code){
    this.data = {
        F : [],
        S : [],
        I : [],
        X : []
    };

    this.compile = function(){
        code = code.replace(/ or /g, " || ")
            .replace(/ and /g, " && ")
            .replace(/!=/g, "{}")
            .replace(/=/g, "==")
            .replace(/\{\}/g, "!=");

        // Tokenize
        this.tokenize();

        // Insert
        this.insert();
        
        code = code.replace(/, \)/g, ", htmlNode)");

        return code;
    };

    this.tokenize = function(){
        //Functions
        var data = this.data.F;
        code = code.replace(/(translate|format-number|contains|substring|local-name|last|position|round|starts-with|string|string-length|sum|floor|ceiling|concat|count|not)\s*\(/g,
            function(d, match){
                return (data.push(match) - 1) + "F_";
            }
        );

        //Strings
        data = this.data.S;
        code = code.replace(/'([^']*)'/g, function(d, match){
                return (data.push(match) - 1) + "S_";
            })
            .replace(/"([^"]*)"/g, function(d, match){
                return (data.push(match) - 1) + "S_";
            });

        //Xpath
        data = this.data.X;
        code = code.replace(/(^|\W|\_)([\@\.\/A-Za-z\*][\*\.\@\/\w\-]*(?:\(\)){0,1})/g,
            function(d, m1, m2){
                return m1 + (data.push(m2) - 1) + "X_";
            })
            .replace(/(\.[\.\@\/\w]*)/g, function(d, m1, m2){
                return (data.push(m1) - 1) + "X_";
            });

        //Ints
        data = this.data.I;
        code = code.replace(/(\d+)(\W)/g, function(d, m1, m2){
            return (data.push(m1) - 1) + "I_" + m2;
        });
    };

    this.insert = function(){
        var data = this.data;
        code = code.replace(/(\d+)X_\s*==\s*(\d+S_)/g, function(d, nr, str){
                return "apf.XPath.selectNodeExtended('"
                    +  data.X[nr].replace(/'/g, "\\'") + "', htmlNode, " + str + ")";
            })
            .replace(/(\d+)([FISX])_/g, function(d, nr, type){
                var value = data[type][nr];

                if (type == "F") {
                    return "apf.XPath.doXpathFunc(htmlNode, '" + value + "', ";
                }
                else if (type == "S") {
                    return "'" + value + "'";
                }
                else if (type == "I") {
                    return value;
                }
                else if (type == "X") {
                    return "apf.XPath.selectNodeExtended('"
                        + value.replace(/'/g, "\\'") + "', htmlNode)";
                }
            })
            .replace(/, \)/g, ")");
    };
};

}



/*FILEHEAD(/var/lib/platform/source/trunk/core/debug/profiler.js)SIZE(24827)TIME(1265032027)*/




/*FILEHEAD(/var/lib/platform/source/trunk/core/debug/debug.js)SIZE(9707)TIME(1258118722)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * Returns a string giving information on a javascript object.
 *
 * @param {mixed} obj the object to investigate
 */
apf.dump2 =
apf.vardump2 = function(obj, depth, norecur, stack){
    if (apf.isWebkit) //@todo RIK please fix this issue.
        return "";
    
    if (!obj) return obj + "";
    if (!stack)stack = "";
    if (!depth) depth = 0;

    var str;
    switch (obj.dataType) {
        case apf.STRING:
            return "\"" + obj + "\"";
        case apf.NUMBER:
            return obj;
        case apf.BOOLEAN:
            return (obj ? "true" : "false");
        case apf.DATE:
            return "Date(\"" + obj + "\)";
        case apf.ARRAY:
            if(obj[obj.length-2]=='$__vardump'){
                return "this"+obj[obj.length-1]; 
            }
            obj.push('$__vardump',stack);
            str = ["[ "];
            for (var i = 0; i < obj.length-2; i++) {
                str.push( str.length>1?",":"",
                    (norecur && depth > 0 ? "{/*"+typeof(obj[i])+"*/}" :
                    apf.vardump2(obj[i], depth + 1, norecur, stack+'['+i+']')) );
            }
            str.push( " ]");
            obj.pop();obj.pop();
            return str.join('');
        default:
            if (typeof obj == "function")
                return "{/*function*/}";
            if (obj.nodeType !== undefined && obj.style && depth != 0)
                return "{/*HTML Element: " + obj.tagName + "*/}";
            if (obj.nodeType !== undefined)
                return "{/*XML Element : " + obj.tagName + "*/}";
                //return depth == 0 ? "[ " + (obj.xml || obj.serialize()) + " ]" : "XML Element";
            if (norecur && depth > 0)
                return "{/*object/*}";

            //((typeof obj[prop]).match(/(function|object)/) ? RegExp.$1 : obj[prop])
            if (obj['$__vardump']) return "this"+obj['$__vardump']+"";
            obj['$__vardump'] = stack;
            str = ["{\n"];
            
            for (var prop in obj) if(prop!='$__vardump'){
                try {
                    var propname = (parseInt(prop)==prop)?"0x"+("00000000"+parseInt(prop).toString(16)).slice(-8):prop;
                    if(str.length>1)str.push(",\n");
                    str.push( "\t".repeat(depth+1), propname, ": ",
                      (norecur && depth > 0 ? "{/*"+typeof(obj[prop])+"*/}":
                        apf.vardump2(obj[prop], depth + 1, norecur, stack+'.'+prop)) );
                } catch(e) {
                    str.push( "\t".repeat(depth+1) , prop , ": null /*ERROR*/");
                }
            }
            str.push( "\n", ("\t".repeat(depth)), "}");
            
            function cleanup(obj){
                if(!obj['$__vardump'])return;
                delete obj['$__vardump'];
                for(var prop in obj){
                    var v = obj[prop];
                    if(typeof(v)=='object')cleanup(obj);
                }
            }
            
            //if(depth==0)
            cleanup(obj);
            
            return str.join('');
    }
};

if (apf.isOpera) {
    window.console = {};
    ["log", "debug", "info", "warn", "error"].forEach(function(type) {
        window.console[type] = function() {
            if (typeof arguments === "undefined") return null;
            if (arguments.length === 1) { // single argument provided
                opera.postError(type + ": " + arguments[0]);
                return type + ": " + arguments[0];
            }
            var s      = arguments[0],
                // string substitution patterns of firebug console
                regexp = /%([sdifo])/g,
                i      = 0,
                match  = null;
            // replace found matches with given arguments
            while (match = regexp.exec(s)) {
                s = s.replace(match[0], String(arguments[++i]));
            }
            // display log messages
            var len = arguments.length;
            while (len > i++) {
                if (arguments[i]) {
                    s += ' ';
                    s += String(arguments[i]);
                }
            }
            opera.postError(type + ": " + s);
        };
    });
}

/**
 * Returns a string giving more detailed informations on a javascript object.
 *
 * @param {mixed} obj the object to investigate
 */
apf.dump =
apf.vardump = function (obj, depth, recur, stack){
    if(!obj) return obj + "";
    if(!depth) depth = 0;

    switch(obj.dataType){
        case "string":    return "\"" + obj + "\"";
        case "number":    return obj;
        case "boolean": return obj ? "true" : "false";
        case "date": return "Date[" + new Date() + "]";
        case "array":
            var str = "{\n";
            for(var i=0;i < obj.length;i++){
                str += "     ".repeat(depth+1) + i + " => " + (!recur && depth > 0 ? typeof obj[i] : apf.vardump(obj[i], depth+1, !recur)) + "\n";
            }
            str += "     ".repeat(depth) + "}";
            
            return str;
        default:
            if(typeof obj == "function") return "function";
            //if(obj.xml) return depth==0 ? "[ " + obj.xml + " ]" : "XML Element";
            if(obj.xml || obj.serialize) return depth==0 ? "[ " + (obj.xml || obj.serialize()) + " ]" : "XML Element";
            
            if(!recur && depth>0) return "object";
        
            //((typeof obj[prop]).match(/(function|object)/) ? RegExp.$1 : obj[prop])
            var str = "{\n";
            for(prop in obj){
                try{
                    str += "     ".repeat(depth+1) + prop + " => " + (!recur && depth > 0? typeof obj[prop] : apf.vardump(obj[prop], depth+1, !recur)) + "\n";
                }catch(e){
                    str += "     ".repeat(depth+1) + prop + " => [ERROR]\n";
                }
            }
            str += "     ".repeat(depth) + "}";
            
            return str;
    }
}

String.prototype.s = function(){
    return this.replace(/[\r\n]/g, "");
}

/**
 * Alerts string giving information on a javascript object.
 * This is older version of this function
 *
 * @param {mixed} obj the object to investigate
 */
apf.alert_r = function(obj, recur){
    alert(apf.vardump(obj, null, recur));
}

/**
 * Alerts string giving information on a javascript object.
 *
 * @param {mixed} obj the object to investigate
 */
apf.alert_r2 = function(obj, recur){
    alert(apf.vardump2(obj, null, !recur));
}

/**
 * Object timing the time between one point and another.
 *
 * @param {Boolean} nostart whether the profiler should start measuring at creation.
 * @constructor
 */
apf.ProfilerClass = function(nostart){
    this.totalTime = 0;

    /**
     * Starts the timer.
     * @param {Boolean} clear resets the total time.
     */
    this.start = function(clear){
        if (clear) this.totalTime = 0;
        this.startTime = new Date().getTime();

        this.isStarted = true;
    }

    /**
     * Stops the timer.
     * @method
     */
    this.stop =
    this.end = function(){
        if (!this.startTime) return;
        this.totalTime += new Date().getTime() - this.startTime;
        this.isStarted = false;
    }

    /**
     * Sends the total time to the console.
     * @param {String} msg Message displayed in the console.
     */
    this.addPoint = function(msg){
        this.end();
        apf.console.time("[TIME] " + (msg || "Profiled Section") + ": " + this.totalTime + "ms");
        this.start(true);
    }

    if (!nostart)
        this.start();
};

apf.Latometer = new apf.ProfilerClass(true);//backward compatibility

if (self.navigator && navigator.userAgent.indexOf("Opera") != -1) {
    window.console = {};
    ["log", "debug", "info", "warn", "error"].forEach(function(type) {
        window.console[type] = function() {
            if (typeof arguments === "undefined") return null;
            if (arguments.length === 1) { // single argument provided
                opera.postError(type + ": " + arguments[0]);
                return type + ": " + arguments[0];
            }
            var s      = arguments[0],
                // string substitution patterns of firebug console
                regexp = /%([sdifo])/g,
                i      = 0,
                match  = null;
            // replace found matches with given arguments
            while (match = regexp.exec(s)) {
                s = s.replace(match[0], String(arguments[++i]));
            }
            // display log messages
            var len = arguments.length;
            while (len > i++) {
                if (arguments[i]) {
                    s += ' ';
                    s += String(arguments[i]);
                }
            }
            opera.postError(type + ": " + s);
        };
    });
}




/*FILEHEAD(/var/lib/platform/source/trunk/core/debug/debugwin.js)SIZE(31815)TIME(1271196961)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



function prettySize(size) {
    if (size < 1024)
        return size + " Bytes";
    else if (size < 1024*1024)
        return Math.round(size/1024) + " KB";
    else if (size < 1024*1024*1024)
        return Math.round(size/(1024*1024)) + " MB";
}

apf.$debugwin = {
    resPath     : "", //@todo
    showtime    : true,
    nativedebug : false,
    highlighthover : true,
    
    cache : [],
    
    apf  : (function(){
        apf.isDebugWindow = self.frameElement 
            && self.frameElement.isDebugWin > -1;
        
        if (apf.isDebugWindow) {//assuming we are the debug window
            var upapf = self.parent.apf;

            apf.xmldb.$xmlDocLut = upapf.xmldb.$xmlDocLut;
            apf.xmldb.$listeners = upapf.xmldb.$listeners;
            apf.xmldb.$nodeCount = upapf.xmldb.$nodeCount;
            
            (apf.$asyncObjects || (apf.$asyncObjects = {}))["$apf_ide_mdlProps"] = 1;
            
            return upapf;
        }
        
        return apf;
    })(),
    
    init : function(){
        this.updateLog();
        this.apf.addEventListener("debug", this.debugHandler);
        
        apf.importCssString(".console_date{display:inline}");
        
        
        apf.storage.init();

        this.showtime       = apf.storage.get("apfdebug_console_date") !== false;
        this.nativedebug    = apf.storage.get("apfdebug_debugger") == true;
        this.highlighthover = apf.storage.get("apfdebug_highlight_hover") !== false;
        
        txtCode.setValue(apf.storage.get("jsexec") || "");
        codetype.setProperty("value", apf.storage.get("scriptype") || "Javascript");
        txtModel.setValue(apf.storage.get("mdlvalue") || "");
        
        this.apf.$debugwin.setNativeDebug(this.nativedebug);
        
        
        itmShowtime.setAttribute("checked", this.showtime);
        itmDebug.setAttribute("checked", this.nativedebug);
        cbHighlightHover.setAttribute("checked", this.highlighthover);
        
        $apf_ide_mdl.load(this.apf.document.documentElement);//"debugwin.html");//
        
        var _self = this;
        this.$mmouseover = function(e){
            var oHtml = e.htmlEvent.srcElement || e.htmlEvent.target;
            var xmlNode = oHtml.tagName == "DIV" || oHtml.tagName == "SPAN" 
                ? null
                : apf.xmldb.findXmlNode(oHtml);
            
            if (cbHighlightHover.checked)
                _self.apf.$debugwin.highlightAmlNode(xmlNode, !xmlNode);
            e.cancelBubble = true;
        }
        
        this.$mmouseout = function(e){
            self.apf.$debugwin.highlightAmlNode(null, true);
            e.cancelBubble = true;
        }
        
        $apf_ide_mdlProps.exec = function(method, args, callback, options){
            if (method == "getProperty" && args[0]) {
                var xml, tag = args[0];
                if (xml = $apf_ide_mdlProps.queryNode(tag))
                    return callback(xml, apf.SUCCESS);

                if (!options)
                    options = {};
                if (!options.callback)
                    options.callback = function(data, state, extra){
                        if (state != apf.SUCCESS) {
                            $apf_ide_mdlProps.exec(method, ["empty"], callback, options);
                            tag = "empty";
                            return false;
                        }
                        else
                            callback($apf_ide_mdlProps.queryNode(tag), state, extra);
                    }
                this.insert("props/" + tag + ".xml", options);
            }
        };
        
        apf.addEventListener("mousedown", function(){
            errBox.hide();
        });
    },
    
    start : function(){
        if (!apf.isDebugWindow)
            window.onerror = this.nativedebug ? null : this.errorHandler;
    },
    
    errorHandler : function(message, filename, linenr, isForced){
        if (!message) message = "";

        if (!isForced) {
            apf.$debugwin.apf.console.error(
              (apf.$debugwin.apf != apf ? "[Debug Window Error]: " : "") 
                + "Error on line " + linenr + " of " 
                + apf.removePathContext(apf.hostPath, filename) + "\n" + message);
                //.replace(/</g, "&lt;")
                //.replace(/\n/g, "\n<br />")
        }
        
        if (apf.$debugwin.apf == apf) 
            apf.$debugwin.show();

        return true;
    },
    
    updateLog : function(){
        apf_console.clear();
        apf_console.setValue(this.apf.console.getAll(
            btnError.value,
            btnWarn.value,
            btnLog.value
        ))
    },
    
    updateTeleportFilter : function(btn){
        var each = tlist.each.split("|");
        if (btn.value)
            each.push(btn.firstChild.nodeValue.toLowerCase());
        else
            each = each.remove(btn.firstChild.nodeValue.toLowerCase());
        
        tlist.setAttribute("each", each.join("|") || "none");
    },
    
    debugHandler : function(e){
        if ((self["btn" + e.type.uCaseFirst()] || btnLog).value || e.type == "custom")
            apf_console.setValue(e.message);
        
        if (e.type == "error" && tabDebug.activepagenr != 0) {
            errBox.setMessage(";<a href='javascript:void(0)' onclick='tabDebug.set(0);errBox.hide()'>" + e.message + "</a>");
            errBox.show();
        }
    },
    
    showAmlNode : function(node){
        tabDebug.set(1);
        pgBrowse.set(0);
        
        if (!mrkAml.xmlRoot) {
            mrkAml.addEventListener("afterload", function(){
                apf.$debugwin.showAmlNode(node);
                mrkAml.removeEventListener("afterload", arguments.callee);
            });
        }
        else {   
            //find in markupeditor, if not there, show in showObject
            mrkAml.expandAndSelect(node);
    
            if (mrkAml.selected != node)
                this.showObject(null, node.getAttribute("id") || "", node);
        }
    },
    
    toggleHighlight : function(debugwin, btn){
        if (document.onmousemove) {
            document.onmousemove = 
            document.onmousedown = null;
            return;
        }
        
        var lastAmlNode;
        document.onmousemove = function(e){
            if (apf.$debugwin.$hdiv)
                apf.$debugwin.$hdiv.style.top = "10000px";
            
            var x = (e || (e = event)).clientX;
            var y = e.clientY;
            var htmlNode = document.elementFromPoint(x, y);

            var amlNode  = apf.findHost(htmlNode);
            if (lastAmlNode != amlNode)
                apf.$debugwin.highlightAmlNode(null, true);
            
            if (lastAmlNode = amlNode)
                apf.$debugwin.highlightAmlNode(amlNode, false, true);
        }
        
        document.onmousedown = function(e){
            var amlNode = lastAmlNode || apf.findHost((e || (e = event)).srcElement || e.target);
            if (amlNode) {
                debugwin.showAmlNode(amlNode);
                apf.$debugwin.highlightAmlNode(null, true);
                btn.setValue(false);
                
                document.onmousemove = 
                document.onmousedown = null;
            }
        }
    },
    
    highlightAmlNode : function(node, remove, border) {
        if (remove) {
            if (this.$hdiv)
                this.$hdiv.style.display = "none";
            return;
        }
        
        if (!node)
            return;
        
        if (!this.$hdiv) {
            apf.importCssString(
                ".apf_highlight_div{\
                    background : #004eff;\
                    position   : absolute;\
                    z-index    : 1000000;\
                    opacity    : 0.3;\
                }\
                .apf_border_div{\
                    background : url(images/spacer.gif);\
                    position   : absolute;\
                    z-index    : 1000000;\
                    border     : 1px solid blue;\
                }");
            
            this.$hdiv = document.body.appendChild(document.createElement("div"));
            this.$hdiv.style.display = "none";
            //apf.setStyleClass(this.$hdiv, "apf_highlight_div");
        }
        
        apf.setStyleClass(this.$hdiv, border 
            ? "apf_border_div" 
            : "apf_highlight_div", ["apf_border_div", "apf_highlight_div"]);
        
        if (false && node.tagName == "html") {
            this.$hdiv.style.left = "0px";
            this.$hdiv.style.top  = "0px";
            this.$hdiv.style.width  = "100%";
            this.$hdiv.style.height = "100%";
            this.$hdiv.style.display = "block";
        }
        else if (node.$ext && (node.$ext.offsetHeight || node.$ext.offsetWidth)) {
            var pos = apf.getAbsolutePosition(node.$ext);
            this.$hdiv.style.left  = pos[0] + "px";
            this.$hdiv.style.top   = pos[1] + "px";
            var diff = apf.getDiff(this.$hdiv);
            this.$hdiv.style.width = (node.$ext.offsetWidth - diff[0]) + "px";
            this.$hdiv.style.height = (node.$ext.offsetHeight - diff[1]) + "px";
            this.$hdiv.style.display = "block";
        }
        else {
            this.$hdiv.style.display = "none";
        }
    },
    
    showObject : function(id, name, obj){
        tabDebug.set(1);
        pgBrowse.set(2);

        txtCurObject.setValue(name);
        trObject.clear("loading");

        var _self = this;
        setTimeout(function(){
            if (!id && id !== 0)
                $apf_ide_mdlObject.load(_self.analyze(obj, name, name));
            else
                $apf_ide_mdlObject.load(_self.analyze(_self.apf.$debugwin.cache[id], 
                    "apf.$debugwin.cache[" + id + "]", name));
        }, 10);
    },
    
    types : ["Object", "Number", "Boolean", "String", "Array", "Date", "RegExp", "Function", "Object"],
    domtypes : [null, "Element", "Attr", "Text", "CDataSection", 
                "EntityReference", "Entity", "ProcessingInstruction", "Comment", 
                "Document", "DocumentType", "DocumentFragment", "Notation"],
    
    calcName : function(xmlNode, useDisplay){
        var name, loopNode = xmlNode.tagName == "method" ? xmlNode.parentNode : xmlNode, path = [];
        do {
            name = useDisplay 
                ? loopNode.getAttribute("display") || loopNode.getAttribute("name") 
                : loopNode.getAttribute("name");
            
            if (!name)
                break;

            path.unshift(!name.match(/^[a-z_\$][\w_\$]*$/i)
                ? (parseInt(name) == name
                    ? "[" + name + "]"
                    : "[\"" + name.replace(/'/g, "\\'") + "\"]")
                : name);
            loopNode = loopNode.parentNode;
        }
        while (loopNode && loopNode.nodeType == 1);
        
        if (path[0].charAt(0) == "[")
            path[0] = path[0].substr(2, path[0].length - 4);
        return path.join(".").replace(/\.\[/g, "[");
    },
    
    analyze : function(pNode, ref, displayName){
        var item, prop;

        //if (!pNode) return pNode + "";
        
        if (pNode && !pNode.dataType && pNode.nodeType && "item|method".indexOf(pNode.tagName) > -1) {
            var name, loopNode = pNode.tagName == "method" ? pNode.parentNode : pNode, path = [];
            do {
                name = loopNode.getAttribute("name");
                if (!name) break;
                path.unshift("['" + name.replace(/'/g, "\\'") + "']");
                loopNode = loopNode.parentNode;
            }
            while (loopNode && loopNode.nodeType == 1);
            
            path[0] = path[0].substr(2, path[0].length - 4);
            o = self.parent.eval(path.join(""));
        }
        else {
            o = pNode;
            pNode = null;
        }
            
        if (pNode && pNode.tagName == "method") {
            var xml = apf.getXml("<method />");
            var doc = xml.ownerDocument;
            for (prop in o) {
                if (typeof o[prop] == "function" && prop.charAt(0) != "$") {
                    item = xml.appendChild(doc.createElement("method"));
                    item.setAttribute("name", prop);
                    item.setAttribute("type", "Function");
                    item.setAttribute("value", prop + o[prop].toString().match(/function\s*[\w-]*(\([\s\S]*?\))/)[1]);
                }
            }
            return xml;
        }
    
        if (!pNode) {
            /*var xml = apf.getXml("<obj><item " + (ref ? "name='" + ref + "'" : "") 
                + (displayName ? " display=\"" + displayName.replace(/"/g, "&quot;") + "\"" : "")
                + " expand='true' /></obj>").firstChild;*/
            var xml = apf.getXml("<obj />");
            var n = {};
            n[displayName] = o;
            if (typeof o == "object" || o && o.dataType == apf.ARRAY)
                n.$isSingleValue = true;
            o = n;
        }
        else {
            var xml = apf.getXml("<item " + (ref ? "name='" + ref + "'" : "") 
                + (displayName ? " display=\"" + displayName.replace(/"/g, "&quot;") + "\"" : "")
                + " expand='true' />");
        }
        var doc = xml.ownerDocument;
        
        //Special case for IE XML elements
        try {prop in o}catch(e){
            //@todo
            return xml;
        }

        for (prop in o) {
            obj = o[prop];
            
            if (prop.charAt(0) == "$" || prop.substr(0, 2) == "a_") //@todo this could be a setting
                continue;
            
            if (typeof obj == "function" && (o.dataType != apf.ARRAY || prop != parseInt(prop))) {
                hasMethods = true;
                continue;
            }
            
            item = xml.appendChild(doc.createElement("item"));
            item.setAttribute("name", prop);
            
            if (typeof obj == "undefined" || obj == null) {
                item.setAttribute("value", String(obj));
                item.setAttribute("type", String(obj));
                item.setAttribute("numtype", 0);
                continue;
            }
            
            if (this.types[obj.dataType])
                item.setAttribute("type", this.types[obj.dataType]);
            
            var hasProperties = null;
            try{for (hasProperties in obj) break;}
            catch(e){hasProperties = true;}
            item.setAttribute("numtype", obj.dataType || (hasProperties ? 8 : 0));
        
            var str, hasMethods;
            switch (obj.dataType) {
                case apf.STRING:
                    if (obj.length > 10000) 
                        item.setAttribute("value", "String of " + obj.length + " bytes (too large to display)");
                    else 
                        item.setAttribute("value", '"' + obj
                          .replace(/"/g, "\\\"")
                          .replace(/</g, "&lt;")
                          .replace(/\n/g, "\\n")
                          .replace(/\r/g, "\\r") + '"');
                break;
                case apf.NUMBER:
                    item.setAttribute("value", obj);
                break;
                case apf.BOOLEAN:
                    item.setAttribute("value", obj ? "true" : "false");
                break;
                case apf.DATE:
                    item.setAttribute("value", "[" + obj.toString() + "]");
                break;
                case apf.FUNCTION:
                    item.setAttribute("value", prop + o[prop].toString().match(/function\s*[\w-]*(\([\s\S]*?\))/)[1]);
                break;
                case apf.ARRAY:
                    item.setAttribute("value", "(" + obj.length + " items)");
                break;
                default:
                    item.setAttribute("value", "{" + (obj.nodeType == 2 
                        ? "@" + obj.nodeName 
                        : (obj.nodeType != 1 && obj.nodeName 
                            ? obj.nodeName + " Node" 
                            : (obj.tagName ? obj.tagName + " Element" : "..."))) + "}");
                    
                    if (obj.nodeType !== undefined && typeof obj.style == "object")
                        item.setAttribute("type", obj.nodeType == 1 
                            ? "HTML" + obj.tagName.toLowerCase().uCaseFirst() + "Element"
                            : "HTML" + this.domtypes[obj.nodeType]);
                    else if (obj.nodeType !== undefined) {
                        var s;
                        if (obj.$regbase & apf.__AMLNODE__) {
                            if (obj.nodeType == 1) {
                                if (obj.namespaceURI == apf.ns.xhtml) {
                                    item.setAttribute("type", "apf.Xhtml" + obj.localName.uCaseFirst() + "Element");
                                    break;
                                }
                                else if (obj.namespaceURI == apf.ns.xsd) {
                                    item.setAttribute("type", "apf.Xsd" + obj.localName.uCaseFirst() + "Element");
                                    break;
                                }
                            }

                            item.setAttribute("type", obj.nodeType == 1 
                                ? "apf." + obj.localName
                                : "apf.Aml" + this.domtypes[obj.nodeType]);
                            break;
                        }
                        
                        item.setAttribute("type", "XML" + this.domtypes[obj.nodeType]);
                    }
                    else {
                        item.setAttribute("type", "Object");
                    } 
                        
                break;
            }
        }
        
        if (!pNode && displayName) {
            xml.firstChild.setAttribute("display", displayName);
            xml.firstChild.setAttribute("expand", "true");
            if (o.$isSingleValue)
                apf.mergeXml(this.analyze(xml.firstChild, name), xml.firstChild);
        }
        
        if (hasMethods) {
            xml.insertBefore(doc.createElement("method"), xml.firstChild)
                .setAttribute("name", "[Methods]");
        }

        return doc.documentElement;
    },
    
    checkChange : function(xmlNode){
        var value = xmlNode.getAttribute("value");
        if (xmlNode.tagName == "method" || "Boolean|String|undefined|null|Number".indexOf(xmlNode.getAttribute("type")) == -1)
            return false;
    },
    
    applyChange : function(xmlNode){
        var value = xmlNode.getAttribute("value");
        var name = this.calcName(xmlNode);
        try{
            if (name.indexOf(".") > -1) {
                var prop, obj = self.parent.eval(name.replace(/\.([^\.\s]+)$/, ""));
                if (obj && obj.$supportedProperties && obj.$supportedProperties.contains(prop = RegExp.$1)) {
                    obj.setProperty(prop, self.parent.eval(value));
                    return;
                }
            }
            
            self.parent.eval(name + " = " + value);
            
            //@todo determine new type
        }
        catch(e) {
            trObject.getActionTracker().undo();
            alert("Invalid Action: " + e.message);
            //@todo undo
        }
    },
    
    showXmlNode : function(xml){
        tabDebug.set(1);
        pgBrowse.set(1);
        
        var lut = apf.xmldb.$xmlDocLut;
        var doc = xml.ownerDocument.documentElement;
        var id = xml.getAttribute(apf.xmldb.xmlIdTag);
        var docId = id.split("\|")[0];
        
        if (!lut[docId]) {
            lut[docId] = doc;
        }
        else if (lut[docId] != doc) {
            var model1 = this.apf.nameserver.get("model", docId);
            lut[docId] = doc;

            var model2 = apf.nameserver.get("model", docId);
            apf.xmldb.getXmlDocId(doc, model2);
            
            if (model1)
                apf.nameserver.register("model", docId, model1);
        }
        
        mrkData.load(xml);
    },
    
    jRunCode : function(code, scripttype,  model){
        
        apf.storage.put("jsexec", code);
        apf.storage.put("scriptype", scripttype);
        apf.storage.put("mdlvalue", model);
        
        var islm = scripttype == 'Live Markup';

        this.apf.console.write("<span style='color:blue'><span style='float:left'>&gt;&gt;&gt;</span><div style='margin:0 0 0 30px'>"
            + code.replace(/ /g, "&nbsp;")
                  .replace(/\t/g, "&nbsp;&nbsp;&nbsp;")
                  .replace(/</g, "&lt;")
                  .replace(/\n/g, "\n<br />") 
            + "</div></span>", "custom", null, null, null, true);

        var _self = this;
        var doIt  = function(data){
            if (islm) {
                var func = apf.$debugwin.apf.lm.compile(code, {parsecode : true});
                if (model) {
                    if (data = apf.$debugwin.apf.nameserver.get("model", model))
                        data = data.data;
                    if (!data) {
                        var data = apf.getData(model, {
                            callback : function(data, state, extra){
                                if (state == apf.SUCCESS) {
                                    doIt(data);
                                }
                                else {
                                    throw new Error();
                                }
                            }
                        })
                        return;
                    }
                }
                var x = func(data);
            }
            else {
                var x = self.parent.eval(code);
            }

            var s = _self.$serializeObject(x, code);
            if (typeof s == "string") {
                _self.apf.console.write(s, "custom", null, null, null, true);
            }
            else {
                _self.apf.console.write(x
                    ? "Could not serialize object: " + s.message
                    : x, "error", null, null, null, true);
            }
        }

        if (apf.$debugwin.nativedebug)
            doIt();
        else {
            try{
                doIt();
            }
            catch(e) {
                this.apf.console.write(e.message, "error", null, null, null, true);
            }
        }
    },
    
    $serializeObject : function(x, code){
        if (x === null)
            x = "null";
        else if (x === undefined)
            x = "undefined";

        try {
            var str;
            if (x.nodeType && (x.nodeType == 1 || x.nodeType == 7) && !x.style) {
                if (x.serialize) //aml
                    str = "<a class='xmlhl' href='javascript:void(0)' onmouseout='if (cbHighlightHover.checked) apf.$debugwin.apf.$debugwin.highlightAmlNode(null, true)' onmouseover='apf.$debugwin.apf.$debugwin.highlightAmlNode(apf.$debugwin.apf.all[" 
                        + x.$uniqueId + "])' onclick='apf.$debugwin.showAmlNode(apf.$debugwin.apf.all[" 
                        + x.$uniqueId + "])'>" + apf.highlightXml(x.serialize().split(">")[0] + ">").replace(/<\/?a(?:>| [^>]*>)/g, "")  + "</a>";
                //else if (x.style) //html
                    //str = x.outerHTML.replace(/</g, "&lt;").replace(/\n/g, "\n<br />")
                else
                    str = "<a class='xmlhl' href='javascript:void(0)' onclick='apf.$debugwin.showXmlNode(apf.$debugwin.cache[" 
                        + (apf.$debugwin.cache.push(x) - 1) + "])'>" 
                        + apf.highlightXml(apf.getCleanCopy(x).xml.split(">")[0] + ">") + "</a>";

                return str;
            }
            else if (typeof x == "object") {
                if (x.dataType == apf.ARRAY) {
                    var out = ["Array { length: " + x.length];
                }
                else {
                    var out = [x.toString(), "{"];
                    for (prop in x) {
                        if (out.length == 5) {
                            out.push("more...");
                            break;
                        }
                        if (typeof x[prop] != "function" && typeof x[prop] != "object" && x[prop] && prop.substr(0,1) != "$")
                            out.push(prop + "=" + x[prop] + ", ");
                    }
                }

                return "<a class='xmlhl' href='javascript:void(0)' style='font-weight:bold;font-size:7pt;color:green' onclick='apf.$debugwin.showObject(" 
                        + (this.apf.$debugwin.cache.push(x) - 1) + ", \"" + code.split(";").pop() + "\")'>" 
                        + out.join(" ") + " }</a>";
            }
            else {
                str = x.toString();
            
                return str
                    .replace(/</g, "&lt;")
                    .replace(/\n/g, "\n<br />");
            }
        }catch(e){
            return e;
        }
    },

    consoleTextHandler: function(e) {
        if (e.keyCode == 9 && e.currentTarget == txtCode) {
            txtCode.focus();
            e.cancelBubble = true;
            return false;
        }
        else if(e.keyCode == 13 && e.ctrlKey) {
            apf.$debugwin.jRunCode(txtCode.value, codetype.value, txtModel.value);
            return false;
        }
    },
    
    setShowTime : function(c){
        
        apf.storage.put("apfdebug_console_date", c);
        
        apf.setStyleRule('.console_date', 'display', c ? 'inline' : 'none');
        this.showtime = c;
    },
    
    setNativeDebug : function(c){
        
        apf.storage.put("apfdebug_debugger", c);
        
        this.nativedebug = c;
        window.onerror = this.nativedebug ? null : this.errorHandler;
    },
    
    setHighlightHover : function(c){
        
        apf.storage.put("apfdebug_highlight_hover", c);
        
        this.highlighthover = c;
    },
    
    first : true,
    show : function(){
        if (apf.isDebugWindow)
            return;
        
        if (apf.loadScreen)
            apf.loadScreen.hide();

        //Initialize css for showing debugwindow
        if (this.first) {
            if (apf.isIE) {
                apf.setStyleRule("BODY", "overflow", "", 0);
    
                p = apf.getBox(apf.getStyle(document.body, "padding"));
                m = apf.getBox(apf.getStyle(document.body, "margin"));
                o = [apf.getStyle(document.documentElement, "overflow"),
                         apf.getStyle(document.documentElement, "overflowX"),
                         apf.getStyle(document.documentElement, "overflowY")];
            }
            else {
                p = [parseInt(apf.getStyle(document.body, "padding-top")),
                     parseInt(apf.getStyle(document.body, "padding-right")),
                     parseInt(apf.getStyle(document.body, "padding-bottom")),
                     parseInt(apf.getStyle(document.body, "padding-left"))];
                m = [parseInt(apf.getStyle(document.body, "margin-top")),
                     parseInt(apf.getStyle(document.body, "margin-right")),
                     parseInt(apf.getStyle(document.body, "margin-bottom")),
                     parseInt(apf.getStyle(document.body, "margin-left"))];
                o = [apf.getStyleRule("html", "overflow") || "auto",
                         apf.getStyleRule("html", "overflow-x") || "auto",
                         apf.getStyleRule("html", "overflow-y") || "auto"];
            }
    
            
            this.resPath = (apf.config.resourcePath || apf.basePath) + "resources/";
            
            

            apf.importCssString("\
                html{\
                    height : 100%;\
                    overflow : hidden;\
                    overflow-x : hidden;\
                    overflow-y : hidden;\
                    margin-bottom : " + (p[0] + m[0] + p[2] + m[2]) + "px;\
                }\
                body{\
                    position : absolute;\
                    left : 0;\
                    top : 0;\
                    right : 0;\
                    bottom : 300px;\
                    margin:0;\
                    overflow  : " + o[0] + ";\
                    overflow-x : " + o[1] + ";\
                    overflow-y : " + o[2] + ";\
                    padding : " + (p[0] + m[0]) + "px " +
                                  (p[1] + m[1]) + "px " +
                                  (p[2] + m[2]) + "px " +
                                  (p[3] + m[3]) + "px;\
                    width : auto;\
                }\
                #apf_debugwin {\
                    position: fixed;\
                    bottom: 0px;\
                    text-align: left;\
                    height: 300px;\
                    background: #fff url(" + this.resPath + "splitter_handle_vertical.gif) no-repeat 1px 50%;\
                    width : 100%;\
                    left: 0px;\
                    z-index: 100000000;\
                }\
            ");
            document.documentElement.style.overflow = "hidden";
            this.first = false;
            
            //src='debugwin.html' 
            document.body.insertAdjacentHTML("beforeend", "<div id='apf_debugwin'><iframe frameborder='0' width='100%' height='100%' /></div>");
            this.$iframe = (this.$ext = document.getElementById("apf_debugwin")).firstChild;
            this.$iframe.isDebugWin = true;

            apf.getWindowWidth = function(){
                return document.body.offsetWidth;
            }
            apf.getWindowHeight = function(){
                return document.body.offsetHeight;
            }
            
            setTimeout(function(){
                apf.$debugwin.$iframe.src = apf.basePath + "debugwin/debugwin.html";
            });
        };

        this.$ext.style.display = "block";
        document.body.style.bottom = "300px";
    },
    
    hide : function(){
        this.$ext.style.display = "none";
        document.body.style.bottom = "0";
        
        /*if (apf.isIE8) {
            document.body.style.overflow = "";
            document.body.style.position = "";
        }*/
    },
    
    activate : function(){
        //Show me
        this.show();
    }
}




/*FILEHEAD(/var/lib/platform/source/trunk/elements/bindingrule.js)SIZE(8750)TIME(1269561674)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * @define bindings element containing all the binding rules for the data 
 * bound elements referencing this element.
 * Example:
 * <code>
 *  <a:model id="mdlList">
 *      <data>
 *          <item date="2009-11-12" deleted="0"></item>
 *          <item date="2009-11-11" deleted="0"></item>
 *      </data>
 *  </a:model>
 *  <a:bindings id="bndFolders" >
 *      <a:caption match="[@date]" />
 *      <a:icon match="[@icon]" />
 *      <a:each match="[item]" sort="[@date]" />
 *  </a:bindings>
 *  <a:list 
 *    id       = "list" 
 *    width    = "200" 
 *    height   = "200" 
 *    model    = "mdlList" 
 *    bindings = "bndFolders" />
 * </code>
 * @see element.smartbinding
 *
 * @constructor
 * @apfclass
 *
 * @author      Ruben Daniels (ruben AT ajax DOT org)
 * @version     %I%, %G%
 * @since       0.8
 *
 * @default_private
 */
apf.BindingRule = function(struct, tagName){
    this.$init(tagName || true, apf.NODE_HIDDEN, struct);
};

(function(){
    this.$bindingRule = true;
    
    this.compile = function(prop){
        return (this["c" + prop] = apf.lm.compile(this[prop], {
            xpathmode  : 3,
            injectself : true
        }));
    };
    
    this.$compile = function(prop, options){
        return (this["c" + prop + "2"] = apf.lm.compile(this[prop], options));
    };

    //1 = force no bind rule, 2 = force bind rule
    this.$attrExcludePropBind = apf.extend({
        value : 1,
        match : 1
    }, this.$attrExcludePropBind);

    this.$propHandlers["value"] = 
    this.$propHandlers["match"] = function(value, prop){
        delete this["c" + prop];
        
        if (this.$amlLoaded) {
            //Find parent that this rule works on
            var node = this;
            while (node && node.$bindingRule) 
                node = node.parentNode;
            
            if (!node) return;
            
            //Reload parent to propagate change
            apf.queue.add("reload" + node.$uniqueId, function(){
                node.reload();
            });
            
            //Recompile ruleset
            if (node.$bindings.$isCompiled)
                node.$bindings.$compiled = node.$bindings.compile(
                    this.localName != "each" && this.localName);
        }
    };
    
    /**** DOM Handlers ****/
    
    /*this.addEventListener("DOMAttrModified", function(e){
        
    });*/
    
    this.addEventListener("DOMNodeInserted", function(e){
        //Find parent that this rule works on
        var node = this;
        while (node.$bindingRule) 
            node = node.parentNode;
        
        //Reload parent to propagate change
        //@todo trigger should be maintained on node itself to prevent dual reload
        apf.queue.add("reload" + node.$uniqueId, function(){
            node.reload();
        });

        //If this node is added, add to set
        if (e.currentTarget == this) {
            (node.$bindings[this.localName] 
                || (node.$bindings[this.localName] = [])).push(this);
        }
        //@todo apf3.0 test if proc instr and cdata needs to be serialized
        //Else just update the binding value
        else  if (!this.attributes.getNamedItem("value"))
            this.value = apf.serializeChildren(this);
        //Or do nothing
        else return;

        //Recompile ruleset
        if (node.$bindings.$isCompiled)
            node.$bindings.$compiled = node.$bindings.compile(
                this.localName != "each" && this.localName);
    });
    
    this.addEventListener("DOMNodeRemoved", function(e){
        //Find parent that this rule works on
        var first, node = this;
        while (node && node.$bindingRule) 
            node = node.parentNode;
       
        if (!node)
            return;
       
        //If this node is removed, remove to set
        if (e.currentTarget == this) {
            if (node.$bindings && node.$bindings[this.localName])
                node.$bindings[this.localName].remove(this);
            else
                return;
        }
        //@todo apf3.0 test if proc instr and cdata needs to be serialized
        //Else just update the binding value
        else  if (!this.attributes.getNamedItem("value") && (first = this.firstChild)) {
            if (first.nodeType == this.NODE_PROCESSING_INSTRUCTION) {
                if (first.target == "lm")
                    this.value = "{" + first.nodeValue + "}";
                else
                    this.value = first.nodeValue;
            }
            else
                this.value = apf.serializeChildren(this).trim();
        }
        //Or do nothing
        else return;

        //Reload parent to propagate change
        apf.queue.add("reload" + node.$uniqueId, function(){
            if(!node.$amlDestroyed)
                node.reload();
        });

        //Recompile ruleset
        if (node.$bindings.$isCompiled)
            node.$bindings.$compiled = node.$bindings.compile(
                this.localName != "each" && this.localName);
    });

    this.addEventListener("DOMNodeInsertedIntoDocument", function(e){
        
        if (!this.match && (!this.value && !this.childNodes.length && !this.get
          || this.localName == "each") || this.select) {
            throw new Error(apf.formatErrorString(0, this, "Bindingrule",
                "Missing attribute 'match'")); //@todo apf3.0 turn this into a good error
        }
        

        var first;
        if (!this.value && (first = this.$aml 
          && this.$aml.firstChild || this.firstChild)) {
            if (first.nodeType == this.NODE_PROCESSING_INSTRUCTION) {
                if (first.target == "lm")
                    this.value = "{" + first.nodeValue + "}";
                else
                    this.value = first.nodeValue;
            }
            else
                this.value = apf.serializeChildren(this.$aml).trim();
        }
        
        //Find the parent this rule works on
        var pNode = this.parentNode;
        while (pNode.$bindingRule)
            pNode = pNode.parentNode;

        //Add the rule to the set
        var bindings = pNode.$bindings || (pNode.$bindings = new apf.ruleList());
        (bindings[this.localName] || (bindings[this.localName] = [])).push(this);
        
        //Compile if necessary
        if (pNode.localName != "bindings" && (this.localName != "each" || !this.childNodes.length)) {
            var ns = this;
            while((ns = ns.nextSibling) && ns.nodeType != 1);
            
            if (!ns || !ns.$bindingRule) {
                pNode.$cbindings = pNode.$bindings.compile(
                  pNode.$bindings.$isCompiled ? this.localName : null);
                
                pNode.dispatchEvent("bindingsload", {
                    bindings: pNode.$bindings, 
                    compiled: pNode.$cbindings
                });
                pNode.$checkLoadQueue();
            }
        }
    });
}).call(apf.BindingRule.prototype = new apf.AmlElement());

apf.aml.setElement("icon",       apf.BindingRule);
apf.aml.setElement("image",      apf.BindingRule);
apf.aml.setElement("caption",    apf.BindingRule);
apf.aml.setElement("css",        apf.BindingRule);
apf.aml.setElement("selectable", apf.BindingRule);
apf.aml.setElement("value",      apf.BindingRule);
apf.aml.setElement("src",        apf.BindingRule);
apf.aml.setElement("collapsed",  apf.BindingRule);
apf.aml.setElement("expanded",  apf.BindingRule);
apf.aml.setElement("empty",      apf.BindingRule);




/*FILEHEAD(/var/lib/platform/source/trunk/elements/toc.js)SIZE(8376)TIME(1269561674)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/elements/portal.js)SIZE(25107)TIME(1269561674)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/*FILEHEAD(/var/lib/platform/source/trunk/elements/audio.js)SIZE(12958)TIME(1268956869)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/elements/actionrule.js)SIZE(3885)TIME(1270640787)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */
 


/**
 * @attribute {String} match
 * @attribute {String} set
 * @attribute {String} undo
 * @attribute {String} lock
 * @define update
 * @attribute {String} get 
 * @attribute {String} parent
 * @define add
 * @attribute {Boolean} get 
 * @attribute {Boolean} parent
 */
apf.ActionRule = function(struct, tagName){
    this.$init(tagName || true, apf.NODE_HIDDEN, struct);
};

(function(){
    this.$actionRule = true;
    
    this.compile = function(prop, options){
        return (this["c" + prop] = apf.lm.compile(this[prop], 
            options || {xpathmode: 2}));
    }
    
    //1 = force no bind rule, 2 = force bind rule
    this.$attrExcludePropBind = apf.extend({
        set    : 1,
        get    : 1,
        undo   : 1,
        lock   : 1,
        match  : 1,
        parent : 1
    }, this.$attrExcludePropBind);

    this.$propHandlers["set"]   = 
    this.$propHandlers["get"]   = 
    this.$propHandlers["parent"]   = 
    this.$propHandlers["match"] = function(value, prop){
        delete this["c" + prop];
    }

    /**** DOM Handlers ****/

    this.addEventListener("DOMNodeInserted", function(e){
        if (e.currentTarget == this) {
            var pNode = this.parentNode;
            if (!pNode.$actions)
                pNode.$actions = new apf.ruleList();
            
            (pNode.$actions[this.localName] 
              || (pNode.$actions[this.localName] = [])).push(this);
        }
        else {
            if (this.attributes.getNamedItem("value"))
                return;
            
             //@todo apf3.0 test if proc instr and cdata needs to be serialized
            this.value = apf.serializeChildren(this);
       }
    });

    this.addEventListener("DOMNodeRemoved", function(e){
        if (e.currentTarget == this) {
            this.parentNode.$actions[this.localName].remove(this);
        }
        else {
            if (this.attributes.getNamedItem("value"))
                return;
            
             //@todo apf3.0 test if proc instr and cdata needs to be serialized
            this.value = apf.serializeChildren(this);
       }
    });

    this.addEventListener("DOMNodeInsertedIntoDocument", function(e){
        if (!this.get)
            this.get = apf.serializeChildren(this.$aml).trim();
        
        var actions = this.parentNode.$actions 
          || (this.parentNode.$actions = new apf.ruleList());
        
        (actions[this.localName] || (actions[this.localName] = [])).push(this);
    });
}).call(apf.ActionRule.prototype = new apf.AmlElement());

apf.aml.setElement("rename", apf.ActionRule);   
apf.aml.setElement("remove", apf.ActionRule);
apf.aml.setElement("add",    apf.ActionRule);
apf.aml.setElement("update", apf.ActionRule);
apf.aml.setElement("copy",   apf.ActionRule);
apf.aml.setElement("move",   apf.ActionRule);




/*FILEHEAD(/var/lib/platform/source/trunk/elements/flowchart.js)SIZE(50777)TIME(1270838607)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/elements/graph.js)SIZE(21558)TIME(1257329184)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/*FILEHEAD(/var/lib/platform/source/trunk/elements/remote.js)SIZE(18454)TIME(1269561674)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/elements/auth.js)SIZE(22649)TIME(1267574466)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/*FILEHEAD(/var/lib/platform/source/trunk/elements/template.js)SIZE(2498)TIME(1269561674)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/elements/item.js)SIZE(21767)TIME(1270640787)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


/**
 * Item of a menu displaying a clickable area.
 * Example:
 *  <a:iconmap 
 *    id     = "tbicons" 
 *    src    = "toolbar.icons.gif"
 *    type   = "horizontal" 
 *    size   = "20" 
 *    offset = "2,2" />
 *  <a:menu id="menu1">
 *      <a:item icon="tbicons:1">Tutorials</a:item>
 *      <a:item icon="tbicons:5">Contact</a:item>
 *  </a:menu>
 *  <a:toolbar>
 *      <a:menubar>
 *          <a:button submenu="menu1">File</a:button>
 *      </a:menubar>
 *  </a:toolbar>
 * </code>
 * @define item, check, radio
 * @constructor
 *
 * @event click Fires when a user presses the mouse button while over this element.
 *   object:
 *   {XMLElement} xmlContext the xml data node that was selected in the opener at the time of showing the context menu.
 *   {AMLElement} opener the element that was clicked upon when showing the context menu.
 */
apf.radio = function(struct, tagName){
    this.$init(tagName || "radio", apf.NODE_HIDDEN, struct);
};

apf.check = function(struct, tagName){
    this.$init(tagName || "check", apf.NODE_HIDDEN, struct);
};

apf.item  = function(struct, tagName){
    this.$init(tagName || "item", apf.NODE_HIDDEN, struct);
};

(function(){
    this.$focussable    = false;
    this.$childProperty = "caption";
    this.$canLeechSkin  = "item";

    this.implement(apf.ChildValue);

    /**** Properties and Attributes ****/
    
    //1 = force no bind rule, 2 = force bind rule
    this.$attrExcludePropBind = apf.extend({
        "match" : 1
    }, this.$attrExcludePropBind);

    this.$supportedProperties.push("submenu", "value", "match", "group", "icon",
                                   "checked", "selected", "disabled", "caption");

    /**
     * @attribute {String} [submenu] the id of the menu that is shown
     * when the user hovers over this menu item.
     * Example:
     * <code>
     *  <a:menu id="msub">
     *      <a:item icon="tbicons:12">test</a:item>
     *      <a:item icon="tbicons:14">test2</a:item>
     *  </a:menu>
     *
     *  <a:menu id="mmain">
     *      <a:item submenu="msub">Sub menu</a:item>
     *  </a:menu>
     *  
     *  <a:toolbar>
     *      <a:menubar>
     *          <a:button submenu="mmain">File</a:button>
     *      </a:menubar>
     *  </a:toolbar>
     * </code>
     */
    this.$propHandlers["submenu"] = function(value){
        apf.setStyleClass(this.$ext, "submenu");
    }
    
    /**
     * @attribute {String} value the value of this element.
     */

    /**
     * @attribute {String} [select] the xpath statement which works on the
     * xml context of the parent menu element to determine whether this
     * item is shown.
     * Example:
     * This example shows a list
     * <code>
     *   <a:menu id="mnuTest">
     *       <a:item match="[person]" method="send">Send an E-mail</a:item>
     *       <a:item match="[phone]" method="call">Call Number</a:item>
     *       <a:divider />
     *       <a:item match="[phone]" method="remove">Remove</a:item>
     *       <a:divider />
     *       <a:item match="[person|phone]" method="viewpictures">View Pictures</a:item>
     *   </a:menu>
     *   
     *   <a:menu id="mnuXY">
     *       <a:item method="reboot">Reboot</a:item>
     *   </a:menu>
     *   
     *   <a:text contextmenu="mnuXY" width="200" height="200">
     *       Please right-click on this plane
     *   </a:text>
     *   
     *   <a:list id="lstTest" allow-deselect="true" width="200" height="200">
     *       <a:each match="[person|phone|computer]">
     *           <a:caption match="[@caption]" />
     *           <a:icon match="[person]" value="user.png" />
     *           <a:icon match="[phone]" value="phone.png" />
     *           <a:icon match="[computer]" value="computer.png" />
     *       </a:each>
     *       <a:model>
     *           <data>
     *               <person caption="Ruben Daniels" />
     *               <person caption="Rik Arends" />
     *               <phone caption="+31 555 544486" />
     *               <phone caption="+1 555 2392" />
     *               <computer caption="Mail Server" />
     *               <computer caption="File Server" />
     *           </data>
     *       </a:model>
     *       <a:contextmenu menu="mnuXY" match="[computer]" />
     *       <a:contextmenu menu="mnuTest" />
     *   </a:list>
     * </code>
     */
    this.$propHandlers["select"] = function(value){
        this.select = value
            ? "self::" + value.split("|").join("|self::")
            : value;
    }
    
    /**
     * @attribute {String} [group] the name of the group this item belongs
     * to.
     * Example:
     * <code>
     *  <a:menu>
     *      <a:radio group="example">item 1</a:radio>
     *      <a:radio group="example">item 2</a:radio>
     *      <a:radio group="example">item 3</a:radio>
     *      <a:radio group="example">item 4</a:radio>
     *  </a:menu>
     * </code>
     */

    
    /**
     * @attribute {String} hotkey the key combination a user can press
     * to active the function of this element. Use any combination of
     * Ctrl, Shift, Alt, F1-F12 and alphanumerical characters. Use a
     * space, a minus or plus sign as a seperator.
     * Example:
     * <code>
     *  <a:item hotkey="Ctrl+Q">Quit</a:item>
     * </code>
     */
    this.$propHandlers["hotkey"] = function(value){
        if (this.$hotkey)
            apf.setNodeValue(this.$hotkey, value);

        if (this.$lastHotkey)
            apf.removeHotkey(this.$lastHotkey);

        if (value) {
            this.$lastHotkey = value;
            var _self = this;
            apf.registerHotkey(value, function(){
                if (_self.disabled || !_self.visible)
                    return;
                
                //hmm not very scalable...
                var buttons = apf.document.getElementsByTagNameNS(apf.ns.aml, "button");
                for (var i = 0; i < buttons.length; i++) {
                    if (buttons[i].submenu == _self.parentNode.name) {
                        var btn = buttons[i];
                        btn.$setState("Over", {});

                        $setTimeout(function(){
                            btn.$setState("Out", {});
                        }, 200);

                        break;
                    }
                }

                _self.$down();
                _self.$up();
                _self.$click();
            });
        }
    }
    
    /**
     * @attribute {String} icon the url of the image used as an icon or
     * a reference to an iconmap.
     */
    this.$propHandlers["icon"] = function(value){
        if (this.$icon)
            apf.skins.setIcon(this.$icon, value, this.parentNode.iconPath);
    }
    
    /**
     * @attribute {String} caption the text displayed on the item.
     */
    this.$propHandlers["caption"] = function(value){
        if (this.$caption)
            apf.setNodeValue(this.$caption, value);
    }
    
    /**
     * @attribute {Boolean} checked whether the item is checked.
     */
    this.$propHandlers["checked"] = function(value){
        if (this.localName != "check")
            return;

        if (apf.isTrue(value))
            apf.setStyleClass(this.$ext, "checked");
        else
            apf.setStyleClass(this.$ext, "", ["checked"]);
    }

    /**
     * @attribute {Boolean} selected whether the item is selected.
     */
    this.$propHandlers["selected"] = function(value){
        if (this.localName != "radio")
            return;

        if (apf.isTrue(value))
            apf.setStyleClass(this.$ext, "selected");
        else
            apf.setStyleClass(this.$ext, "", ["selected"]);
    }
    
    /**
     * @attribute {Boolean} disabled whether the item is active.
     */
    this.$propHandlers["disabled"] = function(value){
        if (apf.isTrue(value))
            apf.setStyleClass(this.$ext, "disabled");
        else
            apf.setStyleClass(this.$ext, "", ["disabled"]);
    }

    /**** Public Methods ****/

    /**
     * @private
     */
    this.enable = function(list){
        apf.setStyleClass(this.$ext,
            this.parentNode.$baseCSSname + "Disabled");
    };

    /**
     * @private
     */
    this.disable = function(list){
        apf.setStyleClass(this.$ext, null,
            [this.parentNode.$baseCSSname + "Disabled"]);
    };

    /**
     * @private
     */
    this.show = function(){
        this.$ext.style.display = "block";
    };

    /**
     * @private
     */
    this.hide = function(){
        this.$ext.style.display = "none";
    };

    /**** Dom Hooks ****/

    this.addEventListener("AMLReparent", function(beforeNode, pNode, withinParent){
        if (!this.$amlLoaded)
            return;

        if (!withinParent && this.skinName != pNode.skinName) {
            //@todo for now, assuming dom garbage collection doesn't leak
            this.loadAml();
        }
    });

    /**** Events ****/

    this.$down = function(){

    };

    this.$up = function(){
        if (this.localName == "radio")
            this.parentNode.select(this.group, this.value || this.caption);

        else if (this.localName == "check")
            this.$handlePropSet("checked", !this.checked);

        if (this.submenu) {
            this.$over(null, true);
            return;
        }

        this.parentNode.$hideTree = true;
        this.parentNode.hide();//true not focus?/

        this.parentNode.dispatchEvent("itemclick", {
            value : this.value || this.caption
        });

        //@todo Anim effect here?
    };

    this.$click = function(){
        this.dispatchEvent("click", {
            xmlContext : this.parentNode.xmlReference,
            opener     : this.parentNode.opener
        });
    };

    var timer;
    this.$out = function(e){
        if (apf.isChildOf(this.$ext, e.toElement || e.explicitOriginalTarget)
          || apf.isChildOf(this.$ext, e.srcElement || e.target))  //@todo test FF
            return;

        clearTimeout(timer);
        if (!this.submenu || this.$submenu(true)) {
            apf.setStyleClass(this.$ext, '', ['hover']);

            var sel = this.parentNode.$selected;
            if (sel && sel != this)
                apf.setStyleClass(sel.$ext, "", ["hover"]);

            this.parentNode.$selected = null;
        }
    };

    this.$over = function(e, force){
        if (this.parentNode.$selected == this)
            return;

        if (this.parentNode.$selected)
            apf.setStyleClass(this.parentNode.$selected.$ext, "", ["hover"]);

        apf.setStyleClass(this.$ext, "hover");
        this.parentNode.$selected = this;

        if (!force && (apf.isChildOf(this.$ext, e.toElement || e.explicitOriginalTarget)
          || apf.isChildOf(this.$ext, e.fromElement || e.target)))  //@todo test FF
            return;

        var ps = this.parentNode.$showingSubMenu;
        if (ps) {
            if (ps.name == this.submenu)
                return;

            ps.hide();
            this.parentNode.$showingSubMenu = null;
        }

        if (this.submenu) {
            if (force) {
                this.$submenu();
            }
            else {
                var _self = this;
                clearTimeout(timer);
                timer = $setTimeout(function(){
                    _self.$submenu();
                    timer = null;
                }, 200);
            }
        }
    };

    this.$submenu = function(hide, force){
        if (!this.submenu)
            return true;

        var menu = self[this.submenu];
        if (!menu) {
            
            throw new Error(apf.formatErrorString(0, this,
                "Displaying submenu",
                "Could not find submenu '" + this.submenu + "'", this.$aml));
            

            return;
        }

        if (!hide) {
            //if (this.parentNode.showingSubMenu == this.submenu)
                //return;

            this.parentNode.$showingSubMenu = menu;

            var pos = apf.getAbsolutePosition(this.$ext, this.parentNode.$ext.offsetParent);
            menu.display(pos[0] + this.$ext.offsetWidth - 3,
                pos[1] + 3, false, this,
                this.parentNode.xmlReference, this.parentNode.$uniqueId);
            menu.setAttribute("zindex", (this.parentNode.zindex || 1) + 1);
        }
        else {
            if (menu.visible && !force) {
                return false;
            }
            
            if(this.parentNode.$showingSubMenu) {
                this.parentNode.$showingSubMenu = null;
            }
            
            apf.setStyleClass(this.$ext, '', ['hover']);
            menu.hide();
            return true;
        }
    };

    /**** Init ****/
    
    this.$draw = function(isSkinSwitch){
        var p = this.parentNode;
        while (p.$canLeechSkin == "item")
            p = p.parentNode;

        //@todo apf3.0 rename doesnt work yet.
        //@todo apf3.0 implement DOM Mutation events for multiselect widgets
        //@todo apf3.0 implement attribute change triggers for icon, image, value, caption to updateNode this.$container
        //@todo apf3.x this should be rearchitected
        //@todo apf3.x the functions dont need to be overloaded if selectNodes would work properly
        if (p.hasFeature(apf.__MULTISELECT__)) {
            var _self = this;
            
            //@todo DOMNodeInserted should reset this
            //@todo DOMNodeRemoved should reset this
            if (!this.$hasSetSkinListener) {
                var f;
                this.parentNode.addEventListener("$skinchange", f = function(){
                    if (_self.$amlDestroyed) //@todo apf3.x
                        return;
                    
                    if (_self.$ext.parentNode)
                        this.$deInitNode(_self, _self.$ext);
    
                    var oInt = p == _self.parentNode ? p.$container : _self.parentNode.$container;
                    var node = oInt.lastChild;//@todo this should be more generic
                    p.$add(_self, _self.getAttribute(apf.xmldb.xmlIdTag) + "|" + this.$uniqueId, 
                        _self.parentNode, oInt != p.$container && oInt, null);
                    p.$fill();
                    
                    if (p.$isTreeArch) {
                        _self.$container = p.$getLayoutNode("item", "container", 
                           _self.$ext = node && node.nextSibling || oInt.firstChild);//@todo this should be more generic
                    }
                    else _self.$ext = node && node.nextSibling || oInt.firstChild;
                    
                    var ns = _self;
                    while((ns = ns.nextSibling) && ns.nodeType != 1);
        
                    if (!ns || ns.$canLeechSkin != "item")
                        p.dispatchEvent("afterload");
                });
                this.addEventListener("DOMNodeRemoved", function(e){
                    this.parentNode.removeEventListener("$skinchange", f);
                });
                
                this.$hasSetSkinListener = true;
            }
            
            if (!p.$itemInited) {
                p.canrename = false; //@todo fix rename
                p.$removeClearMessage(); //@todo this should be more generic
                p.$itemInited = [p.getTraverseNodes, p.getFirstTraverseNode, p.getTraverseParent];
                
                p.getTraverseNodes = function(xmlNode){
                    return (xmlNode || p).getElementsByTagNameNS(apf.ns.apf, "item");
                }
                p.getFirstTraverseNode = function(xmlNode){
                    return (xmlNode || p).getElementsByTagNameNS(apf.ns.apf, "item")[0];
                }
                p.getTraverseParent = function(xmlNode){
                    return xmlNode && xmlNode.parentNode;
                }
                p.each = (this.prefix ? this.prefix + ":" : "") + "item";

                //@todo this is all an ugly hack (copied to baselist.js line 868)
                p.$preventDataLoad = true;//@todo apf3.0 add remove for this

                p.$initingModel = true;
                p.$setDynamicProperty("icon", "[@icon]");
                p.$setDynamicProperty("image", "[@image]");
                p.$setDynamicProperty("caption", "[label/text()|@caption|text()]");
                p.$setDynamicProperty("eachvalue", "[value/text()|@value|text()]");
                p.$canLoadDataAttr = false;
                
                if (!p.xmlRoot)
                    p.xmlRoot = p;
            }
            
            this.$loadAml = function(){
                //hack
                if (!this.getAttribute("caption"))
                    this.setAttribute("caption", this.caption);
                
                var oInt = p == this.parentNode ? p.$container : this.parentNode.$container;
                var node = oInt.lastChild;//@todo this should be more generic
                if (!p.documentId)
                    p.documentId = apf.xmldb.getXmlDocId(this);
                p.$add(this, apf.xmldb.nodeConnect(p.documentId, this, null, p), 
                    this.parentNode, oInt != p.$container && oInt, null);
                p.$fill();
    
                if (p.$isTreeArch) {
                    this.$container = p.$getLayoutNode("item", "container", 
                       this.$ext = node && node.nextSibling || oInt.firstChild);//@todo this should be more generic
                }
                else this.$ext = node && node.nextSibling || oInt.firstChild;
                
                var ns = this;
                while((ns = ns.nextSibling) && ns.nodeType != 1);
    
                if (!ns || ns.$canLeechSkin != "item") {
                    p.dispatchEvent("afterload");
                    if (p.autoselect)
                        p.$selectDefault(this.parentNode);
                }
            }
            
            return;
        }
        
        this.$ext = this.$getExternal(this.$isLeechingSkin
          ? "item" //this.localName 
          : "main", null, function($ext){
            var o = 'var o = apf.lookup(' + this.$uniqueId + '); if (o.disabled) return; o';
            $ext.setAttribute("onmouseup",   o + '.$up(event)');
            $ext.setAttribute("onmousemove", o + '.$over(event)');
            $ext.setAttribute("onmouseout",  o + '.$out(event)');
            $ext.setAttribute("onmousedown", o + '.$down()');
            $ext.setAttribute("onclick",     o + '.$click()');
        });

        /*p.$getNewContext("item");
        var elItem = p.$getLayoutNode("item");*/
        
        //@todo if not elItem try using own skin

        apf.setStyleClass(this.$ext, this.localName);

        //this.$ext   = apf.insertHtmlNode(elItem, this.parentNode.$container);
        this.$caption = this.$getLayoutNode("item", "caption", this.$ext)
        this.$icon    = this.$getLayoutNode("item", "icon", this.$ext);
        this.$hotkey  = this.$getLayoutNode("item", "hotkey", this.$ext);

        if (!isSkinSwitch && this.nextSibling && this.nextSibling.$ext)
            this.$ext.parentNode.insertBefore(this.$ext, this.nextSibling.$ext);
    };

    /**
     * @private
     */
    this.addEventListener("DOMNodeInsertedIntoDocument", function(e){
        //var x = this.$aml;

        //this.skinName    = this.parentNode.skinName;
        var isSkinSwitch = this.$ext ? true : false;
        if (isSkinSwitch) {
            if (typeof this.checked !== "undefined")
                this.$handlePropSet("checked", this.checked);
            else if (typeof this.selected !== "undefined")
                this.$handlePropSet("selected", this.selected);

            if (this.disabled)
                this.$handlePropSet("disabled", this.disabled);

            if (this.caption)
                this.$handlePropSet("caption", this.caption);
        }
    });
}).call(apf.item.prototype = new apf.Presentation());

apf.radio.prototype =
apf.check.prototype = apf.item.prototype;

apf.aml.setElement("radio", apf.radio);
apf.aml.setElement("check", apf.check);
apf.aml.setElement("item",  apf.item);


/*FILEHEAD(/var/lib/platform/source/trunk/elements/modalwindow.js)SIZE(26206)TIME(1270838607)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/elements/xmpp.js)SIZE(90780)TIME(1269451399)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/elements/actiontracker.js)SIZE(34202)TIME(1270838607)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * Element keeping track of all user actions that are triggered in GUI
 * elements. This element maintains a stack of actions and knows how to
 * undo & redo them. It is aware of how to synchronize the changes to the
 * backend data store.
 * Example:
 * <code>
 *   datagrid.getActionTracker().undo();
 * </code>
 * Remarks:
 * With offline support enabled the actiontracker can
 * serialize both its undo stack and its execution stack such that these can
 * be kept in between application sessions. This means that a user will be able
 * to close the application and start it at a later date whilst keeping his or
 * her entire undo/redo stack. Furthermore all changes done whilst being offline
 * will be synchronized to the data store when the application comes online.
 *
 * @constructor
 * @inherits apf.Class
 *
 * @define actiontracker
 * @addnode smartbinding, global
 * @event afterchange   Fires after a change to the action stack occurs
 *    object:
 *    {String} action the name of the action that was execution
 * @event beforechange  Fires before a change to the action stack will occur
 *   cancelable:    Prevents the execution of the action.
 *   object:
 *   {String}  action           the action to be executed
 *   {Array}   args             the arguments for the action
 *   {XmlNode} [xmlActionNode]  the rules to synchronize the changes to the server
 *                              for both execution and undo. (See action rules)
 *   {AmlNode} [amlNode]        the GUI element that triggered the action
 *   {XmlNode} [selNode]        the relevant {@link term.datanode data node} to
 *                              which the action node works on
 *   {Number}  [timestamp]      the start of the action that is now executed.
 * @event actionfail Fires when an action fails to be sent to the server.
 *   bubbles: true
 *   object:
 *     {Error}          error     the error object that is thrown when the event
 *                                callback doesn't return false.
 *     {Number}         state     the state of the call
 *       Possible values:
 *       apf.SUCCESS  the request was successfull
 *       apf.TIMEOUT  the request has timed out.
 *       apf.ERROR    an error has occurred while making the request.
 *       apf.OFFLINE  the request was made while the application was offline.
 *     {mixed}          userdata  data that the caller wanted to be available in
 *                                the callback of the http request.
 *     {XMLHttpRequest} http      the object that executed the actual http request.
 *     {String}         url       the url that was requested.
 *     {Http}           tpModule  the teleport module that is making the request.
 *     {Number}         id        the id of the request.
 *     {String}         message   the error message.
 * @see term.locking
 * @event actionsuccess Fires when an action is successfully sent to the server.
 *   bubbles: true
 *   object:
 *     {Number}         state     the state of the call
 *       Possible values:
 *       apf.SUCCESS  the request was successfull
 *       apf.TIMEOUT  the request has timed out.
 *       apf.ERROR    an error has occurred while making the request.
 *       apf.OFFLINE  the request was made while the application was offline.
 *     {mixed}          userdata  data that the caller wanted to be available in
 *                                the callback of the http request.
 *     {XMLHttpRequest} http      the object that executed the actual http request.
 *     {String}         url       the url that was requested.
 *     {Http}           tpModule  the teleport module that is making the request.
 *     {Number}         id        the id of the request.
 *
 * @author      Ruben Daniels (ruben AT ajax DOT org)
 * @version     %I%, %G%
 * @since       0.8
 */
apf.actiontracker = function(struct, tagName){
    this.$init(tagName || "actiontracker", apf.NODE_HIDDEN, struct);
    
    this.$undostack = [];
    this.$redostack = [];
    this.$execstack = [];
    
};

(function(){
    this.$lastExecStackItem = null;

    this.realtime   = true;
    this.undolength = 0;
    this.redolength = 0;
    

    /**
     * @attribute {Number}  !undolength the length of the undo stack.
     * @attribute {Number}  !redolength the length of the redo stack.
     * @attribute {Number}  !length     the length of the undo/redo stack combined. Use this attribute to bind a slider's max attribute to.
     * @attribute {Number}  position    the position within the total length (same value as undolength). Use this attribute to bind a slider's value attribute to.
     * @attribute {Boolean} realtime    whether changes are immediately send to
     * the datastore, or held back until purge() is called.
     */
    this.$booleanProperties = {};
    this.$booleanProperties["realtime"] = true;
    this.$supportedProperties = ["realtime", "undolength", "redolength", "alias", "length", "position"];
    this.$handlePropSet = function(prop, value, force){
        //Read only properties
        switch (prop) {
            case "undolength":
                this.undolength = this.$undostack.length;
                
                break;
            case "redolength":
                this.redolength = this.$redostack.length;
                break;
            
            
            default:
                this[prop] = value;
        }
    };
    
    this.addEventListener("DOMNodeInsertedIntoDocument", function(e){
        if (this.parentNode)
            this.parentNode.$at = this;
    });
    
    
    
    /**
     * Adds a new action handler which can be used by any actiontracker.
     * @param {String} action Specifies the name of the action
     * @param {Function} func Specifies the function that is executed when
     *                        Executing or undoing the action.
     */
    this.define = function(action, func){
        apf.actiontracker.actions[action] = func;
    };

    /**
     * Searches for the actiontracker that functions as a parent for this one.
     * @return {ActionTracker} Returns the parent actiontracker
     */
    this.getParent = function(){
        return this.parentNode && this.parentNode.getActionTracker
            ? this.parentNode.getActionTracker(true)
            : (apf.window.$at != this ? apf.window.$at : null);
    };

    this.getDone = function(time) {
        if (typeof time != "number")
            return [];
        for (var o, l, i = l = this.$stackDone.length; i >= 0; --i) {
            if (!(o = this.$stackDone[i]) || !o.timestamp) continue;
            if (o.timestamp >= time)
                return this.$stackDone.slice(i);
        }
        return [];
    };

    this.getUndone = function(time) {
        if (typeof time != "number")
            return [];
        for (var o, i = 0, l = this.$stackDone.length; i < l; ++i) {
            if (!(o = this.$stackUndone[i]) || !o.timestamp) continue;
            if (o.timestamp <= time)
                return this.$stackUndone.slice(0, i + 1);
        }
        return [];
    };

    /**
     * Executes an action, which later can be undone and of which the execution
     * can be synchronized to the data store.
     * @param {Object} options the details of the execution.
     *   Properties:
     *   {String}  action           the action to be executed
     *   {Array}   args             the arguments for the action
     *   {XmlNode} [xmlActionNode]  the rules to synchronize the changes to the
     *                              server for both execution and undo. (See action rules)
     *   {AmlNode} [amlNode]        the GUI element that triggered the action
     *   {XmlNode} [selNode]        the relevant {@link term.datanode data node}
     *                              to which the action node works on
     *   {Number}  [timestamp]      the start of the action that is now executed.
     */
    this.execute = function(options){
        if (this.dispatchEvent("beforechange", options) === false)
            return false;

        //Execute action
        var UndoObj = new apf.UndoData(options, this);
        if (options.action && !options.transaction)
            apf.actiontracker.actions[options.action](UndoObj, false, this);

        //Add action to stack
        UndoObj.id = this.$undostack.push(UndoObj) - 1;

        this.setProperty("undolength", this.$undostack.length);

        

        //Respond
        if (UndoObj.multiple) 
            this.$addToQueue(UndoObj.multiple, false, true);
        else
            this.$addToQueue(UndoObj, false);

        //Reset Redo Stack
        this.$redostack.length = 0;
        this.setProperty("redolength", this.$redostack.length);
        
        

        this.dispatchEvent("afterchange", {
            action   : "do"
        })

        //return stack id of action
        return UndoObj;
    };

    //deprecated??
    /*this.$addActionGroup = function(done, rpc){
        var UndoObj = new apf.UndoData("group", null, [
            //@todo apf.copyArray is deprecated and no longer exists
            apf.copyArray(done, UndoData), apf.copyArray(rpc, UndoData)
        ]);
        this.$undostack.push(UndoObj);
        this.setProperty("undolength", this.$undostack.length);
        
        //@todo reset redo here?
        
        

        this.dispatchEvent("afterchange", {action: "group", done: done});
    };*/

    /**
     * Synchronizes all held back changes to the data store.
     * @todo I don't really know if this stacking into the parent is
     * still used, for instance for apf.Transaction. please think
     * about it.
     */
    this.purge = function(nogrouping, forcegrouping){//@todo, maybe add noReset argument
        //var parent = this.getParent();

        //@todo Check if this still works together with transactions
        if (true) {//nogrouping && parent
            if (this.$execstack.length) {
                this.$execstack[0].undoObj.saveChange(this.$execstack[0].undo, this);
                this.$lastExecStackItem = this.$execstack[this.$execstack.length - 1];
            }
        }
        else if (parent) {
            /*
                Copy Stacked Actions as a single
                grouped action to parent ActionTracker
            */
            //parent.$addActionGroup(this.$undostack, stackRPC);
            
            //Reset Stacks
            this.reset();
        }
    };
    
    

    /**
     * Empties the action stack. After this method is run running undo
     * or redo will not do anything.
     */
    this.reset = function(){
        this.$undostack.length = this.$redostack.length = 0;

        this.setProperty("undolength", 0);
        this.setProperty("redolength", 0);
        

        this.dispatchEvent("afterchange", {action: "reset"});
    };

    /**
     * Revert the most recent action on the action stack
     */
    this.undo = function(id, single, rollback){
        change.call(this, id, single, true, rollback);
    };

    /**
     * Re-executes the last undone action
     */
    this.redo = function(id, single, rollback){
        change.call(this, id, single, false, rollback);
    };

    function change(id, single, undo, rollback){
        var undoStack = undo ? this.$undostack : this.$redostack, //local vars switch
            redoStack = undo ? this.$redostack : this.$undostack; //local vars switch

        if (!undoStack.length) return;
        
        if (single) {
            var UndoObj = undoStack[id];
            if (!UndoObj) return;

            
            if (id != undoStack.length - 1) //@todo callstack got corrupted?
                throw new Error("callstack got corrupted");
            
            undoStack.length--;
            redoStack.push(UndoObj); //@todo check: moved from outside if(single)

            

            //Undo Client Side Action
            if (UndoObj.action)
                apf.actiontracker.actions[UndoObj.action](UndoObj, undo, this);

            if (!rollback) {
                if (UndoObj.multiple) 
                    this.$addToQueue(UndoObj.multiple, undo, true);
                else
                    this.$addToQueue(UndoObj, undo);
            }

            //Set Changed Value
            this.setProperty("undolength", this.$undostack.length);
            this.setProperty("redolength", this.$redostack.length);
            return UndoObj;
        }

        if (this.dispatchEvent("beforechange") === false)
            return;

        
        apf.console.info("Executing " + (undo ? "undo" : "redo"));
        

        //Undo the last X places - where X = id;
        if (id == -1)
            id = undoStack.length;

        if (!id)
            id = 1;

        var i = 0;
        while (i < id && undoStack.length > 0) {
            if (!undoStack[undoStack.length - 1]) {
                undoStack.length--;

                
                apf.console.error("The actiontracker is in an invalid \
                                   state. The entire undo and redo stack will \
                                   be cleared to prevent further corruption\
                                   This is a serious error, please contact \
                                   the system administrator.");
                

                this.$undostack = [];
                this.$redostack = [];

                

                return false;
            }
            else {
                change.call(this, undoStack.length - 1, true, undo, rollback);
                i++;
            }
        }

        this.dispatchEvent("afterchange", {
            action   : undo ? "undo" : "redo",
            rollback : rollback
        })
    }

    this.$receive = function(data, state, extra, UndoObj, callback){
        if (state == apf.TIMEOUT
          && extra.tpModule.retryTimeout(extra, state, this) === true)
            return true;

        if (state != apf.SUCCESS) {
            //Tell anyone that wants to hear about our failure :(
            if (this.dispatchEvent("actionfail", apf.extend(extra, {
                  state   : state,
                  message : "Could not sent Action RPC request for control "
                          + this.name
                          + "[" + this.localName + "] \n\n"
                          + extra.message,
                  bubbles : true
              })) === false) {

                
                apf.console.warn("You have cancelled the automatic undo \
                    process! Please be aware that if you don't retry this call \
                    the queue will fill up and none of the other actions will \
                    be sent through.");
                

                return true; //don't delete the call from the queue
            }

            /*
                Undo the failed action. We're only undoing one item of the stack
                if the developer has told us using the @ignore-fail attribute
                that it's ok, the data will be safe if we undo only this one.

                @todo: Shouldn't the stackUndone be cleared after this... or
                       is it intuitive enough for the user that redo will
                       let the user retry the action??
            */
            if (typeof apf.offline != "undefined" && !apf.offline.reloading)
                this.undo(UndoObj.id, extra.userdata, true);

            if (callback)
                callback(!extra.userdata);

            if (!extra.userdata) {
                /*
                    Clearing the execStack, none of the changes will be send to
                    the server. This seems the best way right now and is related
                    to the todo item above.
                    
                    @todo: Think about adding ignore-fail to settings and 
                           actiontracker.
                */
                this.$execstack = [];
                
                var oError = new Error(apf.formatErrorString(0, this, 
                    "Executing action",
                    "Error sending action to the server:\n"
                    + (extra.url ? "Url:" + extra.url + "\n\n" : "") 
                    + extra.message));

                if ((UndoObj && UndoObj.xmlActionNode || extra.amlNode || apf)
                  .dispatchEvent("error", apf.extend({
                    error   : oError,
                    state   : state,
                    bubbles : true
                }, extra)) === false)
                    return;
                    
                throw oError;
            }
        }
        else {
            //Tell anyone that wants to hear about our success
            this.dispatchEvent("actionsuccess", apf.extend(extra, {
                state   : state,
                bubbles : true
            }, extra));

            

            if (callback)
                callback();
        }

        this.$queueNext(UndoObj, callback);
    };

    this.$addToQueue = function(UndoObj, undo, isGroup){
        /*
            Remove item from the execution stack if it's not yet executed
            to keep the stack clean
        */
        //@todo Implement this for isGroup if deemed useful
        if (!isGroup && this.$execstack.length && !UndoObj.state
          && this.$execstack[this.$execstack.length - 1].undoObj == UndoObj) {
            this.$execstack.length--;

            

            

            return;
        }

        var idx, undoObj, qItem;
        // Add the item to the queue
        if (isGroup) { //@todo currently no offline support for grouped actions
            var undoObj, qItem = this.$execstack.shift();
            for (var i = 0; i < UndoObj.length; i++) {
                undoObj = UndoObj[i];
                this.$execstack.unshift({
                    undoObj : (undoObj.tagName 
                        ? undoObj 
                        : new apf.UndoData(undoObj, this)).preparse(undo, this),
                    undo   : undo
                });
            }
            if (qItem)
                this.$execstack.unshift(qItem);

            return;
        }

        qItem = {
            undoObj: UndoObj.preparse(undo, this),
            undo   : undo

        };
        this.$execstack.push(qItem) - 1;

        

        //The queue was empty, yay! we're gonna exec immediately
        if (this.$execstack.length == 1 && this.realtime)
            UndoObj.saveChange(undo, this);
    };

    this.$queueNext = function(UndoObj, callback){
        /*
            These thow checks are so important, that they are also executed
            in release mode.
        */
        if (!this.$execstack[0] || this.$execstack[0].undoObj != UndoObj){
            throw new Error(apf.formatErrorString(0, this, "Executing Next \
                action in queue", "The execution stack was corrupted. This is \
                a fatal error. The application should be restarted. You will \
                lose all your changes. Please contact the administrator."));
        }

        //Reset the state of the undo item
        UndoObj.state = null;

        //Remove the action item from the stack
        var lastItem = this.$execstack.shift();

        

        //Check if there is a new action to execute;
        if (!this.$execstack[0] || lastItem == this.$lastExecStackItem)
            return;

        // @todo you could optimize this process by using multicall, but too much for now

        //Execute action next in queue
        this.$execstack[0].undoObj.saveChange(this.$execstack[0].undo, this, callback);
    };

    
}).call(apf.actiontracker.prototype = new apf.AmlElement());

apf.aml.setElement("actiontracker", apf.actiontracker);




/*FILEHEAD(/var/lib/platform/source/trunk/elements/param.js)SIZE(1681)TIME(1257329184)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * element specifying an argument of a method in an rpc element.
 * @attribute {String}  name             the argument name.
 * @attribute {String}  [value]          the value of the argument.
 * @attribute {String}  [default]        the default value of the argument. If
 *                                       no value is specified when this function
 *                                       is called, the default value is used.
 */
apf.param = function(struct, tagName){
    this.$init(tagName || "param", apf.NODE_HIDDEN, struct);
};

apf.param.prototype = new apf.AmlElement();
apf.param.prototype.$parsePrio = "002";
apf.aml.setElement("variable", apf.param); //backwards compatibility
apf.aml.setElement("param", apf.param);


/*FILEHEAD(/var/lib/platform/source/trunk/elements/spinner.js)SIZE(16997)TIME(1270838607)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/elements/datagrid.js)SIZE(46585)TIME(1271109901)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */







/**
 * Element providing a sortable, selectable grid containing scrollable 
 * information. Grid columns can be reordered and resized.
 * Example:
 * This example shows a datagrid width several columns mixing percentage and
 * fixed size columns.
 * <code>
 *  <a:model id="mdlNews">
 *      <data>
 *          <news title="text 1" subtitle="text 11" date="2009-11-18"></news>
 *          <news title="text 2" subtitle="text 21" date="2009-11-19"></news>
 *          <news title="text 3" subtitle="text 31" date="2009-11-20"></news>
 *      </data>
 *  </a:model>
 *  <a:datagrid model="mdlNews" options="move|size">
 *      <a:each match="[news]">
 *          <a:column caption="Icon" type="icon" width="40" value="newspaper.png" />
 *          <a:column caption="Date" value="[@date]" width="70" />
 *          <a:column caption="Title" width="180" value="[@title]" />
 *          <a:column caption="Subtitle" value="[@subtitle]" width="100" />
 *      </a:each>
 *  </a:datagrid>
 * </code>
 *
 * @constructor
 * @define datagrid
 * @addnode elements
 *
 * @author      Ruben Daniels (ruben AT ajax DOT org)
 * @version     %I%, %G%
 * @since       0.4
 *
 * @inherits apf.BaseTree
 *
 * @binding invalidmsg  Determines the error message that is shown when a cell is not valid.
 * @binding description Determines the text that is displayed under the expanded row.
 */
apf.datagrid = function(struct, tagName){
    this.$init(tagName || "datagrid", apf.NODE_VISIBLE, struct);
    
    this.$headings       = [],
    this.$cssRules       = []; //@todo Needs to be reset;
    this.$lastOpened     = {};
    
    this.$editors        = {};
    
    
    this.$dynCssClasses = [];
    
};

(function(){
    var HAS_CHILD = 1 << 1,
        IS_CLOSED = 1 << 2,
        IS_LAST   = 1 << 3,
        IS_ROOT   = 1 << 4,
        treeState = this.$treeState;
    
    /*this.$init(function() {
        this.addEventListener("keydown", keyHandler, true);
    });*/
    
    this.bufferselect       = false;
    this.$useTable          = false;
    this.$focussable        = true;
    this.$isWindowContainer = -1;
    
    this.$widthdiff      = 0;
    this.$defaultwidth   = 0;
    this.$useiframe      = 0;
    this.$needsDepth     = true;
    
    
    this.canrename = false; //@todo remove rename from basetree and move to tree.js
    

    /**
     * @attribute {Boolean} iframe     whether this element is rendered inside an iframe. This is only supported for IE. Default is false for datagrid and true for spreadsheet and propedit.
     */
    this.$booleanProperties["iframe"]     = true;

    /**
     * This method imports a stylesheet defined in a multidimensional array 
     * @param {Array}    def Required Multidimensional array specifying 
     * @param {Object}    win Optional Reference to a window
     * @method
     * @deprecated
     */    
    function importStylesheet(def, win){
        for (var i = 0; i < def.length; i++) {
            if (!def[i][1]) continue;
            
            if (apf.isIE)
                (win || window).document.styleSheets[0].addRule(def[i][0],
                    def[i][1]);
            else
                (win || window).document.styleSheets[0].insertRule(def[i][0]
                    + " {" + def[i][1] + "}", 0);
        }
    }
    
    function scrollIntoView(){
        var Q = (this.current || this.$selected),
            o = this.$container;
        o.scrollTop = (Q.offsetTop) - 21;
    }

    /**** Keyboard Support ****/
    
    
    /*function keyHandler(e){
        var key      = e.keyCode,
            ctrlKey  = e.ctrlKey,
            shiftKey = e.shiftKey,
            selHtml  = this.$selected || this.$caret;
        
        if (!e.force && (!selHtml || this.renaming)) //@todo how about allowdeselect?
            return;

        var selXml = this.caret || this.selected,
            oInt   = this.$useiframe ? this.oDoc.documentElement : this.$container,
            margin, node, hasScroll, hasScrollX, hasScrollY, items, lines;

        switch (key) {
            case 13:
                if (this.$tempsel)
                    this.$selectTemp();
            
                this.choose(selHtml);
                break;
            case 32:
                if (ctrlKey || !this.isSelected(this.caret))
                    this.select(this.caret, true);
                return false;
            case 109:
            case 46:
                //DELETE
                if (this.disableremove) 
                    return;
                    
                if (this.celledit) {
                    this.rename(this.caret || this.selected, "");
                    return;
                }
            
                if (this.$tempsel)
                    this.$selectTemp();
            
                this.remove(this.mode ? this.caret : null); //this.mode != "check"
                break;
            case 36:
                //HOME
                this.$setTempSelected (this.getFirstTraverseNode(), false, shiftKey);
                this.$container.scrollTop = 0;
                return false;
            case 35:
                //END
                this.$setTempSelected (this.getLastTraverseNode(), false, shiftKey);
                this.$container.scrollTop = this.$container.scrollHeight;
                return false;
            case 107:
                //+
                if (this.more)
                    this.startMore();
                break;
            case 37:
                //LEFT
                if (this.$tempsel)
                    this.$selectTemp();
                    
                if (this.cellselect) {
                    if (this.$lastcell) {
                        if (this.$lastcell.previousSibling) {
                            this.selectCell({target:this.$lastcell.previousSibling},
                                this.$selected);
                        }
                    }
                    else {
                        this.selectCell({target:this.$selected.firstChild}, 
                            this.$selected);
                    }
                }
                else if (this.$withContainer)
                    this.slideToggle(this.$caret || this.$selected, 2)
                return false;
            case 107:
            case 39:
                //RIGHT
                if (this.$tempsel)
                    this.$selectTemp();
                    
                if (this.cellselect) {
                    if (this.$lastcell) {
                        if (this.$lastcell.nextSibling) {
                            this.selectCell({target:this.$lastcell.nextSibling},
                                this.$selected);
                        }
                    }
                    else {
                        this.selectCell({target:this.$selected.firstChild}, 
                            this.$selected);
                    }
                }
                else if (this.$withContainer)
                    this.slideToggle(this.$caret || this.$selected, 1)
                    
                return false;
            case 38:
                //UP
                if (!selXml && !this.$tempsel) 
                    return false;
                    
                node = this.$tempsel 
                    ? apf.xmldb.getNode(this.$tempsel) 
                    : selXml;

                margin    = apf.getBox(apf.getStyle(selHtml, "margin"));
                hasScroll = oInt.scrollHeight > oInt.offsetHeight;
                items     = Math.floor((oInt.offsetWidth
                    - (hasScroll ? 15 : 0)) / (selHtml.offsetWidth
                    + margin[1] + margin[3]));
                
                node = this.getNextTraverseSelected(node, false, items);
                if (node)
                    this.$setTempSelected (node, ctrlKey, shiftKey);
                else
                    return false;

                selHtml = apf.xmldb.findHtmlNode(node, this);
                if (selHtml.offsetTop <= oInt.scrollTop) {
                    oInt.scrollTop = (Array.prototype.indexOf.call(this.getTraverseNodes(), node) < items
                      ? 0
                      : selHtml.offsetTop - margin[0])
                        - parseInt(apf.getStyle(oInt, apf.isIE 
                            ? "paddingTop" 
                            : "padding-top"));
                }
                return false;
            case 40:
                //DOWN
                if (!selXml && !this.$tempsel) 
                    return false;
                    
                node = this.$tempsel 
                    ? apf.xmldb.getNode(this.$tempsel) 
                    : selXml;
                
                margin    = apf.getBox(apf.getStyle(selHtml, "margin"));
                hasScroll = oInt.scrollHeight > oInt.offsetHeight;
                items     = Math.floor((oInt.offsetWidth
                    - (hasScroll ? 15 : 0)) / (selHtml.offsetWidth
                    + margin[1] + margin[3]));
                
                node = this.getNextTraverseSelected(node, true, items);
                if (node)
                   this.$setTempSelected (node, ctrlKey, shiftKey);
                else
                    return false;
                
                selHtml = apf.xmldb.findHtmlNode(node, this);
                if (selHtml.offsetTop + selHtml.offsetHeight
                  > oInt.scrollTop + oInt.offsetHeight) // - (hasScroll ? 10 : 0)
                    oInt.scrollTop = selHtml.offsetTop
                        - oInt.offsetHeight + selHtml.offsetHeight
                        + margin[0]; //+ (hasScroll ? 10 : 0)
                
                return false;
            case 33:
                //PGUP
                if (!selXml && !this.$tempsel) 
                    return false;
                    
                node = this.$tempsel 
                    ? apf.xmldb.getNode(this.$tempsel) 
                    : selXml;
                
                margin     = apf.getBox(apf.getStyle(selHtml, "margin"));
                hasScrollY = oInt.scrollHeight > oInt.offsetHeight;
                hasScrollX = oInt.scrollWidth > oInt.offsetWidth;
                items      = Math.floor((oInt.offsetWidth
                    - (hasScrollY ? 15 : 0)) / (selHtml.offsetWidth
                    + margin[1] + margin[3])) || 1;
                lines      = Math.floor((oInt.offsetHeight
                    - (hasScrollX ? 15 : 0)) / (selHtml.offsetHeight
                    + margin[0] + margin[2]));
                
                node = this.getNextTraverseSelected(node, false, items * lines);
                if (!node)
                    node = this.getFirstTraverseNode();
                if (node)
                   this.$setTempSelected (node, ctrlKey, shiftKey);
                else
                    return false;
                
                selHtml = apf.xmldb.findHtmlNode(node, this);
                if (selHtml.offsetTop < oInt.scrollTop) {
                    oInt.scrollTop = (Array.prototype.indexOf.call(this.getTraverseNodes(), node) < items
                      ? 0
                      : selHtml.offsetTop - margin[0]) 
                        - parseInt(apf.getStyle(oInt, apf.isIE 
                            ? "paddingTop" 
                            : "padding-top"));
                }
                return false;
            case 34:
                //PGDN
                if (!selXml && !this.$tempsel) 
                    return false;

                node = this.$tempsel 
                    ? apf.xmldb.getNode(this.$tempsel) 
                    : selXml;
                
                margin     = apf.getBox(apf.getStyle(selHtml, "margin"));
                hasScrollY = oInt.scrollHeight > oInt.offsetHeight;
                hasScrollX = oInt.scrollWidth > oInt.offsetWidth;
                items      = Math.floor((oInt.offsetWidth - (hasScrollY ? 15 : 0))
                    / (selHtml.offsetWidth + margin[1] + margin[3])) || 1;
                lines      = Math.floor((oInt.offsetHeight - (hasScrollX ? 15 : 0))
                    / (selHtml.offsetHeight + margin[0] + margin[2]));
                
                node = this.getNextTraverseSelected(selXml, true, items * lines);
                if (!node)
                    node = this.getLastTraverseNode();
                if (node)
                   this.$setTempSelected (node, ctrlKey, shiftKey);
                else
                    return false;
                
                selHtml = apf.xmldb.findHtmlNode(node, this);
                if (selHtml.offsetTop + selHtml.offsetHeight
                  > oInt.scrollTop + oInt.offsetHeight) // - (hasScrollY ? 10 : 0)
                    oInt.scrollTop = selHtml.offsetTop
                        - oInt.offsetHeight + selHtml.offsetHeight
                        + margin[0]; //+ 10 + (hasScrollY ? 10 : 0)
                return false;
            default:
                if (this.celledit) {
                    if (!ctrlKey && !e.altKey && (key > 46 && key < 112 || key > 123))
                        this.startRename(null, true);
                    return;
                }
                else if (key == 65 && ctrlKey) {
                    this.selectAll();
                    return false;
                } 
                //@todo make this work with the sorted column
                else if (this.caption || (this.bindingRules || {})["caption"]) {
                    if (!this.xmlRoot) return;
                    
                    //this should move to a onkeypress based function
                    if (!this.lookup || new Date().getTime()
                      - this.lookup.date.getTime() > 300)
                        this.lookup = {
                            str  : "",
                            date : new Date()
                        };
                    
                    this.lookup.str += String.fromCharCode(key);
    
                    var nodes = this.getTraverseNodes(); //@todo start at current indicator
                    for (var v, i = 0; i < nodes.length; i++) {
                        v = this.$applyBindRule("caption", nodes[i]);
                        if (v && v.substr(0, this.lookup.str.length)
                          .toUpperCase() == this.lookup.str) {
                            
                            if (!this.isSelected(nodes[i])) {
                                if (this.mode == "check")
                                    this.setCaret(nodes[i]);
                                else
                                    this.select(nodes[i]);
                            }
                            
                            if (selHtml)
                                this.$container.scrollTop = selHtml.offsetTop
                                    - (this.$container.offsetHeight
                                    - selHtml.offsetHeight) / 2;
                            return;
                        }
                    }
                    return;
                }
                break;
        };
        
        this.lookup = null;
        //return false;
    }*/
    
    
    
    /**** Focus ****/
    // Too slow for IE
    
    this.$focus = function(){
        if (!this.$ext || (apf.isIE && this.$useiframe && this.cssfix)) //@todo fix this by fixing focussing for this component
            return;

        this.$setStyleClass(this.$ext, this.$baseCSSname + "Focus");
        
        if (this.oDoc)
            this.$setStyleClass(this.oDoc.documentElement, this.$baseCSSname + "Focus");
    };

    this.$blur = function(){
        //@todo fix this by fixing focussing for this component
        if (!this.$ext || (apf.isIE && this.$useiframe && this.cssfix))
            return;

        this.$setStyleClass(this.$ext, "", [this.$baseCSSname + "Focus"]);
        
        if (this.oDoc)
            this.$setStyleClass(this.oDoc.documentElement, "", [this.$baseCSSname + "Focus"]);
        
        hideEditor.call(this);
    };
    
    /**** Databinding ****/
    
    this.addEventListener("bindingsload", this.$loaddatabinding = function(e){
        var rules = e.bindings["column"];
        if (!rules || !rules.length)
            return;
        
        this.$headings = rules;
        
        var fixed = 0, found = false;
        for (var h, i = 0, l = rules.length; i < l; i++) {
            h = rules[i];
            
            
            if (!h.$width)
                throw new Error("missing width"); //temporary check
            
            
            if (!h.$isPercentage)
                fixed += parseFloat(h.$width) || 0;
            else 
                found = true;
        }
        
        if (!found) { //@todo removal???
            this.$isFixedGrid = true;
            this.$setStyleClass(this.$ext, "fixed");
            
            if (this.$useiframe)
                this.$setStyleClass(this.oDoc.documentElement, "fixed");
        }
        else {
            //@todo remove
        }

        if (fixed > 0 && !this.$isFixedGrid) {
            var vLeft = fixed;
            
            //first column has total -1 * fixed margin-left. - 5
            //cssRules[0][1] += ";margin-left:-" + vLeft + "px;";
            //cssRules[1][1] += ";margin-left:-" + vLeft + "px;";
            this.$cssRules.push(["." + this.$baseCSSname + " .row" + this.$uniqueId,
                "padding-right:" + vLeft + "px;margin-right:-" + vLeft + "px"]);
        
            //headings and records have same padding-right
            this.$container.style.paddingRight  =
            this.$head.style.paddingRight = vLeft + "px";
        }
        
        this.$fixed = fixed;
        this.$first = 0;

        this.$withContainer = e.bindings.description ? true : false;

        //Activate CSS Rules
        importStylesheet(this.$cssRules, window);
        
        if (this.$useiframe)
            importStylesheet(this.$cssRules, this.oWin);
    });
    
    this.$initNode = function(xmlNode, state, Lid, depth){
        //Build Row
        this.$getNewContext("item");
        var oRow = this.$getLayoutNode("item");
        oRow.setAttribute("id", Lid);
        
        //@todo if treearch
        oRow.setAttribute("class", oRow.getAttribute("class") + " "  
            + treeState[state] + " item" + this.$uniqueId);//"width:" + (totalWidth+40) + "px");
        this.$setStyleClass(this.$getLayoutNode("item", "container"), treeState[state])
        
        oRow.setAttribute("ondblclick", 'var o = apf.lookup(' + this.$uniqueId + ');o.choose(null, true);'
            + (this.$withContainer ? 'o.slideToggle(this, null, true);' : '')
            + (this.celledit && !this.namevalue ? 'o.startRename(null, null, true);' : ''));
        
        if (this.hasFeature(apf.__DRAGDROP__)) {
            oRow.setAttribute("onmouseout", 'this.hasPassedDown = false;');
            oRow.setAttribute("onmousedown", 'var o = apf.lookup(' + this.$uniqueId + ');\
                var xmlNode = apf.xmldb.findXmlNode(this);\
                 var isSelected = o.isSelected(xmlNode);\
                 this.hasPassedDown = true;\
                 if (!o.hasFeature(apf.__DRAGDROP__) || !isSelected && !event.ctrlKey)\
                     o.select(this, event.ctrlKey, event.shiftKey, -1);'
                + (this.cellselect || this.namevalue ? 'o.selectCell(event, this, isSelected);' : ''));
            
            oRow.setAttribute("onmouseup", 'if (!this.hasPassedDown) return;\
                var o = apf.lookup(' + this.$uniqueId + ');\
                 var xmlNode = apf.xmldb.findXmlNode(this);\
                 var isSelected = o.isSelected(xmlNode);\
                 if (o.hasFeature(apf.__DRAGDROP__))\
                     o.select(this, event.ctrlKey, event.shiftKey, -1);');
        } //@todo add DRAGDROP ifdefs
        else {
            oRow.setAttribute("onmousedown", 'var o = apf.lookup(' + this.$uniqueId + ');\
                var wasSelected = o.$selected == this;\
                o.select(this, event.ctrlKey, event.shiftKey, -1);'
                + (this.cellselect || this.namevalue ? 'o.selectCell(event, this, wasSelected);' : ''));
        }
        
        //Build the Cells
        for (var cell, h, i = 0; i < this.$headings.length; i++) {
            h = this.$headings[i];
            
            if (h.tree) {
                this.$getNewContext("treecell");
                cell = this.$getLayoutNode("treecell");
                var oc = this.$getLayoutNode("treecell", "openclose");
                oc.setAttribute("style", "margin-left:" + (((depth||0)) * 15 + 4) + "px;");
                oc.setAttribute("onmousedown",
                    "var o = apf.lookup(" + this.$uniqueId + ");\
                    o.slideToggle(this, null, null, true);\
                    event.cancelBubble = true;\
                    apf.window.$mousedown(event);");
            
                oc.setAttribute("ondblclick", "event.cancelBubble = true");
                
                /*cell.setAttribute("style", "background-position: " 
                    + ((((depth||0)+1) * 15) - 10) + "px 50%");*/
            }
            else {
                this.$getNewContext("cell");
                cell = this.$getLayoutNode("cell");
            }
            
            apf.setStyleClass(cell, h.$className);
            
            if (h.css)
                apf.setStyleClass(cell, (apf.lm.compile(h.css))(xmlNode)); //@todo cashing of compiled function?
            
            if (h.icon) {
                var node = this.$getLayoutNode(h.tree ? "treecell" : "cell", "caption", oRow.appendChild(cell));
                (node.nodeType == 1 && node || node.parentNode)
                    .setAttribute("style", "padding-left:19px;background:url(" 
                        + apf.getAbsolutePath(this.iconPath, 
                            ((h.cicon || h.$compile("icon", {nostring: true}))(xmlNode) || ""))
                        + ") no-repeat 0 0;");
            }
            
            if (h.value) {
                apf.setNodeValue(this.$getLayoutNode(h.tree ? "treecell" : "cell", "caption", oRow.appendChild(cell)),
                    (h.cvalue2 || h.$compile("value", {nostring: true}))(xmlNode) || "");
            }
        }
        
        if (this.$bindings && this.$bindings.color) {
            var colorRule = this.$getDataNode("color", xmlNode);
            this.$setStyleClass(oRow, colorRule ? "highlight" : null, colorRule ? ["highlight"] : null);
        }
        
        
        var cssClass = this.$applyBindRule("css", xmlNode);
        if (cssClass) {
            this.$setStyleClass(oRow, cssClass);
            if (cssClass)
                this.$dynCssClasses.push(cssClass);
        }
        

        /*if (this.$withContainer) {
            var desc = this.$applyBindRule("description", xmlNode);
            this.$getNewContext("container");
            var oDesc = this.$getLayoutNode("container");
            apf.setNodeValue(this.$getLayoutNode("container", "container",
                oDesc), desc);
            oDesc.setAttribute("class", (oDesc.getAttribute("class") || "")
                + " row" + this.$uniqueId);
            
            if (htmlParentNode)
                apf.insertHtmlNode(oDesc, htmlParentNode, beforeNode);
            else 
                this.$nodes.push(oDesc);
        }*/
        
        return oRow;
    };
    
    this.$updateNode = function(xmlNode, htmlNode){
        if (!htmlNode) return;
        
        var nodes     = this.$head.childNodes,
            htmlNodes = htmlNode.childNodes,
            cell, p;
        
        if (!this.namevalue && this.$curBtn)
            p = this.$curBtn.parentNode;

        var nodeIter, h, i = 0;
        nodeIter = htmlNodes[0];
        while (nodeIter) {
            if (nodeIter.nodeType != 1) {
                nodeIter = nodeIter.nextSibling;
                continue;
            }
            
            h = apf.all[nodes[i].getAttribute("hid")];
            
            //@todo fake optimization
            cell = this.$getLayoutNode(h.tree ? "treecell" : "cell", "caption", nodeIter) || nodeIter;//htmlNodes[i].firstChild || 

            if (h.css)
                apf.setStyleClass(cell, (apf.lm.compile(h.css))(xmlNode)); //@todo cashing of compiled function?

            if (h.tree) {
                /*var oc = this.$getLayoutNode("treecell", "openclose", cell);
                oc.setAttribute("style", "margin-left:" + (((depth||0)) * 15 + 4) + "px;");
                oc.setAttribute("onmousedown",
                    "var o = apf.lookup(" + this.$uniqueId + ");\
                    o.slideToggle(this, null, null, true);");*/
            }
            
            if (h.value)
                cell.innerHTML = (h.cvalue2 || h.$compile("value", {nostring: true}))(xmlNode) || "";
            
            if (h.icon) {
                (cell.nodeType == 1 && cell || cell.parentNode).style.backgroundImage = 
                    "url(" + apf.getAbsolutePath(this.iconPath, 
                        ((h.cicon || h.$compile("icon", {nostring: true}))(xmlNode) || ""))
                    + ")";
            }
            
            i++;
            nodeIter = nodeIter.nextSibling;
        }
        
        //return; //@todo fake optimization
        
        if (this.$bindings && this.$bindings.color) {
            var colorRule = this.$getDataNode("color", xmlNode);
            this.$setStyleClass(htmlNode, colorRule ? "highlight" : null,
                colorRule ? ["highlight"] : null);
        }
        
        
        var cssClass = this.$applyBindRule("css", xmlNode);
        if (cssClass || this.$dynCssClasses.length) {
            this.$setStyleClass(htmlNode, cssClass, this.$dynCssClasses);
            if (cssClass && !this.$dynCssClasses.contains(cssClass))
                this.$dynCssClasses.push(cssClass);
        }
        
        
        /*if (this.$withContainer) {
            htmlNode.nextSibling.innerHTML 
                = this.$applyBindRule("description", xmlNode) || "";
        }*/
    };
    
    this.$dblclick = function(htmlNode){
        var _self = this, id, cell;
        while (!(id = htmlNode.getAttribute(apf.xmldb.htmlIdTag)) || id.indexOf("|") == -1) {
            htmlNode = (cell = htmlNode).parentNode;
        }
        
        if (this.$lastEditor && this.$lastEditor[3] == htmlNode)
            return;
        
        var h, colId = cell.className.match(/(col\d+)/)[1];
        for (var i = 0; i < this.$headings.length; i++) {
            if (this.$headings[i].$className == colId) {
                h = this.$headings[i];
                break;
            }
        }
        
        if (!h.editor) //No editor specified
            return;

        /*if (this.$lastEditor) {
            //this.$lastEditor[0].$blur();
            this.$lastEditor[0].setProperty("visible", false);
            
            var nodes = this.$lastEditor[1].childNodes;
            for (var i = 0, l = nodes.length; i < l; i++) {
                if (!nodes[i].host)
                    nodes[i].style.display = "";
            }
        }*/
        
        var xmlNode = apf.xmldb.getNode(htmlNode);
        /*
            - editor (name of widget, lm function returning amlNode or lm template ref)
            - children being aml nodes
        */
        var editParent = h.tree 
          ? this.$getLayoutNode("cell", "caption", cell)
          : cell;

        var oEditor, editor = h.editor; 
        var ceditor = apf.lm.compile(editor, {xpathmode: 2}); //@todo can this be more efficient?
    
        var nodes = editParent.childNodes;
        for (var i = 0, l = nodes.length; i < l; i++) {
            if (!nodes[i].host) {
                if (nodes[i].nodeType == 1)
                    nodes[i].style.display = "none";
                else {
                    this.$lastTextValue = nodes[i].nodeValue;
                    nodes[i].nodeValue = ""; //@todo
                }
            }
        }

        if (ceditor.type == 2) {
            if (!this.$editors[editor]) {
                var constr = apf.namespaces[apf.ns.aml].elements[editor];
                var info   = {
                    htmlNode : editParent,
                    style    : "position:relative;z-index:10000",
                    value    : "[{" + this.id + ".selected}::" 
                        + (v = h.value).substr(1, v.length - 2)  //only xpath value's supported for now
                        + "]",
                    focussable : false
                };
                if (!h.tree)
                    info.width = "100%-3";
                
                //@todo copy all non-known properties of the prop element

                /*if (constr.prototype.hasFeature(apf.__MULTISELECT__)) {
                    info.caption   = "[text()]";
                    info.eachvalue = "[@value]";
                    info.each      = "item";
                    info.model     = "{apf.xmldb.getElementById('" 
                        + prop.getAttribute(apf.xmldb.xmlIdTag) + "')}";
                }*/

                oEditor = this.$editors[editor] = new constr(info);

                var box = apf.getBox(apf.getStyle(oEditor.$ext, "margin"));
                if (box[1] || box[3]) {
                    oEditor.setAttribute("width", "100%+2-" + (box[1] + box[3]));
                }
                //else if (!box[3])
                    //oEditor.$ext.style.marginLeft = "-1px";
                
                //oEditor.$focussable = false;
                oEditor.addEventListener("blur", function(){
                    hideEditor.call(_self);
                });
                oEditor.parentNode   = this;
                oEditor.realtime     = false;
                oEditor.$focusParent = this;
                oEditor.setAttribute("focussable", "true");
                //delete oEditor.parentNode;
                
                oEditor.addEventListener("beforechange", function(e){
                    return _self.dispatchEvent("beforechange", e);
                });
                
                oEditor.addEventListener("afterchange", function(e){
                    return _self.dispatchEvent("afterchange", e);
                });
                
                oEditor.addEventListener("keydown", function(e){
                    if (e.keyCode == 13) {
                        hideEditor.call(_self);
                        _self.$focus();
                    }
                    else if (e.keyCode == 27) {
                        oEditor.removeAttribute("value"); //@todo this bugs in slider
                        hideEditor.call(_self);
                        //_self.getActionTracker().undo();
                    }
                });
                
                //@todo set actiontracker
            }
            else {
                oEditor = this.$editors[editor];
                
                if (oEditor.hasFeature(apf.__MULTISELECT__))
                    oEditor.setAttribute("model", "{apf.xmldb.getElementById('" 
                        + prop.getAttribute(apf.xmldb.xmlIdTag) + "')}");

                oEditor.setAttribute("value", "[{" + this.id + ".selected}::" 
                    + (v = h.value).substr(1, v.length - 2) 
                    + "]");

                oEditor.setProperty("visible", true);
                editParent.appendChild(oEditor.$ext);
                
                oEditor.setAttribute("width", h.tree ? "" : "100%-3");
            }
            
            /*setTimeout(function(){
                oEditor.focus();
            });*/
        }
        else {
            //Create dropdown 
            
            var obj = ceditor.call(this, this.xmlRoot);
            if (obj.localName == "template") {
                //add template contents to dropped area
            }
            else {
                //add xml into dropped area
            }
        }
        
        if (oEditor.localName == "textbox")
            oEditor.select();
        
        oEditor.focus();
        oEditor.$focus();
        
        this.$setStyleClass(htmlNode, "editing");
        
        this.$lastEditor = [oEditor, editParent, xmlNode, htmlNode, this.getActionTracker().undolength];
    }
    
    this.addEventListener("mousedown", function(e){
        if (this.$lastEditor 
          && !apf.isChildOf(this.$lastEditor[1], 
            e.htmlEvent.srcElement || e.htmlEvent.target, true))
                hideEditor.call(this);
    });
    
    this.addEventListener("beforeselect", function hideEditor(e){
        if (this.$lastEditor) {
            var ed = this.$lastEditor;
            this.$lastEditor = null;

            //this.$lastEditor[0].$blur();
            ed[0].setProperty("visible", false);
            
            var nodes = ed[1].childNodes;
            for (var i = 0, l = nodes.length; i < l; i++) {
                if (!nodes[i].host) {
                    if (nodes[i].nodeType == 1)
                        nodes[i].style.display = "";
                    else if (!ed[0].value) {
                        nodes[i].nodeValue = this.$lastTextValue; //@todo
                    }
                }
            }
            
            this.$setStyleClass(ed[3], "", ["editing"]);
            
            this.focus();
        }
    });
    
    /**** Column management ****/

    /**
     * Returns a column definition object based on the column number.
     * @param {Number} hid the heading number; this number is based on the sequence of the column elements.
     */
    this.getColumn = function(nr){
        return this.$headings[nr || this.$lastcol || 0];
    };
    
    /** 
     * Resizes a column.
     * @param {Number} hid      the heading number; this number is based on the sequence of the column elements. 
     * @param {Number} newsize  the new size of the column.
     * @todo optimize but bringing down the string concats
     */
    this.resizeColumn = function(nr, newsize){
        var h = this.$headings[nr];
        h.resize(newsize);
    };

    /**
     * Hides a column.
     * @param {Number} hid      the heading number; this number is based on the sequence of the column elements. 
     */
    this.hideColumn = function(nr){
        var h = this.$headings[nr];
        h.hide();
    };
    
    /**
     * Shows a hidden column.
     * @param {Number} hid      the heading number; this number is based on the sequence of the column elements. 
     */
    this.showColumn = function(nr){
        var h = this.$headings[nr];
        h.show();
    };
    
    /**
     * Sorts a column.
     * @param {Number} hid the heading number; this number is based on the sequence of the column elements.
     */
    this.sortColumn = function(hid){
        var h = this.$headings[nr];
        h.sort();
    };
    
    /**
     * Moves a column to another position.
     * @param {Number} fromHid the heading number of the column to move; this number is based on the sequence of the column elements.
     * @param {Number} toHid   the position the column is moved to;
     */
    this.moveColumn = function(from, to){
        var h = this.$headings[nr];
        h.move(to);
    }
    
    /**** Init ****/

    this.$draw = function(){
        this.$drawBase();
        
        var _self = this;
        this.$ext.onmousedown = function(e){
            _self.dispatchEvent("mousedown", {htmlEvent: e || event}); 
        }
        
        //@todo rename 'body' to 'container'
        
        //Build Main Skin
        this.$head    = this.$getLayoutNode("main", "head", this.$ext);
        this.$pointer = this.$getLayoutNode("main", "pointer", this.$ext);

        if (this.$head.firstChild)
            this.$head.removeChild(this.$head.firstChild);
        if (this.$container.firstChild)
            this.$container.removeChild(this.$container.firstChild);

        var widthdiff = this.$widthdiff = this.$getOption("main", "widthdiff") || 0;
        this.$defaultwidth = this.$getOption("main", "defaultwidth") || "100";
        this.$useiframe    = apf.isIE && (apf.isTrue(this.$getOption("main", "iframe")) || this.iframe);

        //Initialize Iframe 
        if (this.$useiframe && !this.oIframe) {
            //this.$container.style.overflow = "hidden";
            //var sInt = this.$container.outerHTML 
            var sClass   = this.$container.className;
            //this.$container.parentNode.removeChild(this.$container);
            this.oIframe = this.$container.appendChild(document.createElement(apf.isIE 
                ? "<iframe frameborder='0'></iframe>"
                : "iframe"));
            this.oIframe.frameBorder = 0;
            this.oWin = this.oIframe.contentWindow;
            this.oDoc = this.oWin.document;
            this.oDoc.write('<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">\
                <html xmlns="http://www.w3.org/1999/xhtml">\
                    <head><script>\
                        apf = {\
                            lookup : function(uid){\
                                return window.parent.apf.lookup(uid);\
                            },\
                            Init : {add:function(){},run:function(){}}\
                        };</script>\
                    </head>\
                    <body></body>\
                </html>');
            //Import CSS
            //this.oDoc.body.innerHTML = sInt;
            this.$container = this.oDoc.body;//.firstChild;
            this.$container.className = sClass;//this.oIframe.parentNode.className;
            this.oDoc.documentElement.className = this.$ext.className;
            //this.oDoc.body.className = this.$ext.className;

            apf.skins.loadCssInWindow(this.skinName, this.oWin, this.mediaPath, this.iconPath);
            
            if (apf.isIE) //@todo this can be removed when focussing is fixed for this component
                this.$setStyleClass(this.oDoc.documentElement, this.$baseCSSname + "Focus");
            
            apf.convertIframe(this.oIframe, true);

            if (apf.getStyle(this.oDoc.documentElement, apf.isIE 
              ? "overflowY" : "overflow-y") == "auto") {
                //@todo ie only
                this.oIframe.onresize = function(){
                    _self.$head.style.marginRight = 
                      _self.oDoc.documentElement.scrollHeight > _self.oDoc.documentElement.offsetHeight 
                        ? "16px" : "0";
                }
                
                this.addEventListener("afterload", this.oIframe.onresize);
                this.addEventListener("xmlupdate", this.oIframe.onresize);
            }
            
            this.oDoc.documentElement.onscroll = 
                function(){
                    if (_self.$isFixedGrid)
                        _self.$head.scrollLeft = _self.oDoc.documentElement.scrollLeft;
                };
        }
        else {
            if (apf.getStyle(this.$container, apf.isIE 
              ? "overflowY" : "overflow-y") == "auto") {
                this.$resize = function(){
                    _self.$head.style.marginRight = 
                      _self.$container.scrollHeight > _self.$container.offsetHeight 
                        ? "16px" : "0";
                }
                
                
                apf.layout.setRules(this.$ext, this.$uniqueId + "_datagrid",
                    "var o = apf.all[" + this.$uniqueId + "];\
                     if (o) o.$resize()");
                apf.layout.queue(this.$ext);
                
                
                this.addEventListener("afterload", this.$resize);
                this.addEventListener("xmlupdate", this.$resize);
            }
            
            this.$container.onscroll = 
                function(){
                    if (_self.$isFixedGrid)
                        _self.$head.scrollLeft = _self.$container.scrollLeft;
                };
        }
        
        this.$container.ondblclick = function(e){
            if (!e) e = event;
            _self.$dblclick(e.srcElement || e.target);
        }
    };
    
    this.$destroy = function(){
        //@todo destroy this.$txt here

        this.$ext.onclick = this.$container.onresize = null;
        
        
        apf.layout.removeRule(this.$container, "dg" + this.$uniqueId);
        apf.layout.activateRules(this.$container);
        
    };
}).call(apf.datagrid.prototype = new apf.BaseTree());

apf.aml.setElement("datagrid",    apf.datagrid);
//apf.aml.setElement("column",      apf.BindingRule);
apf.aml.setElement("description", apf.BindingRule);
apf.aml.setElement("color",       apf.BindingRule);
apf.aml.setElement("contents",    apf.BindingRule);





/*FILEHEAD(/var/lib/platform/source/trunk/elements/skin.js)SIZE(9726)TIME(1270838607)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


/**
 * element specifying the skin of an application.
 * Example:
 * <code>
 *  <a:skin src="perspex.xml"
 *    name       = "perspex"
 *    media-path = "http://example.com/images"
 *    icon-path  = "http://icons.example.com" />
 * </code>
 * @attribute {String} name       the name of the skinset.
 * @attribute {String} src        the location of the skin definition.
 * @attribute {String} media-path the basepath for the images of the skin.
 * @attribute {String} icon-path  the basepath for the icons used in the elements using this skinset.
 * @allowchild  style, presentation
 * @addnode global, anyaml
 *
 * @author      Ruben Daniels (ruben AT ajax DOT org)
 * @version     %I%, %G%
 * @since       0.4
 */
apf.skin = function(struct, tagName){
    this.$init(tagName || "skin", apf.NODE_HIDDEN, struct);
};
apf.aml.setElement("skin", apf.skin);

(function(){
    this.$parsePrio = "002";
    this.$includesRemaining = 0;
    
    this.$propHandlers["src"] = function(value){
        this.$path = apf.getAbsolutePath(apf.hostPath, value)
        getSkin.call(this, this.$path);
    }
    
    this.$propHandlers["name"] = function(value){
        if (!this.attributes.getNamedItem("src")) {
            this.$path = apf.getAbsolutePath(apf.hostPath, value) + "/index.xml";
            getSkin.call(this, this.$path);
        }
    }
    
    /**
     * @private
     */
    function checkForAmlNamespace(xmlNode){
        if (!xmlNode.ownerDocument.documentElement)
            return false;

        var nodes = xmlNode.ownerDocument.documentElement.attributes;
        for (var found = false, i=0; i<nodes.length; i++) {
            if (nodes[i].nodeValue == apf.ns.aml) {
                found = true;
                break;
            }
        }

        
        if (!found) {
            throw new Error(apf.formatErrorString(0, null,
                "Checking for the aml namespace",
                "The Ajax.org Platform xml namespace was not found in "
                + (xmlNode.getAttribute("filename")
                    ? "in '" + xmlNode.getAttribute("filename") + "'"
                    : "")));
        }
        

        return found;
    }
    
    function getSkin(path){
        var domParser = this.ownerDocument.$domParser;
        
        if (!apf.skins.$first)
            apf.skins.$first = this;
        
        var defer = this.attributes.getNamedItem("defer");
        if (!defer || !apf.isTrue(defer.nodeValue)) {
            domParser.$shouldWait++;
            this.$parseContext = domParser.$parseContext || [this.ownerDocument.documentElement];
        }
        
        //var basePath = apf.hostPath;//only for recursion: apf.getDirname(xmlNode.getAttribute("filename")) || 
        loadSkinFile.call(this, path);
        
    }
    
    function finish(xmlNode){
        if (xmlNode)
            apf.skins.Init(xmlNode, this, this.$path);

        if (!this.defer) {// && this.$parseContext
            var domParser = this.ownerDocument.$domParser;
            domParser.$continueParsing.apply(domParser, this.$parseContext);
        }
    }
    
    
    
    function loadSkinFile(path){
        
        apf.console.info("Loading include file: " + path);
        

        var _self = this;
        
        apf.getData(
        
          path, {
          
          type : "skin",
          
          callback: function(xmlString, state, extra){
             if (state != apf.SUCCESS) {
                var oError = new Error(apf.formatErrorString(1007,
                    _self, "Loading skin file", "Could not load skin file '"
                    + (path || _self.src)
                    + "'\nReason: " + extra.message));

                if (extra.tpModule.retryTimeout(extra, state, null, oError) === true)
                    return true;

                

                throw oError;
            }

            //if (!apf.supportNamespaces)
            xmlString = xmlString.replace(/\<\!DOCTYPE[^>]*>/, "")
                .replace(/^[\r\n\s]*/, "") //.replace(/&nbsp;/g, " ")
                .replace(/xmlns\=\"[^"]*\"/g, "");
            
            if (!xmlString) {
                throw new Error(apf.formatErrorString(0, _self,
                    "Loading skin",
                    "Empty skin file. Maybe the file does not exist?", _self));
            }
            
            var xmlNode = apf.getXml(xmlString);//apf.getAmlDocFromString(xmlString);
            
            
            checkForAmlNamespace(xmlNode);
            
            
            if (!xmlNode) {
                throw new Error(apf.formatErrorString(0, _self,
                    "Loading skin",
                    "Could not parse skin. Maybe the file does not exist?", _self));
            }
            
            xmlNode.setAttribute("filename", extra.url);
            
            
            {
                
                apf.console.info("Loading of " + xmlNode[apf.TAGNAME].toLowerCase() + " skin done from file: " + extra.url);
                
                
                finish.call(_self, xmlNode);
            }
          }, 
          async         : true,
          ignoreOffline : true
        });
    }
    
    //@todo use mutation events to update
    this.addEventListener("DOMNodeInsertedIntoDocument", function(e){
        if (this.src || this.name)
            return;
        
        apf.skins.Init(this);
        
        //@todo implied skin
        /*if (this.parentNode && this.parentNode.parentNode) {
            var name = "skin" + Math.round(Math.random() * 100000);
            q.parentNode.setAttribute("skin", name);
            apf.skins.skins[name] = {name: name, templates: {}};
            apf.skins.skins[name].templates[q.parentNode[apf.TAGNAME]] = q;
        }*/
    });
}).call(apf.skin.prototype = new apf.AmlElement());



/*FILEHEAD(/var/lib/platform/source/trunk/elements/video.js)SIZE(20320)TIME(1259091146)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/elements/model.js)SIZE(40610)TIME(1271234270)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * Element functioning as the central access point for xml data. Data can be
 * retrieved from any data source using data instructions. Data can be
 * submitted using data instructions in a similar way to html form posts. The
 * modal can be reset to it's original state. It has support for offline use and
 * {@link element.remove synchronization between multiple clients}.
 * Example:
 * <code>
 *  <a:model src="products.xml" />
 * </code>
 * Example:
 * A small form where the bound data is submitted to a server using a model.
 * <code>
 *  <a:model id="mdlForm" submission="save_form.asp">
 *      <data name="Lukasz" address="Poland"></data>
 *  </a:model>
 * 
 *  <a:frame model="mdlForm">
 *      <a:label>Name</a:label>
 *      <a:textbox value="[@name]" />
 *      <a:label>Address</a:label>
 *      <a:textarea 
 *        value  = "[@address]" 
 *        width  = "100" 
 *        height = "50" />
 *      <a:button 
 *        default = "true" 
 *        action  = "submit">Submit</a:button>
 *  </a:frame>
 * </code>
 *
 * @event beforeretrieve    Fires before a request is made to retrieve data.
 *   cancelable: Prevents the data from being retrieved.
 * @event afterretrieve     Fires when the request to retrieve data returns both on success and failure.
 * @event receive           Fires when data is successfully retrieved
 *   object:
 *   {String} data  the retrieved data
 * @event beforeload        Fires before data is loaded into the model.
 *   cancelable:
 * @event afterload         Fires after data is loaded into the model.
 * @event beforesubmit      Fires before data is submitted.
 *   cancelable: Prevents the submit.
 *   object:
 *   {String} instruction The data instruction used to store the data.
 * @event submiterror       Fires when submitting data has failed.
 * @event submitsuccess     Fires when submitting data was successfull.
 * @event aftersubmit       Fires after submitting data.
 * @event error             Fires when a communication error has occured while making a request for this element.
 *   cancelable: Prevents the error from being thrown.
 *   bubbles:
 *   object:
 *   {Error}          error     the error object that is thrown when the event callback doesn't return false.
 *   {Number}         state     the state of the call
 *     Possible values:
 *     apf.SUCCESS  the request was successfull
 *     apf.TIMEOUT  the request has timed out.
 *     apf.ERROR    an error has occurred while making the request.
 *     apf.OFFLINE  the request was made while the application was offline.
 *   {mixed}          userdata  data that the caller wanted to be available in the callback of the http request.
 *   {XMLHttpRequest} http      the object that executed the actual http request.
 *   {String}         url       the url that was requested.
 *   {Http}           tpModule  the teleport module that is making the request.
 *   {Number}         id        the id of the request.
 *   {String}         message   the error message.
 *
 * @constructor
 * @define model
 * @allowchild [cdata], instance, load, submission
 * @addnode smartbinding, global
 * @attribute  {String}  src          the data instruction on how to load data from the data source into this model.
 * @attribute  {String}  submission   the data instruction on how to record the data from the data source from this model.
 * @attribute  {String}  session      the data instruction on how to store the session data from this model.
 * @attribute  {Boolean} autoinit     whether to initialize the model immediately. If set to false you are expected to call init() when needed. This is useful when the system has to log in first.
 * @attribute  {Boolean} save-original whether to save the original state of the data. This enables the use of the reset() call.
 * @attribute  {String}  remote       the id of the {@link element.remote} element to use for data synchronization between multiple clients.
 *
 * @author      Ruben Daniels (ruben AT ajax DOT org)
 * @version     %I%, %G%
 * @since       0.8
 */
apf.model = function(struct, tagName){
    this.$init(tagName || "model", apf.NODE_HIDDEN, struct);
    
    this.$amlNodes = {};
    this.$propBinds = {};
    
    this.$listeners = {};
    this.$proplisteners = {};

    if (!apf.globalModel) {
        apf.globalModel = this;
        apf.nameserver.register("model", "@default", this);
    }
};

(function(){
    this.$parsePrio = "020";
    this.$isModel   = true;
    
    this.canHaveChildren  = false;
    this["save-original"] = true;

    this.$state = 0;//1 = loading

    //1 = force no bind rule, 2 = force bind rule
    this.$attrExcludePropBind = apf.extend({
        submission : 1,
        src        : 1,
        session    : 1
    }, this.$attrExcludePropBind);

    this.$booleanProperties["autoinit"]      = true;
    this.$booleanProperties["save-original"] = true;
    this.$supportedProperties = ["submission", "src", "session", "autoinit", 
        "save-original", "remote"];
    
    this.$propHandlers["src"] = 
    this.$propHandlers["get"] = function(value, prop){
        if (this.$amlLoaded)
            this.$loadFrom(value);
    };

    this.$propHandlers["validation"] = function(value, prop){
        apf.nameserver.get("validation", value).register(this); //@todo error handling
    };
    
    

    

    /**
     * Registers a aml element to this model in order for the aml element to
     * receive data loaded in this model.
     *
     * @param  {AMLElement}  amlNode  The aml element to be registered.
     * @param  {String}      [xpath]  the xpath query which is executed on the
     *                                data of the model to select the node to be
     *                                loaded in the <code>amlNode</code>.
     * @return  {Model}  this model
     * @private
     */
    this.register = function(amlNode, xpath){
        if (!amlNode || !amlNode.load) //hasFeature(apf.__DATABINDING__))
            return this;

        //Remove previous model
        if (amlNode.$model && amlNode.$model != this)
            amlNode.$model.unregister(amlNode);

        //Register the aml node
        var item = this.$amlNodes[amlNode.$uniqueId] = {
            amlNode : amlNode, 
            xpath   : xpath
        };
        amlNode.$model = this;

        if (typeof amlNode.noloading == "undefined"
          && amlNode.$setInheritedAttribute 
          && !amlNode.$setInheritedAttribute("noloading"))
            amlNode.noloading = false;

        //amlNode.$model = this;
        if (this.$state == 1) {
            if (amlNode.clear && !amlNode.noloading)
                amlNode.clear("loading");//@todo apf3.0
        }
        else if (this.data) {
            this.$loadInAmlNode(item);
            //this.$loadInAmlProp(amlNode);
        }
        else { //@experimental
            if (amlNode.clear)
                amlNode.clear("empty");
        }

        var p, node, list = amlNode.$propsUsingMainModel;
        for (var prop in list) {
            p = this.$bindXmlProperty(amlNode, prop, 
                    list[prop].xpath, list[prop].optimize);
            
            if (this.data) {
                if (node = p.root || p.listen ? this.data.selectSingleNode(p.root || p.listen) : this.data) {
                    amlNode.$execProperty(prop, node);
                }
                else
                    this.$waitForXml(amlNode, prop);
            }
        }

        return this;
    };

    this.$register = function(amlNode, xpath){
        //@todo apf3.0 update this.$propBinds;
        
        this.$amlNodes[amlNode.$uniqueId].xpath = xpath;
    };

    /**
     * Removes a aml element from the group of registered aml elements.
     * The aml element will not receive any updates from this model, however
     * the data loaded in the aml element is not unloaded.
     *
     * @param  {AMLElement}  amlNode  The aml element to be unregistered.
     * @private
     */
    this.unregister = function(amlNode){
        delete this.$amlNodes[amlNode.$uniqueId];
        
        var list = amlNode.$propsUsingMainModel;
        for (var prop in list)
            this.$unbindXmlProperty(amlNode, prop);
    };

    /**
     * @private
     */
    this.getXpathByAmlNode = function(amlNode){
        var n = this.$amlNodes[amlNode.$uniqueId];
        if (!n)
            return false;

        return n.xpath;
    };
    
    /**
     * @private
     */
    this.$loadInAmlNode = function(item){
        var xmlNode;
        var xpath   = item.xpath;
        var amlNode = item.amlNode;
        
        if (this.data && xpath) {
            xmlNode = this.data.selectSingleNode(xpath);
        }
        else
            xmlNode = this.data || null;
        
        if (xmlNode) {
            delete this.$listeners[amlNode.$uniqueId];
            amlNode.load(xmlNode);
        }
        else 
            this.$waitForXml(amlNode);
    };
    
    this.$loadInAmlProp = function(id, xmlNode){
        var prop, node, p = this.$propBinds[id], amlNode = apf.all[id];
        if(!amlNode){
             delete this.$propBinds[id];
             return;
        }           
        for (prop in p) {
            if (node = p[prop].root ? xmlNode.selectSingleNode(p[prop].root) : xmlNode) {
                apf.xmldb.addNodeListener(xmlNode, amlNode, 
                  "p|" + id + "|" + prop + "|" + this.$uniqueId);
                
                delete this.$proplisteners[id];
                amlNode.$execProperty(prop, node);
            }
            else
                this.$waitForXml(amlNode, prop);
        }            
    };
    
    /*
        We don't want to connect to the root, that would create a rush
        of unnecessary update messages, so we'll find the element that's
        closest to the node that is going to feed us the value
        
        mdlBlah::bli/persons
        mdlBlah::bli/persons/person
        
        $attrBindings
        //split / join, pop, indexOf
        
        <a:textbox value="[persons/person/@blah]" width="[persons/blah/@width]" height="[@height]" model="[mdlBlah::bli]"/>
    */
    this.$bindXmlProperty = function(amlNode, prop, xpath, optimize, listenRoot) {
        var q ,p, id = amlNode.$uniqueId;
        if (!this.$propBinds[id]) 
            this.$propBinds[id] = {};

        /*
            Store
            0 - Original xpath
            1 - Store point of change listener
            2 - Xpath to determine data node passed into load
        */
        p = this.$propBinds[id][prop] = {
            bind: xpath
        };

        //@todo apf3.0
        //Optimize root point, doesnt work right now because it doesnt change the original rule
        if (optimize) {
            //Find xpath for bind on this model of the amlNode
            if ((q = this.$amlNodes[id]) && q.xpath)
                xpath = (p.root = q.xpath) + "/" + xpath;
            
            var l = xpath.split("/"), z = l.pop();
            if (z.indexOf("@") == 0 
              || z.indexOf("text()") > -1 
              || z.indexOf("node()") > -1) {
                p.listen = l.join("/");
            }
            else p.listen = xpath;
        }
        else {
            if ((q = this.$amlNodes[id]) && q.xpath)
                p.listen = q.xpath;
        }
        
        if (listenRoot)
            p.listen = ".";

        if (this.data) {
            var xmlNode = p.listen ? this.data.selectSingleNode(p.listen) : this.data;
            if (xmlNode) {
                apf.xmldb.addNodeListener(xmlNode, amlNode, 
                  "p|" + amlNode.$uniqueId + "|" + prop + "|" + this.$uniqueId);
                
                return p;
            }
        }
        
        this.$waitForXml(amlNode, prop);
        
        return p;
    };
    
    this.$unbindXmlProperty = function(amlNode, prop){
        var id = amlNode.$uniqueId;

        //@todo apf3.0
        var p = this.$propBinds[id] && this.$propBinds[id][prop];
        if (!p) return;
        
        if (this.data) {
            var xmlNode = p.listen ? this.data.selectSingleNode(p.listen) : this.data;
            if (xmlNode) {
                apf.xmldb.removeNodeListener(xmlNode, amlNode, 
                  "p|" + id + "|" + prop + "|" + this.$uniqueId);
            }
        }
        
        delete this.$proplisteners[id + prop];
        delete this.$propBinds[id][prop];
        return p;
    };

    /**
     * Gets a copy of current state of the xml of this model.
     *
     * @return  {XMLNode}  context of this model
     */
    this.getXml = function(){
        return this.data
            ? apf.xmldb.cleanNode(this.data.cloneNode(true))
            : false;
    };

    /**
     * Sets a value of an XMLNode based on an xpath statement executed on the data of this model.
     *
     * @param  {String}  xpath  the xpath used to select a XMLNode.
     * @param  {String}  value  the value to set.
     * @return  {XMLNode}  the changed XMLNode
     */
    this.setQueryValue = function(xpath, value){
        if (!this.data)
            return false;
        
        var node = apf.createNodeFromXpath(this.data, xpath);
        if (!node)
            return null;

        apf.setNodeValue(node, value, true);
        //apf.xmldb.setTextNode(node, value);
        return node;
    };

    /**
     * Gets the value of an XMLNode based on a xpath statement executed on the data of this model.
     *
     * @param  {String}  xpath  the xpath used to select a XMLNode.
     * @return  {String}  value of the XMLNode
     */
    this.queryValue = function(xpath){
        if (!this.data)
            return false;
        
        return apf.queryValue(this.data, xpath);
    };
	
    /**
     * Gets the value of an XMLNode based on a xpath statement executed on the data of this model.
     *
     * @param  {String}  xpath  the xpath used to select a XMLNode.
     * @return  {String}  value of the XMLNode
     */	
    this.queryValues = function(xpath){
        if (!this.data)
            return false;
        
        return apf.queryValue(this.data, xpath);
    };
	
    /**
     * Executes an xpath statement on the data of this model
     *
     * @param  {String}   xpath    the xpath used to select the XMLNode(s).
     * @return  {variant}  XMLNode or NodeList with the result of the selection
     */
    this.queryNode = function(xpath){
        if (!this.data)
            return null;
        
        return this.data.selectSingleNode(xpath)
    };

    /**
     * Executes an xpath statement on the data of this model
     *
     * @param  {String}   xpath    the xpath used to select the XMLNode(s).
     * @return  {variant}  XMLNode or NodeList with the result of the selection
     */
    this.queryNodes = function(xpath){
        if (!this.data)
            return null;
        
        return this.data.selectNodes(xpath);
    };

    /**
     * Appends a copy of the xmlNode or model to this model as a child
     * of it's root node
     */
    this.appendXml = function(xmlNode, xpath){
        var insertNode = xpath
          ? apf.createNodeFromXpath(this.data, xpath)
          : this.data;
        if (!insertNode)
            return null;
        
        if (typeof xmlNode == "string")
            xmlNode = apf.getXml(xmlNode);
        else {
            xmlNode = !xmlNode.nodeType //Check if a model was passed
                ? xmlNode.getXml()
                : apf.xmldb.getCleanCopy(xmlNode);
        }
        
        if (!xmlNode) return;

        apf.xmldb.appendChild(insertNode, xmlNode);
    };

    /**
     * Removes xmlNode from this model 
     */
    this.removeXml = function(xmlNode){
        if (typeof xmlNode == "string")
            xmlNode = this.data.selectNodes(xmlNode);
        else if (!xmlNode.length)
            xmlNode = [xmlNode];
        
        if (xmlNode)
            apf.xmldb.removeNodeList(xmlNode);
    };

    /**
     * Clears the loaded data from this model.
     */
    this.clear = function(){
        this.load(null);
        doc = null; //Fix for safari refcount issue;
    };

    /**
     * Resets data in this model to the last saved point.
     *
     */
    this.reset = function(){
        this.load(this.$copy);
    };

    /**
     * Sets a new saved point based on the current state of the data in this
     * model. The reset() method returns the model to this point.
     */
    this.savePoint = function(){
        this.$copy = apf.xmldb.getCleanCopy(this.data);
    };

    /**
     * @private
     */
    this.reloadAmlNode = function(uniqueId){
        if (!this.data)
            return;

        var item = this.$amlNodes[uniqueId];
        var xmlNode = item.xpath 
            ? this.data.selectSingleNode(item.xpath) 
            : this.data;
        item.amlNode.load(xmlNode);
    };

    /**
     * @private
     */
    //@todo refactor this to use .blah instead of getAttribute
    //@todo move this to propHandlers
    this.addEventListener("DOMNodeInsertedIntoDocument", function(e){
        var x = this.$aml;
        if (this.parentNode.hasFeature(apf.__DATABINDING__)) {
            if (!this.name)
                this.setProperty("id", "model" + this.parentNode.$uniqueId);
            //this.parentNode.$aml.setAttribute("model", this.name); //@todo don't think this is necesary anymore...
            this.register(this.parentNode);
        }

        //Load literal model
        if (!this.src) {
            var strXml, xmlNode = x;
            if (xmlNode.childNodes.length) {
                if (apf.getNode(xmlNode, [0])) {
                    if ((strXml = xmlNode.xml || xmlNode.serialize()).match(/^[\s\S]*?>([\s\S]*)<[\s\S]*?$/)) {
                        strXml = RegExp.$1; //@todo apf3.0 test this with json
                        if (!apf.supportNamespaces)
                            strXml = strXml.replace(/xmlns=\"[^"]*\"/g, "");
                    }
                    
                    return this.load(apf.getXmlDom(strXml).documentElement);
                }
                // we also support JSON data loading in a model CDATA section
                else if (apf.isJson(xmlNode.childNodes[0].nodeValue)) {
                    return this.load(apf.getXmlDom(xmlNode.childNodes[0].nodeValue).documentElement);
                }
            }
            
            //Default data for XForms models without an instance but with a submission node
            if (this.submission)
                this.load("<data />");
        }

        //Load data into model if allowed
        if (!apf.isFalse(this.autoinit))
            this.init();

        //@todo actions apf3.0

        return this;
    });

    /**
     * Loads the initial data into this model.
     * @see element.model.attribute.init
     */
    //callback here is private
    this.init = function(callback){
        if (this.session) {
            this.$loadFrom(this.session, {isSession: true});
        }
        else {
            

            if (this.src)
                this.$loadFrom(this.src, {callback: callback});
        }
    };

    /* *********** LOADING ****************/

    /**
     * Loads data into this model using a data instruction.
     * @param {String}     instruction  the data instrution how to retrieve the data.
     * @param {Object}     options
     *   Properties:
     *   {XMLElement} xmlNode   the {@link term.datanode data node} that provides context to the data instruction.
     *   {Function}   callback  the code executed when the data request returns.
     *   {mixed}      []        Custom properties available in the data instruction.
     */
    this.$loadFrom = function(instruction, options){
        var data      = instruction.split(":");

        if (!options)
            options = {};

        if (!options.isSession) {
            this.src   = instruction;
            this.$srcOptions = [instruction, options];
        }

        //Loading data in non-literal model
        this.dispatchEvent("beforeretrieve");
        
        //Set all components on loading...        
        var uniqueId, item;
        for (uniqueId in this.$amlNodes) {
            if (!(item = this.$amlNodes[uniqueId]) || !item.amlNode)
                continue;

            //@todo apf3.0
            if (!item.amlNode.noloading)
                item.amlNode.clear("loading");
        }

        this.$state = 1;
        if (!this.$callCount)
            this.$callCount = 1;
        else
            this.$callCount++;

        var _self     = this,
            callCount = this.$callCount,
            callback  = options.callback;
        options.callback = function(data, state, extra){
            if (callCount != _self.$callCount)
                return; //another call has invalidated this one
            
            _self.dispatchEvent("afterretrieve");

            

            if (state != apf.SUCCESS) {
                var oError;

                oError = new Error(apf.formatErrorString(1032,
                    _self, "Inserting xml data", "Could not load data\n"
                  + "Instruction: " + instruction + "\n"
                  + "Url: " + extra.url + "\n"
                  + "Info: " + extra.message + "\n\n" + data));

                if (callback && callback.apply(this, arguments) === true)
                    return true;

                if (extra.tpModule && extra.tpModule.retryTimeout(extra, state, _self, oError) === true)
                    return true;

                _self.$state = 0;

                throw oError;
            }

            if (options && options.isSession && !data) {
                if (this.src)
                    return _self.$loadFrom(this.src);
            }
            else {
                if (options && options.cancel)
                    return;

                _self.load(data);
                _self.dispatchEvent("receive", {
                    data: data
                });

                if (callback)
                    callback.apply(this, arguments);
            }
        };

        return apf.getData(instruction, options);
    };
    
    /**
     * Loads the data from the datasource specified for init.
     */
    this.reload = function(){
        if (!this.data)
            return;
        
        if (this.$srcOptions)
            this.$loadFrom.apply(this, this.$srcOptions);
        else if (this.src)
            this.$loadFrom(this.src);
    };

    /**
     * Loads data in this model
     *
     * @param  {XMLElement} [xmlNode]  the data to load in this model. null will clear the data from this model.
     * @param  {Boolean}    [nocopy]   Whether the data loaded will not overwrite the reset point.
     */
    this.load = function(xmlNode, options){
        if (typeof xmlNode == "string") {
            if (xmlNode.charAt(0) == "<") { //xml
                if (xmlNode.substr(0, 5).toUpperCase() == "<!DOC")
                    xmlNode = xmlNode.substr(xmlNode.indexOf(">")+1);
                if (!apf.supportNamespaces)
                    xmlNode = xmlNode.replace(/xmlns\=\"[^"]*\"/g, "");
                xmlNode = apf.getXmlDom(xmlNode, null, true).documentElement; //@todo apf3.0 whitespace issue
            }
            
            else
                return this.$loadFrom(xmlNode, options);
        }

        if (this.ownerDocument && this.ownerDocument.$domParser.$shouldWait) {
            var _self = this;
            this.data = this.$copy = xmlNode; //@todo expirement
            this.$queueLoading = true;
            apf.queue.add("modelload" + this.$uniqueId, function(){
                _self.load(xmlNode, options);
                _self.$queueLoading = false;
            });
            return;
        }
        else if (this.$queueLoading)
            apf.queue.remove("modelload" + this.$uniqueId);
        
        this.$state = 0;

        if (this.dispatchEvent("beforeload", {xmlNode: xmlNode}) === false)
            return false;

        var doc = xmlNode ? xmlNode.ownerDocument : null; //Fix for safari refcount issue;

        //if (apf.isIE && this.$aml && this.getAttribute("ns"))
            //doc.setProperty("SelectionNamespaces", this.getAttribute("ns"));
        
        if (xmlNode) {
            if (!apf.supportNamespaces) {
                /* && (xmlNode.prefix || xmlNode.scopeName)) {
                doc.setProperty("SelectionNamespaces", "xmlns:"
                     + (xmlNode.prefix || xmlNode.scopeName) + "='"
                     + xmlNode.namespaceURI + "'");*/
                var xmlns = [], attr = xmlNode.attributes;
                for (var i = 0, l = attr.length; i < l; i++) {
                    if (attr[i].nodeName.substr(0, 5) == "xmlns") {
                        xmlns.push(attr[i].xml);
                    }
                }
                if (xmlns.length)
                    doc.setProperty("SelectionNamespaces", xmlns.join(" "));
            }
            
            apf.xmldb.addNodeListener(xmlNode, this); //@todo this one can be added for this.$listeners and when there are none removed
            apf.xmldb.nodeConnect(
                apf.xmldb.getXmlDocId(xmlNode, this), xmlNode, null, this);

            if ((!options || !options.nocopy) && this["save-original"])
                this.$copy = apf.xmldb.getCleanCopy(xmlNode);
        }

        this.data = xmlNode;
        
        this.dispatchEvent("afterload", {xmlNode: xmlNode});
        
        for (var id in this.$amlNodes)
            this.$loadInAmlNode(this.$amlNodes[id]);

        for (id in this.$propBinds)
            this.$loadInAmlProp(id, xmlNode);

        return this;
    };
    
    //Listening nodes should be removed in unregister
    this.$waitForXml = function(amlNode, prop){
        if (prop)
            this.$proplisteners[amlNode.$uniqueId + prop] = {
                id      : amlNode.$uniqueId, 
                amlNode : amlNode, 
                prop    : prop
            };
        else 
            this.$listeners[amlNode.$uniqueId] = amlNode;
        
        //@todo apf3.0 this was useful for something, i'm sure it was
        //node.xmlRoot = null; //.load(null)
        //if (amlNode.xmlRoot)
            //amlNode.clear();
    };
    
    this.$xmlUpdate = function(action, xmlNode, listenNode, UndoObj){
        //@todo optimize by only doing this for add, sync etc actions
        
        

        
        
        var p, b;
        for (var id in this.$listeners) {
            if (xmlNode = this.data.selectSingleNode(this.$amlNodes[id].xpath || ".")) {
                this.$listeners[id].load(xmlNode);
                delete this.$listeners[id];
            }
        }

        for (id in this.$proplisteners) {
            p = this.$proplisteners[id];
            b = this.$propBinds[p.id][p.prop];
            if (xmlNode = b.listen ? this.data.selectSingleNode(b.listen) : this.data) {
                apf.xmldb.addNodeListener(xmlNode, p.amlNode, 
                  "p|" + p.id + "|" + p.prop + "|" + this.$uniqueId);
                
                delete this.$proplisteners[id];
                p.amlNode.$execProperty(p.prop, b.root 
                  ? this.data.selectSingleNode(b.root) 
                  : this.data);
            }
        }
    };

    /**** INSERT ****/

    /**
     * Inserts data into the data of this model using a data instruction.
     * @param {String}     instruction  the data instrution how to retrieve the data.
     * @param {Object}     options
     *   Properties:
     *   {XMLElement} insertPoint  the parent element for the inserted data.
     *   {Boolean}    clearContents wether the contents of the insertPoint should be cleared before inserting the new children.
     *   {Boolean}    copyAttributes  wether the attributes of the merged element are copied.
     *   {Function}   callback     the code executed when the data request returns.
     *   {mixed}      <>           Custom properties available in the data instruction.
     */
    this.$insertFrom = function(instruction, options){
        if (!instruction) return false;

        this.dispatchEvent("beforeretrieve");

        
        var amlNode = options.amlNode;
        

        var callback = options.callback, _self = this;
        options.callback = function(data, state, extra){
            _self.dispatchEvent("afterretrieve");

            if (!extra)
                extra = {};

            if (state != apf.SUCCESS) {
                var oError;

                
                oError = new Error(apf.formatErrorString(0,
                    _self, "Inserting xml data", "Could not insert data\n"
                  + "Instruction:" + instruction + "\n"
                  + "Url: " + extra.url + "\n"
                  + "Info: " + extra.message + "\n\n" + data));
                

                if (extra.tpModule.retryTimeout(extra, state, 
                  options.amlNode || _self, oError) === true)
                    return true;

                if (callback 
                  && callback.call(this, extra.data, state, extra) === false)
                    return;

                throw oError;
            }

            //Checking for xpath
            if (typeof options.insertPoint == "string")
                options.insertPoint = _self.data.selectSingleNode(options.insertPoint);

            if (typeof options.clearContents == "undefined" && extra.userdata) 
                options.clearContents = apf.isTrue(extra.userdata[1]); //@todo is this still used?

            //Call insert function
            (options.amlNode || _self).insert(data, options);

            if (callback)
                callback.call(this, extra.data, state, extra);
        };

        apf.getData(instruction, options);
    };

    /**
     * Inserts data in this model as a child of the currently loaded data.
     *
     * @param  {XMLElement} XMLRoot         the {@link term.datanode data node} to insert into this model.
     * @param {Object}     options
     *   Properties:
     *   {XMLElement} insertPoint  the parent element for the inserted data.
     *   {Boolean}    clearContents wether the contents of the insertPoint should be cleared before inserting the new children.
     *   {Boolean}    copyAttributes  wether the attributes of the merged element are copied.
     *   {Function}   callback     the code executed when the data request returns.
     *   {mixed}      <>           Custom properties available in the data instruction.
     */
    this.insert = function(xmlNode, options){
        if (typeof xmlNode == "string") {
            if (xmlNode.charAt(0) == "<") {
                if (xmlNode.substr(0, 5).toUpperCase() == "<!DOC")
                    xmlNode = xmlNode.substr(xmlNode.indexOf(">")+1);
                if (!apf.supportNamespaces)
                    xmlNode = xmlNode.replace(/xmlns\=\"[^"]*\"/g, "");
                xmlNode = apf.getXmlDom(xmlNode).documentElement;
            }
            
            else
                return this.$insertFrom(xmlNode, options);
        }

        if (!options.insertPoint)
            options.insertPoint = this.data;

        
        if (!options.insertPoint) {
            throw new Error(apf.formatErrorString(0, amlNode || _self,
                "Inserting data", "Could not determine insertion point for "
              + "instruction: " + instruction));
        }
        

        //if(this.dispatchEvent("beforeinsert", parentXMLNode) === false) return false;

        //Integrate XMLTree with parentNode
        if (typeof options.copyAttributes == "undefined")
            options.copyAttributes = true;
        
        var newNode = apf.mergeXml(xmlNode, options.insertPoint, options);

        //Call __XMLUpdate on all this.$listeners
        apf.xmldb.applyChanges("insert", options.insertPoint);//parentXMLNode);

        //this.dispatchEvent("afterinsert");

        return xmlNode;
    };

    /* *********** SUBMISSION ****************/

    /**
     * Serialize the full XML DOM to a format specified by 'type'
     * 
     * @param {String} type  how to serialize the data
     */
    this.convertXml = function(type) {
        if (!type)
            return this.data.xml;

        return apf.convertXml(this.data, type);
    };

    /**
     * Submit the data of the model to a data source.
     * @param {String} instruction  the instruction for sending the data, or the url to send the data to.
     * @param {String} type         how to serialize the data.
     *   Possible values:
     *   xml, application/xml
     *   form, application/x-www-form-urlencoded
     *   json, application/json
     * @param {XMLElement} xmlNode  the data node to send to the server.
     */
     //@todo rewrite this for apf3.0
    this.submit = function(instruction, type, xmlNode, options){
        if (!instruction)
            instruction = this.submission;
        
        if (!xmlNode)
            xmlNode = this.data;

        
        if (!xmlNode) {
            throw new Error(apf.formatErrorString(0, this, 
                "Submitting model",
                "Could not submit data, because no data was passed and the "
              + "model does not have data loaded."));
        }
        

        if (!type)
            type = "form";

        if (this.dispatchEvent("beforesubmit", {
            instruction: instruction
        }) === false)
            return false;

        var model = this;
        function cbFunc(data, state, extra){
            if ((state == apf.TIMEOUT 
              || (model.retryOnError && state == apf.ERROR))
              && extra.retries < apf.maxHttpRetries) {
                return extra.tpModule.retry(extra.id);
            }
            else {
                if (state != apf.SUCCESS) {
                    model.dispatchEvent("submiterror", extra);
                }
                else {
                    model.dispatchEvent("submitsuccess", apf.extend({
                        data: data
                    }, extra));
                }
            }
        }
        
        var data;
        if (type.indexOf("xml") > -1)
            data = apf.getXmlString(xmlNode);
        else if (type.indexOf("form") > -1)
            data = apf.convertXml(apf.xmldb.getCleanCopy(xmlNode), "cgiobjects");
        else if (type.indexOf("json") > -1)
            data = apf.convertXml(xmlNode, "json");

        apf.saveData(instruction, apf.extend({
            xmlNode  : xmlNode,
            data     : data,
            callback : cbFunc
        }, options));

        this.dispatchEvent("aftersubmit");
    };

    this.$destroy = function(){
        if (this.session && this.data)
            apf.saveData(this.session, {xmlNode: this.getXml()});
    };
}).call(apf.model.prototype = new apf.AmlElement());

apf.aml.setElement("model", apf.model);




/*FILEHEAD(/var/lib/platform/source/trunk/elements/list.js)SIZE(15894)TIME(1269561674)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * Element displaying a skinnable list of options which can be selected.
 * Selection of multiple items can be allowed. Items can be renamed
 * and removed. The list can be used as a collection of checkboxes or 
 * radiobuttons. This is especially useful for use in forms.
 * This element is one of the most often used elements. It can display lists
 * of items in a cms style interface or display a list of search results in 
 * a more website like interface.
 * Example:
 * A simple list with inline items.
 * <code>
 *  <a:list multimatch="[false]">
 *      <a:item>The Netherlands</a:item>
 *      <a:item>United States of America</a:item>
 *      <a:item>United Kingdom</a:item>
 *      ...
 *  </a:list>
 * </code>
 * Example:
 * A databound list with items loaded from an xml file.
 * <code>
 *  <a:list model="friends.xml" each="[friend]" caption="[@name]" />
 * </code>
 * Example:
 * A databound list using the bindings element
 * <code>
 *  <a:model id="mdlList">
 *      <data>
 *          <item date="2009-11-12" deleted="0"></item>
 *          <item date="2009-11-11" deleted="0"></item>
 *          <item date="2009-11-10" deleted="0"></item>
 *          <item date="2009-11-09" deleted="1"></item>
 *          <item date="2009-11-08" deleted="1"></item>
 *      </data>
 *  </a:model>
 *  <a:list id="list" width="200" height="200" model="mdlList">
 *      <a:bindings>
 *          <a:caption match="[@date]" />
 *          <a:each match="[item[not(@deleted='1')]]" />
 *      </a:bindings>
 *  </a:list>
 * </code>
 *
 * @event click Fires when a user presses a mouse button while over this element.
 *
 * @constructor
 * @define list, select, select1, thumbnail
 * @allowchild {smartbinding}
 * @addnode elements
 *
 * @inherits apf.BaseList
 * @inherits apf.Rename
 *
 * @author      Ruben Daniels (ruben AT ajax DOT org)
 * @version     %I%, %G%
 * @since       0.4
 */
apf.list      = function(struct, tagName){
    this.$init(tagName || "list", apf.NODE_VISIBLE, struct);
};

/**
 * Example:
 * A small product search application using a list to display results.
 * <code>
 *  <a:bar>
 *      <h1>Search for a product</h1>
 *      <a:textbox id="txtSearch" selectfocus="true" />
 *      <a:button onclick="search()" default="true">Search</a:button>
 *  </a:bar>
 * 
 *  <a:model id="mdlSearch">
 *      <data>
 *          <item title="Title 1" src="siteimg/slideshow_img/img1_small.jpg" descr="Descr 1"></item>
 *          <item title="Title 2" src="siteimg/slideshow_img/img2_small.jpg" descr="Descr 2"></item>
 *      </data>
 *  </a:model>
 * 
 *  <a:thumbnail 
 *    model         = "mdlSearch"
 *    autoselect    = "false" 
 *    width         = "400"
 *    height        = "400"
 *    caching       = "false" 
 *    empty-message = "No products found">
 *      <a:bindings>
 *          <a:caption match="[@title]" />
 *          <a:image match="[@src]" />
 *          <a:each match="[item]" />
 *      </a:bindings>
 *  </a:thumbnail>
 * 
 *  <a:script>
 *      function search(){
 *          mdlSearch.$loadFrom("http://localhost/search.php?keyword=" + txtSearch.getValue());
 *      }
 *  </a:script>
 * </code>
 */
apf.thumbnail = function(struct, tagName){
    this.$init(tagName || "thumbnail", apf.NODE_VISIBLE, struct);
};

apf.select    = function(struct, tagName){
    this.$init(tagName || "select", apf.NODE_VISIBLE, struct);
};

apf.select1   = function(struct, tagName){
    this.$init(tagName || "selectl", apf.NODE_VISIBLE, struct);
};

(function(){
    
    if (!apf.isIphone)
        this.implement(apf.Rename);
    
    
    
    this.$getCaptionElement = function(){
        if (!(this.$caret || this.$selected))
            return;
        
        var x = this.$getLayoutNode("item", "caption", this.$caret || this.$selected);
        if (!x) 
            return;
        return x.nodeType == 1 ? x : x.parentNode;
    };
    
    
    
    
    /**** Properties and Attributes ****/
    
    this.$supportedProperties.push("appearance", "mode", "more", "thumbsize");
    
    this.$propHandlers["thumbsize"] = function(value){
        var className = this.thumbclass;
        
        if (apf.isIE) { //@todo detection??
            className = className.splitSafe(",");
            for (var i = 0; i < className.length; i++) {
                apf.setStyleRule(className[i], "width", value + "px");
                apf.setStyleRule(className[i], "height",  value + "px");
            }
            return;
        }
        
        apf.setStyleRule(className, "width", value + "px");
        apf.setStyleRule(className, "height",  value + "px");
    };
    
    
    /**
     * @attribute {String} appearance the type of select this element is. 
     * This is an xforms property and only available if apf is compiled 
     * with __WITH_XFORMS set to 1.
     *   Possible values:
     *   full     depending on the tagName this element is either a list of radio options or of checked options.
     *   compact  this elements functions like a list with multiselect off.
     *   minimal  this element functions as a dropdown element.
     */
    this.$propHandlers["appearance"] = function(value){
        
    };
    
    /**
     * @attribute {String} mode Sets the way this element interacts with the user.
     *   Possible values:
     *   check  the user can select a single item from the list. The selected item is indicated.
     *   radio  the user can select multiple items from a list. Each selected item is indicated.
     */
    this.mode = "normal";
    this.$propHandlers["mode"] = function(value){
        this.mode = value || "normal";
        
        if ("check|radio".indexOf(this.mode) > -1) {
            this.allowdeselect = false;
            
            this.addEventListener("afterrename", $afterRenameMode);
            
            if (this.mode == "check") {
                this.autoselect = false;
                this.ctrlselect    = true;
            }
            else if (this.mode == "radio")
                this.multiselect = false;
            
            //if (!this.actionRules) //default disabled
                //this.actionRules = {}
        }
        else {
            //@todo undo actionRules setting
            this.ctrlselect = false;
            this.removeEventListener("afterrename", $afterRenameMode);
        }
    };
    
    //@todo apf3.0 retest this completely
    function $afterRenameMode(){
    }
    
    
    /**
     * @attribute {String} more Adds a new item to the list and lets the users 
     * type in the new name. This is especially useful in the interface when 
     * {@link element.list.attribute.mode} is set to check or radio. For instance in a form.
     * Example:
     * This example shows a list in form offering the user several options. The
     * user can add a new option. A server script could remember the addition
     * and present it to all new users of the form.
     * <code>
     *  <a:model id="mdlSuggestions">
     *      <suggestions>
     *          <question key="krant">
     *              <answer>Suggestion 1</answer>
     *              <answer>Suggestion 2</answer>
     *          </question>
     *      </suggestions>
     * </a:model>
     * <a:label>Which newspapers do you read?</a:label>
     * <a:list value="[krant]" 
     *   more  = "caption:Add new suggestion" 
     *   model = "[mdlSuggestions::question[@key='krant']]">
     *     <a:bindings>
     *         <a:caption match="[text()]" />
     *         <a:value match="[text()]" />
     *         <a:each match="[answer]" />
     *     </a:bindings>
     *     <a:actions>
     *         <a:rename match="[node()[@custom='1']]" />
     *         <a:remove match="[node()[@custom='1']]" />
     *         <a:add>
     *             <answer custom="1">New Answer</answer>
     *         </a:add>
     *     </a:actions>
     *  </a:list>
     * </code>
     */
    this.$propHandlers["more"] = function(value){
        if (value) {
            this.delayedselect = false;
            this.addEventListener("xmlupdate", $xmlUpdate);
            this.addEventListener("afterload", $xmlUpdate);
            //this.addEventListener("afterrename", $afterRenameMore);
            //this.addEventListener("beforeselect", $beforeSelect);
            
            this.$setClearMessage    = function(msg){
                if (!this.moreItem)
                    this.$fill();
                this.$container.appendChild(this.moreItem);
            };
            this.$updateClearMessage = function(){}
            this.$removeClearMessage = function(){};
        }
        else {
            this.removeEventListener("xmlupdate", $xmlUpdate);
            this.removeEventListener("afterload", $xmlUpdate);
            //this.removeEventListener("afterrename", $afterRenameMore);
            //this.removeEventListener("beforeselect", $beforeSelect);
        }
    };
    
    function $xmlUpdate(e){
        if ((!e.action || "insert|add|synchronize|move".indexOf(e.action) > -1) && this.moreItem)
            this.$container.appendChild(this.moreItem);
    }
    
    /*function $afterRenameMore(){
        var caption = this.$applyBindRule("caption", this.caret)
        var xmlNode = this.findXmlNodeByValue(caption);

        var curNode = this.caret;
        if (xmlNode != curNode || !caption) {
            if (xmlNode && !this.isSelected(xmlNode)) 
                this.select(xmlNode);
            this.remove(curNode);
        }
        else 
            if (!this.isSelected(curNode)) 
                this.select(curNode);
    }
    
    function $beforeSelect(e){
        //This is a hack
        if (e.xmlNode && this.isSelected(e.xmlNode) 
          && e.xmlNode.getAttribute('custom') == '1') {
            this.setCaret(e.xmlNode);
            this.selected = e.xmlNode;
            $setTimeout(function(){
                _self.startRename()
            });
            return false;
        }
    }*/
    
    
    /**** Keyboard support ****/
    
    
    this.addEventListener("keydown", this.$keyHandler, true);
    
    
    /**** Init ****/
    
    this.$draw = function(){
        this.appearance = this.getAttribute("appearance") || "compact";
        var mode = this.getAttribute("mode");

        //@todo apf3.0 checkmode, radiomode
        /*if (this.localName == "select" && (this.appearance == "full" 
          || this.appearance == "minimal") || mode == "check") {
            this.$aml.setAttribute("mode", "check");
            if (!this.getAttribute("skin")) {
                this.skinName = null;
                this.skin = "checklist"
                this.$loadSkin();
            }
        }
        else if (this.localName == "select1" && this.appearance == "full"
          || mode == "radio") {
            this.$aml.setAttribute("mode", "radio");
            if (!this.getAttribute("skin")) {
                this.skinName = null;
                this.skin = "radiolist";
                this.$loadSkin();
            }
        }
        else if (this.localName == "select1" && this.appearance == "compact") 
            this.multiselect = false;*/
        
        //Build Main Skin
        this.$ext = this.$getExternal();
        this.$container = this.$getLayoutNode("main", "container", this.$ext);
        
        if (apf.hasCssUpdateScrollbarBug && !this.mode)
            this.$fixScrollBug();
        
        var _self = this;
        this.$ext.onclick = function(e){
            _self.dispatchEvent("click", {
                htmlEvent: e || event
            });
        }
        
        this.$ext.setAttribute("onmouseout", this.$ext.getAttribute("onmouseout") 
            + ';var o = apf.lookup(' + this.$uniqueId + ');o.$selectSeries(event);');
        
        //Get Options form skin
        //Types: 1=One dimensional List, 2=Two dimensional List
        this.listtype  = parseInt(this.$getOption("main", "type")) || 1;
        //Types: 1=Check on click, 2=Check independent
        this.behaviour = parseInt(this.$getOption("main", "behaviour")) || 1; 
        
        this.thumbsize  = this.$getOption("main", "thumbsize");
        this.thumbclass = this.$getOption("main", "thumbclass");
    };
    
    this.$selectSeries = function(e) {
        e = e || event;
        //e.cancelBubble = true;
        var target = e.target || e.srcElement;

        if (e.type == "mouseover") {
            var target = (target.className || "").indexOf("item") != -1 
                ? target 
                : target.parentNode;
                
            this.highlight(target);
        }
        else {
            target = e.toElement 
                ? e.toElement 
                : (e.relatedTarget 
                    ? e.relatedTarget 
                    : null);
            
            if (!apf.isChildOf(this.$ext, target, true)) {
                this.highlight(this.$selected);
            }
        }
    };
    
    this.highlight = function(target) {
        var options     = this.$ext.childNodes;
        var options_len = options.length;
        var deselect    = false;

        for (var i = 0; i < options_len; i++) {
            if ((options[i].className || "").indexOf("item") != -1) {
                if (!deselect) {
                    this.$setStyleClass(options[i], "selected");
                }
                else {
                    this.$setStyleClass(options[i], "", ["selected"]);
                }
                
                if (options[i] == target) {
                    deselect = true;
                }
            }
        }
    };
    
    this.$loadAml = function(x){
    };
    
    this.$destroy = function(){
        if (this.$ext)
            this.$ext.onclick = null;
        apf.destroyHtmlNode(this.oDrag);
        this.oDrag = null;
    };
}).call(apf.list.prototype = new apf.BaseList());

apf.thumbnail.prototype =
apf.select.prototype    =
apf.select1.prototype   = apf.list.prototype;

apf.aml.setElement("thumbnail", apf.thumbnail);
apf.aml.setElement("select",    apf.select);
apf.aml.setElement("select1",   apf.select1);
apf.aml.setElement("list",      apf.list);



/*FILEHEAD(/var/lib/platform/source/trunk/elements/errorbox.js)SIZE(6093)TIME(1269561674)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/**
 * Element showing an error message when the attached element 
 * is in erroneous state and has the invalidmsg="" attribute specified.
 * In most cases the errorbox element is implicit and will be created 
 * automatically. 
 * Example:
 * <code>
 *  <a:errorbox>
 *      Invalid e-mail address entered.
 *  </a:errorbox>
 * </code>
 * Remarks:
 * In most cases the errorbox element is not created directly but implicitly
 * by a validationgroup. An element that goes into an error state will
 * show the errorbox.
 * <code>
 *  <a:bar validgroup="vgForm">
 *      <a:label>Phone number</a:label>
 *      <a:textbox id="txtPhone"
 *          required   = "true" 
 *          pattern    = "(\d{3}) \d{4} \d{4}" 
 *          invalidmsg = "Incorrect phone number entered" />
 *
 *      <a:label>Password</a:label>
 *      <a:textbox 
 *          required   = "true" 
 *          mask       = "password"
 *          minlength  = "4"
 *          invalidmsg = "Please enter a password of at least four characters" />
 *      <a:button onclick="vgForm.validate()">Validate</a:button>
 *  </a:bar>
 * </code>
 *
 * To check if the element has valid information entered, leaving the textbox
 * (focussing another element) will trigger a check. Programmatically a check
 * can be done using the following code:
 * <code>
 *  txtPhone.validate();
 * 
 *  //Or use the html5 syntax
 *  txtPhone.checkValidity();
 * </code>
 *
 * To check for the entire group of elements use the validation group. For only 
 * the first non-valid element the errorbox is shown. That element also receives
 * focus.
 * <code>
 *  vgForm.validate();
 * </code>
 *
 * @constructor
 * @define errorbox
 * 
 * @allowchild {anyxhtml}
 * @addnode elements
 *
 * @inherits apf.Presentation
 *
 * @author      Ruben Daniels (ruben AT ajax DOT org)
 * @version     %I%, %G%
 * @since       0.4
 */
apf.errorbox = function(struct, tagName){
    this.$init(tagName || "errorbox", apf.NODE_VISIBLE, struct);
};

(function(){
    this.$positioning = "basic";
    this.display = function(host){
        this.host = host;
        
        var refHtml = 
            
            host.$ext;

        document.body.appendChild(this.$ext);
        /*var pos = apf.getAbsolutePosition(refHtml, document.body);

        if (document != refHtml.ownerDocument) {
            var pos2 = apf.getAbsolutePosition(refHtml.ownerDocument.parentWindow.frameElement, document.body);
            pos[0] += pos2[0];
            pos[1] += pos2[1];
        }*/

        var x = (parseFloat(host.$getOption && host.$getOption("main", "erroffsetx") || 0)),
            y = (parseFloat(host.$getOption && host.$getOption("main", "erroffsety") || 0));
        //this.$ext.style.left = x + "px"
        //this.$ext.style.top  = y + "px"

        this.show();
        apf.popup.show(this.$uniqueId, {
            x       : x,
            y       : y,
            animate : false,
            ref     : refHtml
        });

        this.$setStyleClass(this.$ext,
            x + this.$ext.offsetWidth > this.$ext.offsetParent.offsetWidth
                ? "rightbox"
                : "leftbox", ["leftbox", "rightbox"]);
    };
    
    /**
     * Sets the message of the errorbox.
     * @param {String} value 
     */
    this.setMessage = function(value){
        if (value && value.indexOf(";") > -1) {
            value = value.split(";");
            value = "<strong>" + value.shift() + "</strong>" + value.join(";");
        }
        this.$int.innerHTML = value || "";
    };
    
    this.$draw = function(){
        //Build Main Skin
        this.$ext   = this.$getExternal(); 
        this.$int   = this.$getLayoutNode("main", "container", this.$ext);
        this.oClose = this.$getLayoutNode("main", "close", this.$ext);
        
        if (this.oClose) {
            var _self = this;
            this.oClose.onclick = function(){
                _self.hide();

                if (apf.document.activeElement)
                    apf.document.activeElement.focus(true, {mouse:true});
            };
        }
        
        this.$ext.onmousedown = function(e){
            (e || event).cancelBubble = true;
            
            
            if (apf.hasFocusBug)
                apf.window.$focusfix();
            
        }

        apf.popup.setContent(this.$uniqueId, this.$ext, "", null, null);
    };
    
    this.$loadAml = function(x){
        if (!apf.isTrue(this.getAttribute("visible")))
            this.hide();
    };
    
    this.$destroy = function(){
        if (this.oClose)
            this.oClose.onclick = null;
        
        this.$ext.onmousedown = null;
        
        apf.popup.removeContent(this.$uniqueId);
    };
}).call(apf.errorbox.prototype = new apf.Presentation());

apf.aml.setElement("errorbox", apf.errorbox);


/*FILEHEAD(/var/lib/platform/source/trunk/elements/bindingquicksandrule.js)SIZE(12333)TIME(1266969664)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * @todo docs
 */
apf.BindingQuicksandRule = function(struct, tagName){
    this.$init(tagName, apf.NODE_HIDDEN, struct);
};

(function(){
    function getFilteredNodes(pNode) {
        pNode = pNode || this.$parent;
        var attr, tmp,
            res      = [],
            dataIDs  = [],
            xmlNodes = pNode.$getDataNode("quicksand", pNode.xmlRoot, false, null, true),
            domNodes = pNode.$ext.childNodes,
            i        = 0,
            l        = xmlNodes.length;
        if (!domNodes.length || !l)
            return res;

        for (; i < l; ++i)
            dataIDs.push(xmlNodes[i].getAttribute("a_id"));

        for (i = 0, l = domNodes.length; i < l; ++i) {
            if (!domNodes[i] || !(attr = domNodes[i].getAttribute("id")))
                continue;
            tmp = attr.split("|");
            tmp.pop();
            if (dataIDs.indexOf(tmp.join("|")) > -1)
                res.push(domNodes[i]);
        }

        return res;
    }

    function nodeInFilter(node, filtered) {
        var i = 0,
            l = filtered.length,
            s = node.getAttribute("id");
        for (; i < l; ++i) {
            if (filtered[i].getAttribute("id") == s)
                return filtered[i];
        }
        return null;
    }

    function quicksand(parent, customOptions) {
        parent = this.$parent.$ext;

        var i, l, dest, src, offset,
            _self            = this,
            coll             = getFilteredNodes.call(this), // destination (target) collection
            //sourceHeight = apf.getStyle(parent, "height"), // used to keep height and document flow during the animation
            parentOffset     = apf.getAbsolutePosition(parent), // offset of visible container, used in animation calculations
            offsets          = [], // coordinates of every source collection item
            callbackFunction = typeof(arguments[1]) == "function"
                ? arguments[1]
                : typeof arguments[2] == "function" ? arguments[2] : apf.K,
            // Gets called when any animation is finished
            //var postCallbackPerformed = 0; // prevents the function from being called more than one time
            postCallback     = function() {
                _self.dispatchEvent("afterquicksand");
                callbackFunction.call(_self);
                /*if (!postCallbackPerformed) {
                    parent.innerHTML = $dest.innerHTML; // put target HTML into visible source container
                    $("[data-quicksand-owner=" + cssPath(parent) + "]").remove(); // remove all temporary containers
                    if (typeof callbackFunction == "function")
                        callbackFunction.call(this);
                    postCallbackPerformed = 1;
                }*/
            },
            options = {
                steps: 60,
                anim: apf.tween.easeInOutQuad,
                onfinish: postCallback,
                // put false if you don't want the plugin to adjust height of container to fit all the items
                adjustHeight: true
            };
        apf.extend(options, customOptions);;

        // Replace the collection and quit if IE6
        if (apf.isIE && apf.isIE < 7) {
            parent.innerHTML = "";
            for (i = 0, l = coll.length; i < l; i++)
                parent.appendChild(coll[i]);
            return;
        }

        var $source = parent.childNodes; // source collection items

        // Position: relative situations
        var correctionOffset = [0, 0];
        /*var $correctionParent = parent.offsetParent();
        var correctionOffset = apf.getAbsolutePosition($correctionParent);
        if (apf.getStyle($correctionParent, "position") == "relative") {
            if ($correctionParent.get(0).nodeName.toLowerCase() == "body") {

            }
            else {
                correctionOffset[0] += parseFloat($correctionParent.css("border-top-width"));
                correctionOffset[1] += parseFloat($correctionParent.css("border-left-width"));
            }
        } else {
            correctionOffset[0] -= parseFloat($correctionParent.css("border-top-width"));
            correctionOffset[1] -= parseFloat($correctionParent.css("border-left-width"));
            correctionOffset[0] -= parseFloat($correctionParent.css("margin-top"));
            correctionOffset[1] -= parseFloat($correctionParent.css("margin-left"));
        }*/


        // keeps nodes after source container, holding their position
        parent.style.height = parent.offsetHeight + "px";

        // stops previous animations on source container
        apf.tween.clearQueue(parent, true);//$(this).stop();

        // get positions of source collections
        for (i = 0, l = $source.length; i < l; ++i) {
            src = $source[i];
            offsets[i] = apf.getAbsolutePosition(src, parent, false);
        }
        for (i = 0, l = $source.length; i < l; ++i) {
            src = $source[i];
            // This doesn"t move any element at all, just sets position to absolute
            // and adjusts top & left to make them compatible with position: absolute
            with (src.style) {
                position = "absolute";
                margin   = "0";
                top      = (offsets[i][1] - parentOffset[1]) + "px";// - parseFloat(apf.getStyle(src, "margin-top"))  + "px";
                left     = (offsets[i][0] - parentOffset[0]) + "px";// - parseFloat(apf.getStyle(src, "margin-left")) + "px";
            }
        }

        // create temporary container with destination collection
        var $dest = parent.cloneNode(false);
        $dest.setAttribute("id", "");
        //$dest.setAttribute("data-quicksand-owner", parent.selector);
        //$dest.style.height = "auto";
        //$dest.style.width  = parent.offsetWidth + "px";

        for (i = 0, l = coll.length; i < l; ++i) {
            $dest.appendChild(coll[i].cloneNode(true));
            coll[i].$offset = apf.getAbsolutePosition(coll[i]);
        }
        // insert node into HTML
        // Note that the node is under visible source container in the exactly same position
        // The browser render all the items without showing them (opacity: 0.0)
        // No offset calculations are needed, the browser just extracts position from underlayered destination items
        // and sets animation to destination positions.
        parent.parentNode.insertBefore($dest, parent);
        //$dest.setAttribute("data-quicksand-owner", cssPath(parent));
        with ($dest.style) {
            zIndex   = 1;
            opacity  = 0;
            margin   = 0;
            position = "absolute";
            top      = parentOffset[1] - correctionOffset[1] + "px";
            left     = parentOffset[0] - correctionOffset[0] + "px";
        }

        // If destination container has different height than source container
        // the height can be animated, adjusting it to destination height
        if (false) {//options.adjustHeight) {
            apf.tween.single(parent, {
                steps: options.steps,
                anim : options.anim,
                type : "height",
                from : parent.offsetHeight,
                to   : $dest.offsetHeight
            });//parent.animate({height: $dest.height()}, options.duration, options.easing);
        }

        // Now it's time to do shuffling animation
        // First of all, we need to identify same elements within source and destination collections
        var insets = [];
        for (i = 0, l = $source.length; i < l; ++i) {
            src = $source[i];
            //var destElement = coll.filter("[" + options.attribute + "=" + src.getAttribute(options.attribute) + "]");
            if (dest = nodeInFilter(src, coll)) {//destElement.length) {
                // The item is both in source and destination collections
                // If it's under different position, let's move it
                offset = insets.shift() || offsets[i];
                options.tweens = [{
                    type: "top",
                    from: dest.$offset[1] - parentOffset[1],
                    to  : offset[1] - parentOffset[1]
                }, {
                    type: "left",
                    from: dest.$offset[0] - parentOffset[0],
                    to  : offset[0] - parentOffset[0]
                }, {
                    type: "opacity",
                    from: apf.getStyle(src, "opacity"),
                    to  : 1
                }];
                if (apf.supportCSSAnim) {
                    options.tweens.push({
                        type: "transform",
                        subType: "scale",
                        from: 0,
                        to: 1.0
                    });
                }
                apf.tween.multi(src, options);
            }
            else {
                // The item from source collection is not present in destination collections
                // Let's remove it
                options.tweens = [{
                    type: "opacity",
                    from: apf.getStyle(src, "opacity"),
                    to  : 0
                }];
                if (apf.supportCSSAnim) {
                    options.tweens.push({
                        type: "transform",
                        subType: "scale",
                        from: 1.0,
                        to: 0
                    });
                }
                insets.push(offsets[i]);
                apf.tween.multi(src, options);
            }
        }

        for (i = 0, l = coll.length; i < l; ++i) {
            var item = coll[i];
            // Grab all items from target collection not present in visible source collection
            if (!nodeInFilter(item, $source)) {
                // No such element in source collection...
                dest = nodeInFilter(item, coll);
                
                options.tweens = [{
                    type: "opacity",
                    from: 0,
                    to  : 1
                }];
                if (!apf.isIE) {
                    // @todo add scaleTo animation (CSS3) to 0.0
                }
                
                // Let's create it
                offset = apf.getAbsolutePosition(dest);
                dest   = dest.cloneNode(true);

                with (dest.style) {
                    position  = "absolute";
                    margin    = "0";
                    top       = (offset[1] - parentOffset[1]) + "px";
                    left      = (offset[0] - parentOffset[0]) + "px";
                    opacity   = "0";
                    transform = "scale(.0)";
                }
                parent.appendChild(dest);
                apf.tween.multi(dest, options);
            }
        }
    }

    this.addEventListener("DOMNodeInsertedIntoDocument", function(e){
        //Find parent that this rule works on
        var pNode = this;
        while (pNode && pNode.$bindingRule)
            pNode = pNode.parentNode;
        this.$parent = pNode;

        if (!pNode)
            return;

        var _self = this;
        setTimeout(function() {
            quicksand.call(_self);
        });
    });
}).call(apf.BindingQuicksandRule.prototype = new apf.BindingRule());

apf.aml.setElement("quicksand", apf.BindingQuicksandRule);




/*FILEHEAD(/var/lib/platform/source/trunk/elements/services.js)SIZE(1488)TIME(1269561674)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/elements/validation.js)SIZE(3775)TIME(1269561674)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * @define validation 
 *
 * @constructor
 * @apfclass
 *
 * @author      Ruben Daniels (ruben AT ajax DOT org)
 * @version     %I%, %G%
 * @since       0.8
 *
 * @default_private
 */
apf.validation = function(struct, tagName){
    this.$init(tagName || "validation", apf.NODE_HIDDEN, struct);
};

(function(){
    this.$rules = [];
    
    var amlNodes = {};
    this.register = function(amlNode){
        if (amlNode.tagName != "model")
            return;
        
        amlNodes[amlNode.$uniqueId] = amlNode;
        
        amlNode.$validation = this;
        
        //each child should register
    }

    this.unregister = function(){
        //unregister element
        amlNodes[amlNode.$uniqueId] = null;
        delete amlNodes[amlNode.$uniqueId];
        
        amlNode.$validation = null;
    };
    
    this.getRule = function(xmlNode){
        /*var rules = this.$rules[name];
        //@todo Shouldn't allow async calls..., should always give a function
        for (var rule, i = 0, l = rules.length; i < l; i++) {
            var rule = rules[i];
            if ((rule[1] || (rule[1] = (rule[5] = apf.lm.compileMatch(rule[0]))[0] ||apf.K))(xmlNode)) 
                return rule;
        }*/

        var id = apf.xmldb.nodeConnect(apf.xmldb.getXmlDocId(xmlNode), xmlNode.nodeType == 1 ? xmlNode : xmlNode.parentNode);
        for (var i = 0, l = this.$rules.length; i < l; i++) {
            if (xmlNode.ownerDocument.selectSingleNode("(.//" + this.$rules[i][0].split("|").join("|.//") + ")[@" + apf.xmldb.xmlIdTag + "='" + id + "']"))
                return this.$rules[i][1];
        }
    }
    
    this.validate = function(xmlNode, checkRequired, validityState){
        var rule = this.getRule(xmlNode);
        if (!rule) return validityState;
        
        return (rule.isValid || (rule.isValid 
          = apf.validator.compile(rule)))(apf.queryValue(xmlNode), checkRequired, validityState);
    }
    
    //@todo add DOM handlers
    
    /**
     * @private
     */
    this.addEventListener("DOMNodeInsertedIntoDocument", function(e){
        var x = this.$aml;
        
        var rule, attr, node, nodes = x.childNodes;
        for (var i = 0, l = nodes.length; i < l; i++) {
            if ((node = nodes[i]).nodeType != 1)
                continue;
            this.$rules.push([node.getAttribute("match"), (rule = {})]);
            attr = node.attributes;
            for (var j = 0; j < attr.length; j++)
                rule[attr[j].nodeName] = attr[j].nodeValue;
            rule.node = node;
        }
        
        this.register(this.parentNode);
    });
}).call(apf.validation.prototype = new apf.AmlElement());

apf.aml.setElement("validation", apf.validation);



/*FILEHEAD(/var/lib/platform/source/trunk/elements/splitter.js)SIZE(18374)TIME(1265032029)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * @constructor
 * @private
 */
apf.splitter = function(struct, tagName){
    this.$init(tagName || "splitter", apf.NODE_VISIBLE, struct);
    
    
    apf.plane.init();
    
};

(function() {
    this.$focussable = true; // This object can get the focus
    
    /* ********************************************************************
                                        PUBLIC METHODS
    *********************************************************************/
    
    this.update = function(){
        //Optimize this to not recalc for certain cases
        var b = (this.type == "vertical")
            ? {
                fsize      : "fwidth",
                size       : "width",
                offsetPos  : "offsetLeft",
                offsetSize : "offsetWidth",
                pos        : "left"
              }
            : {
                fsize      : "fheight",
                size       : "height",
                offsetPos  : "offsetTop",
                offsetSize : "offsetHeight", 
                pos        : "top"
              };
        
        this.$ext.offsetTop; //@weird somehow this will fix a problem in IE8
        
        this.$amlNode = this.refNode;
        var htmlNode  = this.refHtml;

        var v          = apf.layout.vars;
        var oItem      = this.oItem;
        var needRecalc = false;
        
        var itemStart = htmlNode 
            ? htmlNode[b.offsetPos] 
            : v[b.pos + "_" + oItem.id];
        var itemSize  = htmlNode 
            ? htmlNode[b.offsetSize] 
            : v[b.size + "_" + oItem.id];

        var row = oItem.parent.children;
        for (var z = 0, i = 0; i < row.length; i++)
            if (!row[i][b.fsize])
                z++;

        if (!oItem[b.fsize] && z > 1) {
            for (var rTotal = 0, rSize = 0, i = oItem.stackId + 1; i < row.length; i++) {
                if (!row[i][b.fsize]) {
                    rTotal += row[i].weight || 1;
                    rSize  += (row[i].node 
                        ? row[i].oHtml[b.offsetSize] 
                        : v[b.size + "_" + row[i].id]);
                }
            }
            
            var diff  = this.$ext[b.offsetPos] - itemStart - itemSize;
            var rEach = (rSize - diff)/rTotal;
            
            for (var i = 0; i < oItem.stackId; i++) {
                if (!row[i][b.fsize])
                    row[i].original.weight = (row[i].node 
                        ? row[i].oHtml[b.offsetSize] 
                        : v[b.size + "_" + row[i].id]) / rEach;
            }

            oItem.original.weight = (itemSize + diff) / rEach
            needRecalc = true;
        }
        else {
            var isNumber     = oItem[b.fsize] ? oItem[b.fsize].match(/^\d+$/) : false;
            var isPercentage = oItem[b.fsize] ? oItem[b.fsize].match(/^([\d\.]+)\%$/) : false;
            if (isNumber || isPercentage || !oItem[b.fsize]) {
                var diff      = this.$ext[b.offsetPos] - itemStart - itemSize;
                var newHeight = this.$ext[b.offsetPos] - itemStart;
                
                for (var total = 0, size = 0, i = oItem.stackId + 1; i < row.length; i++) {
                    if (!row[i][b.fsize]) {
                        total += row[i].weight || 1;
                        size  += (row[i].node 
                            ? row[i].oHtml[b.offsetSize] 
                            : v[b.size + "_" + row[i].id]);
                    }
                }
                
                if (total > 0) {
                    var ratio = ((size-diff)/total)/(size/total);
                    for (var i = oItem.stackId + 1; i < row.length; i++)
                        row[i].original.weight = ratio * (row[i].weight || 1);
                }
                else {
                    for (var i = oItem.stackId + 1; i < row.length; i++) {
                        if (row[i][b.fsize].match(/^\d+$/)) {
                            //should check for max here as well
                            var nHeight = (row[i].node 
                                ? row[i].oHtml[b.offsetSize] 
                                : v[b.size + "_" + row[i].id]) - diff;
                            row[i].original[b.fsize] = "" + Math.max(0, nHeight, row[i].minheight || 0);
                            if (row[i][b.fsize] - nHeight != 0) 
                                diff = row[i][b.fsize] - nHeight;
                            else
                                break;
                        }
                        else
                            if (row[i][b.fsize].match(/^([\d\.]+)\%$/)) {
                                var nHeight = (row[i].node 
                                    ? row[i].oHtml[b.offsetSize] 
                                    : v[b.size + "_" + row[i].id]) - diff;
                                row[i].original[b.fsize] = Math.max(0,
                                    ((parseFloat(RegExp.$1) / (row[i].node 
                                    ? row[i].oHtml[b.offsetSize] 
                                    : v[b.size + "_" + row[i].id])) * nHeight)) + "%";
                                //check fheight
                                break;
                            }
                    }
                }
                
                if (oItem.original[b.fsize]) {
                    oItem.original[b.fsize] = isPercentage 
                        ? ((parseFloat(isPercentage[1])/itemSize) * newHeight) + "%" 
                        : "" + newHeight;
                }
                
                //if(total > 0  || isPercentage) needRecalc = true;
                needRecalc = true;
            }
        }

        if (needRecalc) {
            /*
            var l = apf.layout.layouts[this.$ext.parentNode.getAttribute("id")];
            apf.layout.compileAlignment(l.root);
            apf.layout.activateRules(this.$ext.parentNode);

            */
            
            apf.layout.compile(this.$ext.parentNode);
            apf.layout.activateRules(this.$ext.parentNode);
            
            if (apf.hasSingleRszEvent)
                apf.layout.forceResize();

            return;
        }

        apf.layout.forceResize(this.$ext.parentNode);
    };
    
    /* *********
        INIT
    **********/
    //this.implement(apf.GuiElement); /** @inherits apf.GuiElement */
    
    this.init = function(size, refNode, oItem){
        /*var li = size + min + max + (refNode.$uniqueId || refNode);
        if(li == this.$lastinit) return;
        this.$lastinit = li;*/
        this.min     = 0;
        this.max     = 1000000;
        this.size    = parseInt(size) || 3;
        this.refNode = null;
        this.refHtml = null;
        
        var pNode;
        if (refNode) {
            if (typeof refNode != "object")
                refNode = apf.lookup(refNode);
            this.refNode = refNode;
            this.refHtml = this.refNode.$ext;
            pNode        = this.refHtml.parentNode;

            oItem        = refNode.aData.calcData;
        }
        else
            pNode = oItem.pHtml;
        
        this.oItem = oItem;
        if (pNode && pNode != this.$ext.parentNode)
            pNode.appendChild(this.$ext);
        
        var diff = apf.getDiff(this.$ext);
        this.$verdiff  = diff[0];
        this.$hordiff  = diff[1];
        this.$sizeArr  = [];
        
        this.type = oItem.parent.vbox ? "horizontal" : "vertical";
        
        var layout = apf.layout.get(this.$ext.parentNode).layout;
        var name   = "splitter" + this.$uniqueId;
        layout.addRule("var " + name + " = apf.lookup(" + this.$uniqueId + ").$ext");
        
        var vleft   = [name + ".style.left = "];
        var vtop    = [name + ".style.top = "];
        var vwidth  = [name + ".style.width = -" + this.$hordiff + " + "];
        var vheight = [name + ".style.height = -" + this.$verdiff + " + "];
        var oNext   = oItem.parent.children[oItem.stackId+1];
        
        if (this.type == "horizontal") {
            vwidth.push("Math.max(");
            if (oItem.node) {
                vleft.push(oItem.id  + ".offsetLeft");
                vtop.push(oItem.id   + ".offsetTop + " + oItem.id + ".offsetHeight");
                vwidth.push(oItem.id + ".offsetWidth");
            }
            else {
                vleft.push("v.left_"   + oItem.id);
                vtop.push("v.top_"     + oItem.id + " + v.height_" + oItem.id);
                vwidth.push("v.width_" + oItem.id);
            }
            vwidth.push(",", oNext
                ? (oNext.node 
                    ? oNext.id + ".offsetWidth" 
                    : "v.width_" + oNext.id)
                :  0, ")");
            
            layout.addRule(vwidth.join(""));
            this.$ext.style.height = (oItem.splitter - this.$hordiff) + "px";
        }
        else {
            vheight.push("Math.max(");
            if (oItem.node) {
                vleft.push(oItem.id   + ".offsetLeft + " + oItem.id + ".offsetWidth");
                vtop.push(oItem.id    + ".offsetTop");
                vheight.push(oItem.id + ".offsetHeight");
            }
            else {
                vleft.push("v.left_"     + oItem.id + " + v.width_" + oItem.id);
                vtop.push("v.top_"       + oItem.id);
                vheight.push("v.height_" + oItem.id);
            }
            vheight.push(",", oNext 
                ? (oNext.node 
                    ? oNext.id + ".offsetHeight" 
                    : "v.height_" + oNext.id)
                : 0, ")");
            
            layout.addRule(vheight.join(""));
            this.$ext.style.width = (oItem.splitter - this.$hordiff) + "px";
        }
        
        layout.addRule(vleft.join(""));
        layout.addRule(vtop.join(""));

        //if(!apf.p) apf.p = new apf.ProfilerClass();
        //apf.p.start();
        
        //Determine min and max
        var row = oItem.parent.children;
        if (this.type == "vertical") {
            layout.addRule(name + ".host.min = " + (oItem.node 
                ? "document.getElementById('" + oItem.id + "').offsetLeft" 
                : "v.left_" + oItem.id) + " + "
                    + parseInt(oItem.minwidth || oItem.childminwidth || 10));

            var max = [], extra = [];
            for (var hasRest = false, i = oItem.stackId + 1; i < row.length; i++) {
                if (!row[i].fwidth)
                    hasRest = true;
            }
            
            for (var d, i = oItem.stackId + 1; i < row.length; i++) {
                d = row[i];
                
                //should take care here of minwidth due to html padding and html borders
                if (d.minwidth || d.childminheight)
                    max.push(parseInt(d.minwidth || d.childminheight));
                else
                    if (d.fwidth) {
                        if (!hasRest && i == oItem.stackId+1)
                            max.push(10);
                        else
                            if(d.fwidth.indexOf("%") != -1)
                                max.push("(" + d.parent.innerspace + ") * " 
                                    + (parseFloat(d.fwidth)/100));
                        else 
                            max.push(d.fwidth);
                    }
                else 
                    max.push(10);
                
                max.push(d.edgeMargin);
            }
            
            layout.addRule(name + ".host.max = v.left_" + oItem.parent.id 
                + " + v.width_" + oItem.parent.id + " - (" 
                + (max.join("+")||0) + ")");
        }
        else {
            layout.addRule(name + ".host.min = " + (oItem.node 
                ? "document.getElementById('" + oItem.id + "').offsetTop" 
                : "v.top_" + oItem.id) + " + " 
                    + parseInt(oItem.minheight || oItem.childminheight || 10));

            var max = [], extra = [];
            for (var hasRest = false, i = oItem.stackId + 1; i < row.length; i++) {
                if (!row[i].fheight) 
                    hasRest = true;
            }
            
            //This line prevents splitters from sizing minimized items without a rest
            if (!hasRest && oNext && oNext.state > 0)
                return this.$ext.parentNode.removeChild(this.$ext);
            
            for (var d, i = oItem.stackId + 1; i < row.length; i++) {
                d = row[i];
                
                //should take care here of minwidth due to html padding and html borders
                if (d.minheight || d.childminheight)
                    max.push(parseInt(d.minheight || d.childminheight));
                else if (d.fheight) {
                    if (!hasRest && i == oItem.stackId+1)
                        max.push(10);
                    else if(d.fheight.indexOf("%") != -1)
                        max.push("(" + d.parent.innerspace + ") * " 
                            + (parseFloat(d.fheight)/100));
                    else 
                        max.push(d.fheight);
                }
                else
                    max.push(10);
                
                if (d.edgeMargin)
                    max.push(d.edgeMargin);
            }

            layout.addRule(name + ".host.max = v.top_" + oItem.parent.id 
                + " + v.height_" + oItem.parent.id + " - (" 
                + (max.join("+")||0) + ")");
        }

        //apf.p.stop();
        //document.title = apf.p.totalTime;	
        
        this.$setStyleClass(this.$ext, this.type,
            [this.type == "horizontal" ? "vertical" : "horizontal"]);
        
        if (this.type == "vertical")
            this.$setStyleClass(this.$ext, "w-resize", ["n-resize"]);
        else
            this.$setStyleClass(this.$ext, "n-resize", ["w-resize"]);

        return this;
    };
    
    this.$draw = function(){
        //Build Main Skin
        this.$ext = this.$getExternal();

        var _self = this;
        this.$ext.onmousedown = function(e){
            if (!e)
                e = event;
            
            var amlNode = _self;//.$amlNode;
            var pos = apf.getAbsolutePosition(this);
            if (amlNode.type == "vertical")
                amlNode.tx = e.clientX - pos[0];
            else
                amlNode.ty = e.clientY - pos[1];
            amlNode.startPos = amlNode.type == "vertical" 
                ? this.offsetLeft 
                : this.offsetTop;
            
            e.returnValue  = false;
            e.cancelBubble = true;
            
            
            apf.plane.show(this);
            

            amlNode.$setStyleClass(this, "moving");
            
            amlNode.$setStyleClass(document.body,
                amlNode.type == "vertical" ? "w-resize" : "n-resize",
                [amlNode.type == "vertical" ? "n-resize" : "w-resize"]);
            
            //@todo convert to proper way
            document.onmouseup = function(){
                amlNode.$setStyleClass(amlNode.$ext, "", ["moving"]);
        
                
                apf.plane.hide();
                
        
                amlNode.update();
                amlNode.$setStyleClass(document.body, "", ["n-resize", "w-resize"]);
                
                document.onmouseup   = 
                document.onmousemove = null;
            };
            
            //@todo convert to proper way
            document.onmousemove = function(e){
                if(!e) e = event;
        
                if (amlNode.type == "vertical") {
                    if (e.clientX >= 0) {
                        var pos = apf.getAbsolutePosition(amlNode.$ext.offsetParent);
                        amlNode.$ext.style.left = (Math.min(amlNode.max,
                            Math.max(amlNode.min, (e.clientX - pos[0]) - amlNode.tx))) + "px";
                    }
                }
                else {
                    if (e.clientY >= 0) {
                        var pos = apf.getAbsolutePosition(amlNode.$ext.offsetParent);
                        amlNode.$ext.style.top = (Math.min(amlNode.max,
                            Math.max(amlNode.min, (e.clientY - pos[1]) - amlNode.ty))) + "px";
                    }
                }
                
                e.returnValue  = false;
                e.cancelBubble = true;
            };
        }
    };
        
    this.$loadAml = function(x){
        if (this.left || this.top) {
            var O1 = this.left || this.top;
            var O2 = this.right || this.bottom;
            O1 = O1.split(/\s*,\s*/);
            O2 = O2.split(/\s*,\s*/);
            
            for (var i = 0; i < O1.length; i++)
                O1[i] = O1[i];
            for (var i = 0; i < O2.length; i++)
                O2[i] = O2[i];
                
            //Not a perfect hack, but ok, for now
            var _self = this;
            $setTimeout(function(){
                this.$amlNode.init(_self.type,
                    _self.size, 
                    _self.min, 
                    _self.max, 
                    _self.change, O1, O2);
            });
        }
    };
}).call(apf.splitter.prototype = new apf.Presentation());

apf.aml.setElement("splitter", apf.splitter);



/*FILEHEAD(/var/lib/platform/source/trunk/elements/gallery.js)SIZE(26710)TIME(1271093061)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/*FILEHEAD(/var/lib/platform/source/trunk/elements/pager.js)SIZE(9037)TIME(1268956869)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/elements/calendar.js)SIZE(27234)TIME(1267574466)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/*FILEHEAD(/var/lib/platform/source/trunk/elements/comment.js)SIZE(1324)TIME(1269561674)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * all elements within the comment tag are ignored by the parser.
 *
 * @author      Ruben Daniels (ruben AT ajax DOT org)
 * @version     %I%, %G%
 * @since       0.4
 */
apf.comment = function(){
    this.$init("comment", apf.NODE_HIDDEN);
};

apf.comment.prototype = new apf.AmlComment();
apf.aml.setElement("comment", apf.comment);




/*FILEHEAD(/var/lib/platform/source/trunk/elements/lineselect.js)SIZE(4781)TIME(1257329184)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/elements/upload.js)SIZE(31593)TIME(1269561674)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/*FILEHEAD(/var/lib/platform/source/trunk/elements/dropdown.js)SIZE(14957)TIME(1270838607)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */





/**
 * Element allowing a user to select a value from a list, which is 
 * displayed when the user clicks a button.
 * Example:
 * A simple dropdown with inline items.
 * <code>
 *  <a:dropdown>
 *      <a:item>The Netherlands</a:item>
 *      <a:item>United States of America</a:item>
 *      <a:item>United Kingdom</a:item>
 *      ...
 *  </a:dropdown>
 * </code>
 * Example:
 * A databound dropdown with items loaded from an xml file.
 * <code>
 *  <a:dropdown model="friends.xml" each="[friend]" caption="[@name]" />
 * </code>
 * Example:
 * A databound dropdown using the bindings element
 * <code>
 *  <a:dropdown model="friends.xml">
 *      <a:bindings>
 *          <a:caption  match = "[@name]" />
 *          <a:css      match = "[self::node()[@type='best']]" value="bestfriend" />
 *          <a:each     match = "[friend]" />
 *      </a:bindings>
 *  </a:dropdown>
 * </code>
 * Example:
 * A small form.
 * <code>
 *  <a:model id="mdlForm" submission="save_form.asp">
 *      <data>
 *          <name>Mike</name>
 *          <city>amsterdam</city>
 *      </data>
 *  </a:model>
 * 
 *  <a:bar model="mdlForm">
 *      <a:label>Name</a:label>
 *      <a:textbox value="[name]" />
 *    
 *      <a:label>City</a:label>
 *      <a:dropdown value="[mdlForm::city]" model="cities.xml">
 *          <a:bindings>
 *              <a:caption match="[text()]" />
 *              <a:value match="[@value]" />
 *              <a:each match="[city]" />
 *          </a:bindings>
 *      </a:dropdown>
 *    
 *      <a:button default="true" action="submit">Submit</a:button>
 *  </a:bar>
 * </code>
 *
 * @event slidedown Fires when the calendar slides open.
 *   cancelable: Prevents the calendar from sliding open
 * @event slideup   Fires when the calendar slides up.
 *   cancelable: Prevents the calendar from sliding up
 *
 * @constructor
 * @define dropdown
 * @allowchild item, {smartbinding}
 * @addnode elements
 *
 * @inherits apf.BaseList
 *
 * @author      Ruben Daniels (ruben AT ajax DOT org)
 * @version     %I%, %G%
 * @since       0.4
 */
apf.dropdown = function(struct, tagName){
    this.$init(tagName || "dropdown", apf.NODE_VISIBLE, struct);
};

(function(){
    this.$animType        = 1;
    this.$animSteps       = 5;
    this.$animSpeed       = 20;
    this.$itemSelectEvent = "onmouseup";
    
    /**** Properties and Attributes ****/
    
    this.dragdrop      = false;
    this.reselectable  = true;
    this.$focussable   = true;
    this.autoselect    = false;
    this.multiselect   = false;
    this.disableremove = true;
    this.delayedselect = false;
    this.maxitems      = 5;
    
    this.$booleanProperties["disableremove"] = true;
    this.$supportedProperties.push("maxitems", "disableremove", 
        "initial-message", "fill");
    
    /**
     * @attribute {String} initial-message the message displayed by this element
     * when it doesn't have a value set. This property is inherited from parent 
     * nodes. When none is found it is looked for on the appsettings element. 
     *
     * @attribute {Number} maxitems the number of items that are shown at the 
     * same time in the container.
     */
    this.$propHandlers["maxitems"] = function(value){
        this.sliderHeight    = value 
            ? (Math.min(this.maxitems || 100, value) * this.itemHeight)
            : 10;
        this.containerHeight = value
            ? (Math.min(this.maxitems || 100, value) * this.itemHeight)
            : 10;
        /*if (this.containerHeight > 20)
            this.containerHeight = Math.ceil(this.containerHeight * 0.9);*/
    };
    
    /**** Public methods ****/
    
    /**
     * Toggles the visibility of the container with the list elements. It opens
     * or closes it using a slide effect.
     * @private
     */
    this.slideToggle = function(e, userAction){
        if (!e) e = event;
        if (userAction && this.disabled)
            return;

        if (this.isOpen)
            this.slideUp();
        else
            this.slideDown(e);
    };

    /**
     * Shows the container with the list elements using a slide effect.
     * @private
     */
    this.slideDown = function(e){
        if (this.dispatchEvent("slidedown") === false)
            return false;
        
        this.isOpen = true;

        this.$propHandlers["maxitems"].call(this, this.xmlRoot && this.each 
            ? this.getTraverseNodes().length : this.childNodes.length); //@todo apf3.0 count element nodes
        
        this.oSlider.style.display = "block";
        if (!this.ignoreOverflow) {
            this.oSlider.style[apf.supportOverflowComponent
                ? "overflowY"
                : "overflow"] = "visible";
            this.$container.style.overflowY = "hidden";
        }
        
        this.oSlider.style.display = "";

        this.$setStyleClass(this.$ext, this.$baseCSSname + "Down");
        
        //var pos = apf.getAbsolutePosition(this.$ext);
        this.oSlider.style.height = (this.sliderHeight - 1)     + "px";
        this.oSlider.style.width  = (this.$ext.offsetWidth - 2 - this.widthdiff) + "px";

        var _self = this;

        apf.popup.show(this.$uniqueId, {
            x       : 0,
            y       : this.$ext.offsetHeight,
            animate : true,
            ref     : this.$ext,
            width   : this.$ext.offsetWidth - this.widthdiff,
            height  : this.containerHeight,
            callback: function(container){
                if (!_self.ignoreOverflow) {
                    _self.$container.style.overflowY = "auto";
                }
            }
        });
    };
    
    /**
     * Hides the container with the list elements using a slide effect.
     * @private
     */
    this.slideUp = function(){
        if (this.isOpen == 2) return false;
        if (this.dispatchEvent("slideup") === false) return false;
        
        this.isOpen = false;
        if (this.selected) {
            var htmlNode = apf.xmldb.findHtmlNode(this.selected, this);
            if(htmlNode) this.$setStyleClass(htmlNode, '', ["hover"]);
        }
        
        this.$setStyleClass(this.$ext, '', [this.$baseCSSname + "Down"]);
        apf.popup.hide();
        return false;
    };
    
    /**** Private methods and event handlers ****/

    //@todo apf3.0 why is this function called 6 times on init.
    this.$setLabel = function(value){
        
        this.oLabel.innerHTML = value || this["initial-message"] || "";
        

        this.$setStyleClass(this.$ext, value ? "" : this.$baseCSSname + "Initial",
            !value ? [] : [this.$baseCSSname + "Initial"]);
    };

    this.addEventListener("afterselect", function(e){
        if (!e) e = event;
        
        this.slideUp();
        if (!this.isOpen)
            this.$setStyleClass(this.$ext, "", [this.$baseCSSname + "Over"]);
        
        this.$setLabel(e.selection.length
          ? this.$applyBindRule("caption", this.selected)
          : "");
    });
    
    function setMaxCount() {
        if (this.isOpen == 2)
            this.slideDown();
    }

    this.addEventListener("afterload", setMaxCount);
    this.addEventListener("xmlupdate", function(){
        setMaxCount.call(this);
        this.$setLabel(this.$applyBindRule("caption", this.selected));
    });
    
    // Private functions
    this.$blur = function(){
        this.slideUp();
        //this.$ext.dispatchEvent("mouseout")
        if (!this.isOpen)
            this.$setStyleClass(this.$ext, "", [this.$baseCSSname + "Over"])
        
        this.$setStyleClass(this.$ext, "", [this.$baseCSSname + "Focus"]);
    };
    
    /*this.$focus = function(){
        apf.popup.forceHide();
        this.$setStyleClass(this.oFocus || this.$ext, this.$baseCSSname + "Focus");
    }*/
    
    this.$setClearMessage = function(msg){
        this.$setLabel(msg);
    };
    
    this.$removeClearMessage = function(){
        this.$setLabel("");
    };

    this.addEventListener("popuphide", this.slideUp);
    
    /**** Keyboard Support ****/
    
    
    this.addEventListener("keydown", function(e){
        var key      = e.keyCode;
        //var ctrlKey  = e.ctrlKey; << unused
        //var shiftKey = e.shiftKey;
        
        if (!this.xmlRoot) return;
        
        var node;
        
        switch (key) {
            case 38:
                //UP
                if (e.altKey) {
                    this.slideToggle(e.htmlEvent);
                    return;
                }
                
                if (!this.selected) 
                    return;
                    
                node = this.getNextTraverseSelected(this.caret
                    || this.selected, false);

                if (node)
                    this.select(node);
                break;
            case 40:
                //DOWN
                if (e.altKey) {
                    this.slideToggle(e.htmlEvent);
                    return;
                }
                
                if (!this.selected) {
                    node = this.getFirstTraverseNode();
                    if (!node) 
                        return;
                } 
                else
                    node = this.getNextTraverseSelected(this.selected, true);
                
                if (node)
                    this.select(node);
                
                break;
            default:
                if (key == 9 || !this.xmlRoot) return;	
            
                //if(key > 64 && key < 
                if (!this.lookup || new Date().getTime() - this.lookup.date.getTime() > 1000)
                    this.lookup = {
                        str  : "",
                        date : new Date()
                    };

                this.lookup.str += String.fromCharCode(key);
                
                var caption, nodes = this.getTraverseNodes();
                for (var i = 0; i < nodes.length; i++) {
                    caption = this.$applyBindRule("caption", nodes[i]);
                    if (caption && caption.indexOf(this.lookup.str) > -1) {
                        this.select(nodes[i]);
                        return;
                    }
                }
            return;
        }

        return false;
    }, true);
    
    
    /**** Init ****/
    
    this.$draw = function(){
        this.$getNewContext("main");
        this.$getNewContext("container");
        
        this.$animType = this.$getOption("main", "animtype") || 1;
        this.clickOpen = this.$getOption("main", "clickopen") || "button";

        //Build Main Skin
        this.$ext = this.$getExternal(null, null, function(oExt){
            oExt.setAttribute("onmouseover", 'var o = apf.lookup(' + this.$uniqueId
                + ');o.$setStyleClass(o.$ext, o.$baseCSSname + "Over", null, true);');
            oExt.setAttribute("onmouseout", 'var o = apf.lookup(' + this.$uniqueId
                + ');if(o.isOpen) return;o.$setStyleClass(o.$ext, "", [o.$baseCSSname + "Over"], true);');
            
            //Button
            var oButton = this.$getLayoutNode("main", "button", oExt);
            if (oButton) {
                oButton.setAttribute("onmousedown", 'apf.lookup('
                    + this.$uniqueId + ').slideToggle(event, true);');
            }
            
            //Label
            var oLabel = this.$getLayoutNode("main", "label", oExt);
            if (this.clickOpen == "both") {
                oLabel.parentNode.setAttribute("onmousedown", 'apf.lookup('
                    + this.$uniqueId + ').slideToggle(event, true);');
            }
        });
        this.oLabel = this.$getLayoutNode("main", "label", this.$ext);
        
        
        if (this.oLabel.nodeType == 3)
            this.oLabel = this.oLabel.parentNode;
        
        
        this.oIcon = this.$getLayoutNode("main", "icon", this.$ext);
        if (this.$button)
            this.$button = this.$getLayoutNode("main", "button", this.$ext);
        
        this.oSlider = apf.insertHtmlNode(this.$getLayoutNode("container"),
            document.body);
        this.$container = this.$getLayoutNode("container", "contents", this.oSlider);
        this.$container.host = this;
        
        //Set up the popup
        this.$pHtmlDoc = apf.popup.setContent(this.$uniqueId, this.oSlider,
            apf.skins.getCssString(this.skinName));
        
        //Get Options form skin
        //Types: 1=One dimensional List, 2=Two dimensional List
        this.listtype = parseInt(this.$getLayoutNode("main", "type")) || 1;
        
        this.itemHeight     = this.$getOption("main", "item-height") || 18.5;
        this.widthdiff      = this.$getOption("main", "width-diff") || 0;
        this.ignoreOverflow = apf.isTrue(this.$getOption("main", "ignore-overflow")) || false;
    };
    
    this.addEventListener("DOMNodeInsertedIntoDocument", function(){
        if (typeof this["initial-message"] == "undefined")
            this.$setInheritedAttribute("initial-message");
        
        if (!this.selected && this["initial-message"])
            this.$setLabel();
    });
    
    this.$destroy = function(){
        apf.popup.removeContent(this.$uniqueId);
        apf.destroyHtmlNode(this.oSlider);
        this.oSlider = null;
    };

    
}).call(apf.dropdown.prototype = new apf.BaseList());

apf.config.$inheritProperties["initial-message"] = 1;

apf.aml.setElement("dropdown", apf.dropdown);



/*FILEHEAD(/var/lib/platform/source/trunk/elements/contextmenu.js)SIZE(2557)TIME(1270838607)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * element specifying which menu is shown when a
 * contextmenu is requested by a user for a aml node.
 * Example:
 * This example shows a list that shows the mnuRoot menu when the user
 * right clicks on the root {@link term.datanode data node}. Otherwise the mnuItem menu is
 * shown.
 * <code>
 *  <a:list>
 *      <a:contextmenu menu="mnuRoot" match="[root]" />
 *      <a:contextmenu menu="mnuItem" />
 *  </a:list>
 * </code>
 * @attribute {String} menu   the id of the menu element.
 * @attribute {String} select the xpath executed on the selected element of the databound element which determines whether this contextmenu is shown.
 *
 * @author      Ruben Daniels (ruben AT ajax DOT org)
 * @version     %I%, %G%
 * @since       0.4
 */
apf.contextmenu = function(){
    this.$init("contextmenu", apf.NODE_HIDDEN);
};

(function(){
    this.$amlNodes = [];
    
    //1 = force no bind rule, 2 = force bind rule
    this.$attrExcludePropBind = apf.extend({
        "match" : 1
    }, this.$attrExcludePropBind);
    
    this.register = function(amlParent){
        if (!amlParent.contextmenus)
            amlParent.contextmenus = [];
        amlParent.contextmenus.push(this);
    };
    
    this.unregister = function(amlParent){
        amlParent.contextmenus.remove(this);
    };
    
    this.addEventListener("DOMNodeInsertedIntoDocument", function(e){
        this.register(this.parentNode);
    });
}).call(apf.contextmenu.prototype = new apf.AmlElement());

apf.aml.setElement("contextmenu", apf.contextmenu);




/*FILEHEAD(/var/lib/platform/source/trunk/elements/vectorflow.js)SIZE(65716)TIME(1265021706)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/elements/menu.js)SIZE(16905)TIME(1270838607)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * Element displaying a skinnable menu of items which can be choosen.
 * Based on the context of the menu, items can be shown and hidden. That's
 * why this element is often called a contextmenu.
 * Example:
 * <code>
 *  <a:iconmap 
 *    id     = "tbicons" 
 *    src    = "toolbar.icons.gif"
 *    type   = "horizontal" 
 *    size   = "20" 
 *    offset = "2,2"></a:iconmap>
 * 
 *  <a:menu id="msub">
 *      <a:item icon="tbicons:12">test</a:item>
 *      <a:item icon="tbicons:14">test2</a:item>
 *  </a:menu>
 * 
 *  <a:menu id="mmain">
 *      <a:item icon="tbicons:1">table_wizard</a:item>
 *      <a:item icon="tbicons:2" hotkey="Ctrl+M">table_wizard</a:item>
 *      <a:divider></a:divider>
 *      <a:radio>item 1</a:radio>
 *      <a:radio>item 2</a:radio>
 *      <a:radio>item 3</a:radio>
 *      <a:radio>item 4</a:radio>
 *      <a:divider></a:divider>
 *      <a:check hotkey="Ctrl+T">item check 1</a:check>
 *      <a:check hotkey="F3">item check 2</a:check>
 *      <a:divider></a:divider>
 *      <a:item icon="tbicons:11" submenu="msub">table_wizard</a:item>
 *      <a:item icon="tbicons:10">table_wizard</a:item>
 *  </a:menu>
 * 
 *  <a:window 
 *    visible     = "true" 
 *    width       = "200"
 *    height      = "190"
 *    contextmenu = "mmain"
 *    center      = "true">
 *  </a:window>
 * </code>
 * @see baseclass.guielement.event.contextmenu
 *
 * @event display   Fires when the contextmenu is shown.
 * @event itemclick Fires when a user presses the mouse button while over a child of this element.
 *   object:
 *   {String} value the value of the clicked element.
 *
 * @constructor
 * @define menu
 * @allowchild item, divider, check, radio
 * @addnode elements
 *
 * @author      Ruben Daniels (ruben AT ajax DOT org)
 * @version     %I%, %G%
 * @since       0.4
 *
 * @inherits apf.Presentation
 */
apf.menu = function(struct, tagName){
    this.$init(tagName || "menu", apf.NODE_VISIBLE, struct);
};

(function(){
    this.$focussable  = apf.KEYBOARD;
    this.$positioning = "basic"
    //var _self         = this;
    //var blurring      = false;

    /**** Properties and Attributes ****/
    
    this.anim   = true;
    this.zindex = 10000000;

    this.$booleanProperties["anim"] = true;
    this.$propHandlers["visible"] = function(value, prop, force, nofocus, hideOpener){
        if (value) {
            this.$ext.style.display = "block";
            if (this.opener && this.opener.localName.indexOf('item') > -1)
                this.opener.parentNode.$showingSubMenu = this;
        }
        else {
            this.$ext.style.display = "none";

            var lastFocus = apf.menu.lastFocus;

            //@todo test this with a list being the opener of the menu
            if (lastFocus != this.opener && this.opener && this.opener.$blur)
                this.opener.$blur();

            if (this.opener && this.opener.parentNode.localName == "menu") {
                if (!this.$hideTree)
                    this.$hideTree = -1
                this.opener.parentNode.focus();
            }
            
            
            else if (lastFocus) {
                //We're being hidden because some other object gets focus
                if (apf.window.$settingFocus) {
                    if (apf.window.$settingFocus != lastFocus && lastFocus.$blur)
                        lastFocus.$blur();
                    this.$blur();

                    if (apf.window.$settingFocus.localName != "menu") //not menu walking
                        apf.menu.lastFocus = null;
                }
                //We're being hidden because window looses focus
                else if (!apf.window.hasFocus()) {
                    if (lastFocus.$blur)
                        lastFocus.$blur();
                    this.$blur();

                    apf.document.activeElement = lastFocus;
                    if (lastFocus.$focusParent)
                        lastFocus.$focusParent.$lastFocussed = lastFocus;

                    apf.menu.lastFocus = null;
                }
                //We're just being hidden
                else if (this.$hideTree) {
                    if (!this.$hideTree)
                        this.$hideTree = -1

                    var visTest = (lastFocus.disabled || !lastFocus.visible)
                        && lastFocus != apf.document.documentElement;

                    if (nofocus || visTest) {
                        if (lastFocus.$blur)
                            lastFocus.$blur();
                        this.$blur();
                        apf.document.activeElement = null;

                        if (visTest && apf.window.moveNext() === false)
                            apf.window.$focusRoot();
                    }
                    else {
                        lastFocus.focus(null, null, true);
                    }

                    apf.menu.lastFocus = null;
                }
            }
            

            if (this.$showingSubMenu) {
                this.$showingSubMenu.hide();
                this.$showingSubMenu = null;
            }

            if (this.opener && this.opener.$submenu) {
                this.opener.$submenu(true, true);

                //@todo problem with loosing focus when window looses focus
                if (this.$hideTree === true && this.opener.parentNode.localName == "menu") {
                    this.opener.parentNode.$hideTree = true
                    this.opener.parentNode.hide();
                }
                
                this.opener = null;
            }
            this.$hideTree = null;

            if (this.$selected) {
                apf.setStyleClass(this.$selected.$ext, "", ["hover"]);
                this.$selected = null;
            }
        }
    };

    /**** Public Methods ****/

    var lastFocus;

    /**
     * Shows the menu, optionally within a certain context.
     * @param {Number}     x        the left position of the menu.
     * @param {Number}     y        the top position of the menu.
     * @param {Boolean}    noanim   whether to animate the showing of this menu.
     * @param {AMLElement} opener   the element that is the context of this menu.
     * @param {XMLElement} xmlNode  the {@link term.datanode data node} that provides data context to the menu child nodes.
     * @see baseclass.guielement.event.contextmenu
     */
    this.display = function(x, y, noanim, opener, xmlNode, openMenuId, btnWidth){
        this.opener = opener;
        this.dispatchEvent("display");

        //Show / hide Child Nodes Based on XML
        var last, i, node,
            nodes = this.childNodes,
            c     = 0,
            l     = nodes.length, result;
        for (i = 0; i < l; i++) {
            node = nodes[i];
            if (node.nodeType != 1) continue;

            result = !xmlNode || !node.match || (node.cmatch || (node.cmatch = apf.lm.compile(node.match, {
                xpathmode  : 3,
                injectself : true
            })))(xmlNode)

            if (result) {
                node.show();

                if (node.localName == "divider") {
                    last = node;
                    if (c == 0)
                        node.hide();
                    c = 0;
                }
                else c++;
            }
            else {
                node.hide();

                if (!node.nextSibling && c == 0)
                    last.hide();
            }
        }

        if (this.oOverlay) {
            if (btnWidth) {
                this.oOverlay.style.display = "block";
                this.oOverlay.style.width   = btnWidth + "px";
            }
            else
                this.oOverlay.style.display = "none";
        }

        this.visible = false;
        this.show();

        if (x === null) {
            apf.popup.show(this.$uniqueId, {
                x            : 0, 
                y            : opener.$ext.offsetHeight, 
                animate      : noanim || !this.anim ? false : "fade",
                ref          : opener.$ext,
                allowTogether: openMenuId
            });
        }
        else {
            var bodyPos = apf.getAbsolutePosition(document.body);
            apf.popup.show(this.$uniqueId, {
                x            : x - bodyPos[0], 
                y            : y - bodyPos[1] - (apf.isIE && apf.isIE < 8 ? 1 : 0), 
                animate      : noanim || !this.anim ? false : "fade",
                ref          : this.$ext.offsetParent,
                allowTogether: openMenuId,
                autoCorrect  : false
            });
        }
        
        var lastFocus      =
        apf.menu.lastFocus = opener && opener.$focussable === true
            ? opener
            : apf.menu.lastFocus || apf.document.activeElement;
        
        apf.popup.last = null;
        this.focus();

        //Make the component that provides context appear to have focus

        if (lastFocus && lastFocus != this && lastFocus.$focus)
            lastFocus.$focus();

        this.xmlReference = xmlNode;
    };

    /**
     * Returns the current value of this element.
     * @return {String}
     */
    this.getValue = function(group){
        return this.getSelected(group).value || "";
    };

    /**
     * Retrieves the selected element from a group of radio elements.
     * @param {String} group the name of the group.
     * @return {radio} the selected radio element.
     */
    this.getSelected = function(group){
        var nodes = this.childNodes;
        var i, l = nodes.length;
        for (i = 0; i < l; i++) {
            if (nodes[i].group != group)
                continue;

            if (nodes[i].selected)
                return nodes[i];
        }

        return false;
    }

    /**
     * Selects an element within a radio group.
     * @param {String} group  the name of the group.
     * @param {String} value  the value of the item to select.
     */
    this.select = function(group, value){
        var nodes = this.childNodes;
        var i, l = nodes.length;
        for (i = 0; i < l; i++) {
            if (nodes[i].group != group)
                continue;

            if (nodes[i].value == value || !nodes[i].value && nodes[i].caption == value)
                nodes[i].$handlePropSet("selected", true);
            else if (nodes[i].selected)
                nodes[i].$handlePropSet("selected", false);
        }
    };

    /**** Events ****/

    
    this.addEventListener("keydown", function(e){
        var node, key = e.keyCode;
        //var ctrlKey  = e.ctrlKey;
        //var shiftKey = e.shiftKey;

        switch (key) {
            case 13:
                if (!this.$selected)
                    return;

                node = this.$selected;
                node.$down();
                node.$up();
                node.$click();
                break;
            case 38:
                //UP
                node = this.$selected && this.$selected.previousSibling
                  || this.lastChild;

                if (node && node.localName == "divider")
                    node = node.previousSibling;

                if (!node)
                    return;

                if (this.$selected)
                    apf.setStyleClass(this.$selected.$ext, "", ["hover"]);

                apf.setStyleClass(node.$ext, "hover");
                this.$selected = node;
                break;
            case 40:
                //DOWN
                node = this.$selected && this.$selected.nextSibling
                  || this.firstChild;

                if (node && node.localName == "divider")
                    node = node.nextSibling;

                if (!node)
                    return;

                if (this.$selected)
                    apf.setStyleClass(this.$selected.$ext, "", ["hover"]);

                apf.setStyleClass(node.$ext, "hover");
                this.$selected = node;
                break;
            case 37:
                //LEFT
                //if (this.$selected && this.$selected.submenu)
                    //this.$selected.$submenu(true, true);

                if (!this.opener)
                    return;

                if (this.opener.localName == "button") {
                    node = this.opener.previousSibling;
                    while(node && !node.submenu)
                        node = node.previousSibling;

                    if (node) {
                        node.dispatchEvent("mouseover");

                        var btnMenu = node.parentNode.menuIsPressed;
                        if (btnMenu) {
                            self[btnMenu.submenu].dispatchEvent("keydown", {
                                keyCode : 40
                            });
                        }
                    }
                }
                else if (this.opener.parentNode.localName == "menu") {
                    //@todo Ahum bad abstraction boundary
                    var op = this.opener;
                    this.hide();
                    apf.setStyleClass(op.$ext, "hover");
                    op.parentNode.$showingSubMenu = null;
                }

                break;
            case 39:
                //RIGHT
                if (this.$selected && this.$selected.submenu) {
                    this.$selected.$submenu(null, true);
                    this.$showingSubMenu.dispatchEvent("keydown", {
                       keyCode : 40
                    });

                    return;
                }

                if (this.opener) {
                    var op = this.opener;
                    while (op && op.parentNode && op.parentNode.localName == "menu")
                        op = op.parentNode.opener;

                    if (op && op.localName == "button") {
                        node = op.nextSibling;
                        while(node && !node.submenu)
                            node = node.nextSibling;

                        if (node) {
                            node.dispatchEvent("mouseover");

                            var btnMenu = node.parentNode.menuIsPressed;
                            if (btnMenu) {
                                self[btnMenu.submenu].dispatchEvent("keydown", {
                                    keyCode : 40
                                });
                            }

                            return;
                        }
                    }
                }

                if (!this.$selected) {
                    arguments.callee.call(this, {
                       keyCode : 40
                    });
                }

                break;
            default:
                return;
        }

        return false;
    }, true);
    

    //Hide menu when it looses focus or when the popup hides itself
    function forceHide(){
        if (this.$showingSubMenu)
            return;

        if (this.$hideTree != -1) {
            this.$hideTree = true;
            this.hide();
        }

        return false;
    }

    this.addEventListener("focus", function(){
        apf.popup.last = this.$uniqueId;
    });

    this.addEventListener("blur", forceHide);
    this.addEventListener("popuphide", forceHide);

    /**** Init ****/

    this.$draw = function(){
        this.$pHtmlNode = document.body;

        //Build Main Skin
        this.$ext = this.$getExternal();
        this.oOverlay = this.$getLayoutNode("main", "overlay", this.$ext);

        apf.popup.setContent(this.$uniqueId, this.$ext, "", null, null);
    };

    this.$loadAml = function(x){
        this.$int = this.$getLayoutNode("main", "container", this.$ext);
    };

    this.$destroy = function(){
        apf.popup.removeContent(this.$uniqueId);
    };
}).call(apf.menu.prototype = new apf.Presentation());

apf.aml.setElement("menu", apf.menu);


/*FILEHEAD(/var/lib/platform/source/trunk/elements/palette.js)SIZE(5978)TIME(1269561674)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/*FILEHEAD(/var/lib/platform/source/trunk/elements/textbox.js)SIZE(24070)TIME(1270838607)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




//@todo DOCUMENT the modules too

/**
 * Element displaying a rectangular area wich allows a
 * user to type information. The information typed can be
 * restricted by using this.$masking. The information can also
 * be hidden from view when used in password mode. By adding an 
 * {@link element.autocomplete autocomplete element} as a child the 
 * value for the textbox can be looked up as you type. By setting the 
 * {@link element.textbox.attribute.mask mask atribute}, complex data input 
 * validation is done while the users types.
 * 
 * @constructor
 * @define input, secret, textarea, textbox
 * @allowchild autocomplete, {smartbinding}
 * @addnode elements
 *
 * @inherits apf.StandardBinding
 * @inherits apf.XForms
 *
 * @author      Ruben Daniels (ruben AT ajax DOT org)
 * @version     %I%, %G%
 * @since       0.1
 *
 * @binding value  Determines the way the value for the element is retrieved 
 * from the bound data.
 * Example:
 * Sets the value based on data loaded into this component.
 * <code>
 *  <a:model id="mdlTextbox">
 *      <data name="Lukasz"></data>
 *  </a:model>
 *  <a:textbox model="mdlTextbox" value="[@name]" />
 * </code>
 * Example:
 * A shorter way to write this is:
 * <code>
 *  <a:model id="mdlTextbox">
 *      <data name="Lukasz"></data>
 *  </a:model>
 *  <a:textbox value="[mdlTextbox::@name]" />
 * </code>
 *
 * @event click     Fires when the user presses a mousebutton while over this element and then let's the mousebutton go. 
 * @event mouseup   Fires when the user lets go of a mousebutton while over this element. 
 * @event mousedown Fires when the user presses a mousebutton while over this element. 
 * @event keyup     Fires when the user lets go of a keyboard button while this element is focussed. 
 *   object:
 *   {Number}  keyCode   which key was pressed. This is an ascii number.
 * @event clear     Fires when the content of this element is cleared. 
 */
apf.input    = function(struct, tagName){
    this.$init(tagName || "input", apf.NODE_VISIBLE, struct);
};

apf.secret   = function(struct, tagName){
    this.$init(tagName || "secret", apf.NODE_VISIBLE, struct);
};

apf.password = function(struct, tagName){
    this.$init(tagName || "password", apf.NODE_VISIBLE, struct);
};

apf.textarea = function(struct, tagName){
    this.$init(tagName || "textarea", apf.NODE_VISIBLE, struct);
    
    this.multiline = true;
};

// HTML5 email element
apf.email    = function(struct, tagName){
    this.$init(tagName || "email", apf.NODE_VISIBLE, struct);
};

apf.textbox  = function(struct, tagName){
    this.$init(tagName || "textbox", apf.NODE_VISIBLE, struct);
};

(function(){
    this.implement(
        
        apf.DataAction
        
        
    );

    this.$focussable       = true; // This object can get the focus
    this.$masking          = false;

    this.$childProperty    = "value";

    //this.realtime          = false;
    this.value             = "";
    this.isContentEditable = true;
    this.multiline         = false;

    /**
     * @attribute {Boolean} realtime whether the value of the bound data is
     * updated as the user types it, or only when this element looses focus or
     * the user presses enter.
     */
    this.$booleanProperties["focusselect"] = true;
    this.$booleanProperties["realtime"]    = true;
    this.$supportedProperties.push("value", "mask", "initial-message",
        "focusselect", "realtime", "type");

    /**
     * @attribute {String} value the text of this element
     * @todo apf3.0 check use of this.$propHandlers["value"].call
     */
    this.$propHandlers["value"] = function(value, prop, initial){
        if (!this.$input || !initial && this.getValue() == value)
            return;

        // Set Value
        if (!initial && !value) //@todo apf3.x research the use of clear
            this.clear();
        else if (this.isHTMLBox) {
            if (this.$input.innerHTML != value)
                this.$input.innerHTML = value;
        }
        else if (this.$input.value != value)
            this.$input.value = value;
        
        if (this.$button)
            this.$button.style.display = value && !initial ? "block" : "none";
    };

    //See validation
    //var oldPropHandler = this.$propHandlers["maxlength"];
    this.addEventListener("prop.maxlength", function(e){

        //Special validation support using nativate max-length browser support
        if (this.$input.tagName.toLowerCase().match(/input|textarea/))
            this.$input.maxLength = parseInt(e.value) || null;
    });

    /**
     * @attribute {String} mask a complex input pattern that the user should
     * adhere to. This is a string which is a combination of special and normal
     * characters. Then comma seperated it has two options. The first option
     * specifies whether the non input characters (the chars not typed by the
     * user) are in the value of this element. The second option specifies the
     * character that is displayed when the user hasn't yet filled in a
     * character.
     *   Possible values:
     *   0  Any digit
     *   1  The number 1 or 2.
     *   9  Any digit or a space.
     *   #  User can enter a digit, space, plus or minus sign.
     *   L  Any alpha character, case insensitive.
     *   ?  Any alpha character, case insensitive or space.
     *   A  Any alphanumeric character.
     *   a  Any alphanumeric character or space.
     *   X  Hexadecimal character, case insensitive.
     *   x  Hexadecimal character, case insensitive or space.
     *   &  Any whitespace.
     *   C  Any character.
     *   !  Causes the input mask to fill from left to right instead of from right to left.
     *   '  The start or end of a literal part.
     *   "  The start or end of a literal part.
     *   >  Converts all characters that follow to uppercase.
     *   <  Converts all characters that follow to lowercase.
     *   \  Cancel the special meaning of a character.
     * Example:
     * An american style phone number.
     * <code>
     *  <a:textbox mask="(000)0000-0000;;_" />
     * </code>
     * Example:
     * A dutch postal code
     * <code>
     *  <a:textbox mask="0000 AA;;_" />
     * </code>
     * Example:
     * A date
     * <code>
     *  <a:textbox mask="00-00-0000;;_" datatype="xsd:date" />
     * </code>
     * Example:
     * A serial number
     * <code>
     *  <a:textbox mask="'WCS74'0000-00000;1;_" />
     * </code>
     * Example:
     * A MAC address
     * <code>
     *  <a:textbox mask="XX-XX-XX-XX-XX-XX;;_" />
     * </code>
     */
    this.$propHandlers["mask"] = function(value){
        if (this.mask.toLowerCase() == "password")// || !apf.hasMsRangeObject)
            return;

        if (!value) {
            throw new Error("Not Implemented");
        }

        if (!this.$masking) {
            this.$masking = true;
            this.implement(apf.textbox.masking);
            this.focusselect = false;
            //this.realtime    = false;
        }

        this.setMask(this.mask);
    };

    //this.$propHandlers["ref"] = function(value) {
    //    this.$input.setAttribute("name",  value.split("/").pop().split("::").pop()
    //        .replace(/[\@\.\(\)]*/g, ""));
    //};

    /**
     * @attribute {String} initial-message the message displayed by this element
     * when it doesn't have a value set. This property is inherited from parent
     * nodes. When none is found it is looked for on the appsettings element.
     */
    this.$propHandlers["initial-message"] = function(value){
        if (value) {
            
            if (apf.hasFocusBug)
                this.$input.onblur();
            
            
            //this.$propHandlers["value"].call(this, value, null, true);
        }
        
        if (!this.value)
            this.clear();
    };

    /**
     * @attribute {Boolean} focusselect whether the text in this element is
     * selected when this element receives focus.
     */
    this.$propHandlers["focusselect"] = function(value){
        var _self = this;
        this.$input.onmousedown = function(){
            _self.focusselect = false;
        };

        this.$input.onmouseup  =
        this.$input.onmouseout = function(){
            _self.focusselect = value;
        };
    };

    /**
     * @attribute {String} type the type or function this element represents.
     * This can be any arbitrary name. Although there are some special values.
     *   Possible values:
     *   username   this element is used to type in the name part of login credentials.
     *   password   this element is used to type in the password part of login credentials.
     */
    this.$propHandlers["type"] = function(value){
        if (value && "password|username".indexOf(value) > -1
          && typeof this.focusselect == "undefined") {
            this.focusselect = true;
            this.$propHandlers["focusselect"].call(this, true);
        }
    };

    /**** Public Methods ****/

    

    /**
     * Sets the value of this element. This should be one of the values
     * specified in the values attribute.
     * @param {String} value the new value of this element
     */
    this.setValue = function(value){
        return this.setProperty("value", value, false, true);
    };
    
    //@todo cleanup and put initial-message behaviour in one location
    this.clear = function(){
        if (this["initial-message"]) {
            this.$propHandlers["value"].call(this, this["initial-message"], null, true);
            apf.setStyleClass(this.$ext, this.$baseCSSname + "Initial");
        }
        else {
            this.$propHandlers["value"].call(this, "", null, true);
        }
        
        this.dispatchEvent("clear");//@todo this should work via value change
    }

    /**
     * Returns the current value of this element.
     * @return {String}
     */
    this.getValue = function(){
        var v = this.isHTMLBox ? this.$input.innerHTML : this.$input.value;
        return v == this["initial-message"] ? "" : v.replace(/\r/g, "");
    };
    
    

    /**
     * Selects the text in this element.
     */
    this.select   = function(){ 
        try {
            this.$input.select(); 
        }
        catch(e){}
    };

    /**
     * Deselects the text in this element.
     */
    this.deselect = function(){ this.$input.deselect(); };

    /**** Private Methods *****/

    this.$enable  = function(){ this.$input.disabled = false; };
    this.$disable = function(){ this.$input.disabled = true; };

    this.$insertData = function(str){
        return this.setValue(str);
    };

    /**
     * @private
     */
    this.insert = function(text){
        if (apf.hasMsRangeObject) {
            try {
                this.$input.focus();
            }
            catch(e) {}
            var range = document.selection.createRange();
            if (this.oninsert)
                text = this.oninsert(text);
            range.pasteHTML(text);
            range.collapse(true);
            range.select();
        }
        else {
            this.$input.value += text;
        }
    };

    this.addEventListener("$clear", function(){
        this.value = "";//@todo what about property binding?
        
        if (this["initial-message"] && apf.document.activeElement != this) {
            this.$propHandlers["value"].call(this, this["initial-message"], null, true);
            apf.setStyleClass(this.$ext, this.$baseCSSname + "Initial");
        }
        else {
            this.$propHandlers["value"].call(this, "");
        }
        
        if (!this.$input.tagName.toLowerCase().match(/input|textarea/i)) {
            if (apf.hasMsRangeObject) {
                try {
                    var range = document.selection.createRange();
                    range.moveStart("sentence", -1);
                    //range.text = "";
                    range.select();
                }
                catch(e) {}
            }
        }
        
        this.dispatchEvent("clear"); //@todo apf3.0
    });

    this.$keyHandler = function(key, ctrlKey, shiftKey, altKey, e){
        if (this.$button && key == 27) {
            this.clear();
            this.blur();
        }
        
        /*if (this.dispatchEvent("keydown", {
            keyCode   : key,
            ctrlKey   : ctrlKey,
            shiftKey  : shiftKey,
            altKey    : altKey,
            htmlEvent : e}) === false)
                return false;

        // @todo: revisit this IF statement - dead code?
        if (false && apf.isIE && (key == 86 && ctrlKey || key == 45 && shiftKey)) {
            var text = window.clipboardData.getData("Text");
            if ((text = this.dispatchEvent("keydown", {
                text : this.onpaste(text)}) === false))
                    return false;
            if (!text)
                text = window.clipboardData.getData("Text");

            this.$input.focus();
            var range = document.selection.createRange();
            range.text = "";
            range.collapse();
            range.pasteHTML(text.replace(/\n/g, "<br />").replace(/\t/g, "&nbsp;&nbsp;&nbsp;"));

            return false;
        }*/
    };

    var fTimer;
    this.$focus = function(e){
        if (!this.$ext || this.$ext.disabled)
            return;

        this.$setStyleClass(this.$ext, this.$baseCSSname + "Focus");

        if (this["initial-message"] && this.$input.value == this["initial-message"]) {
            this.$propHandlers["value"].call(this, "", null, true);
            apf.setStyleClass(this.$ext, "", [this.$baseCSSname + "Initial"]);
        }
        
        var _self = this;
        function delay(){
            try {
                if (!fTimer || document.activeElement != _self.$input) {
                    _self.$input.focus();
                }
                else {
                    clearInterval(fTimer);
                    return;
                }
            }
            catch(e) {}

            if (_self.$masking)
                _self.setPosition();

            if (_self.focusselect)
                _self.select();
        };

        if ((!e || e.mouse) && apf.isIE) {
            clearInterval(fTimer);
            fTimer = setInterval(delay, 1);
        }
        else
            delay();
    };

    this.$blur = function(e){
        if (!this.$ext)
            return;
        
        if (!this.realtime)
            this.change(this.getValue());

        this.$setStyleClass(this.$ext, "", [this.$baseCSSname + "Focus"]);

        if (this["initial-message"] && this.$input.value == "") {
            this.$propHandlers["value"].call(this, this["initial-message"], null, true);
            apf.setStyleClass(this.$ext, this.$baseCSSname + "Initial");
        }

        /*if (apf.hasMsRangeObject) {
            var r = this.$input.createTextRange();
            r.collapse();
            r.select();
        }*/

        try {
            if (apf.isIE || !e || e.srcElement != apf.window)
                this.$input.blur();
        }
        catch(e) {}

        // check if we clicked on the oContainer. ifso dont hide it
        if (this.oContainer) {
            $setTimeout("var o = apf.lookup(" + this.$uniqueId + ");\
                o.oContainer.style.display = 'none'", 100);
        }
        
        clearInterval(fTimer);
    };

    /**** Init ****/

    this.$draw = function(){
        var _self = this;
        
        //Build Main Skin
        this.$ext = this.$getExternal(null, null, function(oExt){
            var mask = this.getAttribute("mask");

            if ((typeof mask == "string" && mask.toLowerCase() == "password")
              || "secret|password".indexOf(this.localName) > -1) {
                this.type == "password";
                this.$getLayoutNode("main", "input").setAttribute("type", "password");
            }
            
            

            oExt.setAttribute("onmousedown", "if (!this.host.disabled) \
                this.host.dispatchEvent('mousedown', {htmlEvent : event});");
            oExt.setAttribute("onmouseup",   "if (!this.host.disabled) \
                this.host.dispatchEvent('mouseup', {htmlEvent : event});");
            oExt.setAttribute("onclick",     "if (!this.host.disabled) \
                this.host.dispatchEvent('click', {htmlEvent : event});");
        });
        this.$input    = this.$getLayoutNode("main", "input", this.$ext);
        this.$button = this.$getLayoutNode("main", "button", this.$ext);
        
        if (this.type == "password")
            this.$propHandlers["type"].call(this, "password");

        if (!apf.hasContentEditable && "input|textarea".indexOf(this.$input.tagName.toLowerCase()) == -1) {
            var node  = this.$input;
            this.$input = node.parentNode.insertBefore(document.createElement("textarea"), node);
            node.parentNode.removeChild(node);
            this.$input.className = node.className;
            if (this.$ext == node)
                this.$ext = this.$input;
        }
        
        if (this.$button) {
            this.$button.onmousedown = function(){
                _self.clear();
                _self.focus({mouse:true});
            }
        }

        //@todo for skin switching this should be removed
        if (this.$input.tagName.toLowerCase() == "textarea") {
            this.addEventListener("focus", function(e){
                //if (this.multiline != "optional")
                    //e.returnValue = false
            });
        }
        
        this.$input.onselectstart = function(e){
            if (!e) e = event;
            e.cancelBubble = true;
        }
        this.$input.host = this;

        this.$input.onkeydown = function(e){
            e = e || window.event;
            
            if (this.host.disabled) {
                e.returnValue = false;
                return false;
            }

            //Change
            if (!_self.realtime) {
                var value = _self.getValue();
                if (e.keyCode == 13 && value != this.value)
                    _self.change(value);
            }
            else if (apf.isWebkit && _self.xmlRoot && _self.getValue() != this.value) //safari issue (only old??)
                $setTimeout("var o = apf.lookup(" + _self.$uniqueId + ");\
                    o.change(o.getValue())");

            if (_self.multiline == "optional" && e.keyCode == 13 && !e.shiftKey
              || e.ctrlKey && (e.keyCode == 66 || e.keyCode == 73
              || e.keyCode == 85)) {
                e.returnValue = false;
                return false;
            }

            //Autocomplete
            if (_self.oContainer) {
                var oTxt    = _self;
                var keyCode = e.keyCode;
                $setTimeout(function(){
                    oTxt.fillAutocomplete(keyCode);
                });
            }

            //Non this.$masking
            if (!_self.mask) {
                return _self.$keyHandler(e.keyCode, e.ctrlKey,
                    e.shiftKey, e.altKey, e);
            }
        };

        this.$input.onkeyup = function(e){
            if (!e)
                e = event;
                
            if (this.host.disabled)
                return false;

            var keyCode = e.keyCode;
            
            if (_self.$button)
                _self.$button.style.display = this.value ? "block" : "none";

            if (_self.realtime) {
                $setTimeout(function(){
                    var v;
                    if (!_self.mask && (v = _self.getValue()) != _self.value)
                        _self.change(v); 
                    _self.dispatchEvent("keyup", {keyCode : keyCode});//@todo
                });
            }
            else {
                _self.dispatchEvent("keyup", {keyCode : keyCode});//@todo
            }

            
            if (_self.isValid && _self.isValid() && e.keyCode != 13 && e.keyCode != 17)
                _self.clearError();
            
        };

        
        if (apf.hasFocusBug)
            apf.sanitizeTextbox(this.$input);
        

        if (apf.hasAutocompleteXulBug)
            this.$input.setAttribute("autocomplete", "off");

        if (!this.$input.tagName.toLowerCase().match(/input|textarea/)) {
            this.isHTMLBox = true;

            this.$input.unselectable    = "Off";
            this.$input.contentEditable = true;
            this.$input.style.width     = "1px";

            this.$input.select = function(){
                var r = document.selection.createRange();
                r.moveToElementText(this);
                r.select();
            }
        };

        this.$input.deselect = function(){
            if (!document.selection) return;

            var r = document.selection.createRange();
            r.collapse();
            r.select();
        };
    };

    this.$loadAml = function() {
        if (typeof this["initial-message"] == "undefined")
            this.$setInheritedAttribute("initial-message");

        if (typeof this.realtime == "undefined")
            this.$setInheritedAttribute("realtime");
    }

    this.addEventListener("DOMNodeRemovedFromDocument", function(){
        if (this.$button)
            this.$button.onmousedown = null;
        
        if (this.$input) {
            this.$input.onkeypress     =
            this.$input.onmouseup      =
            this.$input.onmouseout     =
            this.$input.onmousedown    =
            this.$input.onkeydown      =
            this.$input.onkeyup        =
            this.$input.onselectstart  = null;
        }
    });

}).call(apf.textbox.prototype = new apf.StandardBinding());


apf.config.$inheritProperties["initial-message"] = 1;
apf.config.$inheritProperties["realtime"]        = 1;

apf.input.prototype    =
apf.secret.prototype   =
apf.password.prototype =
apf.textarea.prototype =
apf.email.prototype    = apf.textbox.prototype;

apf.aml.setElement("input",    apf.input);
apf.aml.setElement("secret",   apf.secret);
apf.aml.setElement("password", apf.password);
apf.aml.setElement("textarea", apf.textarea);
apf.aml.setElement("textbox",  apf.textbox);



/*FILEHEAD(/var/lib/platform/source/trunk/elements/script.js)SIZE(3411)TIME(1271105954)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * element that loads javascript into the application
 * either from it's first child or from a file.
 * Example:
 * <code>
 *  <a:script src="code.js" />
 * </code>
 * Example:
 * <code>
 *  <a:script>//<!-- 
 *      for (var i = 0; i < 2; i++) {
 *          alert(i);
 *      }
 *  //--></a:script>
 * </code>
 * @attribute {String} src the location of the script file.
 * @addnode global, anyaml
 *
 * @author      Ruben Daniels (ruben AT ajax DOT org)
 * @version     %I%, %G%
 * @since       0.4
 */
apf.script = function(){
    this.$init("script", apf.NODE_HIDDEN);
};

(function(){
    this.$propHandlers["src"] = function(value){
        if (apf.isOpera) {
            $setTimeout(function(){
                apf.window.loadCodeFile(apf.hostPath
                    + value);
            }, 1000);
        }
        else {
            apf.window.loadCodeFile(apf.getAbsolutePath(apf.hostPath,
                value));
        }
    }
    
    this.addEventListener("DOMNodeInserted", function(e){
        if (e.currentTarget.nodeType == 3 || e.currentTarget.nodeType == 4) {
            var code = e.currentTarget.nodeValue;
            
            if (!this.type || this.type == "text/javascript") {
                apf.jsexec(code);
            }
            else if (this.type == "application/livemarkup"
              || this.type == "application/lm") { //@todo this is wrong, it should start in code mode
                var func = apf.lm.compile(code, {event: true, parsecode: true, funcglobal: true});
                func(window.event);
            }
        }
    });
    
    //@todo this should use text node insertion
    this.addEventListener("DOMNodeInsertedIntoDocument", function(e){
        var nodes = this.childNodes, s = [];
        for (var i = 0, l = nodes.length; i < l; i++) {
            s[s.length] = nodes[i].nodeValue;
        }
        
        var code = s.join("\n");
        
        if (!this.type || this.type == "text/javascript") {
            apf.jsexec(code);
        }
        else if (this.type == "application/livemarkup"
          || this.type == "application/lm") {
            var func = apf.lm.compile(code, {event: true, parsecode: true, funcglobal: true});
            func(window.event);
        }
    });
}).call(apf.script.prototype = new apf.AmlElement());

apf.aml.setElement("script", apf.script);




/*FILEHEAD(/var/lib/platform/source/trunk/elements/tree.js)SIZE(17054)TIME(1271196962)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */








/**
 * Element displaying data in a list where each item in the list can contain
 * such a list. This element gives the user the ability to walk through this
 * tree of data by clicking open elements to show more elements. The tree
 * can grow by fetching more data when the user requests it.
 * Example:
 * A tree with inline items.
 * <code>
 *  <a:tree id="tree" align="right">
 *      <a:item caption="root" icon="icoUsers.gif">
 *          <a:item icon="icoUsers.gif" caption="test">
 *              <a:item icon="icoUsers.gif" caption="test" />
 *              <a:item icon="icoUsers.gif" caption="test" />
 *              <a:item icon="icoUsers.gif" caption="test" />
 *          </a:item>
 *          <a:item icon="icoUsers.gif" caption="test" />
 *          <a:item icon="icoUsers.gif" caption="test" />
 *          <a:item icon="icoUsers.gif" caption="test" />
 *      </a:item>
 *  </a:tree>
 * </code>
 * Example:
 * <code>
 *  <a:tree model="filesystem.xml">
 *      <a:caption match="[@caption]" />
 *      <a:caption match="[@filename]" />
 *      <a:icon match="[@icon]" />
 *      <a:each match="[drive|file|folder]" />
 *  </a:tree>
 * </code>
 * Example:
 * Inline tree description that draws the same as the above example:
 * <code>
 *  <a:tree 
 *    model   = "filesystem.xml"
 *    caption = "[@caption|@filename]"
 *    icon    = "[@icon]"
 *    each    = "[drive|file|folder]" />
 * </code>
 *
 * @constructor
 * @define tree
 * @allowchild {smartbinding}
 * @addnode elements
 *
 * @author      Ruben Daniels (ruben AT ajax DOT org)
 * @version     %I%, %G%
 * @since       0.4
 *
 * @inherits apf.XForms
 * @inherits apf.MultiSelect
 * @inherits apf.Cache
 * @inherits apf.DataAction
 * @inherits apf.Rename
 *
 * @binding insert Determines how new data is loaded when the user expands 
 * an item. For instance by clicking on the + button. This way only the root nodes
 * need to be loaded at the start of the application. All other children are
 * received on demand when the user requests it by navigating throught the tree.
 * Example:
 * This example shows an insert rule that only works on folder elements. It will
 * read the directory contents using webdav and insert it under the selected 
 * tree node.
 * <code>
 *  <a:tree model="filesystem.xml">
 *      <a:bindings>
 *          <a:caption match="[@caption|@filename]" />
 *          <a:insert match="[folder]" get="{myWebdav.readdir([@id])}" />
 *          <a:each match="[drive|file|folder]" />
 *      </a:bindings>
 *  </a:tree>
 * </code>
 * @attribute {String} get the {@link term.datainstruction data instruction} that is used to load the new data.
 * @binding caption  Determines the caption of a tree node.
 * @binding icon     Determines the icon of a tree node.
 * @binding css      Determines a css class for a tree node.
 * Example:
 * In this example a node is bold when the folder contains unread messages:
 * <code>
 *  <a:tree model="messages.xml">
 *      <a:caption match="[@caption]" />
 *      <a:css match="[folder/message[@unread]]" value="highlighUnread" />
 *      <a:icon match="[@icon]" />
 *      <a:icon match="[folder]" value="icoDir.png" />
 *      <a:each match="[folder|message]" />
 *  </a:tree>
 * </code>
 * @binding tooltip  Determines the tooltip of a tree node.
 * @binding empty    Determines the empty message of a node.
 * Example:
 * This example shows a gouped contact list, that displays a message under 
 * empty groups.
 * <code>
 *  <a:tree model="xml/contacts.xml">
 *      <a:caption match="[@caption]" />
 *      <a:icon match="[contact]" value="icoContact.png" />
 *      <a:icon match="[group]" value="icoFolder.png" />
 *      <a:empty match="[group]" value="Drag a contact to this group." />
 *      <a:each match="[group|contact]" />
 *  </a:tree>
 * </code>
 */
apf.tree = function(struct, tagName){
    this.$init(tagName || "tree", apf.NODE_VISIBLE, struct);
};

(function(){
    var HAS_CHILD = 1 << 1,
        IS_CLOSED = 1 << 2,
        IS_LAST   = 1 << 3,
        IS_ROOT   = 1 << 4,
        treeState = this.$treeState;
    
    /**** Properties and Attributes ****/
    
    /**
     * @attribute {String} mode Sets the way this element interacts with the user.
     *   Possible values:
     *   check  the user can select a single item from this element. The selected item is indicated.
     *   radio  the user can select multiple items from this element. Each selected item is indicated.
     */
    this.$mode = 0;
    this.$propHandlers["mode"] = function(value){
        if ("check|radio".indexOf(value) > -1) {
            this.implement(apf.MultiCheck);
            
            this.addEventListener("afterrename", $afterRenameMode); //what does this do?
            
            this.multicheck = value == "check"; //radio is single
            this.$mode = this.multicheck ? 1 : 2;
        }
        else {
            //@todo undo actionRules setting
            this.removeEventListener("afterrename", $afterRenameMode);
            //@todo unimplement??
            this.$mode = 0;
        }
    };
    
    //@todo apf3.0 retest this completely
    function $afterRenameMode(){
    }
    
    //@todo please upgrade all the event calls to the 21st century, it hurts my eyes.
    this.$initNode = function(xmlNode, state, Lid){
        //Setup Nodes Interaction
        this.$getNewContext("item");
        
        var hasChildren = state & HAS_CHILD || this.emptyMessage 
            && this.$applyBindRule("empty", xmlNode),
            //should be restructured and combined events set per element
            oItem = this.$getLayoutNode("item");
        //@todo this should use dispatchEvent, and be moved to oExt
        oItem.setAttribute("onmouseover",
            "var o = apf.lookup(" + this.$uniqueId + ");\
            o.$setStyleClass(this, 'hover', null, true);");
        oItem.setAttribute("onmouseout",
            "var o = apf.lookup(" + this.$uniqueId + ");\
            o.$setStyleClass(this, '', ['hover'], true);");
        /*oItem.setAttribute("onmousedown",
            "var o = apf.lookup(" + this.$uniqueId + ");\
            if (o.onmousedown) o.onmousedown(event, this);");*/
        
        //Set open/close skin class & interaction
        this.$setStyleClass(this.$getLayoutNode("item", "class"), treeState[state]).setAttribute(apf.xmldb.htmlIdTag, Lid);
        this.$setStyleClass(this.$getLayoutNode("item", "container"), treeState[state])
        //this.$setStyleClass(oItem, xmlNode.tagName)
        var elOpenClose = this.$getLayoutNode("item", "openclose");
        if (elOpenClose) { //hasChildren && 
            elOpenClose.setAttribute("children", hasChildren);
            elOpenClose.setAttribute("onmousedown",
                "if (this.getAttribute('children') == false) return;\
                var o = apf.lookup(" + this.$uniqueId + ");\
                o.slideToggle(this, null, null, true);\
                apf.cancelBubble(event, o);");
            
            elOpenClose.setAttribute("ondblclick", "event.cancelBubble = true");
        }
        
        
        
        var ocAction = this.opencloseaction || "ondblclick";
        
        //Icon interaction
        var elIcon = this.$getLayoutNode("item", "icon");
        if (elIcon && elIcon != elOpenClose) {
            if (ocAction != "ondblclick") {
                elIcon.setAttribute(ocAction, 
                  "var o = apf.lookup(" + this.$uniqueId + ");" +
                   (ocAction == "onmousedown" ? "o.select(this, event.ctrlKey, event.shiftKey, -1);" : "") +
                   (true ? "o.slideToggle(this, null, null, true);" : ""));
            }
            if (ocAction != "onmousedown") {
                elIcon.setAttribute("onmousedown", 
                  "apf.lookup(" + this.$uniqueId + ").select(this, event.ctrlKey, event.shiftKey, -1);");
            }
            
            elIcon.setAttribute("ondblclick", 
              "var o = apf.lookup(" + this.$uniqueId + ");\
              o.choose();" + 
              
              "o.stopRename();" + 
              
              (true && !ocAction == "ondblclick" ? "o.slideToggle(this, null, null, true);" : "") +
              "apf.cancelBubble(event,o);");
        }

        //Select interaction
        var elSelect = this.$getLayoutNode("item", "select"),
            strMouseDown;
        
        
        if (this.hasFeature(apf.__RENAME__) || this.hasFeature(apf.__DRAGDROP__)) {
            strMouseDown =
                'var o = apf.lookup(' + this.$uniqueId + ');\
                 var xmlNode = apf.xmldb.findXmlNode(this);\
                 var isSelected = o.isSelected(xmlNode);\
                 this.hasPassedDown = true;\
                 if (!o.renaming && o.hasFocus() && isSelected == 1) \
                    this.dorename = true;\
                 if (!o.hasFeature(apf.__DRAGDROP__) || !isSelected && !event.ctrlKey)\
                     o.select(this, event.ctrlKey, event.shiftKey, -1);';
            
            elSelect.setAttribute("onmouseout", 'this.hasPassedDown = false;' + (elSelect.getAttribute("onmouseout") || ""));
            elSelect.setAttribute("onmouseup", 'if (!this.hasPassedDown) return;\
                var o = apf.lookup(' + this.$uniqueId + ');' +
                
                'if (this.dorename && !o.mode)\
                    o.startDelayedRename(event, null, true);' +
                
                'this.dorename = false;\
                 var xmlNode = apf.xmldb.findXmlNode(this);\
                 var isSelected = o.isSelected(xmlNode);\
                 if (o.hasFeature(apf.__DRAGDROP__))\
                     o.select(this, event.ctrlKey, event.shiftKey, -1);');
        }
        else 
        
        {
            strMouseDown = "o.select(this, event.ctrlKey, event.shiftKey, -1);";
        }
        
        if (ocAction != "ondblclick") {
            elSelect.setAttribute(ocAction, 
              "var o = apf.lookup(" + this.$uniqueId + ");" +
               (ocAction == "onmousedown" ? strMouseDown : "") +
               (true ? "o.slideToggle(this, null, null, true);" : ""));
        }
        if (ocAction != "onmousedown") {
            elSelect.setAttribute("onmousedown", 
              "var o = apf.lookup(" + this.$uniqueId + ");" + strMouseDown);
        }

        elSelect.setAttribute("ondblclick", 
          "var o = apf.lookup(" + this.$uniqueId + ");\
          o.choose();" + 
          
          "o.stopRename();this.dorename=false;" + 
          
          (ocAction == "ondblclick" ? "o.slideToggle(this, null, null, true);" : "") +
          "apf.cancelBubble(event,o);");
        
        //Setup Nodes Identity (Look)
        if (elIcon) {
            var iconURL = this.$applyBindRule("icon", xmlNode);
            if (iconURL) {
                if (elIcon.tagName.match(/^img$/i))
                    elIcon.setAttribute("src", apf.getAbsolutePath(this.iconPath, iconURL));
                else
                    elIcon.setAttribute("style", "background-image:url(" 
                        + apf.getAbsolutePath(this.iconPath, iconURL) + ")");
            }
        }

        var elCaption = this.$getLayoutNode("item", "caption");
        if (elCaption) {
            apf.setNodeValue(elCaption,
                this.$applyBindRule("caption", xmlNode));
        }
        
        var strTooltip = this.$applyBindRule("tooltip", xmlNode)
        if (strTooltip)
            oItem.setAttribute("title", strTooltip);
        
        
        var cssClass = this.$applyBindRule("css", xmlNode);
        if (cssClass) {
            this.$setStyleClass(this.$getLayoutNode("item", null, oItem), cssClass);
            this.$setStyleClass(this.$getLayoutNode("item", "container", oItem), cssClass);
            this.$dynCssClasses.push(cssClass);
        }
        

        return oItem;
    };
    
    this.$updateNode = function(xmlNode, htmlNode){
        var elIcon  = this.$getLayoutNode("item", "icon", htmlNode),
            iconURL = this.$applyBindRule("icon", xmlNode);
        if (elIcon && iconURL) {
            if (elIcon.tagName && elIcon.tagName.match(/^img$/i))
                elIcon.src = apf.getAbsolutePath(this.iconPath, iconURL);
            else
                elIcon.style.backgroundImage = "url(" 
                    + apf.getAbsolutePath(this.iconPath, iconURL) + ")";
        }

        var elCaption = this.$getLayoutNode("item", "caption", htmlNode);
        if (elCaption) {
            /*if (elCaption.nodeType == 1)
                elCaption.innerHTML = this.$applyBindRule("caption", xmlNode);
            else
                elCaption.nodeValue = this.$applyBindRule("caption", xmlNode);*/
            
            if (elCaption.nodeType != 1)
                elCaption = elCaption.parentNode;

            elCaption.innerHTML = this.$applyBindRule("caption", xmlNode);
        }
        
        var strTooltip = this.$applyBindRule("tooltip", xmlNode);
        if (strTooltip) 
            htmlNode.setAttribute("title", strTooltip);

        
        var cssClass = this.$applyBindRule("css", xmlNode);
        if (cssClass || this.$dynCssClasses.length) {
            this.$setStyleClass(htmlNode, cssClass, this.$dynCssClasses);
            if (cssClass && !this.$dynCssClasses.contains(cssClass))
                this.$dynCssClasses.push(cssClass);
        }
        
    };
    
    /**** Init ****/
    
    this.$draw = function(){
        this.$drawBase();
    };
}).call(apf.tree.prototype = new apf.BaseTree());

apf.aml.setElement("tree", apf.tree);

apf.aml.setElement("checked", apf.BindingRule);



/*FILEHEAD(/var/lib/platform/source/trunk/elements/bar.js)SIZE(4239)TIME(1269561674)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/**
 * Element displaying a skinnable rectangle which can contain other 
 * aml elements. This element is used by other elements such as the 
 * toolbar and statusbar element to specify sections within those elements
 * which in turn can contain other aml elements.
 * Remarks:
 * This component is used in the accordion element to create its sections. In
 * the statusbar the panel element is an alias of bar.
 *
 * @constructor
 *
 * @define bar, panel, menubar
 * @attribute {String} icon the url pointing to the icon image.
 * @attribute {Boolean} collapsed   collapse panel on load, default is false
 * Possible values:
 *     true    panel is collapsed
 *     false   panel is not collapsed
 * @attribute {String} title   describes content in panel
 * @allowchild button
 * @allowchild {elements}, {anyaml}
 * @addnode elements
 *
 * @author      Ruben Daniels (ruben AT ajax DOT org)
 * @version     %I%, %G%
 * @since       0.4
 */
apf.section = function(struct, tagName){
    this.$init(tagName || "section", apf.NODE_VISIBLE, struct);
};

apf.menubar = function(struct, tagName){
    this.$init(tagName || "menubar", apf.NODE_VISIBLE, struct);
};

apf.bar     = function(struct, tagName){
    this.$init(tagName || "bar", apf.NODE_VISIBLE, struct);
};

(function(){
    this.$focussable     = false;
    this.$canLeechSkin   = true;
    this.$isLeechingSkin = false;
    
    this.$propHandlers["caption"] = function(value) {
        this.$int.innerHTML = value;
    }
    
    //@todo apf3.0 refactor
    this.addEventListener("AMLReparent", 
        function(beforeNode, pNode, withinParent){
            if (!this.$amlLoaded)
                return;

            if (this.$isLeechingSkin && !withinParent
              && this.skinName != pNode.skinName
              || !this.$isLeechingSkin
              && this.parentNode.$hasLayoutNode 
              && this.parentNode.$hasLayoutNode(this.localName)) {
                this.$isLeechingSkin = true;
                this.$forceSkinChange(this.parentNode.skinName.split(":")[0] + ":" + skinName);
            }
        });

    this.$draw = function(){
        //Build Main Skin
        this.$ext = this.$getExternal(this.$isLeechingSkin
            ? this.localName 
            : "main");

        //Draggable area support, mostly for a:toolbar
        if (this.oDrag) //Remove if already exist (skin change)
            this.oDrag.parentNode.removeChild(this.oDrag);
        
        this.oDrag = this.$getLayoutNode(this.$isLeechingSkin
            ? this.localName 
            : "main", "dragger", this.$ext);
            
        this.$int = this.$getLayoutNode(this.$isLeechingSkin
            ? this.localName 
            : "main", "container", this.$ext);
    };

    this.$loadAml = function(x){
        
    };
    
    
}).call(apf.bar.prototype = new apf.Presentation());

apf.menubar.prototype = 
apf.section.prototype = apf.bar.prototype;

apf.aml.setElement("bar", apf.bar);
apf.aml.setElement("menubar", apf.menubar);
apf.aml.setElement("section", apf.section);




/*FILEHEAD(/var/lib/platform/source/trunk/elements/actions.js)SIZE(3177)TIME(1269561674)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
* @define actions  element containing all the action rules for the data 
 * bound elements referencing this element.
 * Example:
 * <code>
 *  <a:actions id="actPerson" >
 *      <a:add set="{comm.addPerson([.])}">
 *          <person name="New person" />
 *      </a:add
 *      <a:rename set="{comm.renamePerson([@id], [@name])}" />
 *      <a:remove match="[@new]" set="{comm.removePerson([@id])}"/>
 *  </a:actions>
 *
 *  <a:tree actions="actPerson" />
 * </code>
 * @allowchild {actions}
 * @addnode smartbinding, global
 *
 * @constructor
 * @apfclass
 *
 * @author      Ruben Daniels (ruben AT ajax DOT org)
 * @version     %I%, %G%
 * @since       0.8
 *
 * @default_private
 */
apf.actions = function(struct, tagName){
    this.$init(tagName || "actions", apf.NODE_HIDDEN, struct);
    
    this.$actions      = new apf.ruleList();
    this.$amlNodes     = {};
};

(function(){
    this.$smartbinding = null;

    this.register = function(amlNode){
        if (amlNode.localName == "smartbinding") {
            this.$smartbinding = amlNode;
            this.$smartbinding.add(this); //Assuming only at init
            return;
        }
        
        this.$amlNodes[amlNode.$uniqueId] = amlNode;
        amlNode.$actions = this.$actions;
        amlNode.dispatchEvent("actionsload", {bindings: this});
    }

    this.unregister = function(amlNode){
        //unregister element
        this.$amlNodes[amlNode.$uniqueId] = null;
        delete this.$amlNodes[amlNode.$uniqueId];
        
        delete amlNode.$actions;
        amlNode.dispatchEvent("actionsunload", {bindings: this});
    };
    
    /**** DOM Handlers ****/
    
    this.addEventListener("DOMNodeInsertedIntoDocument", function(e){
        var nodes = this.childNodes;
        for (var node, i = 0, l = nodes.length; i < l; i++) {
            if ((node = nodes[i]).nodeType != 1)
                continue;
                
            node.dispatchEvent("DOMNodeInsertedIntoDocument");
        }
        
        this.register(this.parentNode);
    });
}).call(apf.actions.prototype = new apf.AmlElement());

apf.aml.setElement("actions", apf.actions);



/*FILEHEAD(/var/lib/platform/source/trunk/elements/caldropdown.js)SIZE(35640)TIME(1270546982)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/elements/radiobutton.js)SIZE(16245)TIME(1270838607)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * Element displaying a two state button which is one of a grouped set.
 * Only one of these buttons in the set can be checked at the same time.
 * Example:
 * <code>
 *  <a:frame caption="Options">
 *      <a:radiobutton>Option 1</a:radiobutton>
 *      <a:radiobutton>Option 2</a:radiobutton>
 *      <a:radiobutton>Option 3</a:radiobutton>
 *      <a:radiobutton>Option 4</a:radiobutton>
 *  </a:frame>
 * </code>
 * Example:
 * This example shows radio buttons with an explicit group set:
 * <code>
 *  <a:label>Options</a:label>
 *  <a:radiobutton group="g1">Option 1</a:radiobutton>
 *  <a:radiobutton group="g1">Option 2</a:radiobutton>
 *
 *  <a:label>Choices</a:label>
 *  <a:group id="g2" value="[mdlForm::choice]">
 *      <a:radiobutton value="c1">Choice 1</a:radiobutton>
 *      <a:radiobutton value="c2">Choice 2</a:radiobutton>
 *  </a:grou>
 * </code>
 *
 * @constructor
 * @define radiobutton
 * @allowchild {smartbinding}
 * @addnode elements
 *
 * @inherits apf.Presentation
 *
 * @author      Ruben Daniels (ruben AT ajax DOT org)
 * @version     %I%, %G%
 * @since       0.4
 *
 * @binding value  Determines the way the value for the element is retrieved 
 * from the bound data.
 * Example:
 * Sets the selection based on data loaded into this component.
 * <code>
 *  <a:radiobutton group="g2" bindings="bndExample" value="1">Choice 1</a:radiobutton>
 *  <a:radiobutton group="g2" value="2">Choice 2</a:radiobutton>
 *
 *  <a:bindings id="bndExample">
 *      <a:value match="[@value]" />
 *  </a:bindings>
 * </code>
 * Example:
 * A shorter way to write this is:
 * <code>
 *  <a:radiobutton group="g2" value="[@value]" value="1">Choice 1</a:radiobutton>
 *  <a:radiobutton group="g2" value="2">Choice 2</a:radiobutton>
 * </code>
 *
 * @event click Fires when the user presses a mousebutton while over this element and then let's the mousebutton go. 
 * @see baseclass.amlnode.event.afterchange
 */
apf.radiobutton = function(struct, tagName){
    this.$init(tagName || "radiobutton", apf.NODE_VISIBLE, struct);
    
    this.$constructor = apf.radiobutton;
    var fEl = apf.aml.setElement("radiobutton", function(){
        this.$init(tagName || "radiobutton", apf.NODE_VISIBLE, struct);
    });
    fEl.prototype = apf.radiobutton.prototype;
    apf.radiobutton = fEl;
};

(function(){
    this.implement(apf.ChildValue);
    this.$childProperty = "label";
    
    this.$focussable = true; // This object can get the focus
    
    //1 = force no bind rule, 2 = force bind rule
    /*this.$attrExcludePropBind = apf.extend({
        checked: 1
    }, this.$attrExcludePropBind);*/

    /**** Properties and Attributes ****/

    this.$booleanProperties["checked"] = true;
    this.$supportedProperties.push("value", "background", "group",
        "label", "checked", "tooltip", "icon");

    /**
     * @attribute {String} group the name of the group to which this radio
     * button belongs. Only one item in the group can be checked at the same
     * time. When no group is specified the parent container functions as the
     * group; only one radiobutton within that parent can be checked.
     */
    this.$propHandlers["group"] = function(value){
        if (!this.$amlLoaded)
            return;
        
        if (this.$group && this.$group.$removeRadio)
            this.$group.$removeRadio(this);
            
        if (!value) {
            this.$group = null;
            return;
        }
        
        var group = typeof value == "string"
            ? apf.nameserver.get("radiogroup", value)
            : value;
        if (!group) {
            group = apf.nameserver.register("radiogroup", value, 
                new apf.$group());
            group.setAttribute("id", value);
            group.dispatchEvent("DOMNodeInsertedIntoDocument");
            group.parentNode = this;
        }
        this.$group = group;
        
        if (this.oInput)
            this.oInput.setAttribute("name", value);
        
        this.$group.$addRadio(this);
    };
    
    /**
     * @attribute {String} tooltip the tooltip of this radio button.
     */
    this.$propHandlers["tooltip"] = function(value){
        this.$ext.setAttribute("title", value);
    };

    /**
     * @attribute {String} icon the icon for this radiobutton
     */
    this.$propHandlers["icon"] = function(value){
        
        if (!this.oIcon)
            return apf.console.warn("No icon defined in the Button skin", "button");
        

        if (value)
            this.$setStyleClass(this.$ext, this.$baseCSSname + "Icon");
        else
            this.$setStyleClass(this.$ext, "", [this.$baseCSSname + "Icon"]);

        apf.skins.setIcon(this.oIcon, value, this.iconPath);
    };

    /**
     * @attribute {String} label the label for this radiobutton
     */
    this.$propHandlers["label"] = function(value){
        if (value)
            this.$setStyleClass(this.$ext, "", [this.$baseCSSname + "Empty"]);
        else
            this.$setStyleClass(this.$ext, this.$baseCSSname + "Empty");
        
        if (this.oLabel)
            this.oLabel.innerHTML = value;
    };

    /**
     * @attribute {String} checked whether this radiobutton is the checked one in the group it belongs to.
     */
    this.$propHandlers["checked"] = function(value){
        if (!this.$group)
            return;

        if (value)
            this.$group.setProperty("value", this.value);
        //else if (this.$group.value == this.value)
            //this.$group.setProperty("value", "");
    };
    
    this.addEventListener("prop.model", function(e){
        if (this.$group)
            this.$group.setProperty("model", e.value);
    });

    /**
     * @attribute {string} background sets a multistate background. The arguments
     * are seperated by pipes '|' and are in the order of:
     * 'imagefilename|mapdirection|nrofstates|imagesize'
     * The mapdirection argument may have the value of 'vertical' or 'horizontal'.
     * The nrofstates argument specifies the number of states the iconfile contains:
     * 1 - normal
     * 2 - normal, hover
     * 3 - normal, hover, down
     * 4 - normal, hover, down, disabled
     * The imagesize argument specifies how high or wide each icon is inside the
     * map, depending of the mapdirection argument.
     *
     * Example:
     * A 3 state picture where each state is 16px high, vertically spaced
     * <code>
     * background="threestates.gif|vertical|3|16"
     * </code>
     * @see baseclass.basebutton
     */
    this.$propHandlers["background"] = function(value){
        var oNode = this.$getLayoutNode("main", "background", this.$ext);
        if (value) {
            var b = value.split("|");
            this.$background = b.concat(["vertical", 2, 16].slice(b.length - 1));

            oNode.style.backgroundImage  = "url(" + this.mediaPath + b[0] + ")";
            oNode.style.backgroundRepeat = "no-repeat";
        }
        else {
            oNode.style.backgroundImage  = "";
            oNode.style.backgroundRepeat = "";
            this.$background = null;
        }
    }

    /**** Public methods ****/

    

    /**
     * Sets the value of this element. This should be one of the values
     * specified in the values attribute.
     * @param {String} value the new value of this element
     */
    this.setValue = function(value){
        this.setProperty("value", value, false, true);
    };

    /**
     * Returns the current value of this element.
     * @return {String}
     */
    this.getValue = function(){
        return this.value;
    };
    
    this.check = function(){
        this.setProperty("checked", true, false, true);
    }
    
    this.uncheck = function(){
        this.setProperty("checked", false, false, true);
    }
    
    this.getGroup = function(){
        return this.$group;
    }
    
    

    /**
     * Sets the checked state and related value
     */
    this.$check = function(visually){
        this.$setStyleClass(this.$ext, this.$baseCSSname + "Checked");
        this.checked = true;
        if (this.oInput)
            this.oInput.checked = true;
        this.doBgSwitch(2);
    };

    this.$uncheck = function(){
        this.$setStyleClass(this.$ext, "", [this.$baseCSSname + "Checked"]);
        this.checked = false;
        if (this.oInput)
            this.oInput.checked = false;
        this.doBgSwitch(1);
    };

    /**** Private methods ****/

    this.$enable = function(){
        if (this.oInput)
            this.oInput.disabled = false;

        var _self = this;
        this.$ext.onclick = function(e){
            if (!e) e = event;
            if ((e.srcElement || e.target) == this)
                return;

            _self.dispatchEvent("click", {
                htmlEvent: e
            });
            _self.$group.change(_self.value);
        }

        this.$ext.onmousedown = function(e){
            if (!e) e = event;
            if ((e.srcElement || e.target) == this)
                return;

            apf.setStyleClass(this, _self.$baseCSSname + "Down");
        }

        this.$ext.onmouseover = function(e){
            if (!e) e = event;
            if ((e.srcElement || e.target) == this)
                return;

            apf.setStyleClass(this, _self.$baseCSSname + "Over");
        }

        this.$ext.onmouseout =
        this.$ext.onmouseup  = function(){
            apf.setStyleClass(this, "", [_self.$baseCSSname + "Down", _self.$baseCSSname + "Over"]);
        }
    };

    this.$disable = function(){
        if (this.oInput)
            this.oInput.disabled = true;
        this.$ext.onclick = null
        this.$ext.onmousedown = null
    };

    /**
     * @private
     */
    this.doBgSwitch = function(nr){
        if (this.bgswitch && (this.bgoptions[1] >= nr || nr == 4)) {
            if (nr == 4)
                nr = this.bgoptions[1] + 1;

            var strBG = this.bgoptions[0] == "vertical"
                ? "0 -" + (parseInt(this.bgoptions[2]) * (nr - 1)) + "px"
                : "-"   + (parseInt(this.bgoptions[2]) * (nr - 1)) + "px 0";

            this.$getLayoutNode("main", "background", this.$ext)
                .style.backgroundPosition = strBG;
        }
    };

    this.$focus = function(){
        if (!this.$ext)
            return;
        if (this.oInput && this.oInput.disabled)
            return false;

        this.$setStyleClass(this.$ext, this.$baseCSSname + "Focus");
    };

    this.$blur = function(){
        if (!this.$ext)
            return;
        this.$setStyleClass(this.$ext, "", [this.$baseCSSname + "Focus"]);
    };

    /**** Keyboard support ****/

    
    this.addEventListener("keydown", function(e){
        var key = e.keyCode;

        if (key == 13 || key == 32) {
            //this.check();
            //this.$group.current = this;
            this.$group.change(this.value);
            return false;
        }
        //Up
        else if (key == 38) {
            var node = this;
            while (node && node.previousSibling) {
                node = node.previousSibling;
                if (node.localName == "radiobutton" && !node.disabled
                  && node.$group == this.$group) {
                    node.check();
                    node.focus();
                    return;
                }
            }
        }
        //Down
        else if (key == 40) {
            var node = this;
            while (node && node.nextSibling) {
                node = node.nextSibling;
                if (node.localName == "radiobutton" && !node.disabled
                  && node.$group == this.$group) {
                    node.check();
                    node.focus();
                    return;
                }
            }
        }
    }, true);
    

    /**** Init ****/

    this.$draw = function(){
        //Build Main Skin
        this.$ext = this.$getExternal();
        this.oInput = this.$getLayoutNode("main", "input", this.$ext);
        this.oLabel = this.$getLayoutNode("main", "label", this.$ext);
        this.oIcon  = this.$getLayoutNode("main", "icon", this.$ext);

        if (this.oLabel && this.oLabel.nodeType != 1)
            this.oLabel = this.oLabel.parentNode;

        this.enable();
    };

    this.$childProperty = "label";
    this.$loadAml = function(x){
        if (this.group)
            this.$propHandlers["group"].call(this, this.group);
        
        else if (this.parentNode.localName == "group")
            this.$propHandlers["group"].call(this, this.parentNode);

        if (!this.$group) {
            this.$propHandlers["group"].call(this,
                "radiogroup" + this.parentNode.$uniqueId);
        }
    };
    
    this.$destroy = function(){
        if (this.$group)
            this.$group.$removeRadio(this);
    }
}).call(apf.radiobutton.prototype = new apf.Presentation());

apf.aml.setElement("radiobutton", apf.radiobutton);

apf.$group = function(struct, tagName){
    this.$init(tagName || "radiogroup", apf.NODE_VISIBLE, struct);
    
    this.implement(
        apf.StandardBinding,
        
        apf.DataAction
        
        
    );

    var radiobuttons = [];

    this.$supportedProperties.push("value", "selectedItem");
    this.$propHandlers["value"] = function(value){
        for (var i = 0; i < radiobuttons.length; i++) {
            if (radiobuttons[i].value == value) {
                return this.setProperty("selectedItem", radiobuttons[i]);
            }
        }
        return this.setProperty("selectedItem", null);
    };
    
    var lastSelected;
    this.$propHandlers["selectedItem"] = function(rb){
        if (lastSelected)
            lastSelected.$uncheck();
        if (!rb)
            return;
            
        rb.$check();
        lastSelected = rb;
        
        for (var i = 0; i < radiobuttons.length; i++)
            radiobuttons[i].setProperty("selectedItem", rb);
    };

    this.$addRadio = function(rb){
        var id = radiobuttons.push(rb) - 1;
        
        if (!rb.value)
            rb.setProperty("value", id);
        
        if (this.value && rb.value == this.value)
            this.setProperty("selectedItem", rb);
        else if (rb.checked)
            this.setProperty("value", rb.value);
    };

    this.$removeRadio = function(rb){
        radiobuttons.remove(rb);
        
        if (rb.value === rb.id)
            rb.setProperty("value", "");
        
        if (rb.selectedItem == rb)
            this.setProperty("value", null);
    }

    /**
     * Sets the current value of this element.
     */
    this.setValue = function(value){
        this.setProperty("value", value);
    };
    
    /**
     * Returns the current value of this element.
     * @return {String}
     */
    this.getValue = function(){
        return this.value;
    };

    this.$draw = function(){
        this.$ext = this.$int = this.$pHtmlNode;
    }
};
apf.$group.prototype = new apf.GuiElement();

apf.aml.setElement("group", apf.$group);




/*FILEHEAD(/var/lib/platform/source/trunk/elements/style.js)SIZE(1888)TIME(1271196962)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * @todo description
 *
 * @author      Ruben Daniels (ruben AT ajax DOT org)
 * @version     %I%, %G%
 * @since       0.4
 */
apf.style = function(struct, tagName){
    this.$init(tagName || "style", apf.NODE_HIDDEN, struct);
};

(function(){
    this.$focussable = false;
    
    this.$propHandlers["src"] = function(value){
        apf.getData(value, {
            callback : function(data, state){
                if (state == apf.SUCCESS) {
                    apf.importCssString(data);
                }
            }
        });
    }
    
    this.addEventListener("DOMNodeInsertedIntoDocument", function(e){
        if (this.type != "text/chartcss" && this.firstChild)
            apf.importCssString(this.firstChild.nodeValue);
    });
}).call(apf.style.prototype = new apf.AmlElement());

apf.aml.setElement("style", apf.style);
apf.xhtml.setElement("style",  apf.style);



/*FILEHEAD(/var/lib/platform/source/trunk/elements/page.js)SIZE(14671)TIME(1270838607)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * A page in a pageable element. (i.e. a page in {@link element.tab})
 *
 * @constructor
 * @define  page
 * @allowchild  {elements}, {anyaml}
 * @addnode elements
 *
 * @author      Ruben Daniels (ruben AT ajax DOT org)
 * @version     %I%, %G%
 * @since       0.8
 */
apf.page = function(struct, tagName){
    this.$init(tagName || "page", apf.NODE_VISIBLE, struct);
};

(function(){
    this.canHaveChildren = true;
    
    this.$focussable     = false;
    this.buttons         = false;
    this.closebtn        = false;

    

    
    /**
     * Sets the caption of the button of this element.
     * @param {String} caption the text displayed on the button of this element.
     */
    this.setCaption = function(caption){
        this.setProperty("caption", caption, false, true);
    };

    /**
     * Sets the icon of the button of this element.
     * @param {String} icon the icon displayed on the button of this element.
     */
    this.setIcon = function(icon) {
        this.setProperty("icon", icon, false, true);
    };
    

    /**** Delayed Render Support ****/

    
    //Hack
    this.addEventListener("beforerender", function(){
        this.parentNode.dispatchEvent("beforerender", {
            page : this
        });
    });

    this.addEventListener("afterrender",  function(){
        this.parentNode.dispatchEvent("afterrender", {
            page : this
        });
    });
     

    /**** Properties ****/

    this.$booleanProperties["visible"]  = true;
    this.$booleanProperties["fake"]     = true;
    this.$booleanProperties["closebtn"] = true;
    this.$supportedProperties.push("fake", "caption", "icon", 
        "type", "buttons", "closebtn");

    this.$propHandlers["buttons"] = function(value){
        this.buttons = value;
    };
    
    this.$propHandlers["closebtn"] = function(value){
        this.closebtn = value;
    };

    /**
     * @attribute {String} caption the text displayed on the button of this element.
     */
    this.$propHandlers["caption"] = function(value){
        if (!this.parentNode)
            return;

        var node = this.parentNode
            .$getLayoutNode("button", "caption", this.$button);

        if (node.nodeType == 1)
            node.innerHTML = value;
        else
            node.nodeValue = value;
    };

    this.$propHandlers["icon"] = function(value) {
        if (!this.parentNode)
            return;

        var node = this.parentNode
            .$getLayoutNode("button", "icon", this.$button);

        if (node && node.nodeType == 1)
            apf.skins.setIcon(node, value, this.parentNode.iconPath);
    };

    this.$propHandlers["visible"] = function(value){
        if (!this.parentNode)
            return;

        if (value) {
            this.$ext.style.display = "";
            if (this.parentNode.$hasButtons)
                this.$button.style.display = "block";

            if (!this.parentNode.$activepage) {
                this.parentNode.set(this);
            }
        }
        else {
            if (this.$active) {
                this.$deactivate();

                // Try to find a next page, if any.
                var nextPage = this.parentNode.activepagenr + 1;
                var pages = this.parentNode.getPages()
                var len = pages.length
                while (nextPage < len && !pages[nextPage].visible)
                    nextPage++;

                if (nextPage == len) {
                    // Try to find a previous page, if any.
                    nextPage = this.parentNode.activepagenr - 1;
                    while (nextPage >= 0 && len && !pages[nextPage].visible)
                        nextPage--;
                }

                if (nextPage >= 0)
                    this.parentNode.set(nextPage);
                else {
                    this.parentNode.activepage   =
                    this.parentNode.activepagenr =
                    this.parentNode.$activepage = null;
                }
            }

            this.$ext.style.display = "none";
            if (this.parentNode.$hasButtons)
                this.$button.style.display = "none";
        }
    };

    /**
     * @attribute {Boolean} fake whether this page actually contains elements or
     * only provides a button in the pageable parent element.
     */
    this.$propHandlers["fake"] = function(value){
        if (this.$ext) {
            apf.destroyHtmlNode(this.$ext);
            this.$int = this.$ext = null;
        }
    };

    this.$propHandlers["type"] = function(value) {
        this.setProperty("fake", true);
        this.relPage = this.parentNode.getPage(value);
        if (this.$active)
            this.$activate();
    };

    /**** DOM Hooks ****/

    this.addEventListener("DOMNodeRemoved", function(e){
        if (e && e.currentTarget != this)
            return;
        
        if (this.$button) {
            if (this.$position & 1)
                this.parentNode.$setStyleClass(this.$button, "", ["firstbtn", "firstcurbtn"]);
            if (this.$position & 2)
                this.parentNode.$setStyleClass(this.$button, "", ["lastbtn"]);
        }

        if (!e.$doOnlyAdmin) {
            if (this.$button)
                this.$button.parentNode.removeChild(this.$button);

            if (this.parentNode.$activepage == this) {
                if (this.$button)
                    this.parentNode.$setStyleClass(this.$button, "", ["curbtn"]);
                this.parentNode.$setStyleClass(this.$ext, "", ["curpage"]);
            }
        }
    });

    //beforeNode, pNode, withinParent
    this.addEventListener("DOMNodeInserted", function(e){
        if (e && e.currentTarget != this || !this.$amlLoaded 
          || !e.$oldParent)
            return;

        if (!e.$isMoveWithinParent 
          && this.skinName != this.parentNode.skinName) {
            this.$destroy(); //clean up button
        }
        else if (this.$button && e.$oldParent.$hasButtons)
            this.parentNode.$buttons.insertBefore(this.$button,
                e.$beforeNode && e.$beforeNode.$button || null);
    }, true);

    /**** Private state functions ****/

    this.$position = 0;
    this.$first = function(remove){
        if (remove) {
            this.$position -= 1;
            this.parentNode.$setStyleClass(this.$button, "",
                ["firstbtn", "firstcurbtn"]);
        }
        else {
            this.$position = this.$position | 1;
            this.parentNode.$setStyleClass(this.$button, "firstbtn"
                + (this.parentNode.$activepage == this ? " firstcurbtn" : ""));
        }
    };

    this.$last = function(remove){
        if (remove) {
            this.$position -= 2;
            this.parentNode.$setStyleClass(this.$button, "", ["lastbtn"]);
        }
        else {
            this.$position = this.$position | 2;
            this.parentNode.$setStyleClass(this.$button, "lastbtn");
        }
    };

    this.$deactivate = function(fakeOther){
        //if (this.disabled)
            //return false;

        this.$active = false

        if (this.parentNode.$hasButtons) {
            if (this.$position > 0)
                this.parentNode.$setStyleClass(this.$button, "", ["firstcurbtn"]);
            this.parentNode.$setStyleClass(this.$button, "", ["curbtn"]);
        }

        if ((!this.fake || this.relPage) && !fakeOther) {
            this.parentNode.$setStyleClass(this.fake
                ? this.relPage.$ext
                : this.$ext, "", ["curpage"]);
            
            
            this.dispatchEvent("prop.visible", {value:false});
            
        }
    };

    this.$activate = function(){
        //if (this.disabled)
            //return false;

        this.$active = true;

        if (!this.$drawn) {
            var f;
            this.addEventListener("DOMNodeInsertedIntoDocument", f = function(e){
                this.removeEventListener("DOMNodeInsertedIntoDocument", f);
                if (!this.$active)
                    return;
                    
                this.$activate();
            });
            return;
        }

        if (this.parentNode.$hasButtons) {
            if (this.$position > 0)
                this.parentNode.$setStyleClass(this.$button, "firstcurbtn");
            this.parentNode.$setStyleClass(this.$button, "curbtn");
        }

        if (!this.fake || this.relPage) {
            this.parentNode.$setStyleClass(this.fake
                ? this.relPage.$ext
                : this.$ext, "curpage");
            
            if (apf.layout)
                apf.layout.forceResize(this.fake ? this.relPage.$int : this.$int);
            
        }

        
        if (this.$render)
            this.$render();
        
        
        if (!this.fake) {
            if (apf.isIE) {
                var cls = this.$ext.className;
                this.$ext.className = "rnd" + Math.random();
                this.$ext.className = cls;
            }
            
            
            this.dispatchEvent("prop.visible", {value:true});
            
        }
    };

    this.addEventListener("$skinchange", function(){
        if (this.caption)
            this.$propHandlers["caption"].call(this, this.caption);

        if (this.icon)
            this.$propHandlers["icon"].call(this, this.icon);
    });

    /**** Init ****/

    this.$canLeechSkin = true;

    this.$draw = function(isSkinSwitch){
        this.skinName = this.parentNode.skinName;

        var sType = this.getAttribute("type")
        if (sType) {
            this.fake = true;
            this.relPage = this.parentNode.getPage(sType) || null;
        }

        if (this.parentNode.$hasButtons) {
            //this.parentNode.$removeEditable(); //@todo multilingual support is broken when using dom

            this.parentNode.$getNewContext("button");
            var elBtn = this.parentNode.$getLayoutNode("button");
            elBtn.setAttribute(this.parentNode.$getOption("main", "select") || "onmousedown",
                'var page = apf.lookup(' + this.$uniqueId + ');\
                 if (page.disabled) return;\
                 page.parentNode.set(page);\
                 page.canHaveChildren = 2;');
            elBtn.setAttribute("onmouseover", 'var o = apf.lookup('
                + this.parentNode.$uniqueId + ');if(apf.lookup(' + this.$uniqueId
                + ') != o.$activepage) o.$setStyleClass(this, "over", null, true);');
            elBtn.setAttribute("onmouseout", 'var o = apf.lookup('
                + this.parentNode.$uniqueId + ');\
                  o.$setStyleClass(this, "", ["over"], true);\
                  var page = apf.lookup(' + this.$uniqueId + ');\
                  page.canHaveChildren = true;');

            var nameOrId = this.getAttribute("id") || this.getAttribute("name"),
                closebtn = this.getAttribute("closebtn");

            if ((closebtn == "true" || (this.parentNode.buttons == "close" && closebtn == null)) && nameOrId) {
                var btncontainer = this.parentNode.$getLayoutNode("button", "btncontainer");

                this.parentNode.$getNewContext("btnclose");
                var elBtnClose = this.parentNode.$getLayoutNode("btnclose");
                
                if (!elBtnClose)
                    return;
                    
                elBtnClose.setAttribute("onclick",
                    'var page = apf.lookup(' + this.$uniqueId + ');\
                     page.parentNode.remove(' + nameOrId + ');');
                     
                btncontainer.appendChild(elBtnClose);
            }
            
            this.$button = apf.insertHtmlNode(elBtn, this.parentNode.$buttons);

            if (!isSkinSwitch && this.nextSibling && this.nextSibling.$button)
                this.$button.parentNode.insertBefore(this.$button, this.nextSibling.$button);

            this.$button.host = this;
        }

        if (this.fake)
            return;

        if (this.$ext)
            this.$ext.parentNode.removeChild(this.$ext); //@todo mem leaks?

        this.$ext = this.parentNode.$getExternal("page",
            this.parentNode.oPages, null, this);
        this.$ext.host = this;
        
        this.$int = this.parentNode
            .$getLayoutNode("page", "container", this.$ext);
        //if (this.$int)
            //this.$int.setAttribute("id", this.$int.getAttribute("id"));
    };

    this.$loadAml = function(x){
        
    };

    this.$destroy = function(){
        if (this.$button) {
            this.$button.host = null;
            this.$button = null;
        }
    };
}).call(apf.page.prototype = new apf.Presentation());

apf.aml.setElement("page", apf.page);



/*FILEHEAD(/var/lib/platform/source/trunk/elements/submitform.js)SIZE(30214)TIME(1269561674)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/elements/notifier.js)SIZE(15283)TIME(1265032029)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/elements/bindingdndrule.js)SIZE(3737)TIME(1257329184)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * @attribute {String} target 
 * @attribute {String} action
 * @attribute {Boolean} copy
 */
apf.BindingDndRule = function(struct, tagName){
    this.$init(tagName, apf.NODE_HIDDEN, struct);
};

(function(){
    this.compile = function(prop){
        if (!this[prop])
            return;
        
        var compileData;
        if (prop == "value")
            compileData = apf.lm.compile(this[prop], {
                xpathmode  : 3
            });
        else if (prop == "match")
            compileData = apf.lm.compile(this[prop], {
                xpathmode  : 3,
                injectself : true
            });
        else if (prop == "target")
            compileData = apf.lm.compile(this[prop], {
                xpathmode  : 2,
                injectself : true
            });
        else if (prop == "action")
            compileData = apf.lm.compile(this[prop], {
                nostring : true
            });
        else if (prop == "copy")
            compileData = apf.lm.compile(this[prop], {
                withopt  : true,
                nostring : true
            });
        else
            throw new Error("Missing property handler for compile");
        
        return (this["c" + prop] = compileData);
    }
    
    //1 = force no bind rule, 2 = force bind rule
    this.$attrExcludePropBind = apf.extend({
        target   : 1,
        parent   : 1,
        action   : 1,
        dragcopy : 1
    }, this.$attrExcludePropBind);

    this.$propHandlers["target"]   = 
    this.$propHandlers["parent"]   = 
    this.$propHandlers["action"]   = 
    this.$propHandlers["dragcopy"] = function(value, prop){
        delete this["c" + prop];
    }
    
    this.$noderegister = function(e){
         apf.GuiElement.propHandlers["drop"].call(e.amlNode, true);
    }
    
    //@todo removal
    
    this.addEventListener("DOMNodeInsertedIntoDocument", function(e){
        //Find parent that this rule works on
        var pNode = this;
        while (pNode && pNode.$bindingRule) 
            pNode = pNode.parentNode;
       
        if (!pNode)
            return;
        
        if (pNode.localName == "bindings") {
            pNode.addEventListener("noderegister", this.$noderegister);
            
            var nodes = pNode.$amlNodes;
            for (var i = 0; i < nodes.length; i++)
                apf.GuiElement.propHandlers["drop"].call(nodes[i], true);
        }
        else {
            apf.GuiElement.propHandlers["drop"].call(pNode, true);
        }
    });
}).call(apf.BindingDndRule.prototype = new apf.BindingRule());

apf.aml.setElement("drag", apf.BindingDndRule);
apf.aml.setElement("drop", apf.BindingDndRule);




/*FILEHEAD(/var/lib/platform/source/trunk/elements/toolbar.js)SIZE(2821)TIME(1269561674)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * Element displaying a bar containing buttons and other aml elements.
 * This element is usually positioned in the top of an application allowing
 * the user to choose from grouped buttons.
 * Example:
 * <code>
 *  <a:menu id="menu5">
 *      <a:item>About us</a:item>
 *      <a:item>Help</a:item>
 *  </a:menu>
 *  <a:menu id="menu6">
 *      <a:item icon="email.png">Tutorials</a:item>
 *      <a:item>Live Helps</a:item>
 *      <a:divider></a:divider>
 *      <a:item>Visit Ajax.org</a:item>
 *      <a:item>Exit</a:item>
 *  </a:menu>
 *  <a:window 
 *    id          = "winMail"
 *    contextmenu = "menu6"
 *    width       = "300"
 *    height      = "200" 
 *    visible     = "true"
 *    resizable   = "true" 
 *    title       = "Mail message"
 *    icon        = "email.png">
 *      <a:toolbar>
 *          <a:menubar>
 *              <a:button submenu="menu6">File</a:button>
 *              <a:button submenu="menu5">Edit</a:button>
 *          </a:menubar>
 *      </a:toolbar>
 *  </a:window>
 * </code>
 *
 * @constructor
 * @define toolbar
 * @addnode elements
 * @allowchild bar, menubar
 *
 * @author      Ruben Daniels (ruben AT ajax DOT org)
 * @version     %I%, %G%
 * @since       0.4
 *
 * @inherits apf.Presentation
 */

apf.toolbar = function(struct, tagName){
    this.$init(tagName || "toolbar", apf.NODE_VISIBLE, struct);
};

(function(){
    this.$focussable     = false;
    
    /**** DOM Hooks ****/
    
    
    /**** Init ****/

    this.$draw = function(){
        //Build Main Skin
        this.$ext = this.$getExternal();
        this.$int = this.$getLayoutNode("main", "container", this.$ext);
    };
}).call(apf.toolbar.prototype = new apf.Presentation());

apf.aml.setElement("toolbar", apf.toolbar);



/*FILEHEAD(/var/lib/platform/source/trunk/elements/colorpicker.js)SIZE(12770)TIME(1269561674)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/elements/divider.js)SIZE(2934)TIME(1270838607)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * Element displaying a divider. For use in toolbars, menu's and such.
 * @define divider
 * @constructor
 */
apf.divider = function(struct, tagName){
    this.$init(tagName || "divider", apf.NODE_VISIBLE, struct);
};

(function() {
    this.$focussable = false;

    this.implement(apf.ChildValue);
    this.$childProperty = "caption";
    
    this.addEventListener("AMLReparent", function(beforeNode, pNode, withinParent){
        if (!this.$amlLoaded)
            return;
        
        if (!withinParent && this.skinName != pNode.skinName) {
            //@todo for now, assuming dom garbage collection doesn't leak
            this.loadAml();
        }
    });
    
    /** 
     * @attribute {String} caption the text displayed in the area defined by this 
     * element. 
     */
    this.$supportedProperties.push("caption", "value", "for", "textalign");
    this.$propHandlers["caption"] = function(value){
        if (this.$caption) {
            this.$caption.style.display = value ? "inline" : "";
            this.$caption.innerHTML = value;
        }
    };
    
    /**
     * @ref amlNode#show
     */
    this.show = function(){
        this.setProperty("visible", true);
    };
    
    /**
     * @ref amlNode#hide
     */
    this.hide = function(){
        this.setProperty("visible", false);
    };
    
    this.$canLeechSkin = true;
    
    /**
     * @private
     */
    this.$draw = function() {
        if (this.$isLeechingSkin) {
            this.$ext = apf.insertHtmlNode(
                this.parentNode.$getLayoutNode("divider"), this.$pHtmlNode);
        }
        else {
            this.$ext     = this.$getExternal("main");
            this.$caption = this.$getLayoutNode("main", "caption", this.$ext);
        }
    };
}).call(apf.divider.prototype = new apf.Presentation);

apf.aml.setElement("divider", apf.divider);



/*FILEHEAD(/var/lib/platform/source/trunk/elements/hbox.js)SIZE(28611)TIME(1271196962)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


/**
 * @define vbox Container that stacks it's children vertically.
 * @see element.hbox
 * @define hbox Container that stacks it's children horizontally.
 * Example:
 * <code>
 *  <a:hbox height="500" width="600">
 *      <a:vbox height="500" width="500">
 *          <a:bar height="250" caption="Top bar" />
 *          <a:hbox width="500" height="250">
 *              <a:bar width="150" caption="Bottom left bar"/>
 *              <a:bar width="350" caption="Bottom Right bar"/>
 *          </a:hbox>
 *      </a:vbox>
 *      <a:bar width="100" caption="Right bar"/>
 *  </a:hbox>
 * </code>
 * Remarks:
 * The layouting engine of Ajax.org Platform lets you store layouts and set them
 * dynamically. It's very easy to make a layout manager this way. For more 
 * information see {@link object.layout}
 * @addnode elements
 * @constructor
 *
 * @author      Ruben Daniels (ruben AT ajax DOT org)
 * @version     %I%, %G%
 * @since       0.9
 */
apf.hbox = function(struct, tagName){
    this.$init(tagName || "hbox", apf.NODE_VISIBLE, struct);
    
    this.$lastRules = [];
};
apf.vbox = function(struct, tagName){
    this.$init(tagName || "vbox", apf.NODE_VISIBLE, struct);
    
    this.$lastRules = [];
};

(function(){
    var l = apf.layout;
    
    /**** Properties and Attributes ****/
    
    this.$focussable     = false;
    this.$update         = false;
    
    this.padding    = 2;
    this.edge       = "5 5 5 5";
    this.pack       = "start"; //start|center|end
    this.stretch    = true;
    
    var CSSFLOAT    = apf.isIE ? "styleFloat" : "cssFloat";
    
    /**
     * @attribute {String} padding      the space between each element. Defaults to 2.
     * @attribute {String} edge         the space between the container and the elements, space seperated in pixels for each side. Similar to css in the sequence top right bottom left. Defaults to "5 5 5 5".
     * Example:
     * <code>
     *  <a:vbox edge="10 10 40 10" />
     * </code>
     * @attribute {String} pack       
     * @attribute {String} lean       
     */
    this.$supportedProperties.push("padding", "margin", "flex", "pack", "stretch");
    this.$booleanProperties["stretch"] = true;
    
    this.$propHandlers["padding"]    =
    this.$propHandlers["edge"]       = 
    this.$propHandlers["pack"]       = 
    this.$propHandlers["stretch"]    = function(value){
        if (!this.$update && apf.loaded)
            l.queue(this.$ext, this.$updateObj);
        this.$update = true;
    };
    
    function visibleHandler(){
        var p = this.parentNode;
        if (!p.$update && apf.loaded)
            l.queue(p.$ext, p.$updateObj);
        p.$update = true;
    }
    
    //@todo move this to enableTable, disableTable
    this.register = function(amlNode){
        amlNode.$propHandlers["left"]   = 
        amlNode.$propHandlers["top"]    = 
        amlNode.$propHandlers["right"]  = 
        amlNode.$propHandlers["bottom"] = apf.K;
        
        amlNode.$propHandlers["align"]      = 
        amlNode.$propHandlers["flex"]       = 
        amlNode.$propHandlers["width"]      = 
        amlNode.$propHandlers["height"]     = 
        amlNode.$propHandlers["margin"]     = this.$updateObj.updateTrigger;
        
        amlNode.addEventListener("prop.visible", visibleHandler);

        l.queue(this.$ext, this.$updateObj);
        this.$update = true;
    }
    
    this.unregister = function(amlNode){
        amlNode.$propHandlers["left"]       = 
        amlNode.$propHandlers["top"]        = 
        amlNode.$propHandlers["right"]      = 
        amlNode.$propHandlers["bottom"]     =
        amlNode.$propHandlers["align"]      = 
        amlNode.$propHandlers["flex"]       = 
        amlNode.$propHandlers["width"]      = 
        amlNode.$propHandlers["height"]     = 
        amlNode.$propHandlers["margin"]     = null;
        
        amlNode.removeEventListener("prop.visible", visibleHandler);
        
        amlNode.$altExt = null;
        
        l.queue(this.$ext, this.$updateObj);
        this.$update = true;
    }
    /*
         this.addEventListener("DOMNodeInsertedIntoDocument", function(e){
        this.register(this.parentNode);
    });
    */
    
    /**** DOM Hooks ****/
    
    this.addEventListener("DOMNodeRemoved", function(e){
        if (this.$isWaitingOnDisplay || !this.$updateObj || e.$doOnlyAdmin)
            return;

        if (e.currentTarget == this) {
            var p = this;
            while (p) {
                p.unwatch("visible", this.$updateObj.propChange);
                p = p.parentNode;
            }
        }
        else if (e.relatedNode == this){
            this.unregister(e.currentTarget);
            
            //Clear css properties and set layout
            if (e.currentTarget.nodeFunc == apf.NODE_VISIBLE) {
                //e.currentTarget.$setLayout();
                e.currentTarget.$ext.style.display = e.currentTarget.visible ? "block" : "none";
                e.currentTarget.$ext.style.verticalAlign = "";
                e.currentTarget.$ext.style[CSSFLOAT] = "";
            }
        }
    });

    this.addEventListener("DOMNodeInserted", function(e){
        if (this.$isWaitingOnDisplay || e.currentTarget.nodeType != 1) // || e.currentTarget != this
            return;

        if (e.currentTarget == this) {
            var p = this;
            while (p) {
                p.watch("visible", this.$updateObj.propChange);
                p = p.parentNode;
            }
        }
        else if (e.relatedNode == this) {
            if (e.$isMoveWithinParent) {
                l.queue(this.$ext, this.$updateObj);
                this.$update = true;
            }
            else {
                e.currentTarget.$setLayout(this.localName);
            }
        }
    });
    
    /**
     * @macro
     */
    function setPercentage(expr, value){
        return typeof expr == "string" 
            ? expr.replace(apf.percentageMatch, "((" + value + " * $1)/100)")
            : expr;
    }
    
    this.addEventListener("prop.height", function(e){
        if (!this.$update) {
            this.$update = true;
            l.queue(this.$ext, this.$updateObj);
        }
    });
    
    this.addEventListener("prop.width", function(e){
        if (!this.$update) {
            this.$update = true;
            l.queue(this.$ext, this.$updateObj);
        }
    });
    
    //@todo this component requires a rewrite to be like table (again...)
    this.$isWaitingOnDisplay = false;
    this.$updateBox = function(){ //@todo prevent this from being called so much
        if (!this.$update)
            return;

        //@todo this cleanup should also be there when moving nodes away
        if (this.$lastRules.length) {
            for (var i = 0, il = this.$lastRules.length; i < il; i++) {
                l.removeRule(this.$lastRules[i][0], this.$lastRules[i][1]);
                l.queue(this.$lastRules[i][0]);
            }
            this.$lastRules = [];
        }

        //@todo when not visible make all property settings rule based
        //@todo isnt there a better way for doing this? (faster)
        
        if (!this.$ext.offsetWidth) {
            this.$isWaitingOnDisplay = true;
            this.watch("visible", this.$updateObj.propChange);
            
            var p = this.parentNode;
            while(p) {
                p.watch("visible", this.$updateObj.propChange);
                p = p.parentNode;
            }
            
            return;
        }
        
        
        this.padding = parseInt(this.padding);
        
        var id;
        var pWidth  = "pWidth",
            pHeight = "pHeight",
            edge    = apf.getBox(String(this.edge)),
            amlNodes  = this.childNodes,
            paddAdj = {total: 0, count: [], html: []},
            heightAdj = [],
            oExt, diff, j, m, s, cellInfo, span, amlNode, htmlLookup;

        this.ids = [this.$ext];
        
        var length = amlNodes.length, vbox = this.localName == "vbox", hbox = !vbox;
        
        this.$hasPerc    = false;
        this.$totalPerc  = 0;
        this.$totalFixed = (vbox ? edge[2] : edge[1]) + ((length - 1) * this.padding);
        
        var hasWidth = this.$ext.style.width;
        var hasHeight = this.$ext.style.height;
        var hasDefinedHeight = this.height || this.top && this.bottom || this.anchors;

        var minSizeX = 0;
        var size = vbox ? "height" : "width";
        var offset = vbox ? "offsetHeight" : "offsetWidth";
        for (var nodes = [], i = 0, il = amlNodes.length; i < il; i++) {
            amlNode = amlNodes[i];
            if (amlNode.nodeType != 1 && amlNode.nodeType != 7 
              || amlNode.nodeFunc == apf.NODE_HIDDEN || amlNode.visible === false) {
                /*if (amlNode.localName == "collection") {
                    amlNodes = amlNodes.slice(0);
                    for (var z = 0, zl = amlNode.childNodes.length; z < zl; z++)
                        amlNodes.insertIndex(amlNode.childNodes[z], i);
                }*/
                
                continue;
            }
            
            m = apf.getBox(String(amlNode.margin));

            diff = apf.getDiff(oExt = amlNode.$ext);

            span = amlNode.span;
            cellInfo = {
                m       : m,
                weight  : parseInt(amlNode.weight) || 1,
                align   : amlNode.align,
                width   : amlNode.width,
                height  : amlNode.height,
                minwidth  : amlNode.minwidth || 0,
                minheight : amlNode.minheight || 0,
                oHtml   : oExt
            }
            cellInfo.isPerc = String(cellInfo[size]).indexOf("%") > -1;

            
            if (cellInfo.width && !String(cellInfo.width).match(/^\d+%?$/)) {
                throw new Error ("Invalid width specified:" + cellInfo.width); //@todo turn into decent apf error
            }
            if (cellInfo.height && !String(cellInfo.height).match(/^\d+%?$/)) {
                throw new Error ("Invalid height specified:" + cellInfo.height); //@todo turn into decent apf error
            }
            

            nodes.push(cellInfo);

            //set display method
            oExt.style.display = hbox ? "inline-block" : "block"; //@todo optimize by moving this to dominsert - or in css rule push
            if (hbox)
                oExt.style.verticalAlign = "top";//@todo optimize by moving this to dominsert - or in css rule push

            //Set size
            var first = false;
            if (!hasHeight && !hasDefinedHeight && cellInfo.isPerc) {
                delete cellInfo[size];
                cellInfo.isPerc = false;
            }

            if (cellInfo.isPerc) {
                this.$createInt();
                
                //@todo only do this when element has diff...
                if (!amlNode.$altExt) {
                    amlNode.$altExt = this.$int.insertBefore(document.createElement("div"), oExt);
                    amlNode.$altExt.appendChild(oExt);
                    amlNode.$altExt.style.position = "relative";
                    if (hbox) {
                        amlNode.$altExt.style.display = "inline-block";
                        amlNode.$altExt.style.verticalAlign = "top";//@todo optimize by moving this to dominsert - or in css rule push
                    }
                    first = true;
                }

                if ((amlNode.width || vbox && (this.stretch || !oExt.style.width)) 
                  && (amlNode.height || hbox && this.stretch)) {
                    oExt.style.position  = "absolute";
                    oExt.style.left   = 0;
                    oExt.style.top    = 0;
                    oExt.style.right  = 0;
                    oExt.style.bottom = 0;
                    oExt.style.height = "";
                    oExt.style.width = "";
                }
                else {
                    oExt.style.position = "relative";
                    oExt.style.display = "block";
                    oExt.style.width = "auto";
                }
                oExt.style.margin = "";
                
                oExt = cellInfo.oHtml = amlNode.$altExt;
                amlNode.$altExt.style[size] = cellInfo[size];
                this.$hasPerc = true;
                this.$totalPerc++;
                
                //Fix for IE bug not firing onresize after reparenting
                if (first && apf.isIE)
                    apf.layout.forceResize(amlNode.$ext);
                
                if (hbox)
                    oExt.style[CSSFLOAT] = "";
            }
            else {
                if (amlNode.$altExt) {
                    if (amlNode.$altExt.parentNode == this.$int)
                        this.$int.insertBefore(oExt, amlNode.$altExt);
                    amlNode.$altExt.parentNode.removeChild(amlNode.$altExt);
                    amlNode.$altExt = null;
                    first = true;
                    
                    oExt.style.position = "";
                    oExt.style.display = "";
                }
                
                if (cellInfo[size] || cellInfo[size] === 0) {
                    
                    if (parseInt(cellInfo[size]) == NaN) {
                        apf.console.warn("Invalid " + size + " specific. Only \
                            numbers or percentage is allowed:" + cellInfo[size]);
                        cellInfo[size] = null;
                    }
                    else
                    
                    {
                        this.$totalFixed += parseInt(cellInfo[size]);
                    }

                    oExt.style[size] = Math.max(0, cellInfo[size] - diff[vbox ? 1 : 0]) + "px";
                }
                else {
                    oExt.style[size] = "";
                    this.$totalFixed += oExt[offset];

                    if (!oExt.getAttribute("id"))
                        htmlLookup = "document.getElementById('" + apf.setUniqueHtmlId(oExt) + "')";
                    else
                        htmlLookup = "document.getElementById('" + oExt.getAttribute("id") + "')";
                    
                    paddAdj.html.push(oExt);
                    paddAdj.count.push(htmlLookup + "." + offset);
                    paddAdj.total += oExt[offset];
                }
                
                oExt.style.position = "relative";
                
                //Fix for IE bug not firing onresize after reparenting
                if (first && apf.isIE)
                    apf.layout.forceResize(amlNode.$ext);
                
                if (hbox) {
                    oExt.style[CSSFLOAT] = cellInfo.align && cellInfo.align != this.pack
                        ? (cellInfo.align == "start" ? "left" : "right")
                        : "";
                }
            }
            
            //set width
            if (vbox) {
                if ((cellInfo.width || cellInfo.width === 0) && String(cellInfo.width).indexOf("%") == -1) {
                    minSizeX = Math.max(minSizeX, cellInfo.width);
                    oExt.style.width = (cellInfo.width - diff[0]) + "px";
                }
                else if (this.stretch) {//this.width && 
                    minSizeX = Math.max(minSizeX, cellInfo.minwidth || 5);
                    oExt.style.width = "auto";
                }
                else { 
                    oExt.style.width = "";
                    minSizeX = Math.max(minSizeX, cellInfo.minwidth);
                }
                minSizeX += m[1] + m[3];
            }
            //set height
            else if (hbox) {
                if ((cellInfo.height || cellInfo.height === 0) && String(cellInfo.height).indexOf("%") == -1) {
                    minSizeX = Math.max(minSizeX, cellInfo.height);
                    oExt.style.height = (cellInfo.height - diff[1]) + "px";
                }
                else if (hasDefinedHeight && this.stretch) {
                    minSizeX = Math.max(minSizeX, cellInfo.minheight || 5);
                    heightAdj.push([oExt, diff[1], cellInfo.m]);
                }
                else {
                    oExt.style.height = "";
                    minSizeX = Math.max(minSizeX, cellInfo.minheight);
                }
                minSizeX += m[0] + m[2];
            }
            
            this.$totalFixed += (vbox ? m[0] + m[2] : m[1] + m[3]);
            
            //calc minwidth / minheight here?
        }
        
        if (nodes.length == 0) {
            this.$update = false;
            return;
        }

        var last, m, next;
        for (i = 0, il = nodes.length; i < il; i++) {
            cellInfo = nodes[i];
            
            //Set margin (m and padding)
            m = cellInfo.m;
            next = nodes[i+1] && nodes[i+1].m;
            cellInfo.oHtml.style.margin = vbox 
                ? (m[0] + (last && last[2] || 0)) + "px " +
                   m[1] + "px " +
                  (m[2] + (next && next[0] || 0) + (i < il - 1 ? this.padding : 0)) + "px " +
                   m[3] + "px"
                :  m[0] + "px " +
                  (m[1] + (next && next[3] || 0) + (i < il - 1 ? this.padding : 0)) + "px " +
                   m[2] + "px " +
                  (m[3] + (last && last[1] || 0)) + "px"

            last = cellInfo.m;
        }

        var oldP = apf.getBox(this.$ext.style.padding);//apf.getStyle(this.$ext, "padding"));
        if (this.$hasPerc)
            this.$ext.style.padding = vbox 
                ? edge[0] + "px " + edge[1] + "px " + this.$totalFixed + "px " + edge[3] + "px"
                : edge[0] + "px " + this.$totalFixed + "px " + edge[2] + "px " + edge[3] + "px";
        else
            this.$ext.style.padding = edge.join("px ") + "px";

        if (paddAdj.count) {
            var me = "apf.all[" + this.$uniqueId + "]";
            paddAdj.count = paddAdj.count.join(" + ");
            for (var i = 0; i < paddAdj.html.length; i++) {
                //@todo add rule to layoutServer to adjust padding-bottom of this.$int
                html = paddAdj.html[i];
                if (this.$hasPerc) {
                    //@todo if hasDefinedHeight set height
                    l.setRules(html, "boxp", me + ".$ext.style.padding" 
                        + (vbox ? "Bottom" : "Right") + " = (" 
                        + (this.$totalFixed - paddAdj.total) 
                        + " + " + paddAdj.count + ") + 'px';", true);
                }
                else {
                    //@todo buggy...
                    l.setRules(html, "boxp", me + ".$ext.style.min" 
                        + (vbox ? "Height" : "Width") + " = -" 
                        + (vbox ? edge[2] : edge[1]) + " + (" + me 
                        + "['min" + size + "'] = " 
                        + (this.$totalFixed - paddAdj.total) 
                        + " + " + paddAdj.count + ") + 'px';", true);
                }
                l.queue(html);
                this.$lastRules.push([html, "boxp"]);
            }
            
            this.$totalFixed += vbox ? edge[0] : edge[3];
        }

        var newP = apf.getBox(this.$ext.style.padding);//apf.getStyle(this.$ext, "padding"));

        var width  = parseInt(apf.getStyle(this.$ext, "width"));
        var height = parseInt(apf.getStyle(this.$ext, "height"));

        //Set fixed height if a percentage is involved
        /*if (vbox && this.$hasPerc && !hasHeight) {
            hasHeight = true;
            height = this.$ext.offsetHeight;
        }*/

        if (hasWidth && (width || width === 0)) {
            if (this.width)
                this.$propHandlers["width"].call(this, this.width);
            else if (this.left && this.right)
                this.$propHandlers["right"].call(this, this.right);
            else
                this.$ext.style.width = Math.max(0, width + oldP[1] - newP[1] + oldP[3] - newP[3]) + "px";
        }

        if (hasHeight && (height || height === 0)) {
            if (this.height)
                this.$propHandlers["height"].call(this, this.height);
            else if (this.top && this.bottom)
                this.$propHandlers["bottom"].call(this, this.bottom);
            else {
                this.$ext.style.height = Math.max(0, height + oldP[0] - newP[0] + oldP[2] - newP[2]) + "px";
            }
        }

        if (hasDefinedHeight && heightAdj.length) {
            var rules = ["var height = apf.all[" + this.$uniqueId + "].$ext.offsetHeight"];
            for (i = 0; i < heightAdj.length; i++) {
                html = heightAdj[i][0];
                //@todo add rule to layoutServer to adjust height
                if (!html.getAttribute("id"))
                    htmlLookup = "document.getElementById('" + apf.setUniqueHtmlId(html) + "')";
                else
                    htmlLookup = "document.getElementById('" + html.getAttribute("id") + "')";
                
                rules.push(htmlLookup + ".style.height = (height - " 
                    + "apf.getHeightDiff(" + htmlLookup + ")" + " - " +
                    + (edge[0] + edge[2] + heightAdj[i][2][0] + heightAdj[i][2][2]) + ") + 'px'"); //borders???
            }

            l.setRules(this.$ext, "boxh", (rules.length 
                ? "try{" + rules.join(";}catch(e){};\ntry{") + ";}catch(e){};" 
                : ""), true);
            l.queue(this.$ext);
            this.$lastRules.push([this.$ext, "boxh"]);
        }
        
        if (hbox) {
            this.$int.style.textAlign = this.$hasPerc || !this.pack || this.pack == "start" 
                ? "left"
                : (this.pack == "middle"
                    ? "center"
                    : "right");
        }
        else if (this.pack || this.$ext != this.$int) {
            this.$createInt();
            if (this.$hasPerc || !this.pack || this.pack == "start") {
                this.$int.style.position = "static";
                if (vbox)
                    this.$int.style.height = "100%";
                this.$int.style.top = "";
                this.$int.style.marginTop = "";
            }
            else if (this.pack == "middle") {
                this.$int.style.position = "relative";
                this.$int.style.top = "50%";
                this.$int.style.height = "auto";
                this.$int.style.marginTop = "-" + (this.$int.offsetHeight/2) + "px";  //@todo add layout rule
            }
            else if (this.pack == "end") {
                this.$int.style.position = "relative";
                this.$int.style.top = "100%";
                this.$int.style.height = "auto";
                this.$int.style.marginTop = "-" + this.$int.offsetHeight + "px"; //@todo add layout rule
            }
        }

        //@todo what is this 3 ???
        this["min" + size] = this.$totalFixed + (vbox ? edge[0] : edge[3]) - 3 + (this.$totalPerc * 5); //@todo it's an illusion that percentage items smallest size is 5 (think their own min* and content)
        this.$ext.style["min" + size.uCaseFirst()] = ((this.$hasPerc
          ? (this.$totalPerc * 5) //@todo it's an illusion that percentage items smallest size is 5 (think their own min* and content)
          : this.$totalFixed - (vbox ? edge[2] : edge[1]) - 3)
            
            ) + "px";
        
        this["min" + (vbox ? "width" : "height")] = minSizeX + (vbox ? edge[1] + edge[3] : edge[0] + edge[2]);
        this.$ext.style["min" + (vbox ? "Width" : "Height")] = (minSizeX 
            
            ) + "px";

        this.$update = false;
    };
    
    this.$createInt = function(){
        if (this.$ext == this.$int) { //is this slow?
            this.$int = this.$ext.appendChild(document.createElement("div"));
            this.$int.style.whiteSpace = "nowrap";
            this.$int.className = "int";
            var cnodes = this.$ext.childNodes;
            for (var j = cnodes.length - 2; j >= 0; j--) {
                this.$int.insertBefore(cnodes[j], this.$int.firstChild);
            }
            
            if (this.localName == "vbox")
                this.$int.style.height = "100%";
        }
    }
    
    this.$draw = function(){
        var _self = this;
        this.$updateObj = {
            $updateLayout : function(){
                _self.$updateBox();
            },
            updateTrigger : function(value){
                //@todo this is called up the tree when nesting elements. Should be fixed when optimizing.
                if (!_self.$update && _self.$amlLoaded)
                    l.queue(_self.$ext, _self.$updateObj);
                _self.$update = true;
            },
            
            propChange : function (name, old, value){
                if (_self.$update && apf.isTrue(value) && _self.$ext.offsetWidth) {
                    _self.$updateBox();
                    l.activateRules(_self.$ext);
                    
                    var p = _self;
                    while (p) {
                        p.unwatch("visible", _self.$updateObj.propChange);
                        p = p.parentNode;
                    }
                    
                    _self.$isWaitingOnDisplay = false;
                }
            }
            
        }
        
        this.$ext = this.$pHtmlNode.appendChild(document.createElement("div"));
        this.$ext.className = this.localName + " " + (this.getAttribute("class") || "");
        this.$ext.style.whiteSpace = "nowrap";
        this.$ext.style.overflow   = "hidden";
        this.$int = this.$ext;
        this.$ext.host = this;

        this.$ext.style.position  = "relative";
        this.$ext.style.minHeight = "10px";
        
        if (!apf.vbox.$initedcss) {
            apf.importCssString(".vbox>*{white-space:normal;} .hbox>*{white-space:normal;} .vbox>.int>*{white-space:normal;} .hbox>.int>*{white-space:normal;}");
            apf.vbox.$initedcss = true;
        }
        
        l.queue(this.$ext, this.$updateObj);
        this.$update = true;
    };
    
    this.$loadAml = function(x){
        if (!this.width && (apf.getStyle(this.$ext, "position") == "absolute"
          || this.left || this.top || this.right || this.bottom || this.anchors))
            this.$ext.style.width  = "100%"
    };
}).call(apf.vbox.prototype = new apf.GuiElement());

apf.hbox.prototype = apf.vbox.prototype;

apf.aml.setElement("hbox", apf.hbox);
apf.aml.setElement("vbox", apf.vbox);



/*FILEHEAD(/var/lib/platform/source/trunk/elements/browser.js)SIZE(6301)TIME(1270838607)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/elements/accordion.js)SIZE(22288)TIME(1262085721)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/*FILEHEAD(/var/lib/platform/source/trunk/elements/event.js)SIZE(2115)TIME(1265032029)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * Displays a popup element with a message with optionally an icon at the
 * position specified by the position attribute. After the timeout has passed
 * the popup will dissapear automatically. When the mouse hovers over the popup
 * it doesn't dissapear.
 *
 * @event click Fires when the user clicks on the representation of this event.
 */
apf.event = function(struct, tagName){
    this.$init(tagName || "event", apf.NODE_HIDDEN, struct);
};

(function() {
    this.$hasInitedWhen = false;

    this.$booleanProperties["repeat"] = true;
    this.$supportedProperties.push("when", "message", "icon", "repeat");

    this.$propHandlers["when"] = function(value) {
        if (this.$hasInitedWhen && value && this.parentNode && this.parentNode.popup) {
            var _self = this;
            $setTimeout(function() {
                _self.parentNode.popup(_self.message, _self.icon, _self);
            });
        }
        this.$hasInitedWhen = true;

        if (this.repeat)
            delete this.when;
    };

    this.$loadAml = function(x) {};
}).call(apf.event.prototype = new apf.AmlElement());

apf.aml.setElement("event", apf.event);


/*FILEHEAD(/var/lib/platform/source/trunk/elements/source.js)SIZE(1592)TIME(1257329184)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/elements/flashplayer.js)SIZE(4101)TIME(1269561674)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/*FILEHEAD(/var/lib/platform/source/trunk/elements/bindingseriesrule.js)SIZE(1944)TIME(1257329183)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * @attribute {String} formula 
 * @attribute {Number} length
 * @attribute {String} delimiter
 * @attribute {String} split
 * @attribute {String} css
 */
apf.BindingSeriesRule = function(struct, tagName){
    this.$init(tagName || "series", apf.NODE_HIDDEN, struct);
};

(function(){
    //1 = force no bind rule, 2 = force bind rule
    this.$attrExcludePropBind = apf.extend({
        formula : 1
    }, this.$attrExcludePropBind);

    this.$propHandlers["formula"] = function(value, prop){
        delete this["c" + prop];
    }
    
    /*this.addEventListener("DOMNodeInsertedIntoDocument", function(e){
        //Find parent that this rule works on
        var pNode = this;
        while (pNode && pNode.$bindingRule) 
            pNode = pNode.parentNode;
       
        if (!pNode)
            return;
    });*/
}).call(apf.BindingSeriesRule.prototype = new apf.BindingRule());

apf.aml.setElement("series", apf.BindingSeriesRule);




/*FILEHEAD(/var/lib/platform/source/trunk/elements/defaults.js)SIZE(1798)TIME(1269561674)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/elements/iconmap.js)SIZE(3244)TIME(1269561674)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * element that provides a means to get icons from a
 * single image containing many icons.
 * Example:
 * <code>
 *  <a:iconmap 
 *    id     = "tbicons" 
 *    src    = "toolbar.icons.gif"
 *    type   = "horizontal" 
 *    size   = "20" 
 *    offset = "2,2" />
 *  <a:menu id="menu1">
 *      <a:item icon="tbicons:1">Tutorials</a:item>
 *      <a:item icon="tbicons:5">Contact</a:item>
 *  </a:menu>
 *  <a:toolbar>
 *      <a:menubar>
 *          <a:button submenu="menu1">File</a:button>
 *      </a:menubar>
 *  </a:toolbar>
 * </code>
 * @attribute {String} src    the location of the image.
 * @attribute {String} type   the spatial distribution of the icons within the image.
 *   Possible values:
 *   horizontal the icons are horizontally tiled.
 *   vertically the icons are vertically tiled.
 * @attribute {String} size   the width and height in pixels of an icon. Use this for square icons.
 * @attribute {String} width  the width of an icon in pixels.
 * @attribute {String} height the height of an icon in pixels.
 * @attribute {String} offset the distance from the calculated grid point that has to be added. This value consists of two numbers seperated by a comma. Defaults to 0,0.
 * @addnode elements
 *
 * @author      Ruben Daniels (ruben AT ajax DOT org)
 * @version     %I%, %G%
 * @since       0.4
 */
apf.iconmap = function(){
    this.$init("iconmap", apf.NODE_HIDDEN);
};

(function(){
    this.$parsePrio = "050";
    
    this.addEventListener("DOMNodeInsertedIntoDocument", function(e){
        
        if (!this.id) {
            throw new Error(apf.formatErrorString(0, this,
                "Creating icon map",
                "Could not create iconmap. Missing id attribute", this.$aml));
        }
        

        apf.skins.addIconMap({
            name   : this.id,
            src    : this.src,
            type   : this.type,
            size   : parseInt(this.size),
            width  : parseInt(this.width),
            height : parseInt(this.height),
            offset : (this.offset || "0,0").splitSafe(",")
        });
    });
}).call(apf.iconmap.prototype = new apf.AmlElement());

apf.aml.setElement("iconmap", apf.iconmap);




/*FILEHEAD(/var/lib/platform/source/trunk/elements/progressbar.js)SIZE(8743)TIME(1269561674)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/elements/collection.js)SIZE(2383)TIME(1270640787)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/*FILEHEAD(/var/lib/platform/source/trunk/elements/chart.js)SIZE(9720)TIME(1268956869)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/*FILEHEAD(/var/lib/platform/source/trunk/elements/bindingcolumnrule.js)SIZE(19900)TIME(1270838607)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * @attribute {String}  icon
 * @attribute {String}  caption
 * @attribute {String}  width
 * @attribute {String}  options
 * @attribute {String}  editor
 * @attribute {String}  colspan
 * @attribute {String}  align
 * @attribute {String}  css
 * @attribute {Boolean} tree
 */
apf.BindingColumnRule = function(struct, tagName){
    this.$init(tagName, apf.NODE_HIDDEN, struct);
    
    this.$className = "col" + this.$uniqueId;
};

(function(){
    this.$defaultwidth = "100";
    this.$width        = 100;
    
    this.$sortable  = true; //@todo set defaults based on localName of element to which its applied
    this.$resizable = true;
    this.$movable   = true;
    this.$cssInit   = false;
    
    //1 = force no bind rule, 2 = force bind rule
    this.$attrExcludePropBind = apf.extend({
        css     : 1,
        icon    : 1,
        caption : 1
    }, this.$attrExcludePropBind);
    
    this.$supportedProperties.push("tree", "icon", "caption", "width", "options", 
        "editor", "colspan", "align", "css");
    
    this.$booleanProperties["tree"] = true;
    
    this.$propHandlers["icon"]  = function(value, prop){
        
    }
    
    this.$propHandlers["caption"]  = function(value, prop){
        
    }
    
    this.$propHandlers["width"]  = function(value, prop){
        if (!value)
            value = this.$defaultwidth;

        this.$isPercentage = value && String(value).indexOf("%") > -1;
        this.$width = parseFloat(value);
    }
    
    this.$propHandlers["options"]  = function(value, prop){
        this.$sortable  = value.indexOf("sort") > -1;
        this.$resizable = value.indexOf("size") > -1;
        this.$movable   = value.indexOf("move") > -1;
    }
    
    this.$propHandlers["editor"]  = function(value, prop){
        
    }
    
    this.$propHandlers["colspan"]  = function(value, prop){
        
    }
    
    this.$propHandlers["align"]  = function(value, prop){
        
    }
    
    this.$propHandlers["css"]  = function(value, prop){
        
    }
    
    this.resize = function(newsize, pNode){
        var hN;
        if (this.$isPercentage) {
            var oldsize = (this.$ext.offsetWidth - (pNode.$widthdiff - 3)),
                ratio = newsize / oldsize, //div 0 ??
                next  = [],
                fixed = [],
                total = 0,
                node  = this.$ext.nextSibling;
            
            while (node && node.getAttribute("hid")) {
                hN = apf.all[node.getAttribute("hid")];
                if (hN.$isPercentage) {
                    next.push(hN);
                    total += hN.$width;
                }
                else fixed.push(hN);
                node = node.nextSibling;
            }
            
            if (fixed.length && !next.length)
                return fixed[0].resize(fixed[0].$width + (oldsize - newsize), pNode);
            
            var newPerc  = ratio * this.$width,
                diffPerc = newPerc - this.$width,
                diffRatio = (total - diffPerc) / total;
            if (diffRatio < 0.01) {
                if (newsize < 20) return;
                return this.resize(newsize - 10, pNode);//pNode.resizeColumn(nr, newsize - 10);
            }
            
            for (var n, i = 0; i < next.length; i++) {
                n = next[i];
                n.$width *= diffRatio;
                apf.setStyleRule("." + n.$className, "width", n.$width + "%"); //Set
                //apf.setStyleRule("." + pNode.$baseCSSname + " .records ."
                    //+ n.$className, "width", n.$width + "%", null, pNode.oWin); //Set
            }
            
            this.$width = newPerc;
            apf.setStyleRule("." + this.$className, "width", this.$width + "%"); //Set
            //apf.setStyleRule("." + pNode.$baseCSSname + " .records ."
                //+ h.$className, "width", this.$width + "%", null, pNode.oWin); //Set
        }
        else {
            var diff = newsize - this.$width;
            this.$width = newsize;
            if (apf.isIE && pNode.oIframe) {
                this.$ext.style.width = newsize + "px";
            }
            else {
                //apf.setStyleRule("." + this.$className, "width", newsize + "px"); //Set
            }
            apf.setStyleRule("." + this.$className, "width", newsize + "px", null, pNode.oWin); //Set

            pNode.$fixed += diff;
            var vLeft = (pNode.$fixed) + "px";

            if (!this.$isFixedGrid) {
                //apf.setStyleRule("." + this.$baseCSSname + " .headings ." + hFirst.$className, "marginLeft", "-" + vLeft); //Set
                //apf.setStyleRule("." + this.$baseCSSname + " .records ." + hFirst.$className, "marginLeft", "-" + vLeft); //Set
                apf.setStyleRule("." + pNode.$baseCSSname + " .row" + pNode.$uniqueId,
                    "paddingRight", vLeft, null, this.oWin); //Set
                apf.setStyleRule("." + pNode.$baseCSSname + " .row" + pNode.$uniqueId,
                    "marginRight", "-" + vLeft, null, pNode.oWin); //Set
            
                //headings and records have same padding-right
                pNode.$container.style.paddingRight  =
                pNode.$head.style.paddingRight = vLeft;
            }
        }
    }
    
    this.hide = function(){
        apf.setStyleRule("." + this.$baseCSSname + " .records ." + h.$className,
            "visibility", "hidden", null, this.oWin);
        
        //Change percentages here
    }
    
    this.show = function(){
        apf.setStyleRule("." + this.$baseCSSname + " .records ." + h.$className,
            "visibility", "visible", null, this.oWin);
        
        //Change percentages here
    }
    
    /**
     * Sorts a column.
     * @param {Number} hid the heading number; this number is based on the sequence of the column elements.
     */
    this.sort = function(pNode){
        if (pNode.$lastSorted == this) {
            apf.setStyleClass(this.$int,
                pNode.toggleSortOrder()
                    ? "ascending"
                    : "descending", ["descending", "ascending"]);
            return;
        }

        var h;
        if (h = pNode.$lastSorted) {
            apf.setStyleRule("." + h.$className, "background", "white"); //This breaks row coloring
            apf.setStyleClass(h.$int, "", ["descending", "ascending"]);
        }
        
        apf.setStyleRule("." + this.$className, "background", "#f3f3f3");
        apf.setStyleClass(this.$int, "ascending", ["descending", "ascending"]);
        
        if (!pNode.length)
            return;
        
        pNode.resort({
            order : "ascending",
            xpath : this.cvalue2.xpaths[1]
            //type : 
        });
        
        pNode.$lastSorted = this;
    };
    
    /**
     * Moves a column to another position.
     * @param {Number} fromHid the heading number of the column to move; this number is based on the sequence of the column elements.
     * @param {Number} toHid   the position the column is moved to;
     */
    this.move = function(hTo, pNode){
        if (hTo && this == hTo) 
            return;
        
        var hFrom       = this,
            childNrFrom = apf.getChildNumber(hFrom.$int),
            childNrTo   = hTo && apf.getChildNumber(hTo.$int);

        pNode.$head.insertBefore(hFrom.$int, hTo && hTo.$int || null);

        if (!pNode.length)
            return;

        (function _recur(nodes){
            for (var node, i = 0; i < nodes.length; i++) {
                //if (pNode.$withContainer && ((i+1) % 2) == 0)
                    //continue;
    
                node = nodes[i];
                if (pNode.$isTreeArch && node.tagName == "BLOCKQUOTE") { //@todo small hack
                    _recur(node.childNodes);
                }
                else {
                    node.insertBefore(node.childNodes[childNrFrom], 
                    typeof childNrTo != "undefined" && node.childNodes[childNrTo] || null);
                }
            }
        })(pNode.$container.childNodes);
        
        /*if (this.$first == from || this.$first == to) {
            var hReset = this.$first == from ? hFrom : hTo;
            
            apf.setStyleRule("." + this.$baseCSSname + " .headings ."
                + hReset.className, "marginLeft", "-5px"); //Reset
            apf.setStyleRule("." + this.$baseCSSname + " .records ."
                + hReset.className, "marginLeft", "-5px"); //Reset
            
            this.$first = pNode.$head.firstChild.getAttribute("hid");
            var h = headings[this.$first];
            var vLeft = "-" + (this.$fixed + 5) + "px";

            apf.setStyleRule("." + this.$baseCSSname + " .headings ."
                + h.className, "marginLeft", vLeft); //Set
            apf.setStyleRule("." + this.$baseCSSname + " .records ."
                + h.className, "marginLeft", vLeft); //Set
        }*/
    }
    
    this.$draw = function(pNode, caption, width, className){
        //Find the parent this rule works on
        var pNode = pNode || this.parentNode;
        while (pNode.$bindingRule)
            pNode = pNode.parentNode;
        
        if (!pNode.hasFeature(apf.__PRESENTATION__))
            return;
            
        if (width) 
            this.$propHandlers["width"].call(this, width);

        //"." + this.$baseCSSname + " .headings 
        //if initial
        //only needs once if this works
        apf.importStylesheet([
          ["." + this.$className,
            "width:" + this.$width + (this.$isPercentage ? "%;" : "px;")
            + "text-align:" + this.align]
        ]);
        
        //Add to htmlRoot
        pNode.$getNewContext("headitem");
        var $head = pNode.$getLayoutNode("headitem");
        $head.setAttribute("class", this.$className + (className ? " " + className : ""));
        $head.setAttribute("hid", this.$uniqueId);
        
        var hCaption = pNode.$getLayoutNode("headitem", "caption");
        /*if (this.icon) {
            this.$sortable = false;
            $head.setAttribute("style", "background-image:url("
                + apf.getAbsolutePath(pNode.iconPath, this.icon) 
                + ")");
            hCaption.nodeValue = "&nbsp;";
        }
        else*/
            hCaption.nodeValue = this.caption || caption || "";
        
        this.$ext = this.$int = apf.insertHtmlNode($head, pNode.$head || pNode.$container);
        
        var dragging = false;
        var _self    = this;
        
        this.$int.onmouseover = function(e){
            if (!e) e = event;
            
            if (pNode.disabled) return;

            apf.setStyleClass(this, "hover", ["down"]);
        };
        
        this.$int.onmouseup = function(e){
            if (!e) e = event;
            
            if (pNode.disabled || !apf.isChildOf(dragging, this, true)) 
                return;
            
            apf.setStyleClass(this, "hover", ["down"]);

            if (_self.$sortable)
                _self.sort(pNode);
            
            //@todo pNode or Self?
            pNode.dispatchEvent("sortcolumn", _self);
        };
        
        this.$int.onmousedown = function(e){
            if (!e) e = event;
            dragging = target = this;
            
            if (pNode.disabled) return;

            //Resizing
            var pos   = apf.getAbsolutePosition(target),
                sLeft = pNode.$head.scrollLeft;
            var d     = e.clientX - pos[0] + sLeft;
            if (d < 4 || target.offsetWidth - d - 8 < 3
              && apf.getChildNumber(_self.$int) < pNode.$headings.length - 1) {
                var t = d < 4 && target.previousSibling || target;
                
                if (_self.$resizable) {
                    pos   = apf.getAbsolutePosition(t);
                    apf.setStyleClass(pNode.$pointer, "size_pointer", ["move_pointer"]);
                    pNode.$pointer.style.display = "block";
                    pNode.$pointer.style.left    = (t.offsetLeft - sLeft - 1) + "px";
                    pNode.$pointer.style.width   = (t.offsetWidth - pNode.$widthdiff + 1) + "px";
                    
                    
                    apf.plane.show(pNode.$pointer, null, true);
                    

                    dragging = true;
                    document.onmouseup = function(){
                        if (!e) e = event;
    
                        document.onmouseup = 
                        document.onmousemove = null;
                        
                        apf.all[t.getAttribute("hid")].resize(pNode.$pointer.offsetWidth, pNode);
                        
                        dragging = false;
                        pNode.$pointer.style.display = "none";
                        
                        
                        apf.plane.hide();
                        

                    };
                    
                    document.onmousemove = function(e){
                        if (!e) e = event;

                        pNode.$pointer.style.width = Math.max(10, 
                            Math.min(pNode.$container.offsetWidth - pNode.$pointer.offsetLeft - 20, 
                                e.clientX - pos[0] - 1 + sLeft)) + "px";
                    };
                    
                    return;
                }
            }
            
            apf.setStyleClass(target, "down", ["hover"]);
            
            //Moving
            if (!_self.$movable) {
                document.onmouseup = function(e){
                    document.onmouseup = null;
                    dragging = false;
                };
                
                return;
            }
            
            apf.setStyleClass(pNode.$pointer, "move_pointer", ["size_pointer"]);
            
            var x = e.clientX - target.offsetLeft, sX = e.clientX,
                y = e.clientY - target.offsetTop,  sY = e.clientY,
                copy;
            
            document.onmouseup = function(e){
                if (!e) e = event;
                
                document.onmouseup   =
                document.onmousemove = null;
                
                dragging = false;
                pNode.$pointer.style.display = "none";
                
                if (!copy)
                    return;
                    
                copy.style.top = "-100px";
                
                var el = document.elementFromPoint(e.clientX, e.clientY);
                if (el.parentNode == copy.parentNode) {
                    var pos = apf.getAbsolutePosition(el);
                    var beforeNode = (e.clientX - pos[0] > el.offsetWidth / 2
                        ? el.nextSibling
                        : el);

                    _self.move(beforeNode ? apf.all[beforeNode.getAttribute("hid")] : null, pNode);
                }
                
                apf.destroyHtmlNode(copy);
            };

            document.onmousemove = function(e){
                if (!e) e = event;
                
                if (!copy) {
                    if (Math.abs(e.clientX - sX) < 3 && Math.abs(e.clientY - sY) < 3)
                        return;
                    
                    copy = target.cloneNode(true);
                    copy.style.position = "absolute";
                    var diff = apf.getWidthDiff(target);
                    copy.style.width    = (target.offsetWidth - diff
                        - pNode.$widthdiff + 2) + "px";
                    copy.style.left     = target.offsetLeft;
                    copy.style.top      = target.offsetTop;
                    copy.style.margin   = 0;
                    copy.removeAttribute("hid")
                    
                    apf.setStyleClass(copy, "drag", ["ascending", "descending"]);
                    target.parentNode.appendChild(copy);
                }
                
                copy.style.top               = "-100px";
                pNode.$pointer.style.display = "none";
                
                var el = document.elementFromPoint(e.clientX, e.clientY);
                if (el.parentNode == copy.parentNode) {
                    var pos = apf.getAbsolutePosition(el);
                    pNode.$pointer.style.left = (el.offsetLeft 
                        + ((e.clientX - pos[0] > el.offsetWidth / 2)
                            ? el.offsetWidth - 8
                            : 0)) + "px";
                    pNode.$pointer.style.display = "block";
                }
                
                copy.style.left = (e.clientX - x) + 'px';
                copy.style.top  = (e.clientY - y) + 'px';
            };
        };
        
        this.$int.onmouseout = function(e){
            if (!e) e = event;
            
            if (pNode.disabled) return;
            
            pNode.$ext.style.cursor = "";
            apf.setStyleClass(this, "", ["hover", "down"]);
        };
        
        this.$int.onmousemove = function(e){
            if (dragging || pNode.disabled)
                return;
                
            if (!e) e = event;

            var pos   = apf.getAbsolutePosition(this),
                sLeft = pNode.$head.scrollLeft;
            var d = e.clientX - pos[0] + sLeft;

            if (d < 4 || this.offsetWidth - d - pNode.$widthdiff < 3 
              && apf.getChildNumber(_self.$int) < pNode.$headings.length - 1) {
                var t = d < 4 ? this.previousSibling : this;
                pNode.$ext.style.cursor = t && _self.$resizable
                    ? "w-resize"
                    : "default";
            }
            else {
                pNode.$ext.style.cursor = "default";
            }
        };
        
        return this;
    }
    
    this.addEventListener("DOMNodeInsertedIntoDocument", function(e){
        this.$draw();
    });
    
    this.addEventListener("DOMNodeRemovedFromDocument", function(e){
        if (!this.$int)
            return;
        
        this.$int.onmouseover   =
        this.$int.onmouseup     =
        this.$int.onmousedown   =
        this.$int.onmousemove   =
        this.$int.onmouseout    = null;
    });
    
}).call(apf.BindingColumnRule.prototype = new apf.BindingRule());

apf.aml.setElement("column", apf.BindingColumnRule);




/*FILEHEAD(/var/lib/platform/source/trunk/elements/table.js)SIZE(16686)TIME(1271196962)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


/**
 * Any child element of this element is placed in a table. The size of the 
 * columns and rows of the table can be set by attributes. Child elements can
 * span multiple columns. Using '*' as a size indicator will use the remaining
 * size for that column or row, when the table's size is set.
 * Example:
 * This example shows a window with a table and two buttons that change the 
 * orientation of the table runtime. The textarea and it's label have a span set
 * to '*'. This means they will span the entire width of all columns, no matter
 * how many columns there are.
 * <code>
 *  <a:window visible="true" width="500" height="400">
 *      <a:table id="tableTest" 
 *        columns = "80, *"
 *        edge    = "10 10 10 10"
 *        padding = "5"
 *        bottom  = "35"
 *        top     = "0">
 *          <a:label>Name</a:label>
 *          <a:textbox />
 *          <a:label>Address</a:label>
 *          <a:textarea height="50" />
 *          <a:label>Country</a:label>
 *          <a:dropdown />
 *          
 *          <a:label span="*">Message</a:label>
 *          <a:textarea id="txtMessage" 
 *            height = "*" 
 *            span   = "*" />
 *      </a:table>
 *      
 *      <a:button 
 *        caption = "Two Columns"
 *        bottom  = "10"
 *        left    = "10"
 *        onclick = "tableTest.setAttribute('columns', '80, *');"/>
 *              
 *      <a:button 
 *        bottom  = "10"
 *        left    = "125"
 *        caption = "Four Columns"
 *        onclick = "tableTest.setAttribute('columns', '60, 120, 60, *');"/>
 *  </a:window>
 * </code>
 * Remarks:
 * This is one of three positioning methods.
 * See {@link baseclass.alignment}
 * See {@link baseclass.anchoring}
 *
 * @define table
 * @allowchild {elements}, {anyaml}
 * @addnode elements
 * @constructor
 *
 * @author      Ruben Daniels (ruben AT ajax DOT org)
 * @version     %I%, %G%
 * @since       1.0
 */
apf.table = function(struct, tagName){
    this.$init(tagName || "table", apf.NODE_VISIBLE, struct);
};

(function(){
    /**** Properties and Attributes ****/
    
    this.$focussable = false;
    this.$update     = false;
    
    this.columns    = "150,200";
    this.padding    = 2;
    this.$edge      = [5, 5, 5, 5];
    this.cellheight = 19;
    
    /**
     * @attribute {String} columns      a comma seperated list of column sizes. A column size can be specified in a number (size in pixels) or using a number and a % sign to indicate a percentage. A '*' indicates the column spans the rest space. There can be only one '*' in the column string.
     * Example:
     * <code>
     *  <a:table columns="150, *, 20%" />
     * </code>
     * @attribute {String} padding      the space between each element. Defaults to 2.
     * @attribute {String} edge         the space between the container and the elements, space seperated in pixels for each side. Similar to css in the sequence top right bottom left. Defaults to "5 5 5 5".
     * Example:
     * <code>
     *  <a:table edge="10 10 40 10" />
     * </code>
     */
    this.$supportedProperties.push("columns", "padding", "edge", 
        "cellheight", "span");
    
    this.$propHandlers["columns"] = function(value){
        if (!value.match(/^(\d+\%?\s*(?:,\s*|\s*$))+$/)) {
            
            apf.console.warn("Invalid column string found for table: " + value);
            
            return;
        }
        
        var col, colsize = this.$columns = value.splitSafe(",");

        var total = 0, cols = this.$table.getElementsByTagName("col");
        if (cols.length) {
            for (var sz, i = 0, l = Math.min(cols.length, colsize.length); i < l; i++) {
                cols[i].style.width = (sz = colsize[i]).indexOf("%") > -1 ? sz : sz + "px";
                total += parseInt(sz);
            }
        }
        
        var start = cols.length - colsize.length;
        if (start > 0) {
            for (var i = cols.length - start; i < cols.length; i++) {
                cols[i].parentNode.removeChild(cols[i]);
            }
        }
        else if (start < 0) {
            for (var i = colsize.length + start; i < colsize.length; i++) {
                col = this.$table.appendChild(document.createElement("col"));
                col.style.width = (sz = colsize[i]).indexOf("%") > -1 ? sz : sz + "px";
                col.setAttribute("valign", "top");
                total += parseInt(sz);
            }
        }

        this.$table.style.width = String(value).indexOf("%") > -1 
            ? "auto" 
            : (total + ((colsize.length - 1) * this.padding) 
                + this.$edge[0] + this.$edge[2]) + "px";

        var cells = this.$tbody.firstChild.getElementsByTagName("td");
        for (var i = cells.length - 1; i >= 0; i--)
            cells[i].parentNode.removeChild(cells[i]);
        
        for (var c, i = 0; i < colsize.length; i++) {
            c = this.$tbody.firstChild.appendChild(document.createElement("td"));
            if (colsize[i].indexOf("%") > -1)
                c.appendChild(document.createElement("div")).style.width = "50px";
        }
        
        if (start && this.$amlLoaded)
            visibleHandler({sync: true, parentNode: this});
    }

    this.$propHandlers["padding"] = function(value){
        var cells = this.$table.getElementsByTagName("td");
        var lastCol, lastRow, cell, lRow = this.$tbody.lastChild;
        for (var i = this.$columns.length, l = cells.length; i < l; i++) {
            lastCol = (cell = cells[i]).parentNode.lastChild == cell;
            lastRow = cell.parentNode == lRow;
            cell.style.padding = "0px " + (lastCol ? 0 : value) + "px " + (lastRow ? 0 : value) + "px 0px";
        }
    }
    
    this.$propHandlers["edge"] = function(value){
        this.$table.style.padding = (this.$edge = apf.getBox(value)).join("px ") + "px";
    }
    
    function visibleHandler(e){
        var table = e.parentNode || this.parentNode;
        if (e.sync || e.value && !this.$altExt || !e.value && this.$altExt) {
            var nodes = table.childNodes;
            
            var cells = apf.getArrayFromNodelist(table.$tbody.getElementsByTagName("td"));
            var rows  = table.$tbody.getElementsByTagName("tr");
            var empty = [], row = 1, cs, rs, collen = table.$columns.length;
            var z = table.$columns.length, lastCol, lastRow;
            for (var node, td, last, l = nodes.length, i = 0; i < l; i++) {
                if ((node = nodes[i]).visible === false)
                    continue;

                td = node.$altExt = last = cells[z++];
                
                if (!rows[row])
                    table.$tbody.appendChild(document.createElement("tr"));
                
                rows[row].appendChild(td);
                td.appendChild(node.$ext);
                td.setAttribute("colspan", cs = Math.min(collen - (empty[0] || 0), parseInt(node.colspan || node.span || 1)));
                
                td.setAttribute("rowspan", rs = parseInt(node.rowspan || 1));
                
                if (!empty[0])
                    empty[0] = 0;
                empty[0] += cs;

                if (rs > 1) {
                    for (var k = 1; k < rs; k++) {
                        if (!empty[k])
                            empty[k] = 0;
                        empty[k] += cs;
                    }
                }

                if (empty[0] >= collen) {
                    lastCol = true;
                    empty.shift();
                    row++;
                }
                else lastCol = false;

                td.style.padding = "0px " + (lastCol ? 0 : table.padding) 
                    + "px " + (i == l - 1 ? 0 : table.padding) + "px 0px";
            }
            
            for (;z < cells.length; z++)
                cells[z].parentNode.removeChild(cells[z]);
            
            if (e.sync) return;

            if (e.value)
                table.$addTd(nodes[l - 1]); //what if it's not visible
            else {
                //last.parentNode.removeChild(last);
                this.$altExt = null;
            }
        }
    }
    
    this.$addTd = function(amlNode){
        var cells = this.$table.getElementsByTagName("td");
        var total = 0;
        for (var cell, i = 0; i < cells.length; i++) {
            total += 1 + (parseInt((cell = cells[i]).getAttribute("colspan") || 1) - 1) 
                + (parseInt((cell = cells[i]).getAttribute("rowspan") || 1) - 1);
        }
        
        if (total % this.$columns.length == 0) { //New Row
            var row = this.$tbody.appendChild(document.createElement("tr"));
        }
        else
            row = cells[cells.length - 1].parentNode;

        //Add a new cell in the last row
        var cel = row.appendChild(document.createElement("td"));
        cel.style.position = "relative";
        
        if (amlNode.colspan || amlNode.span)
            cel.setAttribute("colspan", amlNode.colspan || amlNode.span);
        if (amlNode.rowspan)
            cel.setAttribute("rowspan", amlNode.rowspan);

        cel.appendChild(amlNode.$ext);

        amlNode.$altExt = cel;
    }
    
    var propHandlers = {
        "width" : function(value){
            this.$ext.style.width = "";/*value 
                ? Math.max(0, value - apf.getWidthDiff(this.$ext)) + "px"
                : "";*/
        },
        
        "height" : function(value){
            this.$ext.style.height = value 
                ? Math.max(0, value - apf.getHeightDiff(this.$ext)) + "px"
                : "";
        },
        
        "margin" : function(value){
            this.$ext.style.margin = apf.getBox(value).join("px ") + "px";
        },
        
        "colspan" : function(value){
            if (!value)
                this.$altExt.removeAttribute("colspan");
            else
                this.$altExt.setAttribute("colspan", value);
            
            visibleHandler.call(this, {sync: true});
        },
        
        "rowspan" : function(value){
            if (!value)
                this.$altExt.removeAttribute("rowspan");
            else
                this.$altExt.setAttribute("rowspan", value);
        
            visibleHandler.call(this, {sync: true});
        },
        
        "valign" : function(value){
            this.$altExt.valign = value;
        },
        
        "align" : function(value){
            this.$altExt.align = value;
        }
    }
    propHandlers.span = propHandlers.colspan;
    
    //@todo move this to enableTable, disableTable
    this.register = function(amlNode){
        if (amlNode.$altExt) //@todo hack, need to rearch layouting
            return;

        amlNode.$propHandlers["left"]   = 
        amlNode.$propHandlers["top"]    = 
        amlNode.$propHandlers["right"]  = 
        amlNode.$propHandlers["bottom"] = apf.K;
        
        for (var prop in propHandlers) {
            amlNode.$propHandlers[prop] = propHandlers[prop];
        }
        
        amlNode.addEventListener("prop.visible", visibleHandler);

        this.$addTd(amlNode);
        
        if (amlNode.margin)
            propHandlers.margin.call(amlNode, amlNode.margin);
        
        //Why was this commented out?
        if (amlNode.$ext.tagName == "INPUT") {
            //amlNode.$ext.style.width = "100%";
        }
        else
            amlNode.$ext.style.width = "auto";
        
        if (this.lastChild == amlNode)
            this.$propHandlers["padding"].call(this, this.padding);
    }
    
    this.unregister = function(amlNode){
        amlNode.$propHandlers["left"]   = 
        amlNode.$propHandlers["top"]    = 
        amlNode.$propHandlers["right"]  = 
        amlNode.$propHandlers["bottom"] = null;
        
        for (var prop in propHandlers) {
            delete amlNode.$propHandlers[prop];
        }
        
        amlNode.removeEventListener("prop.visible", visibleHandler);
        
        visibleHandler.call(amlNode, {value: false}); //maybe parent is already reset here?
        
        if (amlNode.margin)
            amlNode.$ext.style.margin = "";
        
        if (amlNode.width)
            amlNode.$ext.style.width = "";
    }
    /*
         this.addEventListener("DOMNodeInsertedIntoDocument", function(e){
        this.register(this.parentNode);
    });
    */
    
    /**** DOM Hooks ****/
    
    this.addEventListener("DOMNodeRemoved", function(e){
        if (e.$doOnlyAdmin || e.currentTarget == this)
            return;

        if (e.relatedNode == this){
            this.unregister(e.currentTarget);
            e.currentTarget.$setLayout();
        }
    });

    this.addEventListener("DOMNodeInserted", function(e){
        if (e.currentTarget == this || e.currentTarget.nodeType != 1)
            return;

        if (e.relatedNode == this) {
            if (e.$isMoveWithinParent) {
                visibleHandler.call(e.currentTarget, {sync: true}); 
            }
            else {
                e.currentTarget.$setLayout("table");
                if (e.currentTarget.nextSibling)
                    visibleHandler.call(e.currentTarget, {sync: true});
            }
        }
    });
    
    this.$draw = function(){
        this.$pHtmlNode.insertAdjacentHTML("beforeend", "<div><table cellSpacing='0' cellPadding='0'><tbody><tr class='first'></tr></tbody></table></div>");
        this.$ext = this.$pHtmlNode.lastChild;
        this.$table = this.$ext.firstChild;
        this.$tbody = this.$table.firstChild;
        this.$ext.className = "table " + (this.getAttribute("class") || "");
        //this.$ext.style.overflow = "hidden";
        this.$int = this.$ext;
        this.$ext.host = this;

        if (this.getAttribute("class")) 
            apf.setStyleClass(this.$ext, this.getAttribute("class"));
        
        
        apf.layout.setRules(this.$ext, "table",
            "apf.all[" + this.$uniqueId + "].$resize()", true);
        apf.layout.queue(this.$ext);
        
        
        this.$originalMin = [this.minwidth || 0,  this.minheight || 0];
    };
    
    //@todo implement percentage by using fixed and add functionality here
    this.$resize = function(){
        if (this.$table.offsetWidth >= this.$ext.offsetWidth)
            this.$ext.style.minWidth = (this.minwidth = Math.max(0, this.$table.offsetWidth 
                - apf.getWidthDiff(this.$ext))) + "px";
        else {
            this.$ext.style.minWidth = "";
            this.minwidth = this.$originalMin[0];
        }

        if (this.$table.offsetHeight >= this.$ext.offsetHeight)
            this.$ext.style.minHeight = (this.minheight = Math.max(0, this.$table.offsetHeight 
                - apf.getHeightDiff(this.$ext))) + "px";
        else {
            this.$ext.style.minHeight = "";
            this.minheight = this.$originalMin[1];
        }
    }
    
    this.$loadAml = function(x){
        this.$amlLoaded = false; //@todo hack

        if (!this.$columns)
            this.$propHandlers.columns.call(this, this.columns);
        this.$amlLoaded = true; //@todo hack
    };
}).call(apf.table.prototype = new apf.GuiElement());

apf.aml.setElement("table", apf.table);



/*FILEHEAD(/var/lib/platform/source/trunk/elements/tab.js)SIZE(3014)TIME(1269561674)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */





/**
 * Element displaying a page and several buttons allowing a
 * user to switch between the pages. Each page can contain
 * arbitrary aml. Each page can render it's content during
 * startup of the application or when the page is activated.
 * Example:
 * <code>
 *  <a:tab id="tab" width="300" height="100">
 *      <a:page caption="General">
 *          <a:checkbox>Example</a:checkbox>
 *          <a:button>Example</a:button>
 *      </a:page>
 *      <a:page caption="Advanced">
 *          <a:checkbox>Test checkbox</a:checkbox>
 *          <a:checkbox>Test checkbox</a:checkbox>
 *          <a:checkbox>Test checkbox</a:checkbox>
 *      </a:page>
 *      <a:page caption="Ajax.org">
 *          <a:checkbox>This ok?</a:checkbox>
 *          <a:checkbox>This better?</a:checkbox>
 *      </a:page>
 *  </a:tab>
 * </code>
 *
 * @constructor
 * @define tab, pages, switch
 * @allowchild page
 * @addnode elements
 *
 * @author      Ruben Daniels (ruben AT ajax DOT org)
 * @version     %I%, %G%
 * @since       0.1
 *
 * @inherits apf.BaseTab
 */

apf["switch"] = function(struct, tagName){
    this.$hasButtons = false;
    this.$init(tagName || "switch", apf.NODE_VISIBLE, struct);
};

apf.pages     = function(struct, tagName){
    this.$hasButtons = false;
    this.$init(tagName || "pages", apf.NODE_VISIBLE, struct);
};

apf.tab       = function(struct, tagName){
    this.$hasButtons = true;
    this.$init(tagName || "tab", apf.NODE_VISIBLE, struct);
};

(function(){
    this.$focussable = apf.KEYBOARD; // This object can get the focus from the keyboard

    /**** Init ****/

    this.$draw = function(bSkinChange){
        //Build Main Skin
        this.$ext = this.$getExternal();
        this.$loadChildren();
    };
}).call(apf.tab.prototype = new apf.BaseTab());

apf["switch"].prototype =
apf.pages.prototype     = apf.tab.prototype;

apf.aml.setElement("switch", apf["switch"]);
apf.aml.setElement("pages",  apf.pages);
apf.aml.setElement("tab",    apf.tab);



/*FILEHEAD(/var/lib/platform/source/trunk/elements/teleport.js)SIZE(1019)TIME(1257329184)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



apf.aml.setElement("teleport", apf.AmlElement);



/*FILEHEAD(/var/lib/platform/source/trunk/elements/label.js)SIZE(4428)TIME(1270838607)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * Element displaying a text in the user interface, usually specifying
 * a description of another element. When the user clicks on the label it 
 * can set the focus to the connected aml element.
 * Example:
 * This example uses the for attribute to connect the label to the form element.
 * <code>
 *  <a:label for="txtAddress">Address</a:label>
 *  <a:textbox id="txtAddress" value="Some text" />
 * </code>
 *
 * @constructor
 * @allowchild {smartbinding}
 * @addnode elements
 *
 * @inherits apf.BaseSimple
 *
 * @author      Ruben Daniels (ruben AT ajax DOT org)
 * @version     %I%, %G%
 * @since       0.4
 *
 * @binding value  Determines the way the value for the element is retrieved 
 * from the bound data.
 * Example:
 * Sets the label text based on data loaded into this component.
 * <code>
 *  <a:model id="mdlLabel">
 *      <data text="Some text"></data>
 *  </a:model>
 *  <a:label model="mdlLabel" value="[@text]" />
 * </code>
 * Example:
 * A shorter way to write this is:
 * <code>
 *  <a:model id="mdlLabel">
 *      <data text="Some text"></data>
 *  </a:model>
 *  <a:label value="[mdlLabel::@text]" />
 * </code>
 */
apf.label = function(struct, tagName){
    this.$init(tagName || "label", apf.NODE_VISIBLE, struct);
};

(function(){
    this.implement(
        
        apf.DataAction,
        
        apf.ChildValue
    );

    var _self = this;
    
    this.$focussable = false;
    var forElement;
    
    
    
    /**
     * Sets the value of this element. This should be one of the values
     * specified in the values attribute.
     * @param {String} value the new value of this element
     */
    this.setValue = function(value){
        this.setProperty("value", value, false, true);
    };
    
    /**
     * Returns the current value of this element.
     * @return {String}
     */
    this.getValue = function(){
        return this.value;
    }
    
    
    
    /** 
     * @attribute {String} value the text displayed in the area defined by this 
     * element. Using the value attribute provides an alternative to using
     * the text using a text node.
     *
     * @attribute {String} for the id of the element that receives the focus 
     * when the label is clicked on.
     */
    this.$supportedProperties.push("caption", "for", "textalign");
    this.$propHandlers["caption"] = function(value){
        this.$caption.innerHTML = value;
    };
    this.$propHandlers["for"] = function(value){
        forElement = typeof value == "string" ? self[value] : value;
    };
    this.$propHandlers["textalign"] = function(value){
        this.$caption.style.textAlign = value || "";
    };

    this.$draw = function(){
        //Build Main Skin
        this.$ext = this.$getExternal();
        this.$caption = this.$getLayoutNode("main", "caption", this.$ext);
        if (this.$caption.nodeType != 1) 
            this.$caption = this.$caption.parentNode;
        
        this.$ext.onmousedown = function(){
            if (forElement && forElement.$focussable && forElement.focussable)
                forElement.focus();
        }
    };
    
    this.$childProperty = "caption";
    
}).call(apf.label.prototype = new apf.BaseSimple());

apf.aml.setElement("label", apf.label);



/*FILEHEAD(/var/lib/platform/source/trunk/elements/slideshow.js)SIZE(47238)TIME(1270937595)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/*FILEHEAD(/var/lib/platform/source/trunk/elements/scrollbar.js)SIZE(15384)TIME(1265032029)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/elements/bindingloadrule.js)SIZE(1529)TIME(1257329184)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * @todo docs
 */
apf.BindingLoadRule = function(struct, tagName){
    this.$init(tagName, apf.NODE_HIDDEN, struct);
};

(function(){
    //1 = force no bind rule, 2 = force bind rule
    this.$attrExcludePropBind = apf.extend({
        get   : 1
    }, this.$attrExcludePropBind);

    this.$propHandlers["get"] = function(value, prop){
        delete this["c" + prop];
    }
}).call(apf.BindingLoadRule.prototype = new apf.BindingRule());

apf.aml.setElement("load", apf.BindingLoadRule);
apf.aml.setElement("insert", apf.BindingLoadRule);




/*FILEHEAD(/var/lib/platform/source/trunk/elements/button.js)SIZE(28756)TIME(1270838607)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */





/**
 * Element displaying a clickable rectangle that visually confirms to the
 * user when the area is clicked and then executes a command.
 *
 * @constructor
 * @define button, submit, trigger, reset
 * @addnode elements
 *
 * @author      Ruben Daniels (ruben AT ajax DOT org)
 * @version     %I%, %G%
 * @since       0.4
 *
 * @inherits apf.BaseButton
 */
apf.submit  = function(struct, tagName){
    this.$init(tagName || "submit", apf.NODE_VISIBLE, struct);
};

apf.trigger = function(struct, tagName){
    this.$init(tagName || "trigger", apf.NODE_VISIBLE, struct);
};

apf.reset   = function(struct, tagName){
    this.$init(tagName || "reset", apf.NODE_VISIBLE, struct);
};

apf.button  = function(struct, tagName){
    this.$init(tagName || "button", apf.NODE_VISIBLE, struct);
};

(function() {
    this.$useExtraDiv;
    this.$childProperty  = "caption";
    this.$inited         = false;
    this.$isLeechingSkin = false;
    this.$canLeechSkin   = true;

    /**** Properties and Attributes ****/

    this.$focussable = true; // This object can get the focus
    this.value       = null;
    
    this.$init(function(){
        //@todo reparenting
        var forceFocus, _self = this;
        this.$propHandlers["default"] = function(value){
            if (!this.focussable && value || forceFocus)
                this.setAttribute("focussable", forceFocus = value);

            this.parentNode.removeEventListener("focus", setDefault);
            this.parentNode.removeEventListener("blur", removeDefault);
    
            if (!value)
                return;
    
            //Currrently only support for parentNode, this might need to be expanded
            this.parentNode.addEventListener("focus", setDefault);
            this.parentNode.addEventListener("blur", removeDefault);
        };
    
        function setDefault(e){
            if (e.defaultButtonSet || e.returnValue === false)
                return;
    
            e.defaultButtonSet = true;
    
            if (this.$useExtraDiv)
                _self.$ext.appendChild(apf.button.$extradiv);
    
            _self.$setStyleClass(_self.$ext, _self.$baseCSSname + "Default");
    
            if (e.srcElement != _self && _self.$focusParent) {
                _self.$focusParent.addEventListener("keydown", btnKeyDown);
            }
        }
    
        function removeDefault(e){
            if (this.$useExtraDiv && apf.button.$extradiv.parentNode == _self.$ext)
                _self.$ext.removeChild(apf.button.$extradiv);
    
            _self.$setStyleClass(_self.$ext, "", [_self.$baseCSSname + "Default"]);
    
            if (e.srcElement != _self && _self.$focusParent) {
                _self.$focusParent.removeEventListener("keydown", btnKeyDown);
            }
        }
    
        function btnKeyDown(e){
            var ml;
    
            var f = apf.document.activeElement;
            if (f) {
                if (f.hasFeature(apf.__MULTISELECT__))
                    return;
    
                ml = f.multiline;
            }
    
            if (!_self.$ext.onmouseup)
                return;
    
            if (ml && ml != "optional" && e.keyCode == 13
              && e.ctrlKey || (!ml || ml == "optional")
              && e.keyCode == 13 && !e.ctrlKey && !e.shiftKey && !e.altKey)
                _self.$ext.onmouseup(e.htmlEvent, true);
        }
    
        this.addEventListener("focus", setDefault);
        this.addEventListener("blur", removeDefault);
        
        this.$enable = function(){
            if (this["default"]) {
                setDefault({});
                if (apf.document.activeElement)
                    apf.document.activeElement.focus(true);
            }
            if (this.state && this.value) {
                this.$setState("Down", {});
            }
    
            this.$doBgSwitch(1);
        };
    
        this.$disable = function(){
            if (this["default"])
                removeDefault({});
    
            this.$doBgSwitch(4);
            this.$setStyleClass(this.$ext, "",
                [this.$baseCSSname + "Over", this.$baseCSSname + "Down"]);
        };
    });

    /**
     * @attribute {String}  icon     the url from which the icon image is loaded.
     * @attribute {Boolean} state    whether this boolean is a multi state button.
     * @attribute {String}  value    the initial value of a state button.
     * @attribute {String}  color    the text color of the caption of this element.
     * @attribute {String}  caption  the text displayed on this element indicating the action when the button is pressed.
     * @attribute {String}  action   one of the default actions this button can perform when pressed.
     *   Possible values:
     *   undo     Executes undo on the action tracker of the target element.
     *   redo     Executes redo on the action tracker of the target element.
     *   remove   Removes the selected node(s) of the target element.
     *   add      Adds a node to the target element.
     *   rename   Starts the rename function on the target element.
     *   login    Calls log in on the auth element with the values of the textboxes of type username and password.
     *   logout   Calls lot out on the auth element.
     *   submit   Submits the data of a model specified as the target.
     *   ok       Executes a commitTransaction() on the target element, and closes or hides that element.
     *   cancel   Executes a rollbackTransaction() on the target element, and closes or hides that element.
     *   apply    Executes a commitTransaction() on the target element.
     *   close    Closes the target element.
     * @attribute {String}  target   id of the element to apply the action to. Defaults to the parent container.
     * @attribute {String}  default  whether this button is the default action for the containing window.
     * @attribute {String}  submenu  the name of the contextmenu to display when the button is pressed.
     */
    this.$booleanProperties["default"] = true;
    this.$supportedProperties.push("icon", "value", "tooltip", "state",
        "color", "caption", "action", "target", "default", "submenu", "hotkye");

    this.$propHandlers["icon"] = function(value){
        
        if (!this.oIcon)
            return apf.console.warn("No icon defined in the Button skin", "button");
        

        if (value)
            this.$setStyleClass(this.$ext, this.$baseCSSname + "Icon");
        else
            this.$setStyleClass(this.$ext, "", [this.$baseCSSname + "Icon"]);

        apf.skins.setIcon(this.oIcon, value, this.iconPath);
    };

    this.$propHandlers["value"] = function(value){
        if (!this.state && !this.submenu)
            return;
        
        if (value === undefined)
            value = !this.value;
        this.value = value;

        if (this.value)
            this.$setState("Down", {});
        else
            this.$setState("Out", {});
    };

    this.$propHandlers["state"] = function(value){
        this.$setStateBehaviour(value == 1);
    };

    this.$propHandlers["color"] = function(value){
        if (this.oCaption)
            this.oCaption.parentNode.style.color = value;
    };

    this.$propHandlers["caption"] = function(value){
        if (value)
            this.$setStyleClass(this.$ext, "", [this.$baseCSSname + "Empty"]);
        else
            this.$setStyleClass(this.$ext, this.$baseCSSname + "Empty");

        if (this.oCaption.nodeType == 1)
            this.oCaption.innerHTML = String(value || "").trim();
        else
            this.oCaption.nodeValue = String(value || "").trim();
    };

    
    /**
     * @attribute {String} hotkey the key combination a user can press
     * to active the function of this element. Use any combination of
     * Ctrl, Shift, Alt, F1-F12 and alphanumerical characters. Use a
     * space, a minus or plus sign as a seperator.
     * Example:
     * <code>
     *  <a:button hotkey="Ctrl-Z">Undo</a:button>
     * </code>
     */
    this.$propHandlers["hotkey"] = function(value){
        if (this.$hotkey)
            apf.setNodeValue(this.$hotkey, value);

        if (this.$lastHotkey)
            apf.removeHotkey(this.$lastHotkey);

        if (value) {
            this.$lastHotkey = value;
            var _self = this;
            apf.registerHotkey(value, function(){
                //hmm not very scalable...
                _self.$setState("Over", {});

                $setTimeout(function(){
                    _self.$setState("Out", {});
                }, 200);

                if (_self.$clickHandler && _self.$clickHandler())
                    _self.$updateState (e || event, "click");
                else
                    _self.dispatchEvent("click");
            });
        }
    }
    

    

    //@todo move this to menu.js
    function menuKeyHandler(e){
        return;
        var key = e.keyCode;

        var next, nr = apf.getChildNumber(this);
        if (key == 37) { //left
            next = nr == 0
                ? this.parentNode.childNodes.length - 1
                : nr - 1;
            this.parentNode.childNodes[next].dispatchEvent("mouseover");
        }
        else if (key == 39) { //right
            next = (nr >= this.parentNode.childNodes.length - 1)
                ? 0
                : nr + 1;
            this.parentNode.childNodes[next].dispatchEvent("mouseover");
        }
    }

    function menuDown(e){
        var menu = self[this.submenu];

        this.value = !this.value;

        if (this.value)
            this.$setState("Down", {});

        
        if (!menu) {
            throw new Error(apf.formatErrorString(0, this,
                "Showing submenu",
                "Could not find submenu '" + this.submenu + "'"));
        }
        

        if (!this.value) {
            menu.hide();
            this.$setState("Over", {}, "toolbarover");

            this.parentNode.menuIsPressed = false;
            if (this.parentNode.hasMoved)
                this.value = false;

            if (apf.hasFocusBug)
                apf.window.$focusfix();

            return false;
        }

        this.parentNode.menuIsPressed = this;

        //var pos = apf.getAbsolutePosition(this.$ext, menu.$ext.offsetParent);
        menu.display(null, null, false, this,
            null, null, this.$ext.offsetWidth - 2);

        this.parentNode.hasMoved = false;

        e.htmlEvent.cancelBubble = true;

        return false;
    }

    function menuOver(){
        var menuPressed = this.parentNode.menuIsPressed;

        if (!menuPressed || menuPressed == this)
            return;

        menuPressed.setValue(false);
        var oldMenu = self[menuPressed.submenu];
        oldMenu.$propHandlers["visible"].call(oldMenu, false, true);//.hide();

        this.setValue(true);
        this.parentNode.menuIsPressed = this;

        var menu = self[this.submenu];

        
        if (!menu) {
            throw new Error(apf.formatErrorString(0, this,
                "Showing submenu",
                "Could not find submenu '" + this.submenu + "'"));
        }
        

        var pos = apf.getAbsolutePosition(this.$ext, menu.$ext.offsetParent);

        menu.display(pos[0],
            pos[1] + this.$ext.offsetHeight, true, this,
            null, null, this.$ext.offsetWidth - 2);

        //apf.window.$focus(this);
        this.$focus();

        this.parentNode.hasMoved = true;

        return false;
    }

    /**
     * @attribute {string} submenu If this attribute is set, the button will
     * function like a menu button
     */
    this.$propHandlers["submenu"] = function(value){
        if (!value){
            if (this.value && this.parentNode)
                menuDown.call(this);

            this.$focussable = true;
            this.$setNormalBehaviour();
            this.removeEventListener("mousedown", menuDown);
            this.removeEventListener("mouseover", menuOver);
            this.removeEventListener("keydown", menuKeyHandler, true);
            return;
        }

        this.$focussable = false;
        this.$setStateBehaviour();

        this.addEventListener("mousedown", menuDown);
        this.addEventListener("mouseover", menuOver);
        this.addEventListener("keydown", menuKeyHandler, true);
    };
    

    /**** Public Methods ****/

    

    /**
     * Sets the value of this element. This should be one of the values
     * specified in the values attribute.
     * @param {String} value the new value of this element
     */
    this.setValue = function(value){
        this.setProperty("value", value, false, true);
    };

    /**
     * Sets the text displayed as caption of this element.
     *
     * @param  {String}  value  required  The string to display.
     * @see    baseclass.validation
     */
    this.setCaption = function(value){
        this.setProperty("caption", value, false, true);
    };

    /**
     * Sets the URL of the icon displayed on this element.
     *
     * @param  {String}  value  required  The URL to the location of the icon.
     * @see    element.button
     * @see    element.modalwindow
     */
    this.setIcon = function(url){
        this.setProperty("icon", url, false, true);
    };
    
    

    /**** Private state methods ****/

    this.$setStateBehaviour = function(value){
        this.value     = value || false;
        this.isBoolean = true;
        this.$setStyleClass(this.$ext, this.$baseCSSname + "Bool");

        if (this.value) {
            this.$setStyleClass(this.$ext, this.$baseCSSname + "Down");
            this.$doBgSwitch(this.states["Down"]);
        }
    };

    this.$setNormalBehaviour = function(){
        this.value     = null;
        this.isBoolean = false;
        this.$setStyleClass(this.$ext, "", [this.$baseCSSname + "Bool"]);
    };

    this.$setState = function(state, e, strEvent){
        //if (this.disabled)
            //return;

        if (strEvent && this.dispatchEvent(strEvent, {htmlEvent: e}) === false)
            return;

        this.$doBgSwitch(this.states[state]);
        var bs = this.$baseCSSname;
        this.$setStyleClass(this.$ext, (state != "Out" ? bs + state : ""),
            [(this.value ? "" : bs + "Down"), bs + "Over"]);

        if (this.submenu) {
            bs = this.$baseCSSname + "menu";
            this.$setStyleClass(this.$ext, (state != "Out" ? bs + state : ""),
            [(this.value ? "" : bs + "Down"), bs + "Over"]);
        }

        //if (state != "Down")
            //e.cancelBubble = true;
    };

    this.$clickHandler = function(){
        // This handles the actual OnClick action. Return true to redraw the button.
        if (this.isBoolean && !this.submenu) {
            this.setProperty("value", !this.value);
            return true;
        }
    };

    
    this.$submenu = function(hide, force){
        if (hide) {
            this.setValue(false);
            this.$setState("Out", {}, "mouseout");
            this.parentNode.menuIsPressed = false;
        }
    };
    

    /**** Init ****/

    this.$draw  = function(){
        var pNode, isToolbarButton = (pNode = this.parentNode).localName == "toolbar" 
            || pNode.parentNode && pNode.parentNode.localName == "toolbar";
        
        if (isToolbarButton) {
            if (typeof this.focussable == "undefined")
                this.focussable = false;
            
            this.$focussable = apf.KEYBOARD;
        }

        //Build Main Skin
        this.$ext     = this.$getExternal();
        this.oIcon    = this.$getLayoutNode("main", "icon", this.$ext);
        this.oCaption = this.$getLayoutNode("main", "caption", this.$ext);

        this.$useExtraDiv = apf.isTrue(this.$getOption("main", "extradiv"));
        if (!apf.button.$extradiv && this.$useExtraDiv) {
            (apf.button.$extradiv = document.createElement("div"))
                .className = "extradiv"
        }

        if (this.localName == "submit")
            this.action = "submit";
        else if (this.localName == "reset")
            this.action = "reset";

        this.$setupEvents();
    };

    

    

    
}).call(apf.button.prototype = new apf.BaseButton());

// submit, trigger, reset, button
apf.submit.prototype  =
apf.trigger.prototype =
apf.reset.prototype   = apf.button.prototype;

apf.aml.setElement("submit",  apf.submit);
apf.aml.setElement("trigger", apf.trigger);
apf.aml.setElement("reset",   apf.reset);
apf.aml.setElement("button",  apf.button);






/*FILEHEAD(/var/lib/platform/source/trunk/elements/statusbar.js)SIZE(3824)TIME(1269561674)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/elements/smartbinding.js)SIZE(33241)TIME(1269561674)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * @term smartbinding Smartbinding is a type of bidirectional databinding where 
 * rules specify how data is rendered in a component <i>and</i> how changes to
 * the bound data are sent back to the server (or other data source). 
 * Smartbindings are specifically designed to solve the problem of databinding
 * for Ajax applications that connect to remote (non-local) datasources.
 * A smartbinding element can contain three elements; {@link element.bindings bindings}, 
 * {@link element.actions actions} and {@link element.model model}.
 *
 * See also more information about {@link term.binding binding rules} and
 * {@link term.action action rules}.
 *
 * Model:
 * The model is the place where your xml data resides. Data is loaded into the
 * model using a {@link term.datainstruction data instruction} as the following
 * example shows:
 * <code>
 *  <a:model src="get_person.php?id=10" />
 * </code>
 * An element can connect directly to a model in order to bind to data.
 * <code>
 *  <a:model id="mdlExample" />
 *  <a:tree model="mdlExample" />
 * </code>
 *
 * The model can also be part of a smartbinding that is used by the element. 
 * A smartbinding can be used by multiple elements referenced by id:
 * <code>
 *  <a:smartbinding id="sbExample">
 *      <a:model id="mdlList" src="http://localhost/get_person.php?id=10" />
 *      <a:bindings>
 *          <a:caption match="[@name]" />
 *          <a:each match="[user]"/>
 *      </a:bindings>
 *  </a:smartbinding>
 *
 *  <a:list width="300" smartbinding="sbExample" />
 * </code>
 *
 * Bindings:
 * The bindings element is a container for binding rules. Binding rules determine
 * how an element renders the data that it's bound to. Some binding rules specify
 * how data can be interacted with (i.e. {@link baseclass.multiselect.binding.select the select rule}).
 * Check the {@link term.binding term binding rules} for more information.
 *
 * Actions:
 * The actions element is a container for action rules. Action rules influence 
 * and trigger several parts of the user interaction. 
 * <ol>
 *  <li>It determines whether a user action can be executed on the bound and/or 
 *      selected {@link term.datanode data node}.</li>
 *  <li>It dispatches events, before and after the data is changed.</li>
 *  <li>It creates a {@link http://en.wikipedia.org/wiki/Command_pattern command object} 
 *      that is pushed on the undo stack of the {@link element.actiontracker actiontracker} 
 *      connected to the element that triggered the action.</li>
 *  <li>The command object contains all the information to send the change back 
 *      to the server</li>
 * </ol>
 * So in short, an action rule is always triggered by the user, creates an 
 * undo item and sends the change back to the server.
 * Check the {@link term.action term action rules} for more information.
 *
 * See:
 * {@link baseclass.databinding.attribute.smartbinding}
 */

/**
 * @term binding Binding rules determine how an element displays the data that 
 * its bound to (ex.: {@link element.tree.binding.caption the caption rule}), 
 * and determines how it can be interacted with 
 * (ex.: {@link baseclass.multiselect.binding.select the select rule}).
 * Binding rules are part of the {@link term.smartbinding smartbinding concept}.
 * 
 * Basic:
 * Let's take a simple example, that of a {@link element.textbox textbox}. A 
 * textbox has a {@link element.textbox.attribute.value value attribute}. This
 * attribute can be set like this:
 * <code>
 *  <a:textbox value="The text" />
 * </code>
 * In many cases it's handy to bind the value of the textbox to data. Imagine
 * you are editing a contact's name in a textbox. In this case you would want to 
 * bind the value of the textbox to the xml data. The binding rule is configured
 * to determine this value based on the bound xml. Let's look at an example:
 * <code>
 *  <a:model id="mdlExample">
 *      <contact>
 *          <name>Test</name>
 *      </contact>
 *  </a:model>
 *  
 *  <a:textbox value="[mdlExample::name]" />
 * </code>
 * The textbox binds to the data of the model. The bind rule sets how the value
 * is retrieved from the bound data. In this case the value of the name node is
 * retrieved. <strong>When the user changes the value of the textbox, the name
 * node is updated with that value.</strong> Subsequently <strong>when the xml
 * changes the value of the textbox is updated</strong>.
 *
 * Each attribute on an element can be bound to data by using the attribute
 * name as the name of the binding rule. In the next example, the visible
 * attribute of a textbox is based on the availability of a {@link term.datanode data node}:
 * <code>
 *  <a:model>
 *      <data name="false" />
 *  </a:model>
 *  
 *  <a:textbox visible="[@name]" value="Text" />
 * </code>
 * Each element has a primary bind rule that can be accessed in a short format.
 * This is usually the value bind rule. The short format works as follows:
 * <code>
 *  <a:model id="mdlExample">
 *      <contact>
 *          <name>Test</name>
 *      </contact>
 *  </a:model>
 *  <a:textbox value="[name]" model="mdlExample" />
 * </code>
 *
 * Advanced:
 * For multi node components databinding adds another conceptual step. The basics
 * stay the same, though a way is introduced to do 'foreach' on the data to 
 * determine which nodes are rendered. This is done using the 
 * {@link element.multiselectbinding.binding.each each binding rule} and
 * the selected nodes are called {@link term.eachnode each nodes}.
 *
 * When the set of each nodes is determined, each is rendered based on other
 * binding rules that determine whatever is deemed necesary by the component. 
 * This can be the caption, icon, tooltip, whether an item is seletable and so on.
 * In the next example a list is bound to some data representing a contact list.
 * Each contact's name is displayed as the caption of the item.
 * <code>
 *  <a:model id="mdlSmart1">
 *      <data>
 *          <contact>
 *              <name>Ruben</name>
 *              <company>Javeline</company>
 *          </contact>
 *          <contact>
 *              <name>Łukasz</name>
 *              <company>Javeline</company>
 *          </contact>
 *      </data>
 *  </a:model>
 *  <a:list model="mdlSmart1">
 *      <a:bindings>
 *          <a:caption value="[name]" />
 *          <a:icon value="contact.png" />
 *          <a:each match="[contact]" />
 *      </a:bindings>
 *  </a:list>
 * </code>
 * 
 * Fallbacks:
 * By stacking multiple binding rules it's possible to define different ways to
 * determine the value for an attribute. Let's say we have a tree that displays
 * files and folders. A file and a folder can have custom icons. If these are 
 * not specified, they each default to an icon representing their type. This would
 * be encoded like this:
 * <code>
 *  <a:model id="mdlSmart1">
 *      <data>
 *          <folder caption="folder 1">
 *              <file caption="file 1" />
 *              <file caption="file 2" />
 *              <file caption="unknown" icon="icoAnything.gif" />
 *          </folder>
 *      </data>
 *  </a:model>
 *  <a:tree model="mdlSmart1">
 *      <a:bindings>
 *          <a:caption value="[@caption]" />
 *          <a:icon match="[@icon]" />
 *          <a:icon match="[folder]" value="Famfolder.gif" />
 *          <a:icon match="[file]" value="icoEmpty.png" />
 *          <a:each match="[folder|file]" />
 *      </a:bindings>
 *  </a:tree>
 * </code>
 *
 * Processors:
 * There are several ways to convert the data retrieved from the xml data into
 * the needed string or boolean. The following example uses {@link term.livemarkup live markup}
 * to determine the icon by the extension of the filename:
 * <code>
 *  <a:model id="mdlSmart1">
 *      <data>
 *          <contact>
 *              <name>Ruben</name>
 *              <filename>Baseclasses</filename>
 *          </contact>
 *          <contact>
 *              <name>Łukasz</name>
 *              <filename>application.png</filename>
 *          </contact>
 *      </data>
 *  </a:model>
 *  <a:list model="mdlSmart1">
 *      <a:bindings>
 *          <a:caption value="[name]" />
 *          <a:icon><?lm
 *              var ext = {[filename].split(".").shift()};
 *              ext == [filename] ? "unknown.png" : ext + ".png";
 *          ?></a:icon>
 *          <a:each match="[contact]" />
 *      </a:bindings>
 *  </a:list>
 * </code>
 * Instead of live markup you can use xslt as well. Furthermore you can apply some
 * javascript to the result by calling a method. The following examples shows
 * a caption where a javascript method inserts smileys.
 * <code>
 *  <a:model id="mdlSmart1">
 *      <data>
 *          <file caption="file 1" />
 *          <file caption="file 2" />
 *      </data>
 *  </a:model>
 *  <a:tree model="mdlSmart1" height="100">
 *      <a:script>
 *          function insertSmileys(value) {
 *              //do something with value
 *              return value;
 *          }
 *      </a:script>
 *      <a:bindings>
 *          <a:caption value="{insertSmileys([@caption])}" />
 *          <a:each match="[file]" />
 *      </a:bindings>
 *  </a:tree>
 * </code>
 *
 * Extending:
 * Two special binding rules are the {@link baseclass.databinding.binding.load load}
 * and the {@link element.tree.binding.insert insert} bindings. These bindings
 * are used to load and insert new data into the data bound to the element that
 * uses them. With these rules an application can start out with only a bit of
 * data and when the user needs it extends the data. A simple example is that of
 * a tree element that loads subnodes whenever a user expands a node. This can
 * be achieved in the following way:
 * <code>
 *  <a:model id="mdlSmart2">
 *      <data>
 *          <group name="Group 1">
 *              <user name="User 1" id="1" leaf="long"></user>
 *              <user name="User 2" id="2"></user>
 *          </group>
 *          <group name="Group 2">
 *              <user name="User 3" id="3" leaf="long"></user>
 *              <user name="User 4" id="4"></user>
 *          </group>
 *      </data>
 *  </a:model>
 *  
 *  <a:tree model="mdlSmart2">
 *      <a:bindings>
 *          <a:caption match="[@name]" />
 *          <a:insert  
 *            match = "[user[not(@leaf)]]" 
 *            get   = "http://localhost/get_person.php?id=[@id]" />
 *          <a:each match="[user|group]" />
 *      </a:bindings>
 *  </a:tree>
 * </code>
 * For more information about how data can be loaded into aml elements please
 * check {@link term.datainstruction data instructions}.
 */

/**
 * @term action Action rules determine whether a user can execute an action and
 * takes care of executing the change both locally and on a remote server. Each
 * triggered action creates an item on the undo stack.
 * Action rules are part of the {@link term.smartbinding smartbinding concept}.
 *
 * Syntax:
 * Actions are added to {@link element.actions}. The <i>select</i> attribute specifies
 * whether an action can be executed. The <i>set</i> attribute specifies how the change
 * to the data is send to the server. The following example shows a remove 
 * action on a datagrid. A jsp script is called to process the change. This is
 * specified using a {@link term.datainstruction data instruction}.
 * <code>
 *  <a:datagrid>
 *      <a:actions>
 *          <a:remove 
 *            match = "[contact[not(@readonly)]]" 
 *            set   = "php/remove_contact.php?id=[@id]" />
 *      </a:actions>
 *  </a:datagrid>
 * </code>
 *
 * Defaults:
 * The default behaviour for all components is to enable all actions when no
 * actions element has been assigned. This can be change by setting 
 * {@link element.appsettings.attribute.auto-disable-actions}. When a actions
 * element <i>is</i> assigned, all actions are disabled unless they are specified.
 * When the select attribute on an action is not set the action will always be
 * allowed. 
 * 
 * Flow:
 * Action rules influence and trigger several parts of the user interaction. 
 * <ol>
 *  <li>It determines whether a user action can be executed on the bound and/or 
 *      selected {@link term.datanode data node}.</li>
 *  <li>It dispatches events, before and after the data is changed.</li>
 *  <li>It creates a {@link http://en.wikipedia.org/wiki/Command_pattern command object} 
 *      that is pushed on the undo stack of the {@link element.actiontracker actiontracker} 
 *      connected to the element that triggered the action.</li>
 *  <li>The command object ({@link core.undodata UndoData}) contains all the 
 *      information to send the change back to the server.</li>
 * </ol>
 *
 * Fallbacks:
 * By stacking multiple action rules it's possible to define different ways to
 * deal with user actions. Let's say we have a tree that displays
 * files and folders. Renaming a file and a folder might have different handlers. 
 * This would be encoded like this:
 * <code>
 *  <a:tree 
 *    id             = "tree" 
 *    height         = "200" 
 *    width          = "250"
 *    model          = "filesystem.xml"
 *    actiontracker  = "atExample"
 *    startcollapsed = "false" 
 *    onerror        = "alert('Sorry this action is not permitted');return false">
 *      <a:each match="[folder|drive]">
 *          <a:caption match="[@caption]" />
 *          <a:icon value="Famfolder.gif" />
 *      </a:each>
 *      <a:rename match = "[file]"   
 *                set    = "rename_folder.php?id=[@fid]" />
 *      <a:rename match = "[folder]" 
 *                set    = "rename_file.php?id=[@fid]" />
 * </a:tree>
 *       
 * <a:button 
 *   caption = "Rename"
 *   right   = "10" 
 *   top     = "10"
 *   onclick = "tree.startRename()" />
 * <a:button onclick="tree.getActionTracker().undo();">Undo</a:button>
 * </code>
 *
 * Undo:
 * When an action is execute it creates an entry on the undostack of an 
 * actiontracker. Undo can be triggered by calling the undo method.
 * <code>
 *  myTree.getActionTracker().undo();
 *  //or
 *  ActionTracker.undo();
 * </code>
 * Executing will revert the change to the data. This will also be communicated
 * to the server. In some cases the call to the server is not symmetric; the set
 * call cannot be used to revert. For these situations set the undo attribute.
 * <code>
 *  <a:tree id="tree" height="200" width="250"
 *    model          = "filesystem.xml"
 *    actiontracker  = "atExample"
 *    startcollapsed = "false" 
 *    onerror        = "alert('Sorry this action is not permitted');return false">
 *      <a:each match="[folder|drive]">
 *          <a:caption match="[@caption]" />
 *          <a:icon value="Famfolder.gif" />
 *      </a:each>
 *      <a:remove set  = "remove.php?id=[@fid]"
 *                undo = "undo_remove.php?id=[@fid]">
 *      </a:remove>
 *  </a:tree>
 *  <a:button onclick="tree.getActionTracker().undo();">Undo</a:button>
 *  <a:button onclick="tree.remove();">Remove</a:button>
 * </code>
 * In the example above the server is required to support reverting remove. 
 * Another possibility is to add the item again as shown in this example:
 * <code>
 *  <a:remove set  = "remove.php?id=[@id]"
 *            undo = "add.php?xml=[.]">
 *  </a:remove>
 * </code>
 *
 * Javascript:
 * Each action has a method associated with it that exists on the element that
 * the action rule is assigned to. The method has the same name as the action 
 * and can be called from javascript. For instance, the {@link baseclass.multiselect.binding.remove remove action}:
 * <code>
 *  myTree.remove();
 *  myTree.remove(dataNode);
 * </code>
 *
 * Add:
 * Adding {@link term.datanode data nodes} to an element is a bit more advanced because the origin of
 * the new data can be encoded in {@link baseclass.multiselect.binding.add the add action rule}. 
 * There are three ways to provide the data to add a node. 
 * 
 * The first is by calling the add method using javascript.
 * <code>
 *  <a:list id="myList">
 *      <a:add set="{comm.addProduct([.])}" />
 *  </a:list>
 *  <a:script>
 *      myList.add('<product name="USB drive" type="storage" />');
 *  </a:script>
 * </code>
 *
 * The second by specifying the template as a child of the add action rule:
 * <code>
 *  <a:add set="{comm.addProduct([.])}">
 *      <product name="USB drive" type="storage" />
 *  </a:add>
 * </code>
 * The third way gets the added node from the server.
 * <code>
 *  <a:rpc id="comm" protocol="cgi">
 *      <a:method 
 *        name = "createNewProduct" 
 *        url  = "http://yourserver.com/create_product.php" />
 *  </a:rpc>
 *  <a:list id="myList" width="200">
 *      <a:bindings>
 *          <a:caption match="[text()]" />
 *          <a:value match="[text()]" />
 *          <a:each match="[product]" />
 *      </a:bindings>
 *      <a:add get="{comm.createNewProduct()}" />
 *      <a:model>
 *          <data>
 *              <product>LCD Panel</product>
 *          </data>
 *      </a:model>
 *  </a:list>
 *  <a:button onclick="myList.add()">Add product</a:button>
 * </code>
 *
 * Purging:
 * Sometimes it's necesary to not send the changes directly to the server. For
 * instance when the application offers a <i>save</i> button. To achieve this
 * set the {@link element.actiontracker.attribute.realtime realtime attribute}
 * of the actiontracker to false. The save button can call the 
 * {@link element.actiontracker.method.purge purge method} to have the 
 * actiontracker send the calls.
 * <code>
 *  <a:actiontracker id="myAt" realtime="false" />
 *  <a:list actiontracker="myAt" />
 *  <a:button onclick="myAt.purge()">Save</a:button>
 * </code>
 * N.B. At a certain amount of changes this way will become inefficient and 
 * you'll want to send the state of your data to the server directly. You can
 * do that like this:
 * <code>
 *  <a:list id="myList" width="200">
 *      <a:bindings>
 *          <a:caption match="[text()]" />
 *          <a:value match="[text()]" />
 *          <a:each match="[product]" />
 *      </a:bindings>
 *      <a:model>
 *          <data>
 *              <product>LCD Panel</product>
 *          </data>
 *      </a:model>
 *      <a:rename />
 *      <a:remove />
 *  </a:list>
 *  <a:button onclick="myList.getModel().submit('save.php', myList.xmlRoot)">
 *      Save
 *  </a:button>
 * </code>
 * See also {@link element.model.method.submit}.
 * 
 * Transactions:
 * A transaction is a 
 * set of changes to data which are treated as one change. When one of the 
 * changes in the set fails, all the changes will be cancelled. In the case of
 * a gui this is happens when a user decides to cancel after 
 * making several changes. A good example are the well known <i>Properties</i> 
 * windows with an ok, cancel and apply button. 
 *
 * When a user edits data, for instance user information, all the changes are
 * seen as one edit and put on the undo stack as a single action. Thus clicking
 * undo will undo the entire transaction, not just the last change done by that
 * user in the edit window. Transaction support both optimistic and pessimistic 
 * locking. For more information on transactions see {@link baseclass.transaction}.
 */
 
/**
 * @term datanode A data node is the term used for any xml node (attribute, 
 * element, textnode or otherwise) that is used in a databound context. So when
 * xml is loaded into a {@link element.model model} we refer to those xml nodes 
 * as data nodes.
 */
 
/**
 * Element containing information on how databound elements process data.
 * The {@link term.smartbinding smartbinding} element specifies how data is transformed and rendered 
 * in databound elements. It also specifies how changes on the bound data are 
 * send to their original data source ({@link element.actions actions}) and
 * which {@link term.datanode data nodes} can be dragged and dropped ({@link element.dragdrop dragdrop}).
 * Example:
 * A simple example of a smartbinding transforming data into representation
 * <code>
 *  <a:smartbinding id="sbProducts">
 *          <a:bindings>
 *               <a:caption match="[text()]" />
 *               <a:value match="[text()]" />
 *               <a:each match="[product]" />
 *           </a:bindings>
 *      </a:smartbinding>
 *     
 *      <a:list smartbinding="sbProducts" width="200">
 *          <a:model>
 *               <data>
 *                   <product>LCD Panel</product>
 *               </data>
 *           </a:model>
 *      </a:list>
 * </code>
 * Example:
 * This is an elaborate example showing how to create a filesystem tree with
 * files and folders in a tree. The smartbinding element describes how the
 * files and folders are transformed to tree elements and how actions within
 * the tree are sent to the data source. In this case {@link teleport.webdav WebDAV}
 * is used. The drag and drop rules specify which elements can be dragged and
 * where they can be dropped.
 * <code>
 *  <a:smartbinding id="sbFilesystem" model="{myWebdav.getRoot()}">
 *      <a:bindings>
 *          <a:insert match="[folder]" get="{myWebdav.readdir([@path])}" />
 *          <a:each match="[file|folder]" sort="[@name]" sort-method="filesort" />
 *          <a:caption match="[@name]" />
 *          <a:icon match="[folder]" value="icoFolder.png" />
 *          <a:icon match="[file]" method="getIcon" />
 *          <a:drag match="[folder|file]" copy="event.ctrlKey" /> 
 *          <a:drop 
 *            match  = "[folder|file]" 
 *            target = "[folder]" 
 *            action = "tree-append" /> 
 *      </a:bindings>
 *      <a:add type="folder" get="{myWebdav.mkdir([@id], 'New Folder')}" />
 *      <a:add type="file" get="{myWebdav.create([@id], 'New File', '')}" />
 *      <a:rename set="{myWebdav.move(oldValue, [@name], [@id])}"/>
 *      <a:copy match="[.]" set="{myWebdav.copy([@id], [../@id])}"/>
 *      <a:move match="[.]" set="{myWebdav.move()}"/>
 *      <a:remove match="[.]" set="{myWebdav.remove([@path])}"/>
 *  </a:smartbinding>
 *
 *  <a:tree 
 *    dragcopy     = "true" 
 *    model        = "mdlFilesystem" 
 *    smartbinding = "sbFilesystem" />
 *
 *  <a:script>
 *      function filesort(value, args, xmlNode) {
 *          return (xmlNode.tagName == "folder" ? 0 : 1) + value;
 *      }
 *
 *      function getIcon(xmlNode){
 *          xmlNode.getAttribute('name').match(/\.([^\.]*)$/);
 *              
 *          var ext = RegExp.$1;
 *          return (SupportedIcons[ext.toUpperCase()]
 *              ? SupportedIcons[ext.toUpperCase()] + ".png" 
 *              : "unknown.png");
 *      }
 *  </a:script>
 * </code>
 * Remarks:
 * Each element has it's own set of binding rules it uses to render the data 
 * elements. The same goes for it's actions. To give an example, a slider has 
 * one action called 'change'. This action is called when then value of the 
 * slider changes. A tree element has several actions - among others: 'add',
 * 'remove', 'move', 'copy' and 'rename'. 
 * 
 * Smartbindings enable many other features in a Ajax.org Platform
 * application. Actions done by the user can be undone by calling 
 * {@link element.actiontracker.method.undo} of the element. The 
 * Remote Smartbinding element can send changes on data to other clients.
 *
 * This element is created especially for reuse. Multiple elements can reference
 * a single smartbinding element by setting the value of the 'smartbinding'
 * attribute to the ID of this smartbinding element. If an element is only used
 * for a single other element it can be set as it's child. In fact, each of the
 * children of the smartbinding element can exist outside the smartbinding
 * element and referenced indepently.
 * Example:
 * This example shows a smartbinding element which references to its children as
 * stand alone elements.
 * <code>
 *  <a:bindings id="bndExample">
 *      ...
 *  </a:bindings>
 *  <a:actions id="actExample">
 *      ...
 *  </a:actions>
 *  <a:dragdrop id="ddExample">
 *      ...
 *  </a:dragdrop>
 *  <a:model id="mdlExample" />
 *
 *  <a:smartbinding id="sbExample"
 *    actions  = "actExample" 
 *    bindings = "bndExample" 
 *    dragdrop = "ddExample" 
 *    model    = "mdlExample" />
 *
 *  <a:list smartbinding="sbExample" />
 *  <a:tree binding="bndExample" action="actExample" model="example.php" />
 * </code>
 * Example:
 * The shortest method to add binding rules to an element is as follows:
 * <code>
 *  <a:tree each="[file|folder]" caption="[@name]" icon="[@icon]" />
 * </code>
 * @see baseclass.databinding
 * @see baseclass.databinding.attribute.smartbinding
 * @see term.smartbinding
 * @see term.binding
 * @see term.action
 * 
 * @define smartbinding
 * @allowchild bindings, actions, ref, action, dragdrop, model
 * @addnode smartbinding, global
 *
 * @constructor
 * @apfclass
 *
 * @author      Ruben Daniels (ruben AT ajax DOT org)
 * @version     %I%, %G%
 * @since       0.8
 *
 * @default_private
 */
apf.smartbinding = function(struct, tagName){
    this.$init(tagName || "smartbinding", apf.NODE_HIDDEN, struct);

    this.$bindNodes = {};
};

(function(){
    this.$supportedProperties = ["bindings", "actions", "model"];
    this.$handlePropSet = function(prop, value, force){
        switch(prop) {
            //@todo apf3 change this to use apf.setModel();
            case "model":
                if (typeof value == "string")
                    value = apf.nameserver.get("model", value);
                this.model          = apf.nameserver.register("model", this.name, value);
                //this.modelBaseXpath = xpath;
                
                var amlNode;
                for (var uniqueId in this.$bindNodes) {
                    amlNode = this.$bindNodes[uniqueId];
                    this.model.unregister(amlNode);
                    this.model.register(amlNode, this.$modelXpath[amlNode.getHost
                        ? amlNode.getHost().$uniqueId
                        //this is a hack.. by making Models with links to other
                        //models possible, this should not be needed
                        : amlNode.$uniqueId] || this.modelBaseXpath);
                    //this.$bindNodes[uniqueId].load(this.model);
                }
                break;
            case "bindings":
                if (this.$bindings)
                    this.remove(this.$bindings);
                
                this.$bindings = typeof value == "object" 
                    ? value 
                    : apf.nameserver.lookup("bindings", value);
                
                this.add(this.$bindings);
                
                break;
            case "actions":
                if (this.$actions)
                    this.remove(this.$actions);
                
                this.$actions = typeof value == "object" 
                    ? value 
                    : apf.nameserver.lookup("actions", value);
                
                this.add(this.$actions);
            
                break;
        }
        
        this[prop] = value;
        
        
        /*if (!apf.nameserver.get(name, attr[i].nodeValue))
            throw new Error(apf.formatErrorString(1036, this, 
                "Connecting " + name, 
                "Could not find " + name + " by name '" 
                + attr[i].nodeValue + "'"));*/
        
    };
    
    this.add = function(node){
        for (var uId in this.$bindNodes)
            node.register(this.$bindNodes[uId]);
        
        this["$" + node.localName] = node;
    };
    
    this.remove = function(node){
        for (var uId in this.$bindNodes)
            node.unregister(this.$bindNodes[uId]);
    };
    
    this.register = function(amlNode){
        this.$bindNodes[amlNode.$uniqueId] = amlNode;
        
        if (this.$bindings)
            this.$bindings.register(amlNode);
        if (this.$actions)
            this.$actions.register(amlNode);
        if (this.$model)
            this.$model.register(amlNode);
    };

    this.unregister = function(amlNode){
        //unregister element
        this.$bindNodes[amlNode.$uniqueId] = null;
        delete this.$bindNodes[amlNode.$uniqueId];
        
        if (this.$bindings)
            this.$bindings.unregister(amlNode);
        if (this.$actions)
            this.$actions.unregister(amlNode);
        if (this.$model)
            this.$model.unregister(amlNode);
    };
    
    /**
     * Loads xml data in the model of this smartbinding element.
     * 
     * @param  {mixed}  xmlNode the {@link term.datanode data node} loaded into
     * the model of this smartbinding element. This can be an XMLElement, a 
     * string or null. 
     * @private
     */
    this.load = function(xmlNode){
        //@todo fix this
        new apf.model().register(this).load(xmlNode);
    };
    
    this.clear = function(state){
        //for all elements do clear(state);
    };
    
    /**
     * @private
     *
     * @attribute {String} bindings the id of the bindings element that contains 
     * the {@link term.binding binding rules} for all elements connected to 
     * this smartbinding element
     * Example:
     * <code>
     *  <a:smartbinding id="sbExample" bindings="bndExample" />
     * </code>
     * @see element.bindings
     * @see term.binding
     * @see term.smartbinding
     *
     * @attribute {String} actions  the id of the actions element that provides 
     * the {@link term.action action rules} for all elements connected to 
     * this smartbinding element
     * Example:
     * <code>
     *  <a:smartbinding id="sbExample" actions="actExample" />
     * </code>
     * @see element.actions
     * @see term.action
     * @see term.smartbinding
     *
     * @attribute {String} dragdrop the id of the dragdrop element that provides 
     * the drag and drop rules for all elements connected to this smartbinding 
     * element
     * Example:
     * <code>
     *  <a:smartbinding id="sbExample" bindings="bndExample" />
     * </code>
     * @see element.dragdrop
     * @see term.smartbinding
     *
     * @attribute {String} model    the id of the model element that provides 
     * the data for all elements connected to this smartbinding element.
     * Example:
     * <code>
     *  <a:smartbinding id="sbExample" model="mdlExample" />
     * </code>
     * @see element.model
     * @see term.smartbinding
     *
     * @define bindings element containing all the binding rules for the data 
     * bound elements referencing this element.
     * Example:
     * <code>
     *  <a:bindings id="bndFolders" >
     *      <a:caption match="[@name]" />
     *      <a:icon match="[@icon]" />
     *      <a:each match="[folder]" sort="[@name]" />
     *  </a:bindings>
     *
     *  <a:tree bindings="bndFolders" />
     * </code>
     * @see element.smartbinding
     * @allowchild {bindings}
     * @addnode smartbinding, global
     * @addnode smartbinding, global
     */
    this.addEventListener("DOMNodeInsertedIntoDocument", function(e){
        if (this.parentNode.hasFeature(apf.__DATABINDING__))
            this.register(this.parentNode);

        
        apf.console.info(this.name
            ? "Creating SmartBinding [" + this.name + "]"
            : "Creating implicitly assigned SmartBinding");
        
    });
}).call(apf.smartbinding.prototype = new apf.AmlElement());

apf.aml.setElement("smartbinding", apf.smartbinding);



/*FILEHEAD(/var/lib/platform/source/trunk/elements/markupedit.js)SIZE(56251)TIME(1271026884)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */








var HAS_CHILD = 1 << 1,
    IS_CLOSED = 1 << 2,
    IS_LAST   = 1 << 3,
    IS_ROOT   = 1 << 4;

/**
 * Element for editing markup in the same way firebug provides.
 *
 * @experimental
 * @todo see if it's possible to create a tree baseclass
 * @constructor
 * @allowchild {smartbinding}
 * @addnode elements:markupedit
 *
 * @inherits apf.XForms
 * @inherits apf.MultiSelect
 * @inherits apf.Cache
 * @inherits apf.DataAction
 * @inherits apf.GuiElement
 *
 * @author      Ruben Daniels (ruben AT ajax DOT org)
 * @version     %I%, %G%
 * @since       0.98.3
 * @default_private
 *
 * @binding css      Determines a css class for a node.
 * @binding empty    Determines the empty message of a node.
 */
apf.markupedit = function(struct, tagName){
    this.$init(tagName || "markupedit", apf.NODE_VISIBLE, struct);
};

(function(){
    this.implement(
        
        
        apf.DataAction,
        
        apf.Rename,
        //apf.MultiSelect,
        apf.Cache
    );

    this.$isTreeArch  = true; // Tree Architecture for loading Data
    this.$focussable  = true; // This object can get the focus

    this.$preventRecursiveUpdate = true;
    this.$enableTextNodeHack     = true;
    
    this.startcollapsed = true;
    this.$animType      = 0;
    this.$animSteps     = 3;
    this.$animSpeed     = 20;
    this.reselectable   = true; //@todo hack!
    
    this.prerender     = false;
    this.each          = "node()[local-name(.) and not(@nomk = 'true')]";
    
    
    this.$dynCssClasses = [];
    
    
    /* ********************************************************************
                                        PUBLIC METHODS
    *********************************************************************/
    
    this.expandAndSelect = function(xmlNode) {
        var _self = this;
        (function _recur(loopNode){
            var pNode = _self.getTraverseParent(loopNode);
            if (pNode != _self.xmlRoot)
                _recur(pNode);
            _self.slideToggle(apf.xmldb.getHtmlNode(pNode, _self), 1, true);
        })(xmlNode);
        
        this.select(xmlNode);
    }
    
    /**
     * Sets an attribute to an xml node
     *
     */
    this.setAttributeValue = function(xmlNode, name, value){
        if (!xmlNode)
            xmlNode = this.caret || this.selected;

        if (!xmlNode || xmlNode.getAttribute(name) == value) 
            return;
        
        this.$executeAction("setAttribute", [xmlNode, name, value],
            "setAttributeValue", xmlNode);
    };
    
    /**
     * Remove an attribute
     *
     */
    this.removeAttribute = function(xmlNode, name, value){
        if (!xmlNode)
            xmlNode = this.caret || this.selected;

        if (!xmlNode || xmlNode.getAttribute(name) == value) 
            return;
        
        this.$executeAction("removeAttribute", [xmlNode, name],
            "removeAttribute", xmlNode);
    };
    
    /**
     * Renames an attribute of an xml node
     *
     */
    this.renameAttribute = function(xmlNode, name, newName){
        if (!xmlNode)
            xmlNode = this.caret || this.selected;

        if (!xmlNode || name == newName) 
            return;
        
        this.$executeAction("multicall", [
              {func: "removeAttribute", args: [xmlNode, name]},
              {func: "setAttribute", args: [xmlNode, newName, xmlNode.getAttribute(name)]}
            ], "renameAttribute", xmlNode);
    };
    
    /**
     * Sets a text node to an xml node
     *
     */
    this.setTextNode = function(xmlNode, value){
        if (!xmlNode)
            xmlNode = this.caret || this.selected;

        if (!xmlNode || apf.queryValue(xmlNode, "text()") == value) 
            return;
        
        this.$executeAction("setTextNode", [xmlNode, value], "setTextNode", xmlNode);
    };
    
    
    /**
     * @private
     */
    this.slideToggle = function(htmlNode, force, immediate){
        if (this.nocollapse) 
            return;

        if (!htmlNode)
            htmlNode = this.$selected;
        
        var id = htmlNode.getAttribute(apf.xmldb.htmlIdTag);
        while (!id && htmlNode.parentNode)
            var id = (htmlNode = htmlNode.parentNode)
                .getAttribute(apf.xmldb.htmlIdTag);

        var elClass, container = this.$getLayoutNode("item", "container", htmlNode);
        if (apf.getStyle(container, "display") == "block") {
            if (force == 1) return;
            elClass = this.$getLayoutNode("item", "openclose", htmlNode);
            elClass.className = elClass.className.replace(/min/, "plus");
            htmlNode.className = htmlNode.className.replace(/min/, "plus");
            this.slideClose(container, apf.xmldb.getNode(htmlNode), immediate);
        }
        else {
            if (force == 2) return;
            elClass = this.$getLayoutNode("item", "openclose", htmlNode);
            elClass.className = elClass.className.replace(/plus/, "min");
            htmlNode.className = htmlNode.className.replace(/plus/, "min");
            this.slideOpen(container, apf.xmldb.getNode(htmlNode), immediate);
        }
    };
    
    this.isCollapsed = function(xmlNode){
        return (apf.getStyle(this.$getLayoutNode("item", "container",
            apf.xmldb.getHtmlNode(xmlNode, this)), "display") == "none");
    }
    
    var lastOpened = {};
    /**
     * @private
     */
    this.slideOpen = function(container, xmlNode, immediate){
        if (!xmlNode)
            xmlNode = this.selected;
        
        var htmlNode = apf.xmldb.findHtmlNode(xmlNode, this);
        if (!container)
            container = this.$findContainer(htmlNode);
        
        //We don't slide open elements without children.
        if (!container.innerHTML && !this.getTraverseNodes(xmlNode).length)
            return; 

        if (this.singleopen) {
            var pNode = this.getTraverseParent(xmlNode),
                p     = (pNode || this.xmlRoot).getAttribute(apf.xmldb.xmlIdTag);
            if (lastOpened[p] && lastOpened[p][1] != xmlNode 
              && this.getTraverseParent(lastOpened[p][1]) == pNode)
                this.slideToggle(lastOpened[p][0], 2);//lastOpened[p][1]);
            lastOpened[p] = [htmlNode, xmlNode];
        }
        
        container.style.display = "block";
        if (!this.prerender && this.$hasLoadStatus(xmlNode, "potential")) {
            this.$extend(xmlNode, container, immediate);
            return;
        }
        
        if (immediate) {
            container.style.height = "auto";
            return;
        }

        var _self = this;
        apf.tween.single(container, {
            type    : 'scrollheight', 
            from    : 0, 
            to      : container.scrollHeight, 
            anim    : this.$animType, 
            steps   : this.$animOpenStep,
            interval: this.$animSpeed,
            onfinish: function(container){
                if (xmlNode && _self.$hasLoadStatus(xmlNode, "potential")) {
                    $setTimeout(function(){
                        _self.$extend(xmlNode, container);
                    });
                    container.style.height = "auto";
                }
                else {
                    //container.style.overflow = "visible";
                    container.style.height = "auto";
                }
            }
        });
    };

    /**
     * @private
     */
    this.slideClose = function(container, xmlNode){
        if (this.nocollapse) 
            return;
        
        if (!xmlNode)
            xmlNode = this.selected;
        
        if (this.singleopen) {
            var p = (this.getTraverseParent(xmlNode) || this.xmlRoot)
                .getAttribute(apf.xmldb.xmlIdTag);
            lastOpened[p] = null;
        }
        
        container.style.height   = container.offsetHeight;
        container.style.overflow = "hidden";

        apf.tween.single(container, {
            type    : 'scrollheight', 
            from    : container.scrollHeight, 
            to      : 0, 
            anim    : this.$animType, 
            steps   : this.$animCloseStep,
            interval: this.$animSpeed,
            onfinish: function(container, data){
               container.style.display = "none";
            }
        });
    };

    //check databinding for how this is normally implemented
    //PROCINSTR
    this.doUpdate = function(xmlNode, container){
        var rule       = this.$getBindRule("insert", xmlNode);
        var xmlContext = rule && rule[1] 
            ? rule[1](xmlNode) 
            : null;
        
        if (rule && xmlContext) {
            this.$setLoadStatus(xmlNode, "loading");
            
            if (rule.getAttribute("get")) {
                this.getModel().$insertFrom(rule.getAttribute("get"), {
                    xmlNode     : xmlContext,
                    insertPoint : xmlContext, 
                    amlNode     : this
                });
            }
            else {
                var data = this.$applyBindRule("Insert", xmlNode);
                if (data)
                    this.insert(data, {insertPoint: xmlContext});
            }
        }
        else
            if (!this.prerender) {
                this.$setLoadStatus(xmlNode, "loading");
                var result = this.$addNodes(xmlNode, container, true); //checkChildren ???
                xmlUpdateHandler.call(this, "insert", xmlNode, result);
            }
    };
    
    /* ***********************
                Skin
    ************************/

    var treeState = {};
    treeState[0]                                     = "";
    treeState[HAS_CHILD]                             = "min";
    treeState[HAS_CHILD | IS_CLOSED]                 = "plus";
    treeState[IS_LAST]                               = "last";
    treeState[IS_LAST | HAS_CHILD]                   = "minlast";
    treeState[IS_LAST | HAS_CHILD | IS_CLOSED]       = "pluslast";
    treeState[IS_ROOT]                               = "root";

    this.fixItem = function(xmlNode, htmlNode, isDeleting, oneLeft, noChildren){
        if (!htmlNode) return;

        if (isDeleting) {
            //if isLast fix previousSibling
            var prevSib;
            if (prevSib = this.getNextTraverse(xmlNode, true))
                this.fixItem(prevSib, this.$findHtmlNode(
                    prevSib.getAttribute(apf.xmldb.xmlIdTag) + "|" 
                    + this.$uniqueId), null, true);

            //if no sibling fix parent
            if (!this.emptyMessage 
              && xmlNode.parentNode.selectNodes(this.each).length == 1) //@todo each parent??
                this.fixItem(xmlNode.parentNode, this.$findHtmlNode(
                    xmlNode.parentNode.getAttribute(apf.xmldb.xmlIdTag) 
                    + "|" + this.$uniqueId), null, false, true); 
        }
        else {
            var hasChildren, container = this.$getLayoutNode("item", "container", htmlNode);
            
            if (noChildren)
                hasChildren = false;
            else
                if (xmlNode.selectNodes(this.each).length > 0)
                    hasChildren = true;
            else
                if (this.$getBindRule("insert", xmlNode))
                    hasChildren = true;
            else
                hasChildren = false;
            
            var isClosed = hasChildren && container.style.display != "block";
            var isLast   = this.getNextTraverse(xmlNode, null, oneLeft ? 2 : 1) 
                ? false 
                : true;

            var state = (hasChildren ? HAS_CHILD : 0) | (isClosed ? IS_CLOSED : 0) 
                | (isLast ? IS_LAST : 0);
            this.$setStyleClass(this.$getLayoutNode("item", "openclose", 
                htmlNode), treeState[state], ["min", "plus", "last", "minlast", 
                "pluslast"]);
            this.$setStyleClass(this.$getLayoutNode("item", null, 
                htmlNode), treeState[state], ["min", "plus", "last", "minlast", 
                "pluslast"]);
            
            if (!hasChildren)
                container.style.display = "none";
            
            if (state & HAS_CHILD) {
                //this.$getLayoutNode("item", "openclose", htmlNode).onmousedown = new Function('e', 'if(!e) e = event; if(e.button == 2) return;var o = apf.lookup(' + this.$uniqueId + ');o.slideToggle(this);if(o.onmousedown) o.onmousedown(e, this);apf.cancelBubble(e, o);');
                //this.$getLayoutNode("item", "icon", htmlNode)[this.opencloseaction || "ondblclick"] = new Function('var o = apf.lookup(' + this.$uniqueId + '); o.slideToggle(this);o.choose();');
                //this.$getLayoutNode("item", "select", htmlNode)[this.opencloseaction || "ondblclick"] = new Function('e', 'var o = apf.lookup(' + this.$uniqueId + '); o.slideToggle(this, true);o.choose();(e||event).cancelBubble=true;');
            }
            /*else{
                //Experimental
                this.$getLayoutNode("item", "openclose", htmlNode).onmousedown = null;
                this.$getLayoutNode("item", "icon", htmlNode)[this.opencloseaction || "ondblclick"] = null;
                this.$getLayoutNode("item", "select", htmlNode)[this.opencloseaction || "ondblclick"] = null;
            }*/
        }
    };
    
    this.startRenameThis = function(oHtml, Lid, isName, id){
        if (this.renaming) {
            this.stopRename(null, true);
            var _self = this;
            return setTimeout(function(){
                _self.startRenameThis(oHtml, Lid, isName);
            });
        }
        
        this.$getCaptionElement = function(){
            return oHtml;
        }
        
        var attrName = oHtml.getAttribute("aname");
        
        var xmlNode = id ? knownElements[id] : apf.xmldb.getNodeById(Lid);
        if (!xmlNode) throw new Error();

        this.$multiLineRename = id && xmlNode.nodeType != 3 ? true : false;

        /*if (!this.isSelected(xmlNode)) {
            this.select(xmlNode);
            return;
        }*/
        
        this.$getCaptionXml = function(){ //@todo
            return xmlNode.nodeType != 1 ? xmlNode 
                : (attrName ? xmlNode.getAttributeNode(attrName) : xmlNode.firstChild);
        }
        
        this.getSelectFromRule = function(setname, cnode){
            return [null, xmlNode.nodeType != 1 ? xmlNode 
                : (attrName ? xmlNode.getAttributeNode(attrName) : xmlNode.firstChild)];
        };
        
        this.$validateRename = function(value){
            return !isName || !value || value.match(/^[a-z]/i);
        }
        
        this.rename = function(x, value){
            this.$noanim = true;
            if (attrName) {
                if (isName) { 
                    if (value == "")
                        this.removeAttribute(xmlNode, attrName);
                    else
                        this.renameAttribute(xmlNode, attrName, value);
                }
                else
                    this.setAttributeValue(xmlNode, attrName, value);
            }
            else
                this.setTextNode(xmlNode, value);
            this.$noanim = false;
        };
        
        this.startRename();
        
        if (isName) {
            this.$txt[apf.hasContentEditable ? "innerHTML" : "value"] = attrName;
            this.$txt.className = "";
        }
        else
            this.$txt.className = "attrvalue";
        
        apf.selectTextHtml(this.$txt);
    }
    
    /**
     * @todo  Make it xmlNode locked
     * @todo  Use escape(27) key to cancel change (see rename)
     */
    function addAttribute(pNode, name, value, htmlNode, Lid){
        this.$getNewContext("attribute");
        var elName = this.$getLayoutNode("attribute", "name");
        var elValue = this.$getLayoutNode("attribute", "value");
        apf.setNodeValue(elName, name);
        apf.setNodeValue(elValue, (value.length > 50 ? "..." : value));
        if (value.length > 50)
            elValue.setAttribute("title", value);

        elName.setAttribute("aname", name);
        elName.setAttribute("onmousedown", "apf.lookup(" + this.$uniqueId + ").startRenameThis(this, '" + Lid + "', true);\
            event.cancelBubble=true;");
        elName.setAttribute("onmouseup", "\
            event.cancelBubble=true;\
            return false;");
        elName.setAttribute("onkeydown", "if (event.keyCode==13) {\
              this.blur();\
              return false;\
            };\
            event.cancelBubble=true;");
        elName.setAttribute("onselectstart", "event.cancelBubble = true;");
        elName.setAttribute("ondblclick", "event.cancelBubble = true;");
        
        elValue.setAttribute("aname", name);
        elValue.setAttribute("onmousedown", "apf.lookup(" + this.$uniqueId + ").startRenameThis(this, '" + Lid + "');\
            event.cancelBubble=true;");
        elValue.setAttribute("onmouseup", "\
            event.cancelBubble=true;\
            return false;");
        elValue.setAttribute("onkeydown", "if (event.keyCode==13) {\
              this.blur();\
              return false;\
            };\
            event.cancelBubble=true;");
        elValue.setAttribute("onselectstart", "event.cancelBubble = true;");
        elValue.setAttribute("ondblclick", "event.cancelBubble = true;");
        
        if (pNode.style) {
            this.$setStyleClass(this.$getLayoutNode("attribute"), "generated");
            
            htmlNode = apf.insertHtmlNode(
                this.$getLayoutNode("attribute"), 
                pNode, 
                this.$getLayoutNode("item", "begintag", htmlNode).nextSibling);
            
            if (!this.$noanim) {
                animHighlight(htmlNode);
                animHighlight(this.$getLayoutNode("attribute", "name", htmlNode));
                animHighlight(this.$getLayoutNode("attribute", "value", htmlNode));
            }
        }
        else
            pNode.appendChild(this.$getLayoutNode("attribute"));
    }
    
    function addTextnode(pNode, value, Lid){
        this.$getNewContext("textnode");
        var elTextNode = this.$getLayoutNode("textnode", "text");
        var elTag = this.$getLayoutNode("textnode", "tag");
        apf.setNodeValue(elTextNode, (value.length > 50 ? "..." : value));
        if (value.length > 50)
            elTextNode.setAttribute("title", value);
        
        elTextNode.setAttribute("onmousedown", "apf.lookup(" + this.$uniqueId + ").startRenameThis(this, '" + Lid + "');");
        elTextNode.setAttribute("onmouseup", "\
            event.cancelBubble=true;\
            return false;");
        elTextNode.setAttribute("onkeydown", "if (event.keyCode==13) {\
              this.blur();\
              return false;\
            };\
            event.cancelBubble=true;");
        elTextNode.setAttribute("onselectstart", "event.cancelBubble = true;");
        elTextNode.setAttribute("ondblclick", "event.cancelBubble = true;");
        
        apf.setNodeValue(elTag, "&gt;");
        
        if (pNode.style) {
            var htmlNode = apf.insertHtmlNode(
                this.$getLayoutNode("textnode"), pNode, pNode.lastChild);
            
            if (!this.$noanim)
                animHighlight(this.$getLayoutNode("textnode", "text", htmlNode));
        }
        else
            pNode.appendChild(this.$getLayoutNode("textnode"));
    }

    //This can be optimized by NOT using getLayoutNode all the time
    this.$initNode = function(xmlNode, state, Lid){
        //Setup Nodes Interaction
        this.$getNewContext("item");
        
        var hasChildren = (state & HAS_CHILD || this.emptyMessage 
            && this.$applyBindRule("empty", xmlNode));
        
        //should be restructured and combined events set per element 
        var elItem = this.$getLayoutNode("item");
        elItem.setAttribute(apf.xmldb.htmlIdTag, Lid);
        
        //Set open/close skin class & interaction
        this.$setStyleClass(this.$getLayoutNode("item", "openclose"), 
            treeState[state]);
        this.$setStyleClass(this.$getLayoutNode("item"), 
            treeState[state])
        var elOpenClose = this.$getLayoutNode("item", "openclose");
        if (hasChildren)
            elOpenClose.setAttribute(this.opencloseaction || "onmousedown",
                "var o = apf.lookup(" + this.$uniqueId + ");\
                o.slideToggle(this);\
                apf.cancelBubble(event,o);");
        
        //Select interaction
        var elSelect = this.$getLayoutNode("item", "select");
        if (hasChildren) {
            var strFunc2 = "var o = apf.lookup(" + this.$uniqueId + ");\
                o.slideToggle(this, true);";
            //if(this.opencloseaction != "onmousedown") elSelect.setAttribute(this.opencloseaction || "ondblclick", strFunc2);
        }
        //if(event.button != 1) return; 
        //apf.isChildOf(o.$selected, this) && o.selected [REMOVED THIS LINE... dunno what the repurcusions are exactly]
        elSelect.setAttribute("onmousedown", "var o = apf.lookup(" + this.$uniqueId + ");\
            apf.cancelBubble(event, o);\
            if (o.hasFocus()) \
                o.select(this);" 
            + (strFunc2 && this.opencloseaction == "onmousedown" ? strFunc2 : ""));
        //if(!elSelect.getAttribute("ondblclick")) elSelect.setAttribute("ondblclick", 'var o = apf.lookup(' + this.$uniqueId + ');o.choose();');

        //elItem.setAttribute("contextmenu", 'alert(1);var o = apf.lookup(' + this.$uniqueId + ');o.dispatchEvent("contextMenu", o.selected);');
        
        var elBegin = this.$getLayoutNode("item", "begintag");
        apf.setNodeValue(elBegin, "&lt;" + xmlNode.tagName);
        
        //attributes
        var elAttributes = this.$getLayoutNode("item", "attributes");
        var len = xmlNode.attributes.length;
        if (typeof len == "function")
            len = xmlNode.attributes.length();
        for (var i = 0; i < len; i++) {
            var attr = xmlNode.attributes.item(i);
            if (attr.nodeName.match(/a_id|a_listen|a_doc|a_loaded/))
                continue;
            
            addAttribute.call(this, elAttributes, attr.nodeName, 
                attr.nodeValue, null, Lid);
        }
        
        var elBeginTail = this.$getLayoutNode("item", "begintail");
        var elEnd = this.$getLayoutNode("item", "endtag");
        if (!(state&HAS_CHILD)) {
            elEnd.setAttribute("style", "display:none");

            if (this.$enableTextNodeHack && (xmlNode.childNodes.length > 1 
              || xmlNode.childNodes.length == 1 
              && xmlNode.firstChild.nodeValue.trim())) {
                addTextnode.call(this, elAttributes, xmlNode.childNodes[0].nodeValue, Lid);
                apf.setNodeValue(elBeginTail, "&lt;/" + xmlNode.tagName + "&gt;");
            }
            else
                apf.setNodeValue(elBeginTail, " /&gt;");
        }
        else {
            apf.setNodeValue(elEnd, "&lt;/" + xmlNode.tagName + "&gt;");
            apf.setNodeValue(elBeginTail, "&gt;");
        }
        elBeginTail.parentNode.appendChild(elBeginTail);
        
        elEnd.setAttribute("onmousedown", 'var o = apf.lookup(' + this.$uniqueId + ');apf.cancelBubble(event, o);');
        
        
        var cssClass = this.$applyBindRule("css", xmlNode);
        if (cssClass) {
            this.$setStyleClass(this.$getLayoutNode("item", null, 
                this.$getLayoutNode("item")), cssClass);
            if (cssClass)
                this.$dynCssClasses.push(cssClass);
        }
        

        return this.$getLayoutNode("item");
    };
    
    this.$deInitNode = function(xmlNode, htmlNode){
        //Lookup container
        var containerNode = this.$getLayoutNode("item", "container", htmlNode);
        var pContainer    = htmlNode.parentNode;
        
        //Remove htmlNodes from tree
        containerNode.parentNode.removeChild(containerNode);
        pContainer.removeChild(htmlNode);
        
        //Fix Images (+, - and lines)
        if (xmlNode.parentNode != this.xmlRoot)
            this.fixItem(xmlNode, htmlNode, true);
        
        if (this.emptyMessage && !pContainer.childNodes.length)
            this.setEmpty(pContainer);
        
        //Fix look (tree thing)
        this.fixItem(xmlNode, htmlNode, true);
        
        if (xmlNode == this.selected)
            this.clearSelection();
        
        //this.fixItem(xmlNode.parentNode, apf.xmldb.findHtmlNode(xmlNode.parentNode, this));
        /*throw new Error();
        if(xmlNode.previousSibling) //should use each here
            this.fixItem(xmlNode.previousSibling, apf.xmldb.findHtmlNode(xmlNode.previousSibling, this));*/
    };
    
    function animHighlight(oHtml){
        if (!oHtml.offsetHeight) return;

        apf.setStyleClass(oHtml, "highlight");
        $setTimeout(function(){
            /*apf.tween.css(oHtml, "highlight", {
                anim    : 0, 
                steps   : 20, 
                interval: 30}, true);*/
            apf.setStyleClass(oHtml, "", ["highlight"]);
        }, 1000);
    }
    
    this.$updateNode = function(xmlNode, htmlNode){
        //Attributes
        var len, i, aLookup   = {};
        var elAttributes = this.$getLayoutNode("item", "attributes", htmlNode);
        var elEnd        = this.$getLayoutNode("item", "endtag", htmlNode);
        var elBeginTail  = this.$getLayoutNode("item", "begintail", htmlNode);

        //if (typeof len == "function")
            len = xmlNode.attributes.length;
        for (var i = 0; i < len; i++) {
            var attr = xmlNode.attributes.item(i);
            if (attr.nodeName.match(/a_id|a_listen|a_doc|a_loaded/))
                continue;
            aLookup[attr.nodeName] = attr.nodeValue;
        }

        var doneFirstChild     = false;
        var deleteQueue        = [];
        var nodes = [], cnodes = elAttributes.childNodes;
        for (i = 0; i < cnodes.length; i++)
            nodes.push(cnodes[i]);
        
        for (i = 0; i < nodes.length; i++) {
            if (nodes[i].nodeType != 1)
                continue;
            
            if (nodes[i].className.indexOf("textnode") > -1) {
                if (xmlNode.childNodes.length == 1 
                  && xmlNode.childNodes[0].nodeType == 3) {
                    var elText = this.$getLayoutNode("textnode", "text", nodes[i]);
                    if (xmlNode.firstChild.nodeValue != elText.innerHTML) {
                        elText.innerHTML = xmlNode.firstChild.nodeValue;
                        //Animate change here
                        animHighlight(elText);
                    }
                }
                else {
                    nodes[i].parentNode.removeChild(nodes[i]);//apf.removeChild here??
                    apf.setNodeValue(elBeginTail, " /&gt;");
                }
                
                doneFirstChild = true;
            }
            
            if (nodes[i].className.indexOf("attribute") == -1) 
                continue;
            
            var elName  = this.$getLayoutNode("attribute", "name", nodes[i]);
            var elValue = this.$getLayoutNode("attribute", "value", nodes[i]);
            
            //Remove attribute if it no longer exists
            var name = elName.innerHTML;
            if (!name in aLookup) //aLookup[name])
                deleteQueue.push(nodes[i]);
            //Change it
            else if(aLookup[name] != elValue.innerHTML) {
                elValue.innerHTML = aLookup[name];
                
                animHighlight(elValue);
                //Animate change here...
                delete aLookup[name];
            } 
            else if(name in aLookup) //aLookup[name])
                delete aLookup[name];
            
            elName.setAttribute("aname", name);
            elValue.setAttribute("aname", name);
        }

        //Add the remaining attributes
        for (var attr in aLookup) {
            if (deleteQueue.length) {
                var html = deleteQueue.pop();
                var elName  = this.$getLayoutNode("attribute", "name", html);
                var elValue = this.$getLayoutNode("attribute", "value", html);
                elName.setAttribute("aname", attr);
                elValue.setAttribute("aname", attr);
                elName.innerHTML  = attr;
                elValue.innerHTML = aLookup[attr];
                
                animHighlight(elName);
            }
            else {
                addAttribute.call(this, elAttributes, attr, aLookup[attr], htmlNode, 
                  xmlNode.getAttribute(apf.xmldb.xmlIdTag) + "|" + this.$uniqueId);
            }
        }
        
        //Remove remaining queue
        for (var i = 0; i < deleteQueue.length; i++) {
            deleteQueue[i].parentNode.removeChild(deleteQueue[i]);//apf.removeChild here??
        }
        
        //Add textnode if its not there yet
        if (this.$enableTextNodeHack && !doneFirstChild 
          && xmlNode.childNodes.length == 1 
          && xmlNode.childNodes[0].nodeType == 3) {
            addTextnode.call(this, elAttributes, xmlNode.childNodes[0].nodeValue);
            apf.setNodeValue(elBeginTail, "</" + xmlNode.tagName + ">");
        }
        
        
        var cssClass = this.$applyBindRule("css", xmlNode);
        if (cssClass || this.$dynCssClasses.length) {
            this.$setStyleClass(htmlNode, cssClass, this.$dynCssClasses);
            if (cssClass && !this.$dynCssClasses.contains(cssClass))
                this.$dynCssClasses.push(cssClass);
        }
        
    };
    
    this.clearEmpty = function(container){
        container.innerHTML = "";
    };
        
    this.setEmpty = function(container){
        this.$getNewContext("empty");
        var oItem = this.$getLayoutNode("empty");
        this.$getLayoutNode("empty", "caption").nodeValue = this.emptyMessage;
        apf.insertHtmlNode(oItem, container);
        
        if (!this.startcollapsed) {
            if (container.style) {
                //container.style.display = "block";
                //container.style.height = "auto";
            }
            //else container.setAttribute("style", "display:block;height:auto;");
        }
    };
    
    this.$setLoading = function(xmlNode, container){
        this.$getNewContext("loading");
        this.$setLoadStatus(xmlNode, "potential");
        apf.insertHtmlNode(this.$getLayoutNode("loading"), container);
    };
    
    this.$removeLoading = function(htmlNode){
        if (!htmlNode) return;
        this.$getLayoutNode("item", "container", htmlNode).innerHTML = "";
    };
    
    //check databinding for how this is normally implemented
    this.$extend = function(xmlNode, container, immediate){
        var rule       = this.$getBindRule("insert", xmlNode),
            xmlContext = rule && rule.match
                ? (rule.cmatch || rule.compile("match"))(xmlNode)
                : xmlNode;

        if (rule && xmlContext) {
            this.$setLoadStatus(xmlNode, "loading");
            
            if (rule.get) {
                
                
                this.getModel().$insertFrom(rule.getAttribute("get"), {
                    xmlNode     : xmlContext,
                    insertPoint : xmlContext, 
                    amlNode     : this
                });
            }
            else {
                if (this.$applyBindRule("insert", xmlNode))
                    this.insert(data, {insertPoint: xmlContext});
            }
        }
        else if (!this.prerender) {
            this.$setLoadStatus(xmlNode, "loading");
            this.$removeLoading(apf.xmldb.findHtmlNode(xmlNode, this));
            
            this.$noanim = true;
            xmlUpdateHandler.call(this, {
                action  : "insert", 
                xmlNode : xmlNode, 
                result  : this.$addNodes(xmlNode, container, true), //checkChildren ???
                anim    : !immediate
            });
            delete this.$noanim;
        }
    };
    
    function xmlUpdateHandler(e){
        /*
            Display the animation if the item added is 
            * Not in the cache
            - Being insterted using xmlUpdate
            - there is at least 1 child inserted
        */
        
        if (e.action == "move-away")
            this.fixItem(e.xmlNode, apf.xmldb.findHtmlNode(e.xmlNode, this), true);

        if (e.action != "insert") return;
        
        var htmlNode = this.$findHtmlNode(e.xmlNode.getAttribute(apf.xmldb.xmlIdTag)+"|"+this.$uniqueId);
        if (!htmlNode) return;
        if (this.$hasLoadStatus(e.xmlNode, "loading") && e.result.length > 0) {
            var container = this.$getLayoutNode("item", "container", htmlNode);
            this.slideOpen(container, e.xmlNode);
        }
        else
            this.fixItem(e.xmlNode, htmlNode);
        
        //Can this be removed?? (because it was added in the insert function)
        if (this.$hasLoadStatus(e.xmlNode, "loading"))
            this.$setLoadStatus(e.xmlNode, "loaded");
    }
    
    this.addEventListener("xmlupdate", xmlUpdateHandler);
    this.addEventListener("beforeload", function(e){
        this.$enableTextNodeHack = !e.xmlNode.$regbase;
        this.each = e.xmlNode.$regbase
            ? "node()[not(@nomk = 'true')]"
            : "node()[local-name(.) and not(@nomk = 'true')]";
    });
    
    /* ***********************
        Keyboard Support
    ************************/
    
    
    this.addEventListener("keydown", function(e){
        var key      = e.keyCode;
        var ctrlKey  = e.ctrlKey;
        var shiftKey = e.shiftKey;
        var selHtml  = this.$caret || this.$selected;
        
        if (!selHtml || this.renaming) 
            return;

        var selXml = this.caret || this.selected;
        var oExt   = this.$ext;

        switch (key) {
            case 13:
                if (this.$tempsel)
                    this.$selectTemp();
            
                if (this.ctrlselect == "enter")
                    this.select(this.caret, true);
            
                this.choose(selHtml);
                break;
            case 32:
                if (ctrlKey)
                    this.select(this.caret, true);
                break;
            case 46:
                if (this.$tempsel)
                    this.$selectTemp();
            
                //DELETE
                //this.remove();
                this.remove(this.mode ? this.caret : null); //this.mode != "check"
                break;
            case 109:
            case 37:
                //LEFT
                if (this.$tempsel)
                    this.$selectTemp();
                    
                if (this.caret.selectSingleNode(this.each))
                    this.slideToggle(this.$caret || this.$selected, 2)
                break;
            case 107:
            case 39:
                //RIGHT
                if (this.$tempsel)
                    this.$selectTemp();
            
                if (this.caret.selectSingleNode(this.each))
                    this.slideToggle(this.$caret || this.$selected, 1)
                break;
            case 187:
                //+
                if (shiftKey)
                    arguments.callee(39);
            break;
            case 189:
                //-
                if (!shiftKey)
                    arguments.callee(37);
                break;
            case 38:
                //UP
                if (!selXml && !this.$tempsel) 
                    return;
                
                var node = this.$tempsel 
                    ? apf.xmldb.getNode(this.$tempsel) 
                    : selXml;
                
                var sNode = this.getNextTraverse(node, true);
                if (sNode) {
                    var nodes = this.getTraverseNodes(sNode);
                    
                    do {
                        var container = this.$getLayoutNode("item", "container",
                            this.$findHtmlNode(apf.xmldb.getID(sNode, this)));
                        if (container && apf.getStyle(container, "display") == "block" 
                          && nodes.length) {
                                sNode = nodes[nodes.length-1];
                        }
                        else 
                            break;
                    }
                    while (sNode && (nodes = this.getTraverseNodes(sNode)).length);
                }
                else if (this.getTraverseParent(node) == this.xmlRoot) {
                    this.dispatchEvent("selecttop");
                    return;
                }
                else
                    sNode = this.getTraverseParent(node);

                if (sNode && sNode.nodeType == 1)
                   this.$setTempSelected (sNode, ctrlKey, shiftKey);
                
                if (this.$tempsel && this.$tempsel.offsetTop < oExt.scrollTop)
                    oExt.scrollTop = this.$tempsel.offsetTop;
                
                return false;
             
                break;
            case 40:
                //DOWN
                if (!selXml && !this.$tempsel) 
                    return;
                    
                var node = this.$tempsel 
                    ? apf.xmldb.getNode(this.$tempsel) 
                    : selXml;
                
                var sNode = this.getFirstTraverseNode(node);
                if (sNode) {
                    var container = this.$getLayoutNode("item", "container",
                        this.$findHtmlNode(apf.xmldb.getID(node, this)));
                    if (container && apf.getStyle(container, "display") != "block")
                        sNode = null;
                }
                
                while (!sNode) {
                    var pNode = this.getTraverseParent(node);
                    if (!pNode) break;
                    
                    var i = 0;
                    var nodes = this.getTraverseNodes(pNode);
                    while (nodes[i] && nodes[i] != node)
                        i++;
                    sNode = nodes[i+1];
                    node  = pNode;
                }
                
                if (sNode && sNode.nodeType == 1)
                   this.$setTempSelected (sNode, ctrlKey, shiftKey);
                
                if (this.$tempsel && this.$tempsel.offsetTop + this.$tempsel.offsetHeight
                  > oExt.scrollTop + oExt.offsetHeight)
                    oExt.scrollTop = this.$tempsel.offsetTop 
                        - oExt.offsetHeight + this.$tempsel.offsetHeight + 10;
                
                return false;
                break;
            case 33: //@todo
                //PGUP
                break;
            case 34: //@todo
                //PGDN
                break;
            case 36: //@todo
                //HOME
                break;
            case 35: //@todo
                //END
                break;
        }
    }, true);
    
    
    /* ***********************
            DATABINDING
    ************************/

    var nodes = [];

    this.$add = function(xmlNode, Lid, xmlParentNode, htmlParentNode, beforeNode, isLast){
        //Why is this function called 3 times when adding one node? (hack/should)
        var loadChildren     = this.$getBindRule("insert", xmlNode) ? true : false,
            traverseNodes    = this.getTraverseNodes(xmlNode),
            hasTraverseNodes = traverseNodes.length ? true : false,
            hasChildren      = loadChildren || hasTraverseNodes,
            startcollapsed   = this.$hasBindRule("collapsed")
                ? (this.$getDataNode("collapsed", xmlNode) ? true : false)
                : (this.$hasBindRule("expanded") 
                    ? (this.$getDataNode("expanded", xmlNode) ? false : true)
                    : this.startcollapsed),
            state            = (hasChildren ? HAS_CHILD : 0) 
                | (startcollapsed && hasChildren  || loadChildren ? IS_CLOSED : 0) 
                | (isLast ? IS_LAST : 0),
            htmlNode         = this.$initNode(xmlNode, state, Lid),
            container        = this.$getLayoutNode("item", "container"),
            eachLength;

        if (!startcollapsed && !this.nocollapse)
            container.setAttribute("style", "overflow:visible;height:auto;display:block;");
        
        //TEMP on for dynamic subloading
        if (!hasChildren || loadChildren)
            container.setAttribute("style", "display:none;");
        
        //Dynamic SubLoading (Insertion) of SubTree
        if (!this.prerender)
            eachLength = traverseNodes.length;

        //Dynamic SubLoading (Insertion) of SubTree
        //@todo weird bug with eachLenght > 2
        if (hasChildren && !this.prerender && eachLength > 0 && startcollapsed
          || loadChildren && (!this.$hasLoadStatus(xmlNode) 
          || this.$hasLoadStatus(xmlNode, "potential"))) {
            this.$setLoading(xmlNode, container);
        }
        else if (!hasTraverseNodes && (msg = this.$applyBindRule("empty", xmlNode))) {
            //this.$setEmptyMessage(container, msg);
            this.setEmpty(container);
        }

        if (!htmlParentNode && (xmlParentNode == this.xmlRoot 
          || xmlNode == this.xmlRoot)) {
            nodes.push(htmlNode);
            if (!apf.isChildOf(htmlNode, container, true))
                nodes.push(container);
            
            this.$setStyleClass(htmlNode,  "root");
            this.$setStyleClass(container, "root");
            
            //if(xmlNode == xmlParentNode) return container;
        }
        else {
            if (!htmlParentNode) {
                htmlParentNode = apf.xmldb.findHtmlNode(xmlNode.parentNode, this);
                htmlParentNode = htmlParentNode 
                    ? this.$getLayoutNode("item", "container", htmlParentNode) 
                    : this.$container;
            }
            
            if (htmlParentNode == this.$container) {
                this.$setStyleClass(htmlNode,  "root");
                this.$setStyleClass(container, "root");
                
                if (this.renderRoot) {
                    var realParent = apf.xmldb.findHtmlNode(this.xmlRoot, this);
                    htmlParentNode = this.$getLayoutNode("item", "container", realParent);
                }
            }
            
            if (!beforeNode && this.getNextTraverse(xmlNode))
                beforeNode = apf.xmldb.findHtmlNode(this.getNextTraverse(xmlNode), this);
            if (beforeNode && beforeNode.parentNode != htmlParentNode)
                beforeNode = null;

            if (htmlParentNode.style && this.getTraverseNodes(xmlNode.parentNode).length == 1) 
                this.clearEmpty(htmlParentNode);
        
            //alert("|" + htmlNode.nodeType + "-" + htmlParentNode.nodeType + "-" + beforeNode + ":" + container.nodeType);
            //Insert Node into Tree
            if (htmlParentNode.style) {
                var q = apf.insertHtmlNode(htmlNode, htmlParentNode, beforeNode);
                if (!this.$noanim)
                    animHighlight(this.$getLayoutNode("item", "select", q));
                
                if (!apf.isChildOf(htmlNode, container, true)) 
                    var container = apf.insertHtmlNode(container, htmlParentNode, beforeNode);
            }
            else {
                htmlParentNode.insertBefore(htmlNode, beforeNode);
                if (!apf.isChildOf(htmlParentNode, container, true)) 
                    htmlParentNode.insertBefore(container, beforeNode);
            }

            //Fix parent if child is added to drawn parentNode
            if (htmlParentNode.style) {
                if(!startcollapsed && this.openOnAdd 
                  && htmlParentNode != this.$container 
                  && htmlParentNode.style.display != "block") 
                    this.slideOpen(htmlParentNode, xmlParentNode);
                
                //this.fixItem(xmlNode, htmlNode); this one shouldn't be called, because it should be set right at init
                this.fixItem(xmlParentNode, apf.xmldb.findHtmlNode(xmlParentNode, this));
                if (this.getNextTraverse(xmlNode, true)) { //should use each here
                    this.fixItem(this.getNextTraverse(xmlNode, true), 
                        apf.xmldb.findHtmlNode(this.getNextTraverse(xmlNode, true), this));
                }
            }
        }
        
        if (this.prerender || eachLength < 1 || !startcollapsed) {
            this.$addNodes(xmlNode, container, false); //checkChildren ???
        }
        /*else {
            this.$setLoadStatus(xmlNode, "potential");
        }*/

        return container;
    };
    
    this.$fill = function(){
        var container;

        //Please please consider moving this to apf.databinding and make it generic.. this is a mess
        /*if(this.renderRoot){
            var htmlNode = apf.xmldb.findHtmlNode(this.xmlRoot, this);
            if(!htmlNode || htmlNode.parentNode != this.$container){
                var nodes = nodes;
                nodes = [];
                
                var Lid = apf.xmldb.nodeConnect(this.documentId, this.xmlRoot, null, this);
                var p = this.$add(this.xmlRoot, Lid, this.xmlRoot, null, null, true);
                for(var i=0;i<nodes.length;i++) p.appendChild(nodes[i]);
            }
            else{
                container = this.$getLayoutNode("item", "container", htmlNode);
            }
        }*/

        apf.insertHtmlNodes(nodes, container || this.$container);
        nodes.length = 0;
    };
    
    var typeName = {};
    typeName[3] = "textnode";
    typeName[4] = "cdata";
    typeName[7] = "procinstr";
    typeName[8] = "comment";
    
    var knownElements = [null];
    this.$addNonElement = function(xmlNode, pNode, checkChildren, insertBefore, depth){
        if (!xmlNode.$regbase) //Won't support non AML nodes for now
            return;
        
        //Check if xmlNode isnt rendered already
        if (checkChildren)
            htmlNode = false;
        
        if (htmlNode)
            return;
        
        if (xmlNode.nodeType == 3) {
            this.$getNewContext("textnode");
            var node = this.$getLayoutNode("textnode");
            var txtNode = this.$getLayoutNode("textnode", "text");
        }
        else {
            //Retrieve DataBind ID
            //var Lid = apf.xmldb.nodeConnect(this.documentId, xmlNode, null, this);
            
            this.$getNewContext("anynode");
            var node     = this.$getLayoutNode("anynode");
            var tagstart = this.$getLayoutNode("anynode", "tagstart");
            var tagend   = this.$getLayoutNode("anynode", "tagend");
            
            switch(xmlNode.nodeType){
                case 4: //CDATA
                    apf.setNodeValue(tagstart, "&lt;![CDATA[");
                    apf.setNodeValue(tagend, "]]&gt;");
                break;
                case 7: //Processing Instruction
                    apf.setNodeValue(tagstart, "&lt;?" + xmlNode.target);
                    apf.setNodeValue(tagend, "?&gt;");
                break;
                case 8: //Comment
                    apf.setNodeValue(tagstart, "&lt;!--");
                    apf.setNodeValue(tagend, "--&gt;");
                break;
                default:
                return;
            }
            
            this.$getLayoutNode("anynode", "openclose").setAttribute("onmousedown", 
                "var o = this.parentNode;\
                 apf.setStyleClass(o, o.className.indexOf('open') > -1 ? '' : 'open', ['open']);")
            
            var txtNode = this.$getLayoutNode("anynode", "text");
        }

        var value = xmlNode.nodeValue;
        if (value.trim().indexOf("\n") > -1) {
            //@todo Changing the nodeValue is technically wrong, but we do it to get rename to play nice.. there are better solution.
            value = (xmlNode.nodeValue = apf.removeStartWhitespaces(value
              .replace(/^ *\n/, "")
              .replace(/\n *$/, "")))
                .replace(/</g, "&lt;")
                .replace(/\n/g, "<br />");
        }
        else
            value = value.trim().replace(/</g, "&lt;");

        apf.setNodeValue(txtNode, value);
        this.$setStyleClass(node, typeName[xmlNode.nodeType], "");
        
        var Lid = xmlNode.parentNode.getAttribute(apf.xmldb.xmlIdTag) + "|" + this.$uniqueId;
        txtNode.setAttribute("onmousedown", "apf.lookup(" + this.$uniqueId 
            + ").startRenameThis(this, '" + Lid + "', false, " 
            + (knownElements.push(xmlNode) - 1) + ");");
        txtNode.setAttribute("onmouseup", "\
            event.cancelBubble=true;\
            return false;");
        txtNode.setAttribute("onkeydown", "if (event.keyCode==13) {\
              this.blur();\
              return false;\
            };\
            event.cancelBubble=true;");
        txtNode.setAttribute("onselectstart", "event.cancelBubble = true;");
        txtNode.setAttribute("ondblclick", "event.cancelBubble = true;");

        if (pNode.style) {
            var htmlNode = apf.insertHtmlNode(node, pNode);
            //if (!this.$noanim)
                //animHighlight(this.$getLayoutNode("anynode", "text", htmlNode));
        }
        else
            pNode.appendChild(node);
    }
    
    this.$getParentNode = function(htmlNode){
        return htmlNode 
            ? this.$getLayoutNode("item", "container", htmlNode) 
            : this.$container;
    };
    
    /* ***********************
            SELECT
    ************************/
    
    this.$calcSelectRange = function(xmlStartNode, xmlEndNode){
        //should be implemented :)
        return [xmlStartNode, xmlEndNode];
    };
    
    this.$findContainer = function(htmlNode){
        return this.$getLayoutNode("item", "container", htmlNode);
    };
    
    this.multiselect = false; // Initially Disable MultiSelect
    
    this.$selectDefault = function(xmlNode){
        if (this.select(this.getFirstTraverseNode(xmlNode), null, null, null, true)) 
            return true;
        else{
            var nodes = this.getTraverseNodes(xmlNode);
            for(var i=0;i<nodes.length;i++){
                if(this.$selectDefault(nodes[i])) return true;
            }
        }
    };
    
    this.$select = function(o){
        if(!o || !o.style) return;
        this.$setStyleClass(this.$getLayoutNode("item", "class", o), "selected");
        return o;
    };

    this.$deselect = function(o){
        if(!o) return;
        this.$setStyleClass(this.$getLayoutNode("item", "class", o), "", ["selected", "indicate"]);
        return o;
    };
    
    this.$indicate = function(o){
        if(!o) return;
        this.$setStyleClass(this.$getLayoutNode("item", "class", o), "indicate");
        return o;
    };

    this.$deindicate = function(o){
        if(!o) return;
        this.$setStyleClass(this.$getLayoutNode("item", "class", o), "", ["indicate"]);
        return o;
    };
    
    /* *********
        INIT
    **********/
    //render the outer framework of this object
    this.$draw = function(){
        //Build Main Skin
        this.$ext = this.$getExternal(); 
        this.$container = this.$getLayoutNode("main", "container", this.$ext);
        this.opencloseaction = this.$getOption("Main", "openclose");
        
        //Need fix...
        //this.$ext.style.MozUserSelect = "none";

        this.$ext.onclick = function(e){
            this.host.dispatchEvent("click", {htmlEvent : e || event});
        }
        
        var _self = this;
        this.$ext.onmouseover = function(e){
            _self.dispatchEvent("mouseover", {htmlEvent: e || event});
        }
        this.$ext.onmouseout = function(e){
            _self.dispatchEvent("mouseover", {htmlEvent: e || event});
        }
    };
    
    this.$loadAml = function(x){
        this.openOnAdd   = !apf.isFalse(x.getAttribute("openonadd"));
        this.startcollapsed = !apf.isFalse(this.getAttribute("startcollapsed") 
            || this.$getOption("Main", "startcollapsed"));
        this.nocollapse  = apf.isTrue(this.getAttribute("nocollapse"));
        if (this.nocollapse)
            this.startcollapsed = false;
        this.singleopen  = apf.isTrue(this.getAttribute("singleopen"));
        //this.prerender   = !apf.isFalse(this.getAttribute("prerender"));
    };
    
    this.$destroy = function(){
        
        if (!this.$ext) {
            apf.console.error("destroy is called more than once for markupedit");
            return;
        }
        
        
        this.$ext.onclick = null;
        apf.destroyHtmlNode(this.oDrag);
        this.oDrag = null;
    };
}).call(apf.markupedit.prototype = new apf.MultiSelect());

apf.aml.setElement("markupedit", apf.markupedit);



/*FILEHEAD(/var/lib/platform/source/trunk/elements/bindingeachrule.js)SIZE(8985)TIME(1271196962)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * @binding each Determines the list of elements for which each
 * gets a visual representation within the element. It also can determine
 * the sequence of how the elements are visualized by offering a way to
 * specify the sort order. (N.B. The sorting mechanism is very similar to
 * that of XSLT)
 * Example:
 * This example contains a list that displays elements with the tagName
 * 'mail' that do not have a deleted attribute set to 1.
 * <code>
 *  <a:model id="mdlList">
 *      <data>
 *          <item date="2009-11-12" deleted="0"></item>
 *          <item date="2009-11-11" deleted="0"></item>
 *          <item date="2009-11-10" deleted="0"></item>
 *          <item date="2009-11-09" deleted="1"></item>
 *          <item date="2009-11-08" deleted="1"></item>
 *      </data>
 *  </a:model>
 *  <a:list id="list" width="200" height="200" model="mdlList">
 *      <a:bindings>
 *          <a:caption match="[@date]" />
 *          <a:each match="[item[not(@deleted='1')]]" />
 *      </a:bindings>
 *  </a:list>
 * </code>
 * Example:
 * This example shows how to use the each rule to order files based
 * on their modified data.
 * <code>
 *  <a:model id="mdlList">
 *      <data>
 *          <item date="2009-11-12"></item>
 *          <item date="2009-11-11"></item>
 *      </data>
 *  </a:model>
 *  <a:list width="200" height="200" model="mdlList">
 *      <a:each match="[item]" sort="[@date]" order="ascending">
 *          <a:caption match="[@date]" />
 *      </a:each>
 *  </a:list>
 * </code>
 * Example:
 * This example shows how to do complex sorting using a javascript callback function.
 * <code>
 *  <a:model id="mdlList">
 *      <data>
 *          <item date="2009-11-12" deleted="0"></item>
 *          <item date="2009-11-11" deleted="0"></item>
 *          <item date="2009-11-10" deleted="1"></item>
 *          <item date="2009-11-09" deleted="1"></item>
 *          <item2 date="2009-11-08" deleted="1"></item2>
 *      </data>
 *  </a:model>
 *  <a:list id="list" width="200" height="200" model="mdlList">
 *      <a:script>
 *          function sth_compare(value, args, xmlNode) {
 *          
 *          }
 *      </a:script>
 *      <a:each match="[item]" sort="[@date]" sort-method="sth_compare">
 *          <a:caption match="[@date]" />
 *      </a:each>
 *  </a:list>
 * </code>
 * @attribute {String} match        an xpath statement which selects the nodes
 *                                  which will be rendered.
 * @attribute {String} sort         an xpath statement which selects the value
 *                                  which is subject to the sorting algorithm.
 * @attribute {String} data-type    the way sorting is executed. See
 *                                  {@link baseclass.multiselectbinding.binding.each.attribute.sort-method}
 *                                  on how to specify a custom sort method.
 *   Possible values:
 *   string  Sorts alphabetically
 *   number  Sorts based on numerical value (i.e. 9 is lower than 10).
 *   date    Sorts based on the date sequence (21-6-1980 is lower than 1-1-2000).
 *           See {@link baseclass.multiselectbinding.binding.each.attribute.date-format}
 *           on how to specify the date format.
 * @attribute {String} date-format  the format of the date on which is sorted.
 *   Possible values:
 *   YYYY   Full year
 *   YY     Short year
 *   DD     Day of month
 *   MM     Month
 *   hh     Hours
 *   mm     Minutes
 *   ss     Seconds
 * Example:
 * <code>
 *  date-format="DD-MM-YYYY"
 * </code>
 * @attribute {String} sort-method  the name of a javascript function to executed
 *                                  to determine the value to sort on.
 * @attribute {String} order        the order of the sorted list.
 *   Possible values:
 *   ascending  Default sorting order
 *   descending Reverses the default sorting order.
 * @attribute {String} case-order   whether upper case characters have preference
 *                                  above lower case characters.
 *   Possible values:
 *   upper-first    Upper case characters are higher.
 *   lower-first    Lower case characters are higher.
 */
apf.BindingEachRule = function(struct, tagName){
    this.$init(tagName, apf.NODE_HIDDEN, struct);
    
    var _self = this;
    this.$noderegister = function(e){
        e.amlNode.$handleBindingRule(_self.match, "each");
    
        
        e.amlNode.$sort = _self.sort ? new apf.Sort(_self) : null;
        
    }
};

(function(){
    //1 = force no bind rule, 2 = force bind rule
    this.$attrExcludePropBind = apf.extend({
        "sort"         : 1,
        "data-type"    : 1,
        "date-format"  : 1,
        "sort-method"  : 1,
        "order"        : 1,
        "case-order"   : 1
    }, this.$attrExcludePropBind);

    this.$propHandlers["sort"]        = 
    this.$propHandlers["data-type"]   = 
    this.$propHandlers["date-format"] = 
    this.$propHandlers["order"]       = 
    this.$propHandlers["case-order"]  = function(value, prop){
        delete this["c" + prop];
        
        //@todo apf3.0 change sort
    }
    
    this.addEventListener("prop.match", function(e){
        var pNode = this.parentNode;//@todo apf3.0 get a list via $bindings
        if (pNode.localName == "bindings") {
            var nodes = pNode.$amlNodes;
            for (var i = 0; i < nodes.length; i++) {
                nodes[i].$handleBindingRule(this.match, "each");
            }
        }
        else
            pNode.$handleBindingRule(this.match, "each");
    });
    
    //@todo apf3.0 optimize
    var f;
    this.addEventListener("DOMNodeInserted", f = function(e){
        if (e.currentTarget != this)
            return;
        
        var pNode = this.parentNode;//@todo apf3.0 get a list via $bindings
        if (pNode.localName == "bindings") {
            pNode.addEventListener("noderegister", this.$noderegister);
            
            var nodes = pNode.$amlNodes;
            for (var i = 0; i < nodes.length; i++) {
                nodes[i].$handleBindingRule(this.match, "each");
    
                
                nodes[i].$sort = this.sort ? new apf.Sort(this) : null;
                
            }
        }
        else {
            pNode.$handleBindingRule(this.match, "each");
    
            
            pNode.$sort = this.sort ? new apf.Sort(this) : null;
            
        }
    });
    
    this.addEventListener("DOMNodeRemoved", function(e){
        if (e.currentTarget != this)
            return;
        
        //@todo apf3.0 how does this conflict with setting it through an attribute.
        //this.$clearDynamicProperty("each");
        //pNode.setProperty("each", null);//@todo double?
        //@todo remove model?
        
        //@todo this should be near $handleBindingRule...
        var pNode = this.parentNode;//@todo apf3.0 get a list via $bindings
        if (pNode.localName == "bindings") {
            pNode.removeEventListener("noderegister", this.$noderegister);
            
            var nodes = pNode.$amlNodes;
            for (var i = 0; i < nodes.length; i++) {
                //delete nodes[i].each; //@todo apf3.x is already set by new one
    
                
                delete nodes[i].$sort;
                
            }
        }
        else {
            //delete pNode.each; //@todo apf3.x is already set by new one
            
            
            delete pNode.$sort;
            
        }
    });
    
    this.addEventListener("DOMNodeInsertedIntoDocument", f);
    
}).call(apf.BindingEachRule.prototype = new apf.BindingRule());

apf.aml.setElement("each", apf.BindingEachRule);




/*FILEHEAD(/var/lib/platform/source/trunk/elements/webdav.js)SIZE(44843)TIME(1268092872)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/elements/editor.js)SIZE(16245)TIME(1268956869)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/elements/text.js)SIZE(13588)TIME(1269561674)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/**
 * Element displaying a rectangle containing arbitrary (X)HTML.
 * This element can be databound and use databounding rules to
 * convert data into (X)HTML using for instance XSLT or JSLT.
 *
 * @constructor
 * @define text
 * @addnode elements
 *
 * @inherits apf.Cache
 *
 * @author      Ruben Daniels (ruben AT ajax DOT org)
 * @version     %I%, %G%
 * @since       0.1
 * @todo Please refactor this object
 */
apf.text = function(struct, tagName){
    this.$init(tagName || "text", apf.NODE_VISIBLE, struct);
};

(function(){
    this.implement(
        apf.ChildValue,
        
        apf.Cache
        
    );

    this.$focussable       = true; // This object can't get the focus
    this.focussable        = false;
    this.$allowSelect      = true;
    this.$hasStateMessages = true;

    this.$textTimer = this.$lastMsg = this.$lastClass = this.$changedHeight = null;

    /**** Properties and Attributes ****/

    /**
     * @attribute {Boolean} scrolldown  whether this elements viewport is always
     *                                  scrolled down. This is especially useful
     *                                  when this element is used to displayed
     *                                  streaming content such as a chat conversation.
     * @attribute {Boolean} secure      whether the content loaded in this element
     *                                  should be filtered in order for it to not
     *                                  be able to execute javascript. This is
     *                                  especially useful when the content does
     *                                  not come from a trusted source, like a
     *                                  web service or xmpp feed.
     */
    this.$booleanProperties["scrolldown"] = true;
    this.$booleanProperties["secure"]     = true;
    this.$supportedProperties.push("behavior", "scrolldown", "secure", "value");

    /**
     * @attribute {String} behaviour specifying how this elements handles new values
     *   Possible values
     *   normal   new values replace the old value.
     *   addonly  new values are added to the current value.
     */
    this.$propHandlers["behavior"] = function(value){
        this.addOnly = value == "addonly";
    }

    /**
     * @attribute {String} value the contents of this element. This can be text or html or xhtml.
     */
    this.$propHandlers["value"] = function(value){
        var cacheObj = false;

        if (value)
            this.$removeClearMessage();
        //@todo else

        if (typeof value != "string")
            value = value ? value.toString() : "";

        if (this.secure) {
            value = value.replace(/<a /gi, "<a target='_blank' ")
                .replace(/<object.*?\/object>/g, "")
                .replace(/<script.*?\/script>/g, "")
                .replace(new RegExp("ondblclick|onclick|onmouseover|onmouseout"
                    + "|onmousedown|onmousemove|onkeypress|onkeydown|onkeyup|onchange"
                    + "|onpropertychange", "g"), "ona");
        }

        if (this.addOnly) {
            if (cacheObj)
                cacheObj.contents += value;
            else
                this.$container.insertAdjacentHTML("beforeend", value);
        }
        else {
            value = value.replace(/\<\?xml version="1\.0" encoding="UTF-16"\?\>/, "");

            if (cacheObj)
                cacheObj.contents = value;
            else
                this.$container.innerHTML = value;//.replace(/<img[.\r\n]*?>/ig, "")
        }

        //Iframe bug fix for IE (leaves screen white);
        if (apf.cannotSizeIframe && this.oIframe)
            this.oIframe.style.width = this.oIframe.offsetWidth + "px";

        if (this.scrolldown && this.$scrolldown)
            this.oScroll.scrollTop = this.oScroll.scrollHeight;
    };

    this.$propHandlers["empty-message"] = function(value) {
        if (!this.childNodes.length)
            this.$setClearMessage(this["empty-message"]);
    };

    /**** Public methods ****/

    

    /**
     * Sets the value of this element. This should be one of the values
     * specified in the values attribute.
     * @param {String} value the new value of this element
     */
    this.setValue = function(value){
        this.setProperty("value", value, false, true);
    };

    /**
     * Returns the current value of this element.
     * @return {String}
     */
    this.getValue = function(){
        return this.$container.innerHTML;
    };
    
    

    /**** Keyboard Support ****/

    
    this.addEventListener("keydown", function(e){
        var key      = e.keyCode;

        switch (key) {
            case 33:
                //PGUP
                this.$container.scrollTop -= this.$container.offsetHeight;
                break;
            case 34:
                //PGDN
                this.$container.scrollTop += this.$container.offsetHeight;
                break;
            case 35:
                //END
                this.$container.scrollTop = this.$container.scrollHeight;
                break;
            case 36:
                //HOME
                this.$container.scrollTop = 0;
                break;
            case 38:
                this.$container.scrollTop -= 10;
                break;
            case 40:
                this.$container.scrollTop += 10;
                break;
            default:
                return;
        }

        return false;
    }, true);
    

    /**** Private methods ****/

    
    this.$xmlUpdate = function(action, xmlNode, listenNode, UndoObj){
        if (this.addOnly && action != "add") return;

        //Action Tracker Support
        if (UndoObj)
            UndoObj.xmlNode = this.addOnly ? xmlNode : this.xmlRoot;//(contents ? contents.xmlRoot : this.xmlRoot);

        //Refresh Properties
        if (this.addOnly) {
            apf.xmldb.nodeConnect(this.documentId, xmlNode, null, this);
            var cacheObj = this.$findHtmlNode(listenNode.getAttribute("id")
                + "|" + this.$uniqueId);

            this.$propHandlers["value"].call(this,
                this.$applyBindRule("value", xmlNode) || "");
        }
        else {
            this.$propHandlers["value"].call(this,
                this.$applyBindRule("value", this.xmlRoot) || "");
        }
    };

    this.$load = function(node){
        //Add listener to XMLRoot Node
        apf.xmldb.addNodeListener(node, this);
        var value = this.$applyBindRule("value", node);

        if (value || typeof value == "string") {
            if (this.caching) {
                var cacheObj = this.$findHtmlNode(node.getAttribute("id")
                    + "|" + this.$uniqueId);
                if (cacheObj)
                    cacheObj.contents = value;
            }
            this.$propHandlers["value"].call(this, value);
        }
        else
            this.$propHandlers["value"].call(this, "");
    };
    

    
    this.$getCurrentFragment = function(){
        return {
            nodeType : 1,
            contents : this.$container.innerHTML
        }
    };

    this.$setCurrentFragment = function(fragment){
        this.$container.innerHTML = fragment.contents;
        if (this.scrolldown)
            this.$container.scrollTop = this.$container.scrollHeight;
    };

    this.$setClearMessage = this.$updateClearMessage = function(msg, className){
        if (this.$lastClass)
            this.$removeClearMessage();
        //@todo move to setClearMessage
        apf.setStyleClass(this.$ext, 
            (this.$lastClass = this.$baseCSSname + (className || "Empty").uCaseFirst()));//"Empty");

        if (msg) {
            if (!this.height) {
                if (this.$container.offsetHeight 
                  && apf.getStyle(this.$container, "height") == "auto" 
                  && (this.$changedHeight = true))
                    this.$container.style.height = (this.$container.offsetHeight 
                      - apf.getHeightDiff(this.$container)) + "px";
                this.$container.innerHTML = msg;
            }
            this.$lastMsg = this.$container.innerHTML;
        }
    };

    this.$removeClearMessage = function(){
        if (this.$lastClass) {
            apf.setStyleClass(this.$ext, "", [this.$lastClass]);
            this.$lastClass = null;
        }
        
        if (this.$container.innerHTML == this.$lastMsg) {
            if (this.$changedHeight && !(this.$changedHeight = false))
                this.$container.style.height = "";
            this.$container.innerHTML = ""; //clear if no empty message is supported
        }
    };

    this.caching = false; //Fix for now
    

    /**** Init ****/

    this.$draw = function(){
        var _self = this;

        this.$ext = this.$getExternal();
        this.$container = this.$getLayoutNode("main", "container", this.$ext);

        if (apf.hasCssUpdateScrollbarBug && !apf.getStyle(this.$container, "padding"))
            this.$fixScrollBug();

        this.oScroll = this.oFocus ? this.oFocus.parentNode : this.$container;

        this.$scrolldown = true;
        this.oScroll.onscroll = function(){
            _self.$scrolldown = this.scrollTop >= this.scrollHeight
                - this.offsetHeight + apf.getVerBorders(this);
        }
        clearInterval(this.$textTimer);
        this.$textTimer = setInterval(function(){
            if (_self.oScroll && _self.$scrolldown && _self.scrolldown) {
                _self.oScroll.scrollTop = _self.oScroll.scrollHeight;
            }
        }, 60);

        if (this.$container.tagName.toLowerCase() == "iframe") {
            if (apf.isIE) {
                this.oIframe = this.$container;
                var iStyle = this.skin.selectSingleNode("iframe_style");
                this.oIframe.contentWindow.document.write(
                    "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\
                    <head>\
                        <style>" + (iStyle ? iStyle.firstChild.nodeValue : "") + "</style>\
                        <script>\
                            document.onkeydown = function(e){\
                                if (!e) e = event;\
                                if (" + 'top.apf.disableF5' + " && e.keyCode == 116) {\
                                    e.keyCode = 0;\
                                    return false;\
                                }\
                            }\
                        </script>\
                    </head>\
                    <body oncontextmenu='return false'></body>");
                this.$container = this.oIframe.contentWindow.document.body;
            }
            else {
                var node = document.createElement("div");
                this.$ext.parentNode.replaceChild(node, this.$ext);
                node.className = this.$ext.className;
                this.$ext = this.$container = node;
            }
        }
        else {
            this.$container.onselectstart = function(e){
                (e ? e : event).cancelBubble = true;
            };

            this.$container.oncontextmenu = function(e){
                if (!this.host.contextmenus)
                    (e ? e : event).cancelBubble = true;
            };

            this.$container.style.cursor = "";

            this.$container.onmouseover = function(e){
                if (!self.STATUSBAR) return;
                if (!e)
                    e = event;

                if (e.srcElement.tagName.toLowerCase() == "a") {
                    if (!this.lastStatus)
                        this.lastStatus = STATUSBAR.getStatus();
                    STATUSBAR.status("icoLink.gif", e.srcElement.getAttribute("href"));
                }
                else if (this.lastStatus) {
                    STATUSBAR.status(this.lastStatus[0], this.lastStatus[1]);
                    this.lastStatus = false;
                }
            };
        }
    };

    this.addEventListener("DOMNodeRemovedFromDocument", function() {
        clearInterval(this.$textTimer);
        apf.destroyHtmlNode(this.oDrag);
        
        if (this.oScroll)
            this.oScroll.onscoll = this.oScroll = null;
        
        this.oDrag = this.oIframe = this.oFocus  = null;
    });
}).call(apf.text.prototype = new apf.BaseSimple());

apf.aml.setElement("text", apf.text);



/*FILEHEAD(/var/lib/platform/source/trunk/elements/propedit.js)SIZE(40986)TIME(1271093061)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



//@todo There is a lot of dead code in here (also in the skin) remove it

/**
 * Element providing a two column grid with properties and values. The values
 * are editable using apf elements.
 *
 * @constructor
 * @define propedit
 * @addnode elements
 *
 * @author      Ruben Daniels (ruben AT ajax DOT org)
 * @version     %I%, %G%
 * @since       0.4
 *
 * @inherits apf.DataBinding
 */
apf.propedit    = function(struct, tagName){
    this.$init(tagName || "propedit", apf.NODE_VISIBLE, struct);
    
    //this.$headings       = [],
    //this.$cssRules       = []; //@todo Needs to be reset;
    this.$nodes          = [];
    //this.$lastOpened     = {};
    
    this.$editors        = {};
    
    
    this.$dynCssClasses = [];
    
};

(function(){
    this.$init(function(){
        this.addEventListener("keydown", keyHandler, true);
    });
    
    /*this.implement(
        
        //apf.Rename
        
        
        //apf.Cache,  
    );*/
    
    this.$focussable     = true; // This object can get the focus
    this.$isTreeArch     = true; // This element has a tree architecture
    this.$isWindowContainer = -1;
    
    this.startClosed     = true;
    this.$animType       = apf.tween.NORMAL;
    this.$animSteps      = 3;
    this.$animSpeed      = 20;

    this.$useiframe      = 0;
    
    //1 = force no bind rule, 2 = force bind rule
    this.$attrExcludePropBind = apf.extend({
        properties : 3 //only when it has an xpath
    }, this.$attrExcludePropBind);
    
    /**
     * @attribute {Boolean} iframe     whether this element is rendered inside an iframe. This is only supported for IE. Default is false for datagrid and true for spreadsheet and propedit.
     */
    this.$booleanProperties["iframe"]     = true;

    /**
     * @attribute {String} template the {@link terms.datainstruction data instruction} 
     * to fetch a template definition of the layout for this component. A template
     * consists of descriptions of columns (or rows for propedit) for which
     * several settings are determined such as validation rules, edit component 
     * and selection rules.
     * Example:
     * This example contains a template that describes the fields in a property
     * editor for xml data representing a news article.
     * <code>
     *  <news>
     *      <prop caption="Title *" type="text" match="[title]" required="true" 
     *        minlength="4" invalidmsg="Incorrect title;The title is required."/>
     *      <prop caption="Subtitle *" type="text" match="[subtitle]" 
     *        required="true" minlength="4" 
     *        invalidmsg="Incorrect subtitle;The subtitle is required."/>
     *      <prop caption="Source" type="text" match="[source]" minlength="4" 
     *        invalidmsg="Incorrect source;The source is required."/>
     *      <prop match="[editors_choice]" caption="Show on homepage"
     *        overview="overview" type="dropdown">
     *          <item value="1">Yes</item> 
     *          <item value="0">No</item> 
     *      </prop>
     *      <prop caption="Auteur*" match="[author]" descfield="name" 
     *        overview="overview" maxlength="10" type="lookup" 
     *        foreign_table="author" required="true" /> 
     *      <prop match="[categories/category]" descfield="name" type="lookup" 
     *        multiple="multiple" caption="Categorie" overview="overview" 
     *        foreign_table="category" /> 
     *      <prop caption="Image" type="custom" 
     *        exec="showUploadWindow('news', 'setNewsImage', selected)" 
     *        match="[pictures/picture/file]" />
     *      <prop match="[comments]" descfield="title" caption="Comments" 
     *        type="children" multiple="multiple">
     *          <props table="news_comment" descfield="title">
     *              <prop match="[name]" datatype="string" caption="Name*" 
     *                required="1" maxlength="255" 
     *                invalidmsg="Incorrect name;The name is required."/> 
     *              <prop match="[email]" datatype="apf:email" caption="Email" 
     *                maxlength="255" 
     *                invalidmsg="Incorrect e-mail;Please retype."/> 
     *              <prop match="[date]" datatype="xsd:date" caption="Date*" 
     *                required="1" 
     *                invalidmsg="Incorrect date;Format is dd-mm-yyyy."/> 
     *              <prop match="[title]" datatype="string" caption="Title*" 
     *                required="1" maxlength="255" 
     *                invalidmsg="Incorrect title;Title is required."/> 
     *              <prop match="[body]" caption="Message*" required="1" 
     *                invalidmsg="Incorrect message;Message is required."/> 
     *          </props>
     *      </prop>
     *  </news>
     * </code>
     */
    this.$propHandlers["properties"] = function(value){
        if (!value)
            return this.clear();
        
        var _self = this;
        var propLoadObj = { //Should probably exist only once if expanded with xmlUpdate
            load : function(data){
                _self.$loadingProps = false;
                
                if (typeof data == "string")
                    data = apf.getXml(data);

                _self.$properties = data;
                if (_self.xmlRoot)
                    _self.load(_self.xmlRoot);
            },
            
            clear : function(){
                _self.$loadingProps = false;
            },
            
            xmlRoot : this.xmlRoot
        };

        var xml;
        this.$loadingProps = true;
        if (typeof value == "string") {
            if (value.substr(0, 1) == "<") 
                propLoadObj.load(value);
            else
                apf.setModel(value, propLoadObj);
        }
        else if (value.$isModel){
            //Value is model aml element
            value.register(propLoadObj);
        }
        else {
            if (this.$properties == value)
                return;

            //Assuming value is xml node
            
            setTimeout(function(){
                propLoadObj.load(value);
            });
            
        }
        
        delete this.$properties;
    };
    
    this.$canLoadData = function(){
        return this.$headings ? true : false;
    }
    
    this.$columns = ["50%", "50%"];
    this.$propHandlers["columns"] = function(value){
        this.$columns = value && value.splitSafe(",") || ["50%", "50%"];
        
        if (this.$headings) {
            this.$headings[0].setProperty("width", this.$columns[0]);
            this.$headings[1].setProperty("width", this.$columns[1]);
        }
    }
    
    function scrollIntoView(){
        var Q = (this.current || this.$selected),
            o = this.$body;
        o.scrollTop = (Q.offsetTop) - 21;
    }

    /**** Keyboard Support ****/
    
    this.$findHtmlNode = function(id) {
        return this.$pHtmlDoc.getElementById(id);
    }
    
    
    function keyHandler(e){
        var key      = e.keyCode,
            ctrlKey  = e.ctrlKey,
            shiftKey = e.shiftKey;
        
        var selXml = this.$lastEditor && this.$lastEditor[2],
            oInt   = this.$useiframe ? this.oDoc.documentElement : this.$body,
            margin, node, hasScroll, hasScrollX, hasScrollY, items, lines;

        switch (key) {
            case 36:
                //HOME
                return false;
            case 35:
                //END
                return false;
            case 107:
                //+
                break;
            case 37:
                //LEFT
                this.$slideToggle(this.$selected.firstChild);
                return false;
            case 107:
            case 39:
                //RIGHT
                this.$slideToggle(this.$selected.firstChild);
                    
                return false;
            case 38:
                //UP
                var node  = selXml;
                var sNode = selXml.previousSibling;
                while(sNode && sNode.nodeType != 1) sNode = sNode.previousSibling;
                
                if (sNode) {
                    var last = sNode, nodes;
                    while ((nodes = last.selectNodes("prop")).length)
                        last = nodes[nodes.length - 1];
                    sNode = last;
                }
                else {
                    sNode = node.parentNode
                    if (sNode[apf.TAGNAME] != "prop") {
                        sNode = sNode.previousSibling;
                        while(sNode && sNode.nodeType != 1) sNode = sNode.previousSibling;
                        
                        if (sNode && sNode[apf.TAGNAME] != "prop") {
                            sNode = (nodes = sNode.selectNodes("prop"))[nodes.length - 1];
                            while(sNode && sNode.nodeType != 1) sNode = sNode.previousSibling;
                        }
                    }
                }

                if (!sNode)
                    return;

                var selHtml = apf.xmldb.findHtmlNode(sNode, this);
                while (!selHtml.offsetWidth)
                    selHtml = apf.xmldb.findHtmlNode(sNode = sNode.parentNode, this);
                
                var top = apf.getAbsolutePosition(selHtml, this.$body)[1]
                     - (selHtml.offsetHeight/2);
                if (top <= this.$ext.scrollTop)
                    this.$ext.scrollTop = top;
                
                this.select(selHtml);
                
                return false;
            case 40:
                //DOWN
                var node, sNode = (node = selXml).selectSingleNode("prop") || node.nextSibling;
                do {
                    while(sNode && (sNode.nodeType != 1 || sNode[apf.TAGNAME] != "prop")) 
                        sNode = sNode.nextSibling;
                    
                    if (!sNode) {
                        sNode = node.parentNode.nextSibling;
                        if (sNode && sNode[apf.TAGNAME] != "prop")
                            sNode = sNode.selectSingleNode("prop");
                    }
                }while(sNode && sNode.nodeType != 1);
                
                if (!sNode)
                    return;

                var selHtml = apf.xmldb.findHtmlNode(sNode, this);
                while (!selHtml.offsetWidth)
                    selHtml = apf.xmldb.findHtmlNode(sNode = sNode.parentNode, this);
                
                if (sNode == node) {
                    sNode = node.nextSibling
                    while(sNode && (sNode.nodeType != 1 || sNode[apf.TAGNAME] != "prop")) 
                        sNode = sNode.nextSibling;
                    var selHtml = apf.xmldb.findHtmlNode(sNode, this);
                }
                
                var top = apf.getAbsolutePosition(selHtml, this.$body)[1] 
                    + (selHtml.offsetHeight/2);
                if (top > this.$ext.scrollTop + this.$ext.offsetHeight)
                    this.$ext.scrollTop = top - this.$ext.offsetHeight;
                
                this.select(selHtml);
                
                return false;
        };
    }
    
    
    
    /**** Focus ****/
    // Too slow for IE
    
    this.$focus = function(){
        if (!this.$ext || (apf.isIE && this.$useiframe && this.cssfix)) //@todo fix this by fixing focussing for this component
            return;

        this.$setStyleClass(this.oFocus || this.$ext, this.$baseCSSname + "Focus");
        
        if (this.oDoc)
            this.$setStyleClass(this.oDoc.documentElement, this.$baseCSSname + "Focus");
    };

    this.$blur = function(){
        
        if (this.renaming)
            this.stopRename(null, true);
        

        //@todo fix this by fixing focussing for this component
        if (!this.$ext || (apf.isIE && this.$useiframe && this.cssfix))
            return;

        this.$setStyleClass(this.oFocus || this.$ext, "", [this.$baseCSSname + "Focus"]);
        
        if (this.oDoc)
            this.$setStyleClass(this.oDoc.documentElement, "", [this.$baseCSSname + "Focus"]);
    };
    
    /**** Sliding functions ****/
    
    this.$slideToggle = function(htmlNode){
        container = htmlNode.parentNode.lastChild;
        
        if (apf.getStyle(container, "display") == "block") {
            htmlNode.className = htmlNode.className.replace(/min/, "plus");
            this.$slideClose(container);
        }
        else {
            htmlNode.className = htmlNode.className.replace(/plus/, "min");
            this.$slideOpen(container);
        }
    };
    
    this.$slideOpen = function(container){
        container.style.display = "";

        apf.tween.single(container, {
            type    : 'scrollheight', 
            from    : 3, 
            diff    : -2,
            to      : container.scrollHeight, 
            anim    : this.$animType,
            steps   : this.$animSteps,
            interval: this.$animSpeed,
            onfinish: function(container){
                container.style.overflow = "visible";
                container.style.height = "auto";
            }
        });
    };

    this.$slideClose = function(container){
        container.style.height   = container.offsetHeight;
        container.style.overflow = "hidden";

        apf.tween.single(container, {
            type    : 'scrollheight', 
            from    : container.scrollHeight, 
            diff    : -2,
            to      : 0, 
            anim    : this.$animType,
            steps   : this.$animSteps,
            interval: this.$animSpeed,
            onfinish: function(container, data){
               container.style.display = "none";
            }
        });
    };
    
    this.$findContainer = function(htmlNode) {
        var node = htmlNode.nextSibling;
        if (!node)
            return htmlNode;
        return node.nodeType == 1 ? node : node.nextSibling;
    };
    
    /**** Databinding ****/
    
    this.addEventListener("bindingsload", this.$loaddatabinding = function(e){
        var rules = e.bindings["properties"];
        if (!rules || !rules.length)
            return;
        
        for (var i = 0, l = rules.length; i < l; i++) {
            
        }
    });
    
    this.$unloaddatabinding = function(){
    };

    /**
     * Returns a column definition object based on the column number.
     * @param {Number} hid the heading number; this number is based on the sequence of the column elements.
     */
    this.getColumn = function(nr){
        return this.$headings[nr || this.$lastcol || 0];
    };
    
    /**** Column management ****/

    /** 
     * Resizes a column.
     * @param {Number} hid      the heading number; this number is based on the sequence of the column elements. 
     * @param {Number} newsize  the new size of the column.
     * @todo optimize but bringing down the string concats
     */
    this.resizeColumn = function(nr, newsize){
        var h = this.$headings[nr];
        h.resize(newsize);
    };

    /**
     * Hides a column.
     * @param {Number} hid      the heading number; this number is based on the sequence of the column elements. 
     */
    this.hideColumn = function(nr){
        var h = this.$headings[nr];
        h.hide();
    };
    
    /**
     * Shows a hidden column.
     * @param {Number} hid      the heading number; this number is based on the sequence of the column elements. 
     */
    this.showColumn = function(nr){
        var h = this.$headings[nr];
        h.show();
    };
    
    /**** Databinding ****/
    
    /*
    Property:
    - caption
    - editor (name of widget, lm function returning amlNode or lm template ref)
        - children being aml nodes
    - value (lm, only when widget is created by grid)
    
    validation attr: (only when widget is created by grid)
    - required
    - datatype
    - required
    - pattern
    - min
    - max
    - maxlength
    - minlength
    - notnull
    - checkequal
    - validtest
    
    Group:
    - name
    - properties
    
    Move from dg to widgets:
    - autocomplete with template
    - dropdown with bound multicheck
    
    Furthermore it supports:
    - properties binding rule to switch properties
    - special node introspection mode
        - .listAttributes()
            - returns array of objects
                - name
                - editor
                - validation rules
        - .setAttribute(name, value)
        - .getAttribute(name)
        - .addEventListener("prop." + name);
        - .removeEventListener("prop." + name);
    */
    
    this.$getProperties = function(xmlNode){
        if (this.properties) {
            return this.$properties || false;
        }
        else if (this.$bindings.properties) {
            var props = this.$bindings.properties;
            for (var i = 0; i < props.length; i++) {
                if (!props[i].match) //compile via lm
                    return xx; //async request entry
            }
        }
        
        return false;
    }
    
    this.$load = function(xmlNode){
        var p = this.$getProperties();
        if (!p) return false;
        
        var output = [];
        var docId = this.documentId = apf.xmldb.getXmlDocId(p);

        //Add listener to XMLRoot Node
        apf.xmldb.addNodeListener(xmlNode, this); //@todo apf3 potential cleanup problem
        //apf.xmldb.addNodeListener(this.xmlRoot, this);

        var _self = this, doc = p.ownerDocument;
        (function walk(nodes, parent, depth){
            for (var u, s, cell, sLid, pnode, html, node, i = 0, l = nodes.length; i < l; i++) {
                node = nodes[i];
                _self.$getNewContext("row") 
                html = _self.$getLayoutNode("row");
                
                if (node[apf.TAGNAME] == "group") {
                    _self.$getNewContext("cell");
                    apf.setStyleClass(html, "heading");

                    cell = html.appendChild(_self.$getLayoutNode("cell"));
                    apf.setNodeValue(_self.$getLayoutNode("cell", "caption", cell),
                        (node.getAttribute("caption") || "").trim() || ""); //@todo for IE but seems not a good idea
                
                    //group|
                    pnode = html.appendChild(doc.createElement("blockquote"));
                    walk(node.selectNodes("prop"), pnode, depth);
                    html.insertBefore(u = doc.createElement("u"), html.firstChild).appendChild(doc.createTextNode(" "));
                    u.setAttribute("class", "min");
                }
                else {
                    apf.xmldb.nodeConnect(docId, node, html, _self);
                
                    //Build the Cells
                    _self.$getNewContext("cell");
                    h = _self.$headings[0];
        
                    cell = html.appendChild(_self.$setStyleClass(_self.$getLayoutNode("cell"), h.$className));
                    apf.setNodeValue(_self.$getLayoutNode("cell", "caption", cell),
                        (node.getAttribute("caption") || "").trim() || ""); //@todo for IE but seems not a good idea

                    if (depth)
                        cell.firstChild.setAttribute("style", "padding-left:" + (depth * 15) + "px");
                    
                    _self.$getNewContext("cell");
                    h = _self.$headings[1];

                    cell = html.appendChild(_self.$setStyleClass(_self.$getLayoutNode("cell"), h.$className));
                    apf.setNodeValue(_self.$getLayoutNode("cell", "caption", cell),
                        ((apf.lm.compile(node.getAttribute("value"), {nostring: true}))(_self.xmlRoot) || "") || ""); //@todo for IE but seems not a good idea
                    
                    if ((s = node.selectNodes("prop")).length) {
                        pnode = html.appendChild(doc.createElement("blockquote"));
                        pnode.setAttribute("style", "display:none;overflow:hidden;height:0;");
                        walk(s, _self.$getLayoutNode("heading", "container", pnode), depth + 1);
                        
                        //Add opener
                        html.insertBefore(u = doc.createElement("u"), html.firstChild).appendChild(doc.createTextNode(" "));
                        u.setAttribute("class", "plus");
                    }
                }

                if (!parent)
                    output.push(html);
                else
                    parent.appendChild(html);
            }
        })(p.selectNodes("group|prop"), null, 0);
        
        apf.insertHtmlNodes(output, this.$body);
        
        this.setProperty("root", this.xmlRoot); //or xmlNode ??

        //@todo select the first one
        var prop = p.selectSingleNode(".//prop");
        if (prop) {
            this.select(this.$findHtmlNode(
              prop.getAttribute(apf.xmldb.xmlIdTag) 
              + "|" + this.$uniqueId));
        }
    }
    
    this.$xmlUpdate = function(action, xmlNode, listenNode, UndoObj){
        if (xmlNode != this.xmlRoot)
            return;

        if (UndoObj && this.$lastEditor[0] == UndoObj.amlNode) {
            this.$lastEditor[1].firstChild.innerHTML = 
                ((apf.lm.compile(this.$lastEditor[2].getAttribute("value"), {
                    nostring: true
                }))(this.xmlRoot) || "") || "";
        }
        else {
            var p = this.$getProperties();
            var node, htmlNode, nodes = p.selectNodes(".//prop");
            for (var i = 0, l = nodes.length; i < l; i++) {
                node     = nodes[i];
                htmlNode = this.$findHtmlNode(
                    node.getAttribute(apf.xmldb.xmlIdTag) + "|" + this.$uniqueId);
                
                htmlNode.childNodes[htmlNode.firstChild.tagName == "U" ? 2 : 1]
                  .firstChild.innerHTML = 
                    ((apf.lm.compile(node.getAttribute("value"), {
                        nostring: true
                    }))(this.xmlRoot) || "") || "";
            }
        }
    }
    
    this.$hideEditor = function(remove){
        if (this.$lastEditor) {
            //this.$lastEditor[0].$blur();
            this.$lastEditor[0].setProperty("visible", false);
            
            if (remove) {
                var pNode = this.$lastEditor[0].$ext.parentNode;
                pNode.removeChild(this.$lastEditor[0].$ext);
                pNode.removeAttribute("id");
                delete pNode.onresize;
            }
            
            var nodes = this.$lastEditor[1].childNodes;
            for (var i = 0, l = nodes.length; i < l; i++) {
                if (!nodes[i].host)
                    nodes[i].style.display = "";
            }
            
            delete this.$lastEditor;
        }
    }
    
    this.select = function(htmlNode){
        if (this.$selected == htmlNode) {
            /*var oEditor = this.$lastEditor[0];
            $setTimeout(function(){
                oEditor.focus();
            });*/
            
            return;
        }

        if (this.$selected)
            this.$setStyleClass(this.$selected, "", ["selected"]);

        this.$setStyleClass(htmlNode, "selected");
        this.$selected = htmlNode;
        
        this.$hideEditor();
        
        var prop = apf.xmldb.getNode(htmlNode);
        var _self = this;
        
        this.setProperty("selected", prop);
        
        /*
            - editor (name of widget, lm function returning amlNode or lm template ref)
            - children being aml nodes
         */
        var editParent = this.$selected.childNodes[this.$selected.firstChild.tagName == "U" ? 2 : 1];
        var oEditor, editor = prop.getAttribute("editor");
        var ceditor = apf.lm.compile(editor, {xpathmode: 2});
        if (ceditor.type == 2) {
            
            if (!editor) {
                if (prop.childNodes.length) //It's a group
                    return;
                else 
                    throw new Error("Missing editor attribute on property element: " + prop.xml); //@todo apf3.0 make into proper error
            }
            
            
            if (!this.$editors[editor]) {
                var constr = apf.namespaces[apf.ns.aml].elements[editor];
                var info   = {
                    htmlNode : editParent,
                    width    : "100%+2",
                    height   : 19,
                    style    : "position:relative;z-index:10000",
                    value    : "[{" + this.id + ".root}::" 
                        + (v = prop.getAttribute("value")).substr(1, v.length - 2) 
                        + "]",
                    focussable : false,
                    realtime   : true
                };
                
                //@todo copy all non-known properties of the prop element

                if (constr.prototype.hasFeature(apf.__MULTISELECT__)) {
                    info.caption   = "[text()]";
                    info.eachvalue = "[@value]";
                    info.each      = "item";
                    info.model     = "{apf.xmldb.getElementById('" 
                        + prop.getAttribute(apf.xmldb.xmlIdTag) + "')}";
                }

                oEditor = this.$editors[editor] = new constr(info);
                
                var box = apf.getBox(apf.getStyle(oEditor.$ext, "margin"));
                if (box[1] || box[3]) {
                    oEditor.setAttribute("width", "100%+2-" + (box[1] + box[3]));
                }
                else if (!box[3])
                    oEditor.$ext.style.marginLeft = "-1px";

                //oEditor.$focussable = false;
                /*oEditor.addEventListener("focus", function(){
                    _self.focus();
                    this.$focus();
                });*/
                oEditor.parentNode   = this;
                oEditor.$focusParent = this;
                oEditor.setAttribute("focussable", "true");
                //delete oEditor.parentNode;
                
                //@todo set actiontracker
                oEditor.$parentId = editParent.getAttribute("id");
                oEditor.$parentRsz = editParent.onresize;
            }
            else {
                oEditor = this.$editors[editor];

                if (oEditor.hasFeature(apf.__MULTISELECT__)) {
                    oEditor.setAttribute("model", "{apf.xmldb.getElementById('" 
                        + prop.getAttribute(apf.xmldb.xmlIdTag) + "')}");
                }

                oEditor.setAttribute("value", "[{" + this.id + ".root}::" 
                    + (v = prop.getAttribute("value")).substr(1, v.length - 2) 
                    + "]");

                oEditor.setProperty("visible", true);
                if (oEditor.$ext.parentNode && oEditor.$ext.parentNode.nodeType == 1) {
                    if (!oEditor.$parentRsz) 
                        oEditor.$parentRsz = oEditor.$ext.parentNode.onresize;
                    oEditor.$ext.parentNode.removeAttribute("id");
                    delete oEditor.$ext.parentNode.onresize;
                }

                editParent.appendChild(oEditor.$ext);
                editParent.setAttribute("id", editParent.$parentId);
                if (oEditor.$parentRsz) {
                    editParent.onresize = oEditor.$parentRsz;
                    editParent.onresize();
                }
            }
            
            /*setTimeout(function(){
                oEditor.focus();
            });*/
        }
        else {
            //Create dropdown 
            
            var obj = ceditor.call(this, this.xmlRoot);
            if (obj.localName == "template") {
                //add template contents to dropped area
            }
            else {
                //add xml into dropped area
            }
        }
        
        var nodes = editParent.childNodes;
        for (var i = 0, l = nodes.length; i < l; i++) {
            if (!nodes[i].host)
                nodes[i].style.display = "none";
        }

        this.$lastEditor = [oEditor, editParent, prop];
    }
    
    this.addEventListener("$clear", function(e){
        this.$hideEditor(true);
    });
    
    /*this.addEventListener("blur", function(){
        if (this.$lastEditor)
            this.$lastEditor[0].$blur();
    });
    
    this.addEventListener("focus", function(){
        if (this.$lastEditor)
            this.$lastEditor[0].$focus();
    });*/
    
    /**** Init ****/

    this.$draw = function(){
        //Build Main Skin
        this.$ext     = this.$getExternal();
        this.$body    = this.$getLayoutNode("main", "body", this.$ext);
        this.$head    = this.$getLayoutNode("main", "head", this.$ext);
        this.$pointer = this.$getLayoutNode("main", "pointer", this.$ext);
        this.$container = this.$body;

        if (this.$head.firstChild)
            this.$head.removeChild(this.$head.firstChild);
        if (this.$body.firstChild)
            this.$body.removeChild(this.$body.firstChild);

        var widthdiff = this.$widthdiff = this.$getOption("main", "widthdiff") || 0;
        this.$defaultwidth = this.$getOption("main", "defaultwidth") || "100";
        this.$useiframe    = apf.isIE && (apf.isTrue(this.$getOption("main", "iframe")) || this.iframe);

        var _self = this;
        
        //Initialize Iframe 
        if (this.$useiframe && !this.oIframe) {
            //this.$body.style.overflow = "hidden";
            //var sInt = this.$body.outerHTML 
            var sClass   = this.$body.className;
            //this.$body.parentNode.removeChild(this.$body);
            this.oIframe = this.$body.appendChild(document.createElement(apf.isIE 
                ? "<iframe frameborder='0'></iframe>"
                : "iframe"));
            this.oIframe.frameBorder = 0;
            this.oWin = this.oIframe.contentWindow;
            this.oDoc = this.oWin.document;
            this.oDoc.write('<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">\
                <html xmlns="http://www.w3.org/1999/xhtml">\
                    <head><script>\
                        apf = {\
                            lookup : function(uid){\
                                return window.parent.apf.lookup(uid);\
                            },\
                            Init : {add:function(){},run:function(){}}\
                        };</script>\
                    </head>\
                    <body></body>\
                </html>');
            //Import CSS
            //this.oDoc.body.innerHTML = sInt;
            this.$body = this.oDoc.body;//.firstChild;
            this.$body.className = sClass;//this.oIframe.parentNode.className;
            this.oDoc.documentElement.className = this.$ext.className;
            //this.oDoc.body.className = this.$ext.className;

            apf.skins.loadCssInWindow(this.skinName, this.oWin, this.mediaPath, this.iconPath);
            
            if (apf.isIE) //@todo this can be removed when focussing is fixed for this component
                this.$setStyleClass(this.oDoc.documentElement, this.$baseCSSname + "Focus");
            
            apf.convertIframe(this.oIframe, true);

            if (apf.getStyle(this.oDoc.documentElement, apf.isIE 
              ? "overflowY" : "overflow-y") == "auto") {
                //@todo ie only
                this.oIframe.onresize = function(){
                    _self.$head.style.marginRight = 
                      _self.oDoc.documentElement.scrollHeight > _self.oDoc.documentElement.offsetHeight 
                        ? "16px" : "0";
                }
                
                this.addEventListener("afterload", this.oIframe.onresize);
                this.addEventListener("xmlupdate", this.oIframe.onresize);
            }
            
            this.oDoc.documentElement.onmousedown = function(e){
                if (!e) e = _self.oWin.event;
                if ((e.srcElement || e.target).tagName == "HTML")
                    apf.popup.forceHide();
            }
                        
            this.oDoc.documentElement.onscroll = 
                function(){
                    if (_self.$isFixedGrid)
                        _self.$head.scrollLeft = _self.oDoc.documentElement.scrollLeft;
                };
        }
        else {
            if (apf.getStyle(this.$body, apf.isIE 
              ? "overflowY" : "overflow-y") == "auto") {
                this.$resize = function(){
                    _self.$head.style.marginRight = 
                      _self.$body.scrollHeight > _self.$body.offsetHeight 
                        ? "16px" : "0";
                }
                
                
                apf.layout.setRules(this.$ext, this.$uniqueId + "_datagrid",
                    "var o = apf.all[" + this.$uniqueId + "];\
                     if (o) o.$resize()");
                apf.layout.queue(this.$ext);
                
                
                this.addEventListener("afterload", this.$resize);
                this.addEventListener("xmlupdate", this.$resize);
            }
            
            this.$body.onmousedown = function(e){
                if (!e) e = event;
                if ((e.srcElement || e.target) == this)
                    apf.popup.forceHide();
            }
            
            this.$body.onscroll = 
                function(){
                    if (_self.$isFixedGrid)
                        _self.$head.scrollLeft = _self.$body.scrollLeft;
                };
        }
        
        var _self = this;
        this.$body.onmousedown = function(e){
            if (!e) e = event;
            var target = e.srcElement || e.target;
            
            if (target == this) return;
            
            if (target.tagName == "U") {
                _self.$slideToggle(target);
                return;
            }
            
            while (target.host || (target.getAttribute(apf.xmldb.htmlIdTag) || "").indexOf("|") == -1) {
                target = target.parentNode;
                if (target == this) return;
            }

            _self.select(target);
        }
    };
    
    this.$loadAml = function(x){
        //Create two columns
        this.$headings = [
            new apf.BindingColumnRule().$draw(this, "Property", this.$columns[0], "first"),
            new apf.BindingColumnRule().$draw(this, "Value", this.$columns[1])
        ];
    };
    
    this.$destroy = function(){
        apf.popup.removeContent(this.$uniqueId);
        
        for (var prop in this.$editors) {
            this.$editors[prop].destroy();
        }
        
        this.$ext.onclick = this.$body.onresize = null;
        
        
        apf.layout.removeRule(this.$body, "dg" + this.$uniqueId);
        apf.layout.activateRules(this.$body);
        
    };

}).call(apf.propedit.prototype = new apf.DataBinding());


apf.aml.setElement("propedit",    apf.propedit);
apf.aml.setElement("column",      apf.BindingColumnRule);
apf.aml.setElement("description", apf.BindingRule);
apf.aml.setElement("color",       apf.BindingRule);





/*FILEHEAD(/var/lib/platform/source/trunk/elements/slider.js)SIZE(31750)TIME(1270838607)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */ 



/*FILEHEAD(/var/lib/platform/source/trunk/elements/colorpicker2.js)SIZE(11146)TIME(1267660867)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/elements/codeeditor.js)SIZE(16302)TIME(1269561674)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/elements/state.js)SIZE(10990)TIME(1269561674)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/*FILEHEAD(/var/lib/platform/source/trunk/elements/checkbox.js)SIZE(7310)TIME(1270838607)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */





/**
 * Element displaying a clickable rectangle having two states which
 * can be toggled by user interaction.
 * Example:
 * <code>
 *  <a:checkbox values="full|empty">the glass is full</a:checkbox>
 * </code>
 *
 * @constructor
 *
 * @define checkbox
 * @addnode elements
 *
 * @author      Ruben Daniels (ruben AT ajax DOT org)
 * @version     %I%, %G%
 * @since       0.4
 *
 * @inherits apf.BaseButton
 * @inherits apf.XForms
 *
 * @binding value  Determines the way the value for the element is retrieved 
 * from the bound data.
 * Example:
 * Sets the value of the checkbox based on data loaded into this component.
 * <code>
 *  <a:model id="mdlCheckbox">
 *      <data answer="Something"></data>
 *  </a:model>
 *  <a:checkbox 
 *    model = "mdlCheckbox" 
 *    value = "[@answer]">Caption</a:checkbox>
 * </code>
 * Example:
 * A shorter way to write this is:
 * <code>
 *  <a:model id="mdlCheckbox">
 *      <data answer="Something"></data>
 *  </a:model>
 *  <a:checkbox value="[mdlCheckbox::@answer]">Caption</a:checkbox>
 * </code>
 */
apf.checkbox = function(struct, tagName){
    this.$init(tagName || "checkbox", apf.NODE_VISIBLE, struct);
};

(function() {
    this.implement(
        
        
        apf.DataAction
        
    );

    //Options
    this.$notfromext = true;
    this.$focussable = true; // This object can get the focus
    this.checked     = false;
    this.$values     = [1, 0];

    /**** Properties and Attributes ****/

    this.$booleanProperties["checked"] = true;
    this.$supportedProperties.push("value", "checked", "label", "values");

    /**
     * @attribute {String}  value    the value of this element.
     */
    this.$propHandlers["value"] = function(value){
        value = (typeof value == "string" ? value.trim() : value);

        this.checked = (typeof value != "undefined" && value !== null
            && value.toString() == this.$values[0].toString());

        if (this.checked)
            apf.setStyleClass(this.$ext, this.$baseCSSname + "Checked");
        else
            apf.setStyleClass(this.$ext, "", [this.$baseCSSname + "Checked"]);
    };

    /**
     * @attribute {Boolean} checked  whether the element is in the checked state.
     */
    this.$propHandlers["checked"] = function(value) {
        if (!this.$values) {
            if (this.getAttribute("values"))
                this.$propHandler["values"].call(this, this.getAttribute("values"));
            else
                this.$values = [false, true];
        }
        this.setProperty("value", this.$values[value ? 0 : 1]);
    };

    /**
     * @attribute {String}  label    the caption of the label explaining what
     * the meaning of the checked state of this element is.
     */
    this.$propHandlers["label"] = function(value){
        if (!this.$ext)
            return;

        var lbl = this.$getLayoutNode("main", "label", this.$ext);
        if (lbl.nodeType == 1)
            lbl.innerHTML = value;
        else
            lbl.nodeValue = value;
    };

    /**
     * @attribute {String}  values   a pipe seperated list of two values which
     * correspond to the two states of the checkbox. The first for the checked
     * state, the second for the unchecked state. Defaults to "true|false".
     */
    this.$propHandlers["values"] = function(value){
        this.$values = typeof value == "string"
            ? value.split("\|")
            : (value || [1, 0]);
    };

    /**** Public Methods ****/

    

    /**
     * Sets the value of this element. This should be one of the values
     * specified in the values attribute.
     * @param {String} value the new value of this element
     */
    this.setValue = function(value){
        if (!this.$values) return;
        this.setProperty("value", value, false, true);
    };

    /**
     * Returns the current value
     */
    this.getValue = function(){
        return this.xmlRoot ? this.$values[this.checked ? 0 : 1] : this.value;
    };

    /**
     * Sets the checked state and related value
     */
    this.check = function(){
        this.setProperty("value", this.$values[0], false, true);
    };

    /**
     * Sets the unchecked state and related value
     */
    this.uncheck = function(){
        this.setProperty("value", this.$values[1], false, true);
    };
    
    

    /**** Private state handling methods ****/

    this.addEventListener("$clear", function(){
        this.setProperty("value", this.$values[1]);
    });

    this.$enable = function(){
        if (this.$input) this.$input.disabled = false;
        this.$doBgSwitch(1);
    };

    this.$disable = function(){
        if (this.$input) this.$input.disabled = true;
        this.$doBgSwitch(4);
    };

    this.$setState = function(state, e, strEvent){
        //if (this.disabled) return;

        this.$doBgSwitch(this.states[state]);
        this.$setStyleClass(this.$ext, (state != "Out" ? this.$baseCSSname + state : ""),
            [this.$baseCSSname + "Down", this.$baseCSSname + "Over"]);
        this.state = state; // Store the current state so we can check on it coming here again.

        if (strEvent)
            this.dispatchEvent(strEvent, e);

        /*if (state == "Down")
            apf.cancelBubble(e, this);
        else
            e.cancelBubble = true;*/
    };

    this.$clickHandler = function(){
        //this.checked = !this.checked;
        this.change(this.$values[(!this.checked) ? 0 : 1]);

        
        if (this.validate) //@todo rewrite button
            this.validate(true);
        

        return true;
    };

    /**** Init ****/

    this.$draw = function(){
        //Build Main Skin
        this.$ext = this.$getExternal();
        this.$input = this.$getLayoutNode("main", "input", this.$ext);

        this.$setupEvents();
    };

    this.$childProperty = "label";

    
}).call(apf.checkbox.prototype = new apf.BaseButton());

apf.aml.setElement("checkbox", apf.checkbox);



/*FILEHEAD(/var/lib/platform/source/trunk/elements/application.js)SIZE(1834)TIME(1269561674)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * @todo description
 *
 * @author      Ruben Daniels (ruben AT ajax DOT org)
 * @version     %I%, %G%
 * @since       0.4
 */
apf.application = function(){
    this.$init("application", apf.NODE_HIDDEN);
    
    if (!apf.isO3) {    
        this.$int        = document.body;
        this.$tabList    = []; //Prevents documentElement from being focussed
        this.$focussable = apf.KEYBOARD;
        this.focussable  = true;
        this.visible     = true;
        this.$isWindowContainer = true;
        this.focus = function(){ this.dispatchEvent("focus"); };
        this.blur  = function(){ this.dispatchEvent("blur"); };
    
        
        apf.window.$addFocus(this);
        
    }
};
apf.application.prototype = new apf.AmlElement();
apf.aml.setElement("application", apf.application);



/*FILEHEAD(/var/lib/platform/source/trunk/elements/img.js)SIZE(7195)TIME(1270594868)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/elements/loader.js)SIZE(2111)TIME(1269561674)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * @todo description
 *
 * @author      Ruben Daniels (ruben AT ajax DOT org)
 * @version     %I%, %G%
 * @since       0.4
 */
apf.loader = function(){
    this.$init("loader", apf.NODE_HIDDEN);
    
    this.show = function(){
        this.$ext.style.display = "block";
    }
    
    this.hide = function(){
        this.$ext.style.display = "none";
    }
    
    this.addEventListener("DOMNodeInsertedIntoDocument", function(e){
        var pHtmlNode;
        if (!(pHtmlNode = this.parentNode.$int)) 
            return;

        this.$ext = apf.insertHtmlNode(null, pHtmlNode, null, this.$aml 
            ? (this.$aml.serialize ? this.$aml.serialize() : this.$aml.xml)
            : this.serialize());
        
        if (!apf.loaded) {
            var _self = this;
            apf.addEventListener("load", function(){
                if (apf.config.autoHideLoading) {
                    apf.queue.empty();
                    _self.hide();
                }
            });
        }
    });
};

apf.loader.prototype = new apf.AmlElement();

apf.aml.setElement("loader", apf.loader);




/*FILEHEAD(/var/lib/platform/source/trunk/elements/body.js)SIZE(1861)TIME(1269561674)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * @todo description
 *
 * @author      Ruben Daniels (ruben AT ajax DOT org)
 * @version     %I%, %G%
 * @since       0.4
 */



apf.AmlConfig = function(){
    this.$init("config", apf.NODE_VISIBLE);
};

(function(){
    this.focussable = false;
    this.$canLeechSkin = true;
    
    this.$draw = function(){
        //Build Main Skin
        this.$ext = this.$int = this.$getExternal(this.$isLeechingSkin
            ? this.localName 
            : "main");
    };

}).call(apf.AmlConfig.prototype = new apf.Presentation());

apf.aml.setElement("config", apf.AmlConfig);



/*FILEHEAD(/var/lib/platform/source/trunk/elements/state-group.js)SIZE(3131)TIME(1269561674)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/*FILEHEAD(/var/lib/platform/source/trunk/elements/bindings.js)SIZE(7882)TIME(1269561674)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * @define bindings element containing all the binding rules for the data 
 * bound elements referencing this element.
 * Example:
 * <code>
 *  <a:model id="mdlList">
 *      <data>
 *          <item date="2009-11-12" deleted="0"></item>
 *          <item date="2009-11-11" deleted="0"></item>
 *      </data>
 *  </a:model>
 *  <a:bindings id="bndFolders" >
 *      <a:caption match="[@date]" />
 *      <a:icon match="[@icon]" />
 *      <a:each match="[item]" sort="[@date]" />
 *  </a:bindings>
 *  <a:list 
 *    id       = "list" 
 *    width    = "200" 
 *    height   = "200" 
 *    model    = "mdlList" 
 *    bindings = "bndFolders" />
 * </code>
 * @see element.smartbinding
 *
 * @constructor
 * @apfclass
 *
 * @author      Ruben Daniels (ruben AT ajax DOT org)
 * @version     %I%, %G%
 * @since       0.8
 *
 * @default_private
 */
apf.bindings = function(struct, tagName){
    this.$init(tagName || "bindings", apf.NODE_HIDDEN, struct);
    
    this.$bindings = new apf.ruleList();
    this.$amlNodes = {};
};

(function(){
    this.$smartbinding = null;

    this.register = function(amlNode){
        if (amlNode.localName == "smartbinding") {
            this.$smartbinding = amlNode;
            this.$smartbinding.add(this); //Assuming only at init
            return;
        }
        
        if (!amlNode.hasFeature(apf.__DATABINDING__))
            return;

        this.$amlNodes[amlNode.$uniqueId] = amlNode;
        
        if (!this.$amlLoaded)
            return;

        if (!this.$bindings.$isCompiled)
            this.$cbindings = this.$bindings.compile();
        
        amlNode.$bindings  = this.$bindings;
        amlNode.$cbindings = this.$cbindings;
        
        //@todo apf3.0 should be deprecated
        amlNode.dispatchEvent("bindingsload", {
            bindings: this.$bindings, 
            compiled: this.$cbindings
        });
        this.dispatchEvent("noderegister", {
            amlNode: amlNode
        });
        amlNode.$checkLoadQueue();
    };

    this.unregister = function(){
        //unregister element
        this.$amlNodes[this.amlNode.$uniqueId] = null;
        delete this.$amlNodes[this.amlNode.$uniqueId];
        
        this.amlNode.$bindings  = 
        this.amlNode.$cbindings = false;
        
        this.amlNode.dispatchEvent("bindingsunload", {
            bindings: this.$bindings, 
            compiled: this.$cbindings
        });
    };
    
    this.reload = function(){
        for (var id in this.$amlNodes){
            this.$amlNodes[id].reload();
        }
    }
    
    /**** DOM Handlers ****/
    
    this.addEventListener("DOMNodeInsertedIntoDocument", function(e){
        var nodes = this.childNodes;
        for (var node, i = 0, l = nodes.length; i < l; i++) {
            if (!(node = nodes[i]).$amlLoaded && node.nodeType == 1)
                node.dispatchEvent("DOMNodeInsertedIntoDocument"); //{relatedParent : nodes[j].parentNode}
        }
        
        this.register(this.parentNode);
        
        for (var id in this.$amlNodes)
            this.register(this.$amlNodes[id]);
    });
}).call(apf.bindings.prototype = new apf.AmlElement());

apf.ruleList = function(){
    this.$compiled = {};
}
apf.ruleList.prototype = {
    $isCompiled : false,
    
    getRule : function(name, xmlNode){
        var rules = this[name];
        if (!rules) return false;
        
        //@todo Shouldn't allow async calls..., should always give a function
        for (var func, rule, i = 0, l = rules.length; i < l; i++) {
            rule = rules[i];
            if (!rule.match) 
                return rule;

            func = rule.cmatch || rule.compile("match", {injectself: true, xpathmode: 2});
            if (func && func(xmlNode))
                return rule;
        }
    },
    
    compile : function(name){
        var rules, s, c = this.$compiled;

        if (name) {
            s     = [];
            rules = this[name];
            for (var rule, i = 0, l = rules.length; i < l; i++) {
                if (!(rule = rules[i]).match && !rule.value)
                    continue;

                s.push(rule.match, rule.value);
            }
            
            //always give a function, no async calls (could also just error on execution)
            c[name] = apf.lm.compileMatch(s); 
            
            return c;
        }
        
        for (name in this) {
            if (name == "each")
                continue;
            
            rules = this[name];
            if (rules.dataType != apf.ARRAY)
                continue;
            
            s = [];
            for (var rule, i = 0, l = rules.length; i < l; i++) {
                if (!(rule = rules[i]).match && !rule.value)
                    continue;

                s.push(rule.match, rule.value);
            }
            
            //always give a function, no async calls (could also just error on execution)
            c[name] = apf.lm.compileMatch(s); 
        }

        this.$isCompiled = true;
        
        return c;
    },
    
    getRuleIndex : function(name, index) {
        var rule = this[name][index];
        if (rule.value) {
            if (!rule.cvalue)
                rule.compile("value");
        }
        else if (rule.match) {
            if (!rule.cmatch)
                rule.compile("match");
        }
        return rule;
    },
    
    getDataNode : function(name, xmlNode, createNode, ruleList, multiple){
        var i, l, func, node, rule, rules = this[name];
        if (!rules)
            return;
        
        //@todo Shouldn't allow async calls..., should always give a function
        for (rule, i = 0, l = rules.length; i < l; i++) {
            rule = rules[i];
            
            func = rule.cvaluematch;
            if (!func) { //@todo apf3.0 cleanup
                if (rule.match && rule.value)
                    rule.valuematch = "{_n = " + rule.match + "; %[child::" 
                        + rule.value.substr(1, rule.value.length - 2)
                            .split("|").join("|child::") + "]}";
                else
                    rule.valuematch = rule.match || rule.value;
                
                func = rule.$compile("valuematch", {
                    xpathmode  : multiple ? 4 : 3, 
                    injectself : rule.match ? true : false
                });
            }
            
            if (func && (node = func(xmlNode, createNode))) {
                if (ruleList)
                    ruleList.push(rule);

                return node;
            }
        }
        
        return false;
    }
}

apf.aml.setElement("bindings", apf.bindings);




/*FILEHEAD(/var/lib/platform/source/trunk/elements/viewport.js)SIZE(1796)TIME(1269561674)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/elements/appsettings.js)SIZE(9284)TIME(1270887863)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * Element specifying the settings of the application.
 * @define appsettings
 * @addnode global
 * @attribute {Boolean} debug                   whether the debug screen is shown at startup.
 * @see core.apf.object.debugwin
 * @see core.apf.object.console
 * @attribute {String}  name                    the name of the application, used by many different services to uniquely identify the application.
 * @attribute {Boolean} disable-right-click     whether a user can get the browsers contextmenu when the right mouse button is clicked.
 * @see element.contextmenu
 * @attribute {Boolean} allow-select            whether general text in the application can be selected.
 * @attribute {Boolean} allow-blur              whether it's possible to blur an element while not giving the focus to another element. Defaults to true.
 * @attribute {Boolean} auto-disable-actions    whether smartbinding actions are by default disabled.
 * @see term.action
 * @attribute {Boolean} auto-disable            whether elements that don't have content loaded are automatically disabled.
 * @attribute {Boolean} disable-f5              whether the F5 key for refreshing is disabled.
 * @attribute {Boolean} auto-hide-loading       whether the load screen defined by the loader element is automatically hidden. Setting this to false enables you to control when the loading screen is hidden. Use the following code to do so:
 * <code>
 *  apf.document.getElementsByTagName("a:loader")[0].hide()
 *  //or
 *  loaderId.hide()
 * </code>
 * @attribute {Boolean} disable-space           whether the space button default behaviour of scrolling the page is disabled.
 * @attribute {Boolean} disable-backspace       whether the backspace button default behaviour of going to the previous history state is disabled.
 * @attribute {String}  default-page            the name of the default page if none is specified using the #. Defaults to "home". See {object.history}.
 * @see element.history
 * @attribute {Boolean} undokeys                whether the undo and redo keys (in windows they are ctrl-Z and ctrl-Y) are enabled.
 * @see element.actiontracker
 * @attribute {String, Boolean} outline         whether an outline of an element is shown while dragging or resizing.
 * @see baseclass.interactive
 * @attribute {String, Boolean} drag-outline    whether an outline of an element is shown while dragging.
 * @see baseclass.interactive
 * @attribute {String, Boolean} resize-outline  whether an outline of an element is shown while resizing.
 * @see baseclass.interactive
 * @attribute {String}  layout                  the {@link term.datainstruction data instruction} to retrieve the layout xml definition.
 * @see core.layout
 * @attribute {String}  baseurl                 the basepath for any relative url used throughout your application. This included teleport definitions and {@link term.datainstruction data instruction}.
 * @see teleport.http
 * @see term.datainstruction
 * @attribute {String}  loading-message         the global value for the loading message of elements during a loading state.
 * @see baseclass.databinding.attribute.loading-message
 * @attribute {String}  offline-message         the global value for the offline message of elements not able to display content while offline.
 * @see baseclass.databinding.attribute.offline-message
 * @attribute {String}  empty-message           the global value for the empty message of elements containing no contents.
 * @see baseclass.databinding.attribute.empty-message
 * @attribute {String}  model                   the default model for this application.
 * @see element.model
 * @attribute {String}  realtime                the global value whether bound values are realtime updated. When set to false elements do not update until they lose focus.
 * @see element.editor.attribute.realtime
 * @see element.textbox.attribute.realtime
 * @see element.slider.attribute.realtime
 * @attribute {String}  skinset                 the skin set used by the application.
 * @see baseclass.presentation.attribute.skinset
 * @attribute {String}  storage                 the {@link core.storage storage provider} to be used for key/value storage.
 * @see core.storage
 * @attribute {String}  offline                 the {@link core.storage storage provider} to be used for offline support.
 * @see element.offline
 * @attribute {String}  login                   the {@link term.datainstruction data instruction} which logs a user into the application.
 * @see element.auth
 * @attribute {String}  logout                  the {@link term.datainstruction data instruction} which logs a user out of the application.
 * @see element.auth
 * @attribute {String}  iepngfix                whether the fix for PNG images with transparency should be applied. Default is false.
 * @attribute {String}  iepngfix-elements       a comma-seperated list of CSS identifiers (classes) to which the transparent-PNG fix will be applied.
 * @attribute {Boolean} iphone-fullscreen       whether the application should cover the entire screen of the iPhone. Default is true.
 * @attribute {String}  iphone-statusbar        the style of the statusbar of the iPhone webbrowser. Posssible values: 'default', black-translucent' or 'black'.
 * @attribute {String}  iphone-icon             path pointing to the icon that should be used when this application is put on the iPhone Dashboard.
 * @attribute {Boolean} iphone-icon-is-glossy   whether the icon specified with 'iphone-icon' already is glossy or if the iPhone OS should apply that effect. Default is false.
 * @attribute {Boolean} iphone-fixed-viewport   whether the viewport of the application is fixed and whether the zoom should be enabled. Default is true.
 * @allowchild auth, authentication, offline, printer, defaults
 * @todo describe defaults
 */
apf.appsettings = function(struct, tagName){
    this.$init(tagName || "appsettings", apf.NODE_HIDDEN, struct);
};

(function(){
    this.$parsePrio = "001";
    
    //1 = force no bind rule, 2 = force bind rule
    this.$attrExcludePropBind = {
        language : 1,
        login    : 1,
        logout   : 1,
        layout   : 1
    };
    
    this.$supportedProperties = ["debug", "name", "baseurl", "resource-path", 
        "disable-right-click", "allow-select", "allow-blur", 
        "auto-disable-actions", "auto-disable", "disable-f5", 
        "auto-hide-loading", "disable-space", "disable-backspace", "undokeys", 
        "initdelay", "default-page", "query-append", "outline", "drag-outline", 
        "resize-outline", "resize-outline", "iepngfix", "iepngfix-elements", 
        "iphone-fullscreen", "iphone-statusbar", "iphone-icon", 
        "iphone-icon-is-glossy", "iphone-fixed-viewport", "layout", "skinset", 
        "language", "storage", "offline", "login"];
    this.$booleanProperties = {
        
        "debug":1,
        "disable-right-click":1,
        "allow-select":1,
        "allow-blur":1,
        "auto-disable-actions":1,
        "auto-disable":1,
        "disable-f5":1,
        "auto-hide-loading":1,
        "disable-space":1,
        "disable-backspace":1,
        "undokeys":1,
        "initdelay":1,
        "outline":1,
        "iepngfix":1,
        "iphone-fullscreen":1,
        "iphone-icon-is-glossy":1, 
        "iphone-fixed-viewport":1
    };
    
    this.$handlePropSet = function(prop, value, force){
        if (this.$booleanProperties[prop])
            value = apf.isTrue(value);

        this[prop] = value;

        apf.config.setProperty(prop, value);
    };
    
    this.addEventListener("DOMNodeInsertedIntoDocument", function(e){
        
        if (apf.isIphone && apf.runIphone) {
            //@todo apf3.0 mike please error check all the settings
            
            apf.runIphone();
            delete apf.runIphone;
        }
        
    });
}).call(apf.appsettings.prototype = new apf.AmlElement());

apf.aml.setElement("appsettings", apf.appsettings);


/*FILEHEAD(/var/lib/platform/source/trunk/elements/bindingcolorrule.js)SIZE(2906)TIME(1258118723)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * @todo docs
 */
apf.BindingColorRule = function(struct, tagName){
    this.$init(tagName, apf.NODE_HIDDEN, struct);
};

(function(){
    this.addEventListener("DOMNodeInsertedIntoDocument", function(e){
        //@todo This should support multiple color rules, by inserting the rules at the right place.
        if (this.$bindings && this.$bindings.color) {
            var clr = this.$bindings.color[0];
            apf.setStyleRule("." + this.$baseCSSname + (apf.isIE
                ? " .records .highlight SPAN"
                : " .records .highlight span"), "color", clr.getAttribute("text"), null, this.oWin);
            apf.setStyleRule("." + this.$baseCSSname + (apf.isIE
                ? " .records .highlight SPAN"
                : " .records .highlight span"), "backgroundColor", clr.getAttribute("row"), null, this.oWin);
            apf.setStyleRule("." + this.$baseCSSname + (apf.isIE
                ? " .records .highlight"
                : " .records .highlight"), "backgroundColor", clr.getAttribute("row"), null, this.oWin);
            /*apf.importCssString("." + this.$baseCSSname + " .records div.highlight{background-color:" 
                + clr.getAttribute("row") + ";} ." 
                + this.$baseCSSname + " .records div.highlight span{color:" 
                + clr.getAttribute("text") + ";}");*/
        }
        
        //"." + this.$baseCSSname + " .headings 
        apf.importStylesheet([
          ["." + this.className,
            "width:" + this.$width + (this.$isPercentage ? "%;" : "px;")
            + "text-align:" + h.align],
          ["." + this.className,
            "width:" + this.$width + (this.$isPercentage ? "%;" : "px;")
            + "text-align:" + h.align]
        ]);
        
        this.$draw();
    });
}).call(apf.BindingColorRule.prototype = new apf.BindingRule());

apf.aml.setElement("color", apf.BindingColorRule);




/*FILEHEAD(/var/lib/platform/source/trunk/elements/rpc.js)SIZE(20869)TIME(1270838607)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * Baseclass for rpc in teleport. Modules are available for
 * SOAP, XML-RPC, CGI, JSON-RPC and several proprietary protocols.
 *
 * Example:
 * Ajax.org Markup Language
 * <code>
 *  <a:rpc id="comm" 
 *    protocol    = "soap" 
 *    url         = "http://example.com/show-product.php" 
 *    soap-prefix = "m" 
 *    soap-xmlns  = "http://example.com">
 *      <a:method 
 *        name    = "searchProduct" 
 *        receive = "processSearch">
 *          <a:param name="search" />
 *          <a:param name="page" />
 *          <a:param name="textbanner" value="1" />
 *      </a:method>
 *      <a:method 
 *        name = "loadProduct">
 *          <a:param name="id" />
 *          <a:param name="search_id" />
 *      </a:method>
 *  </a:rpc>
 *
 *  <a:script>
 *      //This function is called when the search returns
 *      function processSearch(data, state, extra){
 *          alert(data)
 *      }
 *
 *      //Execute a search for the product car
 *      comm.searchProduct('car', 10);
 *  </a:script>
 * </code>
 *
 * Example:
 * This example shows an rpc element using the xmlrpc protocol. It contains
 * two methods which can be called. The return of the first method is handled
 * by a javascript function called processSearch.
 * <code>
 *  <a:rpc 
 *    id       = "flickr" 
 *    protocol = "xmlrpc" 
 *    url      = "http://www.flickr.com/services/xmlrpc/"> 
 *      <a:method 
 *        name        = "search" 
 *        receive     = "flickrResult" 
 *        method-name = "flickr.photos.search" />
 *  </a:rpc>
 *  
 *  <a:script>//<!-- 
 *      //This function is called when the search returns
 *      function flickrResult(data, state, extra) {
 *          alert(data)
 *      };
 *      
 *      //Execute a search for the flowers keyword
 *      flickr.search({
 *          api_key  : '5ab84bdb606e86015a15a45ffe8d022b',
 *          text     : "flowers", 
 *          per_page : 4, 
 *          page     : 1
 *      });
 *  //--></a:script>
 * </code>
 *
 * Example:
 * Ajax.org Markup Language
 * <code>
 *  <a:rpc id="comm" protocol="cgi">
 *      <a:method
 *        name    = "searchProduct"
 *        url     = "http://localhost/search.php"
 *        receive = "processSearch">
 *          <a:param name="search" />
 *          <a:param name="page" />
 *          <a:param name="textbanner" value="1" />
 *      </a:method>
 *  </a:rpc>
 *  
 *  <a:script>
 *      //This function is called when the search returns
 *      function processSearch(data, state, extra){
 *         alert(data)
 *      }
 *  
 *      //Execute a search for the product car
 *      comm.searchProduct('car', 10);
 *  </a:script>
 * </code>
 *
 * Example:
 * Ajax.org Markup Language
 * <code>
 *  <a:rpc id="comm" protocol="jsonrpc">
 *      <a:method 
 *        name    = "searchProduct" 
 *        receive = "processSearch">
 *          <a:param name="search" />
 *          <a:param name="page" />
 *          <a:param name="textbanner" value="1" />
 *      </a:method>
 *      <a:method 
 *        name = "loadProduct">
 *          <a:param name="id" />
 *          <a:param name="search_id" />
 *      </a:method>
 *  </a:rpc>
 *
 *  <a:script>
 *      //This function is called when the search returns
 *      function processSearch(data, state, extra){
 *          alert(data)
 *      }
 *
 *      //Execute a search for the product car
 *      comm.searchProduct('car', 10);
 *  </a:script>
 * </code>
 *
 * Example:
 * Ajax.org Markup Language
 * <code>
 *  <a:rpc id="comm" protocol="cgi">
 *      <a:method
 *        name    = "searchProduct"
 *        url     = "http://example.com/search.php"
 *        receive = "processSearch">
 *          <a:param name="search" />
 *          <a:param name="page" />
 *          <a:param name="textbanner" value="1" />
 *      </a:method>
 *      <a:method
 *        name = "loadProduct"
 *        url  = "http://example.com/show-product.php">
 *          <a:param name="id" />
 *          <a:param name="search_id" />
 *      </a:method>
 *  </a:rpc>
 *
 *  <a:script>
 *      //This function is called when the search returns
 *      function processSearch(data, state, extra){
 *          alert(data)
 *      }
 *
 *      //Execute a search for the product car
 *      comm.searchProduct('car', 10);
 *  </a:script>
 * </code>
 *
 * Example:
 * Ajax.org Markup Language
 * <code>
 *  <a:rpc id="comm" protocol="jsonrpc">
 *      <a:method 
 *        name    = "searchProduct" 
 *        receive = "processSearch">
 *          <a:param name="search" />
 *          <a:param name="page" />
 *          <a:param name="textbanner" value="1" />
 *      </a:method>
 *      <a:method 
 *        name = "loadProduct">
 *          <a:param name="id" />
 *          <a:param name="search_id" />
 *      </a:method>
 *  </a:rpc>
 *
 *  <a:script>
 *      //This function is called when the search returns
 *      function processSearch(data, state, extra){
 *          alert(data)
 *      }
 *
 *      //Execute a search for the product car
 *      comm.searchProduct('car', 10);
 *  </a:script>
 * </code>
 *
 * @attribute {String}  protocol         the name of the plugin that is used
 *                                       to provide the messages.
 * @attribute {Boolean} [multicall]      whether the call is stacked until
 *                                       purge() is called.
 * @attribute {String}  [route-server]   the location of the proxy script that 
 *                                       allows for cross domain communication.
 * @attribute {String}  [http-method]    the http method used to send the data.
 *                                       This attribute is only used by the cgi protocol.
 *   Possible values:
 *   post   Used to store large chunks of data (on a resource).
 *   get    Used to retrieve data from a resource.
 *   delete Used to delete a resource.
 *   head   Returns only the headers.
 *   put    Used to store data at a resource.
 * @attribute {String}  [method-name]    the variable name used to sent the
 *                                       name of the method called to the
 *                                       server. This attribute is only used
 *                                       by the cgi protocol.
 * @attribute {String}  [soap-xmlns]     the url that uniquely identifies the
 *                                       xml namespace for the message. This
 *                                       attribute is only used by the soap
 *                                       protocol.
 * @attribute {String}  [soap-prefix]    the prefix that is paired with the
 *                                       message xml namespace. This attribute
 *                                       is only used by the soap protocol.
 * @define rpc
 * @allowchild method
 *
 * @constructor
 *
 * @author      Ruben Daniels (ruben AT ajax DOT org)
 * @author      Mike de Boer (mike AT javeline DOT com)
 * @version     %I%, %G%
 * @since       0.4
 * @default_private
 */
apf.rpc = function(struct, tagName){
    this.$init(tagName || "rpc", apf.NODE_HIDDEN, struct);

    if (!this.supportMulticall)
        this.multicall = false;
    this.stack    = {};
    this.urls     = {};
    this.$methods = {};
};

(function(){
    this.useHTTP         = true;
    this.namedArguments  = false;

    this["route-server"] = apf.host + "/cgi-bin/rpcproxy.cgi";
    this.autoroute       = false;

    this.$auth           = false;

    this.$booleanProperties["multicall"] = true;

    this.$supportedProperties.push("protocol", "type", "multicall", "http-method");

    this.$propHandlers["route-server"] = function(value){
        this.autoroute = value ? true : false;
    }

    //@todo change this to use prototype
    this.$propHandlers["protocol"] = function(value){
        if (!value)
            return;
        
        if (!apf[value]) {
            
            throw new Error(apf.formatErrorString(1025, null, "Teleport baseclass",
                "Could not find Ajax.org Teleport RPC Component '" + value + "'", this));
            
            return;
        }
        this.implement(apf[value]);
    };

    this.$propHandlers["type"] = function(value) {
        this.$useXml = (typeof value == "string" && value.toUpperCase() == "XML");
    };

    /**
     * Sets the callback for a method on this object.
     * Example:
     * <code>
     *  comm.setCallback("login", function(data, state, extra) {
     *      alert(data);
     *  });
     *
     *  comm.login(user, pass);
     * </code>
     * @param {String}   name the name of the method defined on this object.
     * @param {Function} func the function that is called when the rpc method returns.
     */
    this.setCallback = function(name, func){
        
        if (!this.$methods[name])
            throw new Error(apf.formatErrorString(0, this, "Teleport RPC",
                "Trying to set callback: method not found."));
        
            
        this.$methods[name].callback = func;
    };

    /**
     * Sets the target url for a method on this object.
     * Example:
     * <code>
     *  comm.setCallback("login", "scripts/login.php");
     *
     *  comm.login(user, pass);
     * </code>
     * @param {String} name the name of the method defined on this object.
     * @param {String} url  the target url of method defined on this object.
     */
    this.setUrl = function(name, url) {
        
        if (!this.$methods[name])
            throw new Error(apf.formatErrorString(0, this, "Teleport RPC",
                "Trying to set callback: method not found."));
        

        this.$methods[name].setProperty("url", url);
    };

    this.$convertArgs = function(name, args){
        if (!this.namedArguments)
            return Array.prototype.slice.call(args);

        var nodes = this.$methods[name].names;
        if (!nodes || !nodes.length)
            return {};

        var value, j, i, l, result = {};
        for (j = 0, i = 0, l = nodes.length; i < l; i++) {
            name  = nodes[i].name;
            value = nodes[i].value;

            if (value) {
                value = apf.parseExpression(value);
            }
            else {
                value = args[j++];

                if (apf.isNot(value) && nodes[i]["default"])
                    value = apf.parseExpression(nodes[i]["default"]);
            }

            //Encode string optionally
            value = apf.isTrue(nodes[i].encoded)
                ? encodeURIComponent(value)
                : value;

            result[name] = value;
        }

        return result;
    };

    function getCallback(node) {
        var p, f;
        if (typeof node.callback == "string") {
            // support objects and namespaced functions
            p = node.callback.split("."),
            f = self[p.shift()];
            while (f && p.length)
                f = f[p.shift()];
        }
        else {
            f = node.callback;
        }
        return f || apf.K;
    }

    this.call = function(name, args, options){
        var callback,
            node = this.$methods[name];
        
        if (typeof args[args.length - 1] == "function") {
            args     = Array.prototype.slice.call(args); //@todo optimize?
            callback = args.pop();
        }
        else {
            callback = getCallback(node);
        }

        args = this.$convertArgs(name, args);

        // Set up multicall
        if (this.multicall) {
            if (!this.stack[this.url])
                this.stack[this.url] = this.getMulticallObject
                    ? this.getMulticallObject()
                    : [];

            this.getSingleCall(name, args, this.stack[this.url])
            return true;
        }

        // Get Data
        var _self = this,
            data  = this.createMessage(node["method-name"] || name, args); //function of module

        function pCallback(data, state, extra){
            extra.data = data;

            if (state != apf.SUCCESS)
                callback.call(_self, null, state, extra);
            else if (_self.isValid && !_self.isValid(extra))
                callback.call(_self, null, apf.ERROR, extra);
            else
                callback.call(_self, _self.unserialize(extra.data), state, extra);
        }

        // Send the request
        var auth,
            url  = apf.getAbsolutePath(this.baseurl || apf.config.baseurl, this.url),
            o    = apf.extend({
                callback      : pCallback,
                async         : node.async,
                userdata      : node.userdata,
                nocache       : (this.nocache === false) ? false : true,
                data          : data,
                useXML        : this.$useXml || node.type == "xml",
                caching       : node.caching,
                ignoreOffline : node["ignore-offline"]
            }, options);

        

        return this.$get(url, o);
    };

    /**
     * Purge multicalled requests
     */
    this.purge = function(callback, userdata, async, extradata){
        
        if (!this.stack[this.url] || !this.stack[this.url].length) {
            throw new Error(apf.formatErrorString(0, null, "Executing a multicall", 
                "No RPC calls where executed before calling purge()."));
        }
        

        // Get Data
        var data = this.createMessage("multicall", [this.stack[this.url]]), //function of module
            url  = apf.getAbsolutePath(this.baseurl || apf.config.baseurl, this.url);
        if (extradata) {
            for (var vars = [], i = 0; i < extradata.length; i++) {
                vars.push(encodeURIComponent(extradata[i][0]) + "="
                    + encodeURIComponent(extradata[i][1] || ""))
            }
            url = url + (url.match(/\?/) ? "&" : "?") + vars.join("&");
        }

        var info = this.$get(url, {
            callback : callback,
            async    : async,
            userdata : userdata,
            nocache  : true,
            data     : data,
            useXML   : this.$useXml
        });

        this.stack[this.url] = this.getMulticallObject
            ? this.getMulticallObject()
            : [];

        //return info[1];
    };

    this.revert = function(modConst){
        this.stack[modConst.url] = this.getMulticallObject
            ? this.getMulticallObject()
            : [];
    };

    this.getStackLength = function(){
        return this.stack[this.url] ? this.stack[this.url].length : 0;
    };

    /**
     * Loads aml definition
     */
    this.$addMethod = function(amlNode){
        if (amlNode.localName != "method"){
            
            throw new Error(apf.formatErrorString(0, this,
                "Parsing RPC Teleport node",
                "Found element which is not a method", this));
            
            return false;
        }
        
        var name = amlNode.name,
            cb   = amlNode.receive || this.receive,
            i    = 0,
            l    = amlNode.childNodes.length,
            node;

        this[name] = function(){
            return this.call(name, arguments);
        };

        if (cb)
            amlNode.callback = cb;

        this.$methods[name] = amlNode;

        if (!amlNode.names)
            amlNode.names = [];
        for (; i < l; i++) {
            node = amlNode.childNodes[i];
            if (node.localName == "param" || node.localName == "variable") //@todo deprecate variable
                amlNode.names.push(node);
        }

        return true;
    };

    this.$removeMethod = function(amlNode) {
        var name = amlNode.name;
        delete this[name];
        delete this.$methods[name];
    };

    this.$setAuth = function(amlNode) {
        this.$auth = amlNode;
    };

    /*
    this.addEventListener("DOMNodeInserted", function(e){
        var node = e.currentTarget;
        if (node.parentNode != this)
            return;

        this.register(node);
    });

    this.addEventListener("DOMNodeRemoved", function(e){
        var node = e.currentTarget;
        // we support two levels deep:
        if (!(node.parentNode == this || node.parentNode.parentNode == this))
            return;

        this.unregister(node);
    });*/
    
    
    this.exec = function(method, args, callback, options){
        if (!options) options = {};

        //force multicall if needed;
        if (options.multicall)
            this.forceMulticall = true;
    
        //Set information later neeed
        
        if (!this[method])
            throw new Error(apf.formatErrorString(0, null, "Saving/Loading data",
                "Could not find RPC function by name '" + method + "' in data "
              + "instruction '" + options.instruction + "'"));
        
        
        var props = this.$methods[method];

        if (options.userdata)
            props.userdata = options.userdata;
    
        if (!this.multicall)
            props.callback = callback; //&& this[method].async
    
        //Call method
        var retvalue = this.call(method, args, options);
    
        if (this.multicall)
            return this.purge(callback, "&@^%!@"); //Warning!! @todo Make multicall work with offline
        else if (options.multicall) {
            this.forceMulticall = false;
            return this;
        }
    
        
    
        //Call callback for sync calls
        if (!this.multicall && !props.async && callback)
            callback(retvalue, apf.SUCCESS, {tpModule: this});
    };
    

    /*
     * Post a form with ajax
     *
     * @param form     form
     * @param function callback  Called when http result is received
     * /
     this.submitForm = function(form, callback, callName) {
         this.addMethod('postform', callback);
         this.urls['postform'] = form.action;
         var args = [];
         for (var i = 0; i < form.elements.length; i++) {
             var name = form.elements[i].name.split("[");
             for(var j = 0; j < name.length; j++) {
                 //Hmm problem with sequence of names... have to get that from the variable sequence...
             }
             args[] = form.elements[i].value;
         }

         this['postform'].apply(this, args);
     };
     */
}).call(apf.rpc.prototype = new apf.Teleport());

apf.config.$inheritProperties["baseurl"] = 1;

apf.aml.setElement("rpc", apf.rpc);



/*FILEHEAD(/var/lib/platform/source/trunk/elements/frame.js)SIZE(4708)TIME(1270640787)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/elements/axis.js)SIZE(14042)TIME(1257329184)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/*FILEHEAD(/var/lib/platform/source/trunk/elements/method.js)SIZE(3973)TIME(1270838607)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * element specifying a method available within the rpc element.
 *
 * @attribute {String}  name             the name of the method. This name will
 *                                       be available on the rpc object as a
 *                                       javascript method.
 * Example:
 * <code>
 *  <a:rpc id="comm" protocol="xmlrpc">
 *      <a:method name="save" />
 *  </a:rpc>
 *
 *  <a:script>
 *      comm.save(data);
 *  </a:script>
 * </code>
 * @attribute {String}  [callback]       the name of the method that handles
 *                                       the return of the call.
 * @attribute {Boolean} [async]          whether the call is executed in the
 *                                       backround. Default is true. When set
 *                                       to false the application hangs while
 *                                       this call is executed.
 * @attribute {Boolean} [caching]        whether the call is cached. Default
 *                                       is false. When set to true any call
 *                                       with the same data will return immediately
 *                                       with the cached result.
 * @attribute {Boolean} [ignore-offline] whether the method should not be stored
 *                                       for later execution when offline.
 * @attribute {Boolean} [method-name]    the name sent to the server.
 *
 * @attribute {String}  [type]           the type of the returned data
 * Possible values:
 * xml  returns the response as an xml document
 *
 * @allowchild variable
 */
apf.method = function(struct, tagName){
    this.$init(tagName || "method", apf.NODE_HIDDEN, struct);

    this.async             = true;
    this.caching           = false;
    this["ignore-offline"] = false;
};

(function(){
    this.$parsePrio = "002";
    
    this.$booleanProperties["async"]          = true;
    this.$booleanProperties["caching"]        = true;
    this.$booleanProperties["ignore-offline"] = true;

    this.$supportedProperties.push("name", "receive", "async", "caching",
        "ignore-offline", "method-name", "type", "url");

    this.$propHandlers["ignore-offline"] = function(value){
        this.ignoreOffline = value;
    };
    
    this.$propHandlers["method-name"] = function(value){
        this.methodName = value;
    };

    /**** DOM Handlers ****/

    this.addEventListener("DOMNodeInserted", function(e){
        if (this.parentNode.$addMethod && e.currentTarget == this)
            this.parentNode.$addMethod(this);
    });
    
    this.addEventListener("DOMNodeRemoved", function(e){
        if (this.parentNode.$removeMethod && e.currentTarget == this)
            this.parentNode.$removeMethod(this);
    });

    this.addEventListener("DOMNodeInsertedIntoDocument", function(e){
        if (this.parentNode.$addMethod)
            this.parentNode.$addMethod(this);
    });
}).call(apf.method.prototype = new apf.AmlElement());

apf.aml.setElement("method", apf.method);


/*FILEHEAD(/var/lib/platform/source/trunk/elements/rpc/jsonrpc.js)SIZE(3148)TIME(1269561673)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/elements/rpc/yql.js)SIZE(3985)TIME(1265666736)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/elements/rpc/soap.js)SIZE(10966)TIME(1269561673)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/elements/rpc/jphp.js)SIZE(5897)TIME(1269561673)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/elements/rpc/xmlrpc.js)SIZE(11177)TIME(1269561673)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/elements/rpc/header.js)SIZE(3085)TIME(1269561673)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/elements/rpc/rest.js)SIZE(3550)TIME(1269561673)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/elements/rpc/cgi.js)SIZE(7186)TIME(1271234270)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/**
 * Implementation of the Common Gateway Interface (CGI) as a module for the RPC
 * plugin of apf.teleport.
 * Example:
 * Ajax.org Markup Language
 * <code>
 *  <a:rpc id="comm" protocol="cgi">
 *      <a:method
 *        name    = "searchProduct"
 *        url     = "http://example.com/search.php"
 *        receive = "processSearch">
 *          <a:param name="search" />
 *          <a:param name="page" />
 *          <a:param name="textbanner" value="1" />
 *      </a:method>
 *      <a:method
 *        name = "loadProduct"
 *        url  = "http://example.com/show-product.php">
 *          <a:param name="id" />
 *          <a:param name="search_id" />
 *      </a:method>
 *  </a:rpc>
 *
 *  <a:script>
 *      //This function is called when the search returns
 *      function processSearch(data, state, extra){
 *          alert(data)
 *      }
 *
 *      //Execute a search for the product car
 *      comm.searchProduct('car', 10);
 *  </a:script>
 * </code>
 * Remarks:
 * Calls can be made to a server using cgi variables with a special
 * {@link term.datainstruction data instruction}
 * format.
 * <code>
 *  get="http://www.bla.nl?blah=10&foo=[@bar]&example=[10+5]"
 *  set="post http://www.bla.nl?blah=10&foo={/bar}&example=[10+5]"
 * </code>
 *
 * @addenum rpc[@protocol]:cgi
 *
 * @constructor
 *
 * @inherits apf.Teleport
 * @inherits apf.http
 * @inherits apf.rpc
 *
 * @author      Ruben Daniels (ruben AT ajax DOT org)
 * @version     %I%, %G%
 * @since       0.4
 *
 * @default_private
 */
apf.cgi = function(){
    this.supportMulticall = false;
    this.namedArguments   = true;

    this.unserialize = function(str){
        return str;
    };

    this.getSingleCall = function(name, args, obj){
        obj.push(args);
    };

    // Create message to send
    this.createMessage = function(functionName, args){
        var prop,
            vars = [];

        function recur(o, stack){
            if (o && o.dataType == apf.ARRAY) {
                for (var j = 0; j < o.length; j++)
                    recur(o[j], stack + "%5B" + j + "%5D");//" + j + "
            }
            else if (typeof o == "object") {
                if (o.nodeType) {
                    try{
                        var s = o.outerHTML || o.serialize && o.serialize() 
                          || apf.getCleanCopy(o).xml;
                    }
                    catch(e){
                        var s = "Could not serialize object";
                    }
                    vars.push(stack + "=" + encodeURIComponent(s));
                }
                else {
                    for (prop in o) {
                        
    
                        if (typeof o[prop] == "function")
                            continue;
                        recur(o[prop], stack + "%5B" + encodeURIComponent(prop) + "%5D");
                    }
                }
            }
            else {
                if (typeof o != "undefined" && o !== null) 
                    vars.push(stack + "=" + encodeURIComponent(o));
            }
        };

        if (this.multicall) {
            vars.push("func" + "=" + this.mcallname);
            for (var i = 0; i < args[0].length; i++)
                recur(args[0][i], "f%5B" + i + "%5D");
        }
        else {
            for (prop in args) {
                

                recur(args[prop], prop);
            }
        }

        if (!this.baseUrl)
            this.baseUrl = this.url;

        this.url = this.$methods[functionName].url
            ? this.$methods[functionName].url
            : this.baseUrl;

        if (this.method != "GET")
            return vars.join("&");

        this.url = this.url + (vars.length
            ? (this.url.indexOf("?") > -1 ? "&" : "?") + vars.join("&")
            : "");

        return "";
    };

    this.addEventListener("DOMNodeInsertedIntoDocument", function() {
        this.method      = (this["http-method"] || "GET").toUpperCase();
        this.contentType = this.method == "GET"
            ? null
            : "application/x-www-form-urlencoded";
    });

    /**
     * Submit a form with ajax (GET)
     *
     * @param {HTMLElement} form      the html form element to submit.
     * @param {Function}       callback  called when the http call returns.
     */
    this.submitForm = function(form, callback){
        if (!this['postform'])
            this.addMethod('postform', callback);

        var args = [];
        for (var i = 0, l = form.elements.length; i < l; i++) {
            if (!form.elements[i].name)
                continue;
            if (form.elements[i].tagname == "input"
              && (form.elements[i].type  == "checkbox"
              || form.elements[i].type   == "radio")
              && !form.elements[i].checked)
                continue;

            if (form.elements[i].tagname = "select" && form.elements[i].multiple) {
                for (var j = 0; j < form.elements[i].options.length; j++) {
                    if (form.elements[i].options[j].selected)
                        args.push(form.elements[i].name
                            + "="
                            + encodeURIComponent(form.elements[i].options[j].value));
                }
            }
            else {
                args.push(form.elements[i].name
                    + "="
                    + encodeURIComponent(form.elements[i].value));
            }
        }

        var loc               = (form.action || location.href);
        this.urls['postform'] = loc + (loc.indexOf("?") > -1 ? "&" : "?") + args.join("&");
        this['postform'].call(this);

        return false;
    };
};




/*FILEHEAD(/var/lib/platform/source/trunk/elements/audio/type_flash.js)SIZE(12951)TIME(1259091144)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/*FILEHEAD(/var/lib/platform/source/trunk/elements/audio/type_native.js)SIZE(11013)TIME(1259091144)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/*FILEHEAD(/var/lib/platform/source/trunk/elements/modalwindow/widget.js)SIZE(7077)TIME(1259091144)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/elements/textbox/masking.js)SIZE(13238)TIME(1265032029)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/elements/textbox/autocomplete.js)SIZE(7030)TIME(1257329183)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/elements/textbox/autocomplete2.js)SIZE(14483)TIME(1270640787)*/




/*FILEHEAD(/var/lib/platform/source/trunk/elements/xmpp/muc.js)SIZE(19003)TIME(1268265666)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/elements/xmpp/roster.js)SIZE(12504)TIME(1268265666)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/elements/video/type_qt.js)SIZE(23357)TIME(1265032029)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/elements/video/type_wmp.js)SIZE(12632)TIME(1265032029)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/elements/video/type_silverlight.js)SIZE(15347)TIME(1265032029)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/elements/video/type_vlc.js)SIZE(12493)TIME(1265032029)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/elements/video/type_native.js)SIZE(10825)TIME(1259091144)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/*FILEHEAD(/var/lib/platform/source/trunk/elements/video/type_flv.js)SIZE(17057)TIME(1265032029)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/*FILEHEAD(/var/lib/platform/source/trunk/elements/actiontracker/undodata.js)SIZE(11961)TIME(1270838606)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/**
 * UndoData is the command object for the actiontracker. Each instance of this class
 * contains information about a single event in the application. It can be undone
 * and it knows how to synchronize the change to a (remote) data source.
 *
 * @constructor
 * @default_private
 */
apf.UndoData = function(settings, at){
    this.localName = "UndoData";
    this.extra     = {};
    
    apf.extend(this, settings);

    if (at)
        this.at = at;
    //Copy Constructor
    else if (settings && settings.tagName == "UndoData") {
        this.args    = settings.args.slice();
        
    }
    //Constructor
    else {
        /*
            @todo: Please check the requirement for this and how to solve
            this. Goes wrong with multiselected actions!
        */
        this.selNode = this.selNode || (this.action == "removeNode"
            ? this.args[0]
            : (this.amlNode
                ? this.amlNode.selected
                : null));
    }

    var options, _self = this;

    

    

    /**
     * Save the change to a data source.
     * @param {Boolean} undo whether the change is undone.
     */
    this.saveChange = function(undo, at, callback){
        //Grouped undo/redo support
        if (this.action == "group") {
            var rpcNodes = this.args[1];
            at.$addToQueue(rpcNodes, undo, true);
            return at.$queueNext(this);
        }

        var dataInstruction;
        if (this.xmlActionNode) {
            dataInstruction = this.xmlActionNode.getAttribute(undo ? "undo" : "set");
            if (undo && !dataInstruction)
                dataInstruction = this.xmlActionNode.getAttribute("set");
        }

        if (!dataInstruction) {
            
            return at.$queueNext(this);
        }

        this.state = undo ? "restoring" : "saving";

        
        if (!options || options._pc === true) {
            throw new Error("Error in data instruction:" + dataInstruction); //@todo apf3.0 turn this into a proper apf error
        }
        
        
        if (options._pc == -2) {
            return at.$receive(null, apf.SUCCESS, {amlNode: this.amlNode}, 
                this, callback);
        }
        
        //options._precall = false;
        options.callback = function(data, state, extra){
            extra.amlNode = _self.amlNode;
            return at.$receive(data, state, extra, _self, callback);
        }
        options.ignoreOffline = true;

        apf.saveData(dataInstruction, options);
    };

    this.preparse = function(undo, at, multicall){
        var dataInstruction;
        if (this.xmlActionNode) {
            dataInstruction = this.xmlActionNode.getAttribute(undo ? "undo" : "set");
            if (undo && !dataInstruction)
                dataInstruction = this.xmlActionNode.getAttribute("set");
        }

        if (!dataInstruction)
            return this;

        options = apf.extend({
            //undoObj   : this,
            xmlNode   : this.action == "multicall" 
              ? this.args[0].xmlNode
              : this.selNode || this.xmlNode,
            userdata  : apf.isTrue(this.xmlActionNode.getAttribute("ignore-fail")),
            multicall : multicall,
            undo      : undo,
            _pc       : true,
            callback  : function(data, state, extra){
                options._pc = -2;
            }
        }, this.extra);

        

        apf.saveData(dataInstruction, options); //@todo please check if at the right time selNode is set
        
        if (options._pc === true)
            options._pc = -1; //if this is set then it overwrites the values set by livemarkup
        
        return this;
    };
};


/*FILEHEAD(/var/lib/platform/source/trunk/elements/actiontracker/xmlactions.js)SIZE(7708)TIME(1270838606)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


/**
 * Default actions, that are known to the actiontracker
 * @todo test if the .extra speed impact matters
 * @todo ifdef the undo sections to only be there when the actiontracker is enabled
 * @private
 */
apf.actiontracker.actions = {
    "setTextNode" : function(UndoObj, undo){
        var q = UndoObj.args;

        // Set Text Node
        if (!undo)
            apf.xmldb.setTextNode(q[0], q[1], q[2], UndoObj);
        else //Undo Text Node Setting
            apf.xmldb.setTextNode(q[0], UndoObj.extra.oldValue, q[2]);
    },

    "setAttribute" : function(UndoObj, undo){
        var q = UndoObj.args;

        // Set Attribute
        if (!undo) {
            //Set undo info
            UndoObj.extra.name = q[1];
            UndoObj.extra.oldValue = q[0].getAttribute(q[1]);

            apf.xmldb.setAttribute(q[0], q[1], q[2], q[3], UndoObj);
        }
        // Undo Attribute Setting
        else {
            if (!UndoObj.extra.oldValue)
                apf.xmldb.removeAttribute(q[0], q[1]);
            else
                apf.xmldb.setAttribute(q[0], q[1], UndoObj.extra.oldValue, q[3]);
        }
    },

    "removeAttribute" : function(UndoObj, undo){
        var q = UndoObj.args;

        // Remove Attribute
        if (!undo) {
            // Set undo info
            UndoObj.extra.name = q[1];
            UndoObj.extra.oldValue = q[0].getAttribute(q[1]);

            apf.xmldb.removeAttribute(q[0], q[1], q[2], UndoObj);
        }
        //Undo Attribute Removal
        else
            apf.xmldb.setAttribute(q[0], q[1], UndoObj.extra.oldValue, q[2]);
    },

    "replaceNode" : function(UndoObj, undo){
        var q = UndoObj.args;

        //Set Attribute
        if (!undo)
            apf.xmldb.replaceNode(q[1], q[0], q[2], UndoObj);
        //Undo Attribute Setting
        else
            apf.xmldb.replaceNode(q[0], q[1], q[2], UndoObj);
    },

    "addChildNode" : function(UndoObj, undo){
        var q = UndoObj.args;

        //Add Child Node
        if (!undo)
            apf.xmldb.addChildNode(q[0], q[1], q[2], q[3], UndoObj);
        //Remove Child Node
        else
            apf.xmldb.removeNode(UndoObj.extra.addedNode);
    },

    "appendChild" : function(UndoObj, undo){
        var q = UndoObj.args;

        //Append Child Node
        if (!undo)
            apf.xmldb.appendChild(q[0], q[1], q[2], q[3], q[4], UndoObj);
        //Remove Child Node
        else
            apf.xmldb.removeNode(UndoObj.xmlNode);//q[1]
    },

    "moveNode" : function(UndoObj, undo){
        var q = UndoObj.args;

        //Move Node
        if (!undo)
            apf.xmldb.moveNode(q[0], q[1], q[2], q[3], UndoObj);
        //Move Node to previous position
        else
            apf.xmldb.moveNode(UndoObj.extra.oldParent, q[1],
                UndoObj.extra.beforeNode, q[3]);
    },

    "removeNode" : function(UndoObj, undo){
        var q = UndoObj.args;

        //Remove Node
        if (!undo)
            apf.xmldb.removeNode(q[0], q[1], UndoObj);
        //Append Child Node
        else
            apf.xmldb.appendChild(UndoObj.extra.parent,
                UndoObj.extra.removedNode, UndoObj.extra.beforeNode);
    },

    /**
     * @deprecated Use "multicall" from now on
     */
    "removeNodeList" : function(UndoObj, undo){
        if (undo) {
            var d = UndoObj.extra.removeList;
            for (var i = d.length - 1; i >= 0; i--) {
                apf.xmldb.appendChild(d[i].pNode,
                    d[i].removedNode, d[i].beforeNode);
            }
        }
        else
            apf.xmldb.removeNodeList(UndoObj.args, UndoObj);
    },

    "group" : function(UndoObj, undo, at){
        if (!UndoObj.$undostack) {
            var done = UndoObj.args[0];
            UndoObj.$undostack = done;
            UndoObj.$redostack = [];
        }

        at[undo ? "undo" : "redo"](UndoObj.$undostack.length, false,
            UndoObj.$undostack, UndoObj.$redostack);
    },
    
    /*"setProperty" : function(UndoObj, undo){
        var q = UndoObj.args;//amlNode, name, value

        if (!undo) {
            UndoObj.extra.oldValue = q[0][q[1]];
            q[0].setProperty(q[1], q[2], q[3], q[4]);
        }
        // Undo 
        else {
            q[0].setProperty(q[1], UndoObj.extra.oldValue);
        }
    },*/
    
    "setValueByXpath" : function(UndoObj, undo){
        var q = UndoObj.args;//xmlNode, value, xpath
        // Setting NodeValue and creating the node if it doesnt exist
        if (!undo) {
            if (UndoObj.extra.newNode) {
                apf.xmldb.appendChild(UndoObj.extra.parentNode, UndoObj.extra.newNode);
            }
            else {
                var newNodes = [];
                apf.setNodeValue(q[0], q[1], true, {
                    undoObj  : UndoObj,
                    xpath    : q[2],
                    newNodes : newNodes,
                    forceNew : q[3]
                });
    
                UndoObj.extra.newNode = newNodes[0];
            }
        }
        // Undo Setting NodeValue
        else {
            if (UndoObj.extra.newNode) {
                UndoObj.extra.parentNode = UndoObj.extra.newNode.parentNode;
                apf.xmldb.removeNode(UndoObj.extra.newNode);
            }
            else
                apf.setNodeValue(UndoObj.extra.appliedNode, UndoObj.extra.oldValue, true);
        }
    },

    //@todo please change .func to .action for constency reasons
    "multicall" : function(UndoObj, undo, at){
        var q = UndoObj.args;

        var dUpdate = apf.xmldb.delayUpdate;
        apf.xmldb.delayUpdate = true;

        // Set Calls
        if (!undo) {
            for(var i = 0; i < q.length; i++) {
                if (!q[i].extra)
                    q[i].extra = {};
                
                apf.actiontracker.actions[q[i].action](q[i], false, at);
            }
            
        }
        // Undo Calls
        else {
            for (var i = q.length - 1; i >= 0; i--)
                apf.actiontracker.actions[q[i].action](q[i], true, at);
        }

        apf.xmldb.delayUpdate = dUpdate;

        //if (!dUpdate)
            //apf.xmldb.notifyQueued();
    }
};



/*FILEHEAD(/var/lib/platform/source/trunk/processinginstructions/livemarkup.js)SIZE(3476)TIME(1270838606)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


/**
 * Live Markup processor for a processing instruction
 *
 * @author      Ruben Daniels (ruben AT ajax DOT org)
 * @version     %I%, %G%
 * @since       0.9
 */

apf.LiveMarkupPi = function(){
    //this.$data;
    this.$init();
};

(function(){
    this.mainBind = "data";
    
    this.implement(apf.StandardBinding);

    this.getDocument = function(){
        return this.$data && this.$data.ownerDocument;
    }
    
    this.clear = function(msg){
        if (msg == "loading" && apf.getInheritedAttribute(this, "loading-message")) {
            this.$propHandlers["calcdata"].call(this, "<span class='loading'>Loading...</span>");
            this.calcdata = "";
        }
    }

    this.$propHandlers["calcdata"] = function(data){
        /*if (this.$data) {
            var newXml = apf.getXml("<a:application xmlns:a='" 
              + apf.ns.apf + "'>" + apf.xmlentities(data) + "</a:application>"); //@todo apf3.0 slow, rethink xmlentities
            var oldXml = this.$data;
            apf.xmlDiff(oldXml, newXml);
            
            return;
        }*/

//var dt = new Date().getTime();

        if (this.$data) {
            var nodes = this.$data.childNodes;
            for (var i = nodes.length - 1; i >= 0; i--)
                nodes[i].destroy(true);
        }

        //if (!this.xmlRoot)
            //return this.$ext.innerHTML = "loading...";

        if (typeof data == "string" && data.indexOf("<a:") > -1) {
            this.$ext.innerHTML = "";//data;

            this.$data = this.ownerDocument.$domParser.parseFromString("<a:application xmlns:a='" 
              + apf.ns.apf + "'>" + data + "</a:application>", "text/xml", {
                htmlNode : this.$ext
                //nodelay  : true
            }).documentElement;
            
            //apf.queue.empty();
            
            //alert(new Date().getTime() - dt);
        }
        else {
            if (this.$data) {
                var nodes = this.$data.childNodes;
                for (var i = 0; i < nodes.length; i++)
                    nodes[i].destroy(true);
            }
            this.$ext.innerHTML = data || "";
        }
    };
}).call(apf.LiveMarkupPi.prototype = new apf.AmlProcessingInstruction(true));

apf.aml.setProcessingInstruction("lm", apf.LiveMarkupPi);
apf.aml.setProcessingInstruction("lm-debug", apf.LiveMarkupPi);
apf.aml.setProcessingInstruction("livemarkup", apf.LiveMarkupPi);




/*FILEHEAD(/var/lib/platform/source/trunk/processinginstructions/livetext.js)SIZE(1637)TIME(1269561670)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */


/**
 * Live Markup processor for a processing instruction
 *
 * @author      Ruben Daniels (ruben AT ajax DOT org)
 * @version     %I%, %G%
 * @since       0.9
 */

apf.LiveTextPi = function(){
    //this.$data;
    this.$init();
};

(function(){
    this.mainBind = "data";
    
    this.implement(apf.StandardBinding);

    this.$propHandlers["calcdata"] = function(data){
        this.$ext.innerHTML = data && apf.htmlentities(data) || "";
    };
}).call(apf.LiveTextPi.prototype = new apf.AmlProcessingInstruction(true));

apf.aml.setProcessingInstruction("lt", apf.LiveTextPi);
apf.aml.setProcessingInstruction("livetext", apf.LiveTextPi);



/*FILEHEAD(/var/lib/platform/source/trunk/jpack_end.js)SIZE(801)TIME(1271112406)*/



//Conditional compilation workaround... (can this be improved??)
if (document.all) {
    var oldWinError = window.onerror, z;
    window.onerror = z = function(m){
        apf.console.error("Error caught from early startup. Might be a html parser syntax error (not your fault). " + m);

        if (!arguments.caller)
            return true;
    }
}
apf.Init.addConditional(function(){
    if (document.all && window.onerror == z) //Conditional compilation workaround... (can this be improved??)
        window.onerror = oldWinError;

    apf.dispatchEvent("domready");
}, null, ["body", "class"]);

/*if(document.body)
    apf.Init.run("body");
else*/
    apf.addDomLoadEvent(function(){apf.Init.run('body');});

//Start
apf.start();




/*FILEHEAD(/var/lib/platform/source/trunk/loader-o3.js)SIZE(7176)TIME(1263239583)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */



/*FILEHEAD(/var/lib/platform/source/trunk/apf-o3.js)SIZE(13670)TIME(1271105954)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */




/*FILEHEAD(/var/lib/platform/source/trunk/loader.js)SIZE(15622)TIME(1270937595)*/

/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 *
 */

/**
 * Bootloader for Ajax.org Platform
 *
 * Include apf.js, then just go about it as you would with the 
 * packaged version. Adapt this file to include your preferred modules
 */


